{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/BN.png","path":"images/BN.png","modified":1,"renderable":0},{"_id":"source/images/BN_back.png","path":"images/BN_back.png","modified":1,"renderable":0},{"_id":"source/images/BN_y.png","path":"images/BN_y.png","modified":1,"renderable":0},{"_id":"source/images/Capture.PNG","path":"images/Capture.PNG","modified":1,"renderable":0},{"_id":"source/images/Capture1.PNG","path":"images/Capture1.PNG","modified":1,"renderable":0},{"_id":"source/images/Capture2.PNG","path":"images/Capture2.PNG","modified":1,"renderable":0},{"_id":"source/images/Capture3.PNG","path":"images/Capture3.PNG","modified":1,"renderable":0},{"_id":"source/images/Capture4.PNG","path":"images/Capture4.PNG","modified":1,"renderable":0},{"_id":"source/images/Capture5.PNG","path":"images/Capture5.PNG","modified":1,"renderable":0},{"_id":"source/images/L1.jpg","path":"images/L1.jpg","modified":1,"renderable":0},{"_id":"source/images/L2.jpg","path":"images/L2.jpg","modified":1,"renderable":0},{"_id":"source/images/Untitled.png","path":"images/Untitled.png","modified":1,"renderable":0},{"_id":"source/images/analysis_final_1.PNG","path":"images/analysis_final_1.PNG","modified":1,"renderable":0},{"_id":"source/images/analysis_final_3.PNG","path":"images/analysis_final_3.PNG","modified":1,"renderable":0},{"_id":"source/images/analysis_final_5.PNG","path":"images/analysis_final_5.PNG","modified":1,"renderable":0},{"_id":"source/images/classification.PNG","path":"images/classification.PNG","modified":1,"renderable":0},{"_id":"source/images/filename_txt.PNG","path":"images/filename_txt.PNG","modified":1,"renderable":0},{"_id":"source/images/lesson13_1.png","path":"images/lesson13_1.png","modified":1,"renderable":0},{"_id":"source/images/lesson16_1.png","path":"images/lesson16_1.png","modified":1,"renderable":0},{"_id":"source/images/lesson16_2.png","path":"images/lesson16_2.png","modified":1,"renderable":0},{"_id":"source/images/lesson16_3.png","path":"images/lesson16_3.png","modified":1,"renderable":0},{"_id":"source/images/lesson6.png","path":"images/lesson6.png","modified":1,"renderable":0},{"_id":"source/images/lesson6_3.png","path":"images/lesson6_3.png","modified":1,"renderable":0},{"_id":"source/images/lesson6_3b.png","path":"images/lesson6_3b.png","modified":1,"renderable":0},{"_id":"source/images/lesson6_3c.png","path":"images/lesson6_3c.png","modified":1,"renderable":0},{"_id":"source/images/lesson7.png","path":"images/lesson7.png","modified":1,"renderable":0},{"_id":"source/images/lesson7_2.png","path":"images/lesson7_2.png","modified":1,"renderable":0},{"_id":"source/images/lesson8.png","path":"images/lesson8.png","modified":1,"renderable":0},{"_id":"source/images/lesson8_2.png","path":"images/lesson8_2.png","modified":1,"renderable":0},{"_id":"source/images/lesson9_1.png","path":"images/lesson9_1.png","modified":1,"renderable":0},{"_id":"source/images/lesson9_2.png","path":"images/lesson9_2.png","modified":1,"renderable":0},{"_id":"source/images/lesson9_3.png","path":"images/lesson9_3.png","modified":1,"renderable":0},{"_id":"source/images/lesson9_4.png","path":"images/lesson9_4.png","modified":1,"renderable":0},{"_id":"source/images/lesson9_5.png","path":"images/lesson9_5.png","modified":1,"renderable":0},{"_id":"source/images/pat_1086.jpg","path":"images/pat_1086.jpg","modified":1,"renderable":0},{"_id":"source/images/woff_decode.PNG","path":"images/woff_decode.PNG","modified":1,"renderable":0},{"_id":"source/images/进程状态转换图.jpg","path":"images/进程状态转换图.jpg","modified":1,"renderable":0},{"_id":"themes/landscape/source/baidu_verify_CPVBgyCjF8.html","path":"baidu_verify_CPVBgyCjF8.html","modified":1,"renderable":1},{"_id":"themes/landscape/source/baidu_verify_KS1HHksWBu.html","path":"baidu_verify_KS1HHksWBu.html","modified":1,"renderable":1},{"_id":"themes/landscape/source/google9da4e92e637f6c53.html","path":"google9da4e92e637f6c53.html","modified":1,"renderable":1},{"_id":"source/images/analysis_final_2.PNG","path":"images/analysis_final_2.PNG","modified":1,"renderable":0},{"_id":"source/images/analysis_final_4.PNG","path":"images/analysis_final_4.PNG","modified":1,"renderable":0},{"_id":"source/images/lesson6b.png","path":"images/lesson6b.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"5f5cda3f6c72ad3ee0b593daafabfec550a41dc6","modified":1536644772973},{"_id":"source/README.md","hash":"454bddac036bc573c4f7c7e7832231becd2cee83","modified":1538270406419},{"_id":"source/favicon.ico","hash":"696f776d5517ca053000dfe5948e819bf48e1dd6","modified":1537761514009},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1536644772981},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1536644772981},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1536644772981},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1536644772981},{"_id":"themes/landscape/_config.yml","hash":"dd14fcdbf7e7949e5b35e3d7b84d58415dabc830","modified":1539164374942},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1536644772985},{"_id":"source/categories/index.md","hash":"998826a4be87e88a9d2d51684d52017839db4c3f","modified":1536644772973},{"_id":"source/_posts/7个好用的在线YouTube视频下载工具.md","hash":"180b67062f3b7ad7c2ec0ae3c1110e71be887138","modified":1539160539986},{"_id":"source/_posts/HTML5与CSS3权威指南之HTML5学习记录.md","hash":"9c8d4bcdfa1b9a33040acf293df32966ba5483d9","modified":1539160645121},{"_id":"source/_posts/HTML与CSS学习记录.md","hash":"6b9b372f1645e2e0b8b209662eda34144312771b","modified":1539160659901},{"_id":"source/_posts/HTTP学习记录.md","hash":"b1aa44ec17f4a7ca1b14d3eece6510f53406feef","modified":1539160664381},{"_id":"source/_posts/JavaScript原型链-prototype与-proto.md","hash":"3b37b9baad1d2d9dac6befacf7aa91ee884a931b","modified":1539160673893},{"_id":"source/_posts/JavaScript学习记录一.md","hash":"dbca48393a617f03a5c82d93334e2f3dacad89a4","modified":1539160680862},{"_id":"source/_posts/JavaScript学习记录三.md","hash":"c0b2f84243a61e2ce207033e04ce98c54876cf9f","modified":1539161569832},{"_id":"source/_posts/JavaScript学习记录二.md","hash":"9aaf08edfe8a592d83267ec7d80d2460f3ea1fd2","modified":1539161638680},{"_id":"source/_posts/JavaScript学习记录四.md","hash":"b07098532b496e5e74ab5b1d3f4a27fadc4828cf","modified":1539160695523},{"_id":"source/_posts/JavaScript实现双向链表.md","hash":"9915900a08d2e4d22acce758e1fb7ec9d02c5d89","modified":1539160736417},{"_id":"source/_posts/PAT刷题记录.md","hash":"f0f96e57efe3c95d3e5a80209918be416c1653d8","modified":1539160752346},{"_id":"source/_posts/Promise与async-await.md","hash":"febc9878b2ef424641842c71b52260da42fd8671","modified":1539160760302},{"_id":"source/_posts/TensorFlow基础知识.md","hash":"6c9ead74089fca382e5dfdfc13c27c965aa200ef","modified":1539160768851},{"_id":"source/_posts/TensorFlow训练MNIST报错ResourceExhaustedError.md","hash":"634fd0b47e4dbe0a309326541c320345d6ce925c","modified":1539160778735},{"_id":"source/_posts/Ubuntu下使用Deepin-wine的移植版安装qq微信等.md","hash":"b09bcdb2a37f07bb6842bd4330bae6fd463ca409","modified":1539160827126},{"_id":"source/_posts/Vuex入门.md","hash":"423706a0eb6dae630441e414bd3dfa3d7af6fec1","modified":1539160880396},{"_id":"source/_posts/Web前端错题模糊题记录.md","hash":"59177726374e77211d72cd643b7cdac108dd8421","modified":1539160891360},{"_id":"source/_posts/cookie、sessionStorage和localStorage.md","hash":"3257c584d66cce256535966a3cb8954a3116e39c","modified":1539161592384},{"_id":"source/_posts/git相关整理.md","hash":"d6aa983cfd5190553f214c6b368243191ef003ee","modified":1539160584638},{"_id":"source/_posts/hexo创建的tags和categories页面为空的解决办法.md","hash":"efb1c441e53f1c19c0f364a68935ad6c12a34e8d","modified":1539160609005},{"_id":"source/_posts/hexo博客谷歌百度收录踩坑日记.md","hash":"c0202319379b3703a1ce4fcbeb63cfce5b4af400","modified":1539160625401},{"_id":"source/_posts/numpy常用函数和数据类型.md","hash":"540c8df39694c855a40f706cf960f27f019039b1","modified":1539160745813},{"_id":"source/_posts/ubuntu-18-04下安装稳定版Chrome谷歌浏览器.md","hash":"1452075ccca8b5bbb1be6382ebb512d96ab87609","modified":1539160811541},{"_id":"source/_posts/ubuntu18-04中安装iNode.md","hash":"a616e35a8e754bc3b2a0220e00360f2e9c16837f","modified":1539160785324},{"_id":"source/_posts/ubuntu18-04开机慢的解决办法.md","hash":"acf84159cf6b992002e8938f967a6c993558eef5","modified":1539160797108},{"_id":"source/_posts/ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法.md","hash":"0cacb722366f991b8cb98179f938bc849196c1ac","modified":1536644772973},{"_id":"source/_posts/ubuntu下创建文件夹快捷方式.md","hash":"68f29e20df557f0901a13752b83549f880440f85","modified":1536644772973},{"_id":"source/_posts/ubuntu下无法将iNode绑定到侧边栏的解决办法.md","hash":"7bc6c4118da0d083e5b5c2239328db4c75ae1967","modified":1536644772973},{"_id":"source/_posts/ubuntu修改顶栏颜色.md","hash":"b51d063ef0f2788591239a34dacbbe2e61a3f423","modified":1539160848507},{"_id":"source/_posts/使用TensorBoard可视化工具.md","hash":"1f8e07933162799d82ede315a710842b07e910b7","modified":1539160896161},{"_id":"source/_posts/关于hexo-markdown添加的图片在github-page中无法显示的问题.md","hash":"19fabae46672060f6a3015db23d5431dd3a5e8ee","modified":1539161313912},{"_id":"source/_posts/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法.md","hash":"44c87eb8e69e279a03e790467062a2e69211c5e4","modified":1539160912321},{"_id":"source/_posts/前端向后台发送请求有哪些方式.md","hash":"0b5827dc7aa250db1e48c4206de503ef3c9dd7d3","modified":1537849925656},{"_id":"source/_posts/同步与异步.md","hash":"157bfd6aa4b01b9de435575d2bf701154e6cbef9","modified":1539160934002},{"_id":"source/_posts/在ubuntu中安装Markdown神器Typora.md","hash":"8bae1d7429924dfad8e7285734141f17ce9b5bec","modified":1536644772973},{"_id":"source/_posts/堆和栈的区别.md","hash":"9a3677727bfdbd510e0850cb832f540c4100cd6a","modified":1539160955911},{"_id":"source/_posts/将hexo的评论系统由gitment改为Valine.md","hash":"86eec4c11df6a07c341e1028c87cea371ac38b63","modified":1539161012873},{"_id":"source/_posts/常用SQL语句.md","hash":"22f6ed99e209b58f101997d91d07290ce6c2914e","modified":1539161305476},{"_id":"source/_posts/接入gitment为hexo添加评论功能.md","hash":"baf068a578d9da18aca25061e7de970753fd334d","modified":1539161299440},{"_id":"source/_posts/操作系统面试相关总结.md","hash":"4546564f6e2f36c8d7d36190073391cea43f6707","modified":1539161293408},{"_id":"source/_posts/数据库基础知识.md","hash":"2a0ea6a4c94e84d938aa3172eb537b674f3021e6","modified":1539161288508},{"_id":"source/_posts/智能指针.md","hash":"3e7dea0c70cca6b9ffcd6ecd15caf04be3ef2d2c","modified":1539161283784},{"_id":"source/_posts/求包含每个有序数组-共k个-至少一个元素的最小区间.md","hash":"d1eed3bdf1ad3d64cad88d3b0fda26b34d9e4a40","modified":1539161260503},{"_id":"source/_posts/深度学习周报week01-week02.md","hash":"2d6b19eb3ad0fab25a2fabce5b87d9cdf8bc3b06","modified":1539161228443},{"_id":"source/_posts/深度学习周报week03-week04.md","hash":"0898c333a9ad1f71f9c29514d33209fd466ac4f6","modified":1539161219118},{"_id":"source/_posts/深度学习周报week05-week06.md","hash":"45646ca2444dd372e283ca2192dae21eb921de5a","modified":1539161208142},{"_id":"source/_posts/深度学习周报week07-week08.md","hash":"3e96a78dc993aee2b6b30b05403931d90eeab9b5","modified":1539161192514},{"_id":"source/_posts/深度学习周报week09-week10.md","hash":"898fbe60feba4ca18fcf11714f91d98214be5891","modified":1536644772973},{"_id":"source/_posts/深度学习周报week11-week12.md","hash":"6ff0c0bc77638cf49baadfb65f5a6e26f8020e11","modified":1539161165841},{"_id":"source/_posts/牛客网前端挑战编程题解.md","hash":"34a5502241b1f84387035fe20a15ad4961251997","modified":1539161160513},{"_id":"source/_posts/猫眼电影加密数字破解（爬取评分票房票价）.md","hash":"b8c89653e863195326c3f7cda7f6be519bbd31dc","modified":1539161154557},{"_id":"source/_posts/系统分析与设计作业FinalReport.md","hash":"4d95e02f5f72eb17400d7cbb3eaa32dcbe2f0776","modified":1539161805758},{"_id":"source/_posts/系统分析与设计作业七.md","hash":"c80dab188d56c8edaff7c302ee32edc5996095a0","modified":1539161138361},{"_id":"source/_posts/系统分析与设计作业九.md","hash":"df74f622a1e0433533f449c722f1fea031ae4583","modified":1539161132268},{"_id":"source/_posts/系统分析与设计作业五.md","hash":"583ce2e06ad716d0c3e15c922489075bbbf503ee","modified":1539161125676},{"_id":"source/_posts/系统分析与设计作业八.md","hash":"481809caf54d89e1b4f3fac6a2d767a9fa3c7715","modified":1539161116000},{"_id":"source/_posts/系统分析与设计作业六.md","hash":"b5506c140cf4cc0531e8bcadacd7edcf7ee26b20","modified":1539161104724},{"_id":"source/_posts/系统分析与设计作业十三.md","hash":"bd213b47e74ae5bd447d7e62edda3cb60ee7e77b","modified":1539161096839},{"_id":"source/_posts/系统分析与设计作业十六.md","hash":"65a983ff65dcf52917d4216fdc67b59f55b521eb","modified":1539161089551},{"_id":"source/_posts/继续磕面经.md","hash":"c5a61e799bd3394066941e0c49ef1ae261b4a874","modified":1539161079235},{"_id":"source/_posts/遇见逆水寒男号女NPC奇物好感统计.md","hash":"8f24d0bc486cc3972c793595dc7faabf1b2c6849","modified":1539161065047},{"_id":"source/_posts/部署hexo后github-pages页面未更新或无法打开问题.md","hash":"13a3b98b919e8ea5da7d7fd1935d0ee7101fca5b","modified":1539161027133},{"_id":"source/images/BN.png","hash":"16a8d79aff9c062eb5654627f404cf37db042e8b","modified":1536644772973},{"_id":"source/images/BN_back.png","hash":"b1457ee4faac43b4e561ee259327bc9b43bd06a2","modified":1536644772977},{"_id":"source/images/BN_y.png","hash":"278d7811ac757a93d5067baecd1244e6012f031f","modified":1536644772977},{"_id":"source/images/Capture.PNG","hash":"92290ce107044453cc8f78bd1c73c0142e0190df","modified":1536644772977},{"_id":"source/images/Capture1.PNG","hash":"c6dd3c2cb3585bf7ce1dea86dfb6c433c589c355","modified":1536644772977},{"_id":"source/images/Capture2.PNG","hash":"c68af93d76ea39560435b0e5b3d768fbb2051462","modified":1536644772977},{"_id":"source/images/Capture3.PNG","hash":"a88eb075f4cfa82822fae098458cdc4617153dde","modified":1536644772977},{"_id":"source/images/Capture4.PNG","hash":"6902b1d3acd40c54183f7ec398ebfcdecf4037f2","modified":1536644772977},{"_id":"source/images/Capture5.PNG","hash":"97f3f8567f653b671854b5f96eb679c53c18bbd1","modified":1536644772977},{"_id":"source/images/L1.jpg","hash":"b43e8926a31012f34e6961897ee796f2be364ac5","modified":1536644772977},{"_id":"source/images/L2.jpg","hash":"99f85d9063828c1efd5fd712aa6249bc01c3c519","modified":1536644772977},{"_id":"source/images/Untitled.png","hash":"24ea3d0e09177d1cdf15371775079fef7e5e1c08","modified":1536644772977},{"_id":"source/images/analysis_final_1.PNG","hash":"311843a5328f609273a79c0907bdb397aeac4971","modified":1536644772977},{"_id":"source/images/analysis_final_3.PNG","hash":"61526342708461c189abd9ca54221db5c98bcc3e","modified":1536644772977},{"_id":"source/images/analysis_final_5.PNG","hash":"78aa509a5537c4f4f182eebc73e4ff41e153172f","modified":1536644772977},{"_id":"source/images/classification.PNG","hash":"db34d2712eec4a44cfc20488aac3020394797ca5","modified":1536644772977},{"_id":"source/images/filename_txt.PNG","hash":"4b587eadb4dd595b2a6f609f1087aa74fabc4058","modified":1536644772977},{"_id":"source/images/lesson13_1.png","hash":"31db137a072c31ed7bcb8b6f8e8ddf0187c2fdaa","modified":1536644772977},{"_id":"source/images/lesson16_1.png","hash":"7e45e0bea924348106203e0a4096b2f9628480fe","modified":1536644772981},{"_id":"source/images/lesson16_2.png","hash":"06d407682af5f02d0708a92278a99b4b2abd2ef2","modified":1536644772981},{"_id":"source/images/lesson16_3.png","hash":"ff2b64fd298bf00cb6f9a454798dd01e91dd16f1","modified":1536644772981},{"_id":"source/images/lesson6.png","hash":"c2bae02e87fe851ecc8881f6504f460f603d4d0b","modified":1536644772981},{"_id":"source/images/lesson6_3.png","hash":"43c087415436e9102156fd4bf4f59a8484cd6294","modified":1536644772981},{"_id":"source/images/lesson6_3b.png","hash":"774a6ae430d729a7fa41f1990e84e7c36f6c8ee4","modified":1536644772981},{"_id":"source/images/lesson6_3c.png","hash":"b37095a0a2092d82b90476d95391dd61629c29c0","modified":1536644772981},{"_id":"source/images/lesson7.png","hash":"5a8f624b8683b69f32fbc50d14b9cbafe30b2d06","modified":1536644772981},{"_id":"source/images/lesson7_2.png","hash":"eed9f4172450b140d60fd9d85d214f5a5f3d59ff","modified":1536644772981},{"_id":"source/images/lesson8.png","hash":"58bffcabfa1db623bdb317772483bd1ea8007835","modified":1536644772981},{"_id":"source/images/lesson8_2.png","hash":"5614c0b9f84ac4b46d5bd8a5489ea7bf86812853","modified":1536644772981},{"_id":"source/images/lesson9_1.png","hash":"c355a88e7a51dc46740790378a0605a603aeede9","modified":1536644772981},{"_id":"source/images/lesson9_2.png","hash":"c06f731136f43e58430ef6d5323a9ab105f60d37","modified":1536644772981},{"_id":"source/images/lesson9_3.png","hash":"fa4b73721a97c7806fc035d5d6d2a5c9ed614132","modified":1536644772981},{"_id":"source/images/lesson9_4.png","hash":"8457257aef5b457087086f2502b46d99bbd4cbef","modified":1536644772981},{"_id":"source/images/lesson9_5.png","hash":"5950f6e6ecb706acd441fac3a326f38382203c8f","modified":1536644772981},{"_id":"source/images/pat_1086.jpg","hash":"4e08fe072bcd69e9048ebf9714cc34a2476ae980","modified":1536644772981},{"_id":"source/images/woff_decode.PNG","hash":"21a52a39b4c9cb0e1a6ddbff1ec5a910db603167","modified":1536644772981},{"_id":"source/images/进程状态转换图.jpg","hash":"2b91f43bdd7a7bbd5ef7847f238dc905e14b0031","modified":1538128576674},{"_id":"source/tags/index.md","hash":"b9c8710929fac0a1ff1a72a3138b3aa2067a03c0","modified":1536644772981},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1536644772981},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1536644772981},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1536644772981},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1536644772981},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1536644772981},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1536644772981},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1536644772981},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1536644772981},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1536644772981},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1536644772981},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1536644772985},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1536644772985},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1536644772985},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1536644772985},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1536644772985},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1536644772985},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536644772985},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1536644772985},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1536644772985},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1536644772985},{"_id":"themes/landscape/source/baidu_verify_CPVBgyCjF8.html","hash":"bcdd113d9b4bd2f097dd7d3b43aefe54e4b67d82","modified":1536826598564},{"_id":"themes/landscape/source/baidu_verify_KS1HHksWBu.html","hash":"23c57476910e679926c1390de149bd9119ae6610","modified":1536827812160},{"_id":"themes/landscape/source/google9da4e92e637f6c53.html","hash":"67e87478705d1c4257f2c5dd619d42f5fe83273d","modified":1536644772989},{"_id":"source/images/analysis_final_2.PNG","hash":"519f5d48483b3cd810c61e06386ae566c9aa215a","modified":1536644772977},{"_id":"source/images/analysis_final_4.PNG","hash":"138983b8bc652fb041f94583221f99614dfa68e5","modified":1536644772977},{"_id":"source/images/lesson6b.png","hash":"d200d7a5d15cce2e0538c14ee21bf0c48b251702","modified":1536644772981},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"44e4b5889fdc11c4dfa64045822598b419b0f225","modified":1539164417334},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"6e2cef652920b8ed940a30adf5fe75c5f5ef57bc","modified":1539160166729},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"399a5126d292ca7f8a98c0f0434e54e761b48ce5","modified":1536646514471},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/totop.ejs","hash":"5f7321b652c6698af5982f29fc1102afa946d976","modified":1536910458196},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1536644772985},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1536644772985},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1536644772985},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1536644772985},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1536644772985},{"_id":"themes/landscape/source/css/_extend.styl","hash":"c42f3ca51806b35cd84c3d8583577a4f5a68a935","modified":1536644772985},{"_id":"themes/landscape/source/css/_extend.styl.bak","hash":"7c95099628df6cdfc94e6e2fb9e47813452f0980","modified":1536644772985},{"_id":"themes/landscape/source/css/_variables.styl","hash":"a88cf9c687d8610f5998ab79f266056c73cfb1f0","modified":1536644772985},{"_id":"themes/landscape/source/css/_variables.styl.bak","hash":"a6dcfc0b8dfe87aab360a12b84189c2e95662981","modified":1536644772985},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1536644772989},{"_id":"themes/landscape/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1536909885838},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1536644772989},{"_id":"themes/landscape/source/js/totop.js","hash":"c14c7a191427269bafce8dcc770756a21abd3684","modified":1536910178327},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1536644772985},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"4b6c4384c4f269d9af9557aebbd632b5f732daea","modified":1536909509304},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"2b07778ec0b24fd44b5946f8a4365fbdf28c5448","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/header.styl.bak","hash":"793abd37d8b8ae0e291c341e757f42e8b025f4e8","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1536644772985},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1536644772985},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1536644772985},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1536644772985},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1536644772985},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1536644772985},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1536644772985},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"b4e5b071137a37d064c18888a52e8800021fc1c6","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1536644772985},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1536644772985},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1536644772985},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1536644772985},{"_id":"public/images/BN.png","hash":"a2e7060dde4b6f658713e9ebb8645b70692f1123","modified":1539167555504},{"_id":"public/images/BN_back.png","hash":"596eb14f6a731ef9df5d5c5f372932e39d6f54c6","modified":1539167555775},{"_id":"public/images/BN_y.png","hash":"58c5414ca3f7fc215806ebfecfe65a233db1e07e","modified":1539167555777},{"_id":"public/images/Capture.PNG","hash":"74ef542a8d051485901f198714a7616a1e39b590","modified":1539167559915},{"_id":"public/images/Capture1.PNG","hash":"63499df5459dc5f309e76fd9166b8caf039fc1ae","modified":1539167560878},{"_id":"public/images/Capture2.PNG","hash":"1053bb42eed8955e5b88e0a3e64429c635437595","modified":1539167560879},{"_id":"public/images/Capture3.PNG","hash":"42e389fc3695d6933e4b10c1b5b3549bd80a424b","modified":1539167560904},{"_id":"public/images/Capture4.PNG","hash":"da8590d77b0a1c0cd21b9064c1d9f828863ceaa0","modified":1539167560904},{"_id":"public/images/Capture5.PNG","hash":"f18849a591029501ab090beca24d77e73051e065","modified":1539167560904},{"_id":"public/images/L1.jpg","hash":"822159471ef75e4dfdc6f631d26c5650ee6665f1","modified":1539167560904},{"_id":"public/images/L2.jpg","hash":"ca7421db2b830500fa226ef060b5d7756f2dcb0e","modified":1539167560904},{"_id":"public/images/Untitled.png","hash":"9623e9bb4ce73d28aac4689e6c6198cc3baa9815","modified":1539167560904},{"_id":"public/images/analysis_final_1.PNG","hash":"412d63b13234e7f73ff2f37be78587f19e298e13","modified":1539167560904},{"_id":"public/images/analysis_final_3.PNG","hash":"dc790176deb3307edbee82f5753b85c352509161","modified":1539167560904},{"_id":"public/images/analysis_final_5.PNG","hash":"0f39c674f64e2fdb0c494819547458df6a06dcb8","modified":1539167560904},{"_id":"public/images/classification.PNG","hash":"7d114ce687003ea8118dd273aaf790f5961cb6fb","modified":1539167560904},{"_id":"public/images/filename_txt.PNG","hash":"e9fa08fe3ebe0ccf28de6f4347523020ac1f71c7","modified":1539167560905},{"_id":"public/images/lesson13_1.png","hash":"ec320b4d3eff7108a37e6f396ddfe832c3dd5b22","modified":1539167560905},{"_id":"public/images/lesson16_1.png","hash":"a935da8e31345d1f97cc8d394adf1e5daae1069a","modified":1539167560905},{"_id":"public/images/lesson16_2.png","hash":"d4077152125e8c1c6f5bd5885d044ce5e9594894","modified":1539167560905},{"_id":"public/images/lesson16_3.png","hash":"7f0968b8bf83ad1c19345dc97c2d413649fca814","modified":1539167560905},{"_id":"public/images/lesson6.png","hash":"1f7d0cdfb32318603b441454f54e045393ce568c","modified":1539167560905},{"_id":"public/images/lesson6_3.png","hash":"72ff2c1c774d550928afcdde8e8dbc0ddf8c6735","modified":1539167560905},{"_id":"public/images/lesson6_3b.png","hash":"822e5eabe306d245eb206f22c90669643ed16511","modified":1539167560905},{"_id":"public/images/lesson6_3c.png","hash":"a90d4eac198fecd9d2c18d5a96bd0bf3665454f0","modified":1539167560905},{"_id":"public/images/lesson7.png","hash":"1e56e18d734097cf2c26a55403a06f3f76973028","modified":1539167560905},{"_id":"public/images/lesson7_2.png","hash":"ed7e27e2d2fdc60b4e0439604f03fdca2476a802","modified":1539167560905},{"_id":"public/images/lesson8.png","hash":"20152acd59e9dae931e01df2703ecb3145fbce1f","modified":1539167560905},{"_id":"public/images/lesson8_2.png","hash":"3b1ca38c3818882f43514187202ad6c0fd6d3f27","modified":1539167560905},{"_id":"public/images/lesson9_1.png","hash":"580822a15376de50485323dc0e531cc766045526","modified":1539167560905},{"_id":"public/images/lesson9_2.png","hash":"f83f79376203a016c84dbc26050d10748b55e505","modified":1539167560905},{"_id":"public/images/lesson9_3.png","hash":"1ff56bbec24cd8b953f9cbc9deb3498130a70eef","modified":1539167560905},{"_id":"public/images/lesson9_4.png","hash":"a1af8d48ec85b2dcd2aab9dca9510264570fc311","modified":1539167560906},{"_id":"public/images/lesson9_5.png","hash":"9154b2a37f249514d43f88e928b0e037d413b69e","modified":1539167560906},{"_id":"public/images/pat_1086.jpg","hash":"3d9bfb6746c3680f3ce0135d0b8b9f5189f5ea2a","modified":1539167560906},{"_id":"public/images/woff_decode.PNG","hash":"6dae0642e926c1bb3ae1e7e036075e7df19b368f","modified":1539167560906},{"_id":"public/images/进程状态转换图.jpg","hash":"5d0ac5695914d65cdaf286d1f2e4f664484d1417","modified":1539167560906},{"_id":"public/images/analysis_final_2.PNG","hash":"d5558699cd2dddf096b628665b3788bf082f21ae","modified":1539167560906},{"_id":"public/images/analysis_final_4.PNG","hash":"59db6ef1693de93faa7908f7461bc03502b75b09","modified":1539167560906},{"_id":"public/images/lesson6b.png","hash":"44361a0064a5b288c21ad3880a0389d8a02299a7","modified":1539167560906},{"_id":"public/fancybox/fancybox_loading.gif","hash":"d3e4776a07bf7aee7779e26892cb4076909840b3","modified":1539167560907},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"3494864c175935e45c6ae5e76c2cbe7c9d53c41a","modified":1539167560907},{"_id":"public/fancybox/fancybox_overlay.png","hash":"0183383be7d6a44a90af8666c3ceecab70c9a8a2","modified":1539167560907},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"2f3e392bd9ad92a3dd2a60d1968124f7dfc26e16","modified":1539167560908},{"_id":"public/css/images/banner.jpg","hash":"8a8b6d952dba55e6286df2b2b2dc537443444314","modified":1539167560908},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"52b3cf3d7681a5da40ff94a1fd3eba5bb4ad4c4a","modified":1539167560908},{"_id":"public/baidu_urls.txt","hash":"51f4d7060769fa78f0c0cd9f5d031fbb7ce5daad","modified":1539167560908},{"_id":"public/search.xml","hash":"699bc229a797446440691aa86846ad48d10859ff","modified":1539167560908},{"_id":"public/sitemap.xml","hash":"e611d33338fcbf2ed8724c66ada127b565d5b7f4","modified":1539167560908},{"_id":"public/求包含每个有序数组-共k个-至少一个元素的最小区间.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560926},{"_id":"public/PAT刷题记录.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560926},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560926},{"_id":"public/将hexo的评论系统由gitment改为Valine.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560926},{"_id":"public/接入gitment为hexo添加评论功能.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560927},{"_id":"public/hexo创建的tags和categories页面为空的解决办法.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539167560927},{"_id":"public/archives/page/4/index.html","hash":"8046f29c6b3774b06e503e163f6497f35224506d","modified":1539167560927},{"_id":"public/archives/2018/page/4/index.html","hash":"b7364a37c4e29356613562e247568818e90f83e5","modified":1539167560927},{"_id":"public/archives/2018/07/index.html","hash":"ccb75bb6219506f6bd1625cdae32a15b13bbe76b","modified":1539167560927},{"_id":"public/archives/2018/08/index.html","hash":"aabc68995418295a9f3a497c59960d140d515a85","modified":1539167560927},{"_id":"public/categories/Web/page/2/index.html","hash":"2797bb2d4dce16e8bcb65a63462b01a19761d292","modified":1539167560927},{"_id":"public/categories/OJ/index.html","hash":"299d4ffd25905e45ad8842975db80d7eb158ca1a","modified":1539167560927},{"_id":"public/categories/Python/index.html","hash":"c3cab5d6aca6ce6641f85f4850a56dfe1470a3fd","modified":1539167560927},{"_id":"public/categories/C-C/index.html","hash":"5667f7587de030d6a485f57ed7b2e223fa0f1683","modified":1539167560927},{"_id":"public/tags/youtube/index.html","hash":"fb78af3930334d8cc36c8d1346e88d9687cbd63f","modified":1539167560927},{"_id":"public/tags/CSS/index.html","hash":"2da5b9f02a391b6776aa4a6b081c770c471718ed","modified":1539167560927},{"_id":"public/tags/HTTP/index.html","hash":"90f14d980f0f94cea9aace3397a2bd0fa59bc5b9","modified":1539167560927},{"_id":"public/tags/prototype/index.html","hash":"e2afd2efe74ba8f008cea6cc243d478dfe488269","modified":1539167560927},{"_id":"public/tags/双向链表/index.html","hash":"f6808da5ffbaad02f94f2e13598e2d9610efa01b","modified":1539167560927},{"_id":"public/tags/ES6/index.html","hash":"78ee96142fcf04580fcf77ae9b027285ca0cdcac","modified":1539167560927},{"_id":"public/tags/MNIST/index.html","hash":"dd4987ef60ee9040b544ec06b8cc83af3eca5587","modified":1539167560927},{"_id":"public/tags/PAT/index.html","hash":"51449cbc4a7dca120a8e6c2fd0e91ab1f140ad7b","modified":1539167560927},{"_id":"public/tags/刷题/index.html","hash":"cf6a72f13047ee057c3ed14c4d056bd54e4c8f12","modified":1539167560928},{"_id":"public/tags/Vue/index.html","hash":"057ac9c9b0c91c8c403012659d0101ddb45d2a94","modified":1539167560928},{"_id":"public/tags/Vuex/index.html","hash":"f43a61ac0ea2ec21c5ed5beaac1713b2c0e288a8","modified":1539167560928},{"_id":"public/tags/cookie/index.html","hash":"80d0881bb4055cf0ee2ec81868f9586b34995507","modified":1539167560928},{"_id":"public/tags/webstorage/index.html","hash":"2bd9fa6249d95882346ce8d45eaabd4c10c49926","modified":1539167560928},{"_id":"public/tags/git/index.html","hash":"6b720a898cdad7f78aef52cfa02a5cab74fb666b","modified":1539167560928},{"_id":"public/tags/网站收录/index.html","hash":"2b349972a8dcd90326fc922ad0e3095850edd1ec","modified":1539167560928},{"_id":"public/tags/numpy/index.html","hash":"41085b02b4da3599b8c52242b544125936ee7a3d","modified":1539167560928},{"_id":"public/tags/Chrome/index.html","hash":"8f02abf0743bd59fa7eb9500e09d71cb09f0a277","modified":1539167560928},{"_id":"public/tags/iNode/index.html","hash":"f23530f397f80ad96a1f915f03ad36baa7a70ea8","modified":1539167560928},{"_id":"public/tags/图片显示/index.html","hash":"c8c8bb7df32799abb52851013eacf84b35232322","modified":1539167560928},{"_id":"public/tags/快捷方式/index.html","hash":"cbca4efcafeb301dee027e2427eb7930082b8ebd","modified":1539167560928},{"_id":"public/tags/Ubuntu/index.html","hash":"9ef9efd5f6c3b96f36bd4988ad929aa6b2b9ff41","modified":1539167560928},{"_id":"public/tags/TensorBoard/index.html","hash":"15b61c171e682a58b017f8c7f0250e9838af4e51","modified":1539167560928},{"_id":"public/tags/markdown/index.html","hash":"aed691713fd54efa35f993ed9c46f1e0a2128d10","modified":1539167560928},{"_id":"public/tags/gitment/index.html","hash":"298e4e528b151d5b93a760f11b6318ff2ac2e04f","modified":1539167560928},{"_id":"public/tags/OAuth/index.html","hash":"f6f86ed139200d5cad4a370a5c7c6e9be3d1ae47","modified":1539167560928},{"_id":"public/tags/阿里云/index.html","hash":"ed783e8c7ec829164eb68c169e7f00b71522947d","modified":1539167560929},{"_id":"public/tags/ajax/index.html","hash":"b3484ca5f62e02f4bde27c6ae6f9a27876645915","modified":1539167560929},{"_id":"public/tags/form/index.html","hash":"cc3cd373380decd9879a5471c58ca2971432ef31","modified":1539167560929},{"_id":"public/tags/同步/index.html","hash":"e7482144e06a9712f75c3c67e26e5866d18bda9c","modified":1539167560929},{"_id":"public/tags/异步/index.html","hash":"4f367de6ed386375e16b0162fdd52a76bf9916de","modified":1539167560929},{"_id":"public/tags/Typora/index.html","hash":"30cdb20e2734b350ad6e36dcea4a8573dfd0d48e","modified":1539167560929},{"_id":"public/tags/Markdown/index.html","hash":"1b98625cc37a251a878f9e16e0e2c4cd7d0ab083","modified":1539167560929},{"_id":"public/tags/内存/index.html","hash":"6dc062d6813b6df520b14cc37480181eba98c1d9","modified":1539167560929},{"_id":"public/tags/Valine/index.html","hash":"a77f1cb5a5248fb8c69b9940a6006261d0d450ad","modified":1539167560929},{"_id":"public/tags/数据库/index.html","hash":"53681bb9f0c6268fc506a4a6cd4f32e879b1a383","modified":1539167560929},{"_id":"public/tags/SQL/index.html","hash":"2aea03089720e156dfe9af1b76e46d2e860c2ba5","modified":1539167560929},{"_id":"public/tags/操作系统/index.html","hash":"4756a89cb98422ec21a0d1faa241aa9ee40fd94f","modified":1539167560934},{"_id":"public/tags/指针/index.html","hash":"fcf16aa978ccefd2325b09fe8a17382465179f5a","modified":1539167560934},{"_id":"public/tags/归并/index.html","hash":"a49ff8a931c3ac173dabdb55c7f8ff280099028e","modified":1539167560934},{"_id":"public/tags/Tmux/index.html","hash":"c9683a243bca5d24fefba3a652ed0072b05e2338","modified":1539167560934},{"_id":"public/tags/BN/index.html","hash":"8bf74630766f355ec242ec41ab608d41dfb6d6bf","modified":1539167560934},{"_id":"public/tags/爬虫/index.html","hash":"2dcd37f4cfbcf9238d20152dbb725d1a77bb8e65","modified":1539167560934},{"_id":"public/tags/Python/index.html","hash":"0803ea2c7e609902e01278feb204823977fd0936","modified":1539167560934},{"_id":"public/tags/数据库建模/index.html","hash":"b6ef60a0201c0ea04f5609c33c0a1732bb7ea57f","modified":1539167560934},{"_id":"public/tags/建模/index.html","hash":"f1974784a6e024e35394662aab095b40e6051f36","modified":1539167560934},{"_id":"public/tags/mongoDB/index.html","hash":"0a681a9c2b3e1a41697b84139124794e0dc46074","modified":1539167560934},{"_id":"public/tags/Flask/index.html","hash":"ae47c10f73db2e6a2f7cbb6993f1ce10459791f7","modified":1539167560934},{"_id":"public/tags/SCRUM/index.html","hash":"6195d934b7261383050e5599932c682f50263816","modified":1539167560934},{"_id":"public/tags/VUE/index.html","hash":"4e77d80811a8f5dd36ad4bb2c5fdc2f703e5cdd2","modified":1539167560934},{"_id":"public/tags/Flux/index.html","hash":"acc9062de2430fde744965c31a3a931a8cf7b1a5","modified":1539167560934},{"_id":"public/tags/三层架构/index.html","hash":"c8b57c0eaceef34242947cacf5e2ead1de4a8523","modified":1539167560935},{"_id":"public/tags/设计模式/index.html","hash":"d75f8af1832a0156da153f88ba147b4f83c0ba7d","modified":1539167560935},{"_id":"public/tags/遇见逆水寒/index.html","hash":"bc80e2dbe442612376d03a0d9bd91c6876ca81d8","modified":1539167560935},{"_id":"public/tags/github-pages/index.html","hash":"5514fdc614337d23cb3a4be3b2a6b3257abef809","modified":1539167560935},{"_id":"public/categories/index.html","hash":"9305a81634ee97c1d21ffa9bd1dfea2f33efaf8f","modified":1539167560935},{"_id":"public/tags/index.html","hash":"e218612e440d2d000a63f8e4c1721591984e931d","modified":1539167560935},{"_id":"public/7个好用的在线YouTube视频下载工具.html","hash":"0f45b7529ef55a1f3df62666902116f54e6abcf2","modified":1539167560935},{"_id":"public/JavaScript实现双向链表.html","hash":"be1907663d3990185b487eb9116fae58058e80c2","modified":1539167560935},{"_id":"public/同步与异步.html","hash":"10a5361a6fff549bea9a25aaa3a512b5817c7486","modified":1539167560935},{"_id":"public/Promise与async-await.html","hash":"02ae609a31309b3e84fedc30882dd15f3e11f5f5","modified":1539167560935},{"_id":"public/ubuntu修改顶栏颜色.html","hash":"824f270527695bbff992615a65f8bf2ad963b724","modified":1539167560935},{"_id":"public/常用SQL语句.html","hash":"873dec62f76948fa96d53b5e3495508f5f34e9d4","modified":1539167560935},{"_id":"public/数据库基础知识.html","hash":"864bb7b1d72f299f4e9a32e1271d27872e4689c0","modified":1539167560935},{"_id":"public/操作系统面试相关总结.html","hash":"82cf29b9b613948633840b7cc0ee88779eeef811","modified":1539167560935},{"_id":"public/继续磕面经.html","hash":"03994ccd949c6f14a3be25d5296e87586e44251f","modified":1539167560935},{"_id":"public/cookie、sessionStorage和localStorage.html","hash":"6c3a81cbf6816b79a88ca4edaf382df1ccc0a9ef","modified":1539167560935},{"_id":"public/前端向后台发送请求有哪些方式.html","hash":"6cec081f20e9de9ea9f415083880537a0fb2c0f2","modified":1539167560935},{"_id":"public/git相关整理.html","hash":"69cdbc27a02f8151c53aba120bde8285bafe598e","modified":1539167560936},{"_id":"public/ubuntu18-04开机慢的解决办法.html","hash":"a67a7cca69e80df60f3a7faa18cda067da03ff12","modified":1539167560936},{"_id":"public/Vuex入门.html","hash":"1c8a3a64c9300df72ecabe7de9269ecd2b92bad9","modified":1539167560936},{"_id":"public/HTTP学习记录.html","hash":"5c72ef0325ad100144c975bf02c879a63feee6b0","modified":1539167560936},{"_id":"public/牛客网前端挑战编程题解.html","hash":"4fef371b384e046574dcc93edcdb2b74339cff16","modified":1539167560936},{"_id":"public/Web前端错题模糊题记录.html","hash":"e9c18edbd96fd14c22367bc71730f3f714de39ae","modified":1539167560936},{"_id":"public/Ubuntu下使用Deepin-wine的移植版安装qq微信等.html","hash":"df85bb37cf6bea06a69f9daf35ef3b3ef5fa8567","modified":1539167560936},{"_id":"public/JavaScript学习记录四.html","hash":"87ef397dff05e91d816cae871e04552e561816bc","modified":1539167560936},{"_id":"public/JavaScript学习记录三.html","hash":"69feb7d21e1c911cf32ddf9d2c522ca23d2851a4","modified":1539167560936},{"_id":"public/JavaScript学习记录二.html","hash":"005ab2f141f01dba8c53d004dded9ff8e7f7e3d3","modified":1539167560936},{"_id":"public/JavaScript学习记录一.html","hash":"b5646f8c70173e0014e439dcb539fa84c976c1fb","modified":1539167560936},{"_id":"public/HTML5与CSS3权威指南之HTML5学习记录.html","hash":"9f3dd67b38f0d538550c4e499ee1b5709da90b87","modified":1539167560936},{"_id":"public/HTML与CSS学习记录.html","hash":"1ae7fdbc8604fade28b4bd2fee6209173db396e7","modified":1539167560937},{"_id":"public/JavaScript原型链-prototype与-proto.html","hash":"beec2427e20cb7e380907c2529737e189f29b025","modified":1539167560937},{"_id":"public/ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法.html","hash":"e558cce5fc446bd75f342b11eb41877fc8ac391a","modified":1539167560937},{"_id":"public/ubuntu-18-04下安装稳定版Chrome谷歌浏览器.html","hash":"767134e6e062b37151d196accc55d31103fc0267","modified":1539167560937},{"_id":"public/ubuntu18-04中安装iNode.html","hash":"24b1eca09ec84a4ec989312c167f154cd7674ec8","modified":1539167560937},{"_id":"public/在ubuntu中安装Markdown神器Typora.html","hash":"282a291e1d11bf50c5d43a7bdeb2dd55b9f010e7","modified":1539167560937},{"_id":"public/ubuntu下无法将iNode绑定到侧边栏的解决办法.html","hash":"0a1eec88d672bef1689fde51c582fc2ce8a984e1","modified":1539167560937},{"_id":"public/ubuntu下创建文件夹快捷方式.html","hash":"b2f58eb752b40274470d663695be3c5edc7e8607","modified":1539167560937},{"_id":"public/遇见逆水寒男号女NPC奇物好感统计.html","hash":"42d60e9017df6abd9574f7b4a0a084c40d708244","modified":1539167560937},{"_id":"public/猫眼电影加密数字破解（爬取评分票房票价）.html","hash":"9d3578f5015b217cd56c776e61cadf47b133f213","modified":1539167560937},{"_id":"public/系统分析与设计作业FinalReport.html","hash":"b0765dd053796714265954b3ca504db7785a35ac","modified":1539167560937},{"_id":"public/系统分析与设计作业十六.html","hash":"e685b71114754228a0b27eb8534bd37cb1181fd6","modified":1539167560937},{"_id":"public/深度学习周报week11-week12.html","hash":"6583721309cd41e6991a27914e1d9a52c45a0aad","modified":1539167560937},{"_id":"public/深度学习周报week09-week10.html","hash":"b8861f9d06fe3ba8ef45e1a6276e4f3e743e1c3c","modified":1539167560937},{"_id":"public/系统分析与设计作业十三.html","hash":"6bf430939108b611d0b97e5bb4360c26049aa1cd","modified":1539167560937},{"_id":"public/深度学习周报week07-week08.html","hash":"697184539ebc5318f2b9ee4da4a3cf62ddbfa8dc","modified":1539167560938},{"_id":"public/系统分析与设计作业九.html","hash":"13104f3ddaa621c25f4da35aaf00628e8584513c","modified":1539167560938},{"_id":"public/深度学习周报week05-week06.html","hash":"f025d8c3883683f337fd934df135376cc3ebeb19","modified":1539167560938},{"_id":"public/深度学习周报week03-week04.html","hash":"34f565ac1439d143b0c0cf192a8293918caa5e12","modified":1539167560938},{"_id":"public/系统分析与设计作业八.html","hash":"b7c10dc8cc7ed685f4a3a6b50ec8167f124cb466","modified":1539167560938},{"_id":"public/系统分析与设计作业七.html","hash":"3fd7f2836bb439216382c6f583853a6007482613","modified":1539167560938},{"_id":"public/系统分析与设计作业六.html","hash":"5612eff683d5b0bd721668eb0659b2ab9fd793f1","modified":1539167560938},{"_id":"public/hexo博客谷歌百度收录踩坑日记.html","hash":"ffd2843aa732856d83869423a764fff2c53a2e89","modified":1539167560938},{"_id":"public/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法.html","hash":"08eef52c202aeb15bef84a16adf7317659b2cdfb","modified":1539167560938},{"_id":"public/系统分析与设计作业五.html","hash":"0ca51c890c9ab7387f866a3ed2ba523f62bba364","modified":1539167560938},{"_id":"public/智能指针.html","hash":"a93c96ee1d368fe055d28c9ace9ac948b33db846","modified":1539167560938},{"_id":"public/numpy常用函数和数据类型.html","hash":"8cac0c4b4024aec6701fa757f7c6631c105d7adf","modified":1539167560938},{"_id":"public/使用TensorBoard可视化工具.html","hash":"7562e88d03db4174d9d931e5469dd88fea9358bf","modified":1539167560938},{"_id":"public/TensorFlow训练MNIST报错ResourceExhaustedError.html","hash":"e7427ef387a1f4bc8c0dc6765722eaa1dac44e53","modified":1539167560938},{"_id":"public/TensorFlow基础知识.html","hash":"a52d922572d4786557bdb295ba1ed05992a50648","modified":1539167560938},{"_id":"public/关于hexo-markdown添加的图片在github-page中无法显示的问题.html","hash":"c994f357d5581ad80712eef3c0a0d17599191cd9","modified":1539167560938},{"_id":"public/深度学习周报week01-week02.html","hash":"fa18d88d9540b5dd287a0ec1a66c39d937d0082c","modified":1539167560939},{"_id":"public/部署hexo后github-pages页面未更新或无法打开问题.html","hash":"5dbbeb8a89b64132d82e6e5b14ff58639d27c76d","modified":1539167560939},{"_id":"public/堆和栈的区别.html","hash":"4b2d724d0b1da9276093686294cddb9900a6704f","modified":1539167560939},{"_id":"public/archives/index.html","hash":"0af37b6f1a3e37034632775f4004f3c479d271e6","modified":1539167560939},{"_id":"public/archives/page/2/index.html","hash":"52d3aac95af261e603f3b9a1e55f127ca3fcfca0","modified":1539167560939},{"_id":"public/archives/page/3/index.html","hash":"0c8d502aa98dcf2456deb88f818ea7724d94caf3","modified":1539167560939},{"_id":"public/archives/2018/index.html","hash":"d52d551a752a58f915a3c53464c493ef348dac11","modified":1539167560939},{"_id":"public/archives/2018/page/2/index.html","hash":"949c132f72ef0d2eedf3e6ab16c28bc906ed36f7","modified":1539167560939},{"_id":"public/archives/2018/page/3/index.html","hash":"2f3739044e4bf3f3d60ba7c91c3e2aadc70ddeec","modified":1539167560939},{"_id":"public/archives/2018/03/index.html","hash":"cad4f5586c32d544e4905c3eb080368c0b847edc","modified":1539167560939},{"_id":"public/archives/2018/04/index.html","hash":"ec8a87d5b2e77b878979cc1fbb46674e562ac976","modified":1539167560939},{"_id":"public/archives/2018/05/index.html","hash":"133245364be5903af2a8783969945c70ebd6ae75","modified":1539167560939},{"_id":"public/archives/2018/06/index.html","hash":"d1a2ff9c15aa796d1e330ce3aa92ade1034a884f","modified":1539167560939},{"_id":"public/archives/2018/09/index.html","hash":"536e97212775092409a80b33a426b3acdf3e4ff7","modified":1539167560939},{"_id":"public/archives/2018/09/page/2/index.html","hash":"9f78ff116ae6d9301098faf27c9e2267c158041d","modified":1539167560939},{"_id":"public/archives/2018/10/index.html","hash":"b1b8b36181da37234216f1fe98e579d4a6aa29ca","modified":1539167560940},{"_id":"public/categories/methods/index.html","hash":"f8340af3adb8a1bc60c829b961af8be37dfa6511","modified":1539167560940},{"_id":"public/categories/Web/index.html","hash":"0f04d31d0001ce371d5b1aabb3346a7f47f2d716","modified":1539167560940},{"_id":"public/categories/deep-learning/index.html","hash":"a8b4d21bd9de030c741956870d1d7c2d443bd675","modified":1539167560940},{"_id":"public/categories/系统分析与设计/index.html","hash":"9d871c7a4697fd19881f082bcf4010fd8fb09d31","modified":1539167560940},{"_id":"public/index.html","hash":"cd6fa4be5086eb48ed92f2a02488237f43f6c96d","modified":1539167560940},{"_id":"public/page/3/index.html","hash":"66a0c5a962f78a75a08f27bed02a0682d5a8eb3a","modified":1539167560940},{"_id":"public/page/4/index.html","hash":"85bc3a3a1b193a17657d7d849129f825e52abb2a","modified":1539167560940},{"_id":"public/page/5/index.html","hash":"ebc8adb08181d3230b84b05594f44f2d89b5ab7a","modified":1539167560940},{"_id":"public/page/6/index.html","hash":"e119b6a03c401b78235540b813aa8e6919ead242","modified":1539167560940},{"_id":"public/page/7/index.html","hash":"c497747b77e9f05673e178793d54ce51a1833cf9","modified":1539167560940},{"_id":"public/tags/HTML/index.html","hash":"05b7a4b1ec04ea1f91dae0296f7d9c0468efe098","modified":1539167560940},{"_id":"public/tags/JavaScript/index.html","hash":"9cf45ba3f1b61e33418143c7a4932e9ea02dd26c","modified":1539167560940},{"_id":"public/tags/TensorFlow/index.html","hash":"cbcb8a505b73f180623b5d62dee8c3d793d1c119","modified":1539167560940},{"_id":"public/tags/ubuntu/index.html","hash":"30dae3945288aecbccf5914d173be6f0d1f6ac50","modified":1539167560940},{"_id":"public/tags/hexo/index.html","hash":"17c33d94e76c08700fb7836357d4817ca5d5e814","modified":1539167560941},{"_id":"public/tags/UMLet/index.html","hash":"26b9c993bc486888382b435a50e46f9b22daed0c","modified":1539167560941},{"_id":"public/tags/用例图/index.html","hash":"123d5799b94053c18eadbd01201b8209a6fbcbf5","modified":1539167560941},{"_id":"public/CNAME","hash":"5f5cda3f6c72ad3ee0b593daafabfec550a41dc6","modified":1539167560946},{"_id":"public/README.md","hash":"454bddac036bc573c4f7c7e7832231becd2cee83","modified":1539167560946},{"_id":"public/favicon.ico","hash":"696f776d5517ca053000dfe5948e819bf48e1dd6","modified":1539167560946},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1539167560946},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1539167560946},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1539167560946},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1539167560946},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1539167560946},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1539167560947},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1539167560947},{"_id":"public/css/prism.css","hash":"9ff88ae307098176655ee460023e68ac80358ef4","modified":1539167560947},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1539167561354},{"_id":"public/fancybox/jquery.fancybox.css","hash":"3624d08159d3e8ea713c3f009c6d204bc5ffbd30","modified":1539167562473},{"_id":"public/js/script.js","hash":"d72b7639b3ca5e025b1346343807e8a3432122f8","modified":1539167562473},{"_id":"public/js/totop.js","hash":"672b81dd995c9a541a81e2d22301f79600f7ad30","modified":1539167562473},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"cc3e2694d43f75ea3c808774d411ee7fd55861f3","modified":1539167562473},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"51173185f9268102da561d1f14bbc10121f2e144","modified":1539167562473},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"30e114153900e8f0b40723b05986d11118740e6e","modified":1539167562473},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"38d55280b8b9027774bee8a10cf3b033caa2337d","modified":1539167562473},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"f61b63deaaede4f945c88cc278f9df40de420059","modified":1539167562473},{"_id":"public/baidu_verify_CPVBgyCjF8.html","hash":"bcdd113d9b4bd2f097dd7d3b43aefe54e4b67d82","modified":1539167562473},{"_id":"public/baidu_verify_KS1HHksWBu.html","hash":"23c57476910e679926c1390de149bd9119ae6610","modified":1539167562473},{"_id":"public/google9da4e92e637f6c53.html","hash":"67e87478705d1c4257f2c5dd619d42f5fe83273d","modified":1539167562473},{"_id":"public/css/style.css","hash":"a2dc6ff02339e5a73640c47b9c52ebc1f7cc670b","modified":1539167562473},{"_id":"public/fancybox/jquery.fancybox.js","hash":"230d124b7e4ed10b3e2c074bfc424e6a29068da0","modified":1539167562473},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"18556c762a4e46a475878c44ab89fe29264989ed","modified":1539167562473}],"Category":[{"name":"methods","_id":"cjn30m1v00004fmag6srluo8w"},{"name":"Web","_id":"cjn30m1v60009fmagyfto08gq"},{"name":"deep learning","_id":"cjn30m1vo000yfmagqcyhta9c"},{"name":"OJ","_id":"cjn30m1vy001cfmagvf9gfmb8"},{"name":"Python","_id":"cjn30m1w8001xfmag7y94ebxf"},{"name":"C/C++","_id":"cjn30m1wy0034fmag7tgtxjjd"},{"name":"系统分析与设计","_id":"cjn30m1xr004ifmag7m4ta93s"}],"Data":[],"Page":[{"title":"All categories","date":"2018-03-30T18:11:03.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: All categories\ndate: 2018-03-31 02:11:03\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2018-09-11T05:46:12.973Z","path":"categories/index.html","comments":1,"_id":"cjn30m1ur0000fmagbj68y8g4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","date":"2018-03-30T18:09:33.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ndate: 2018-03-31 02:09:33\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2018-09-11T05:46:12.981Z","path":"tags/index.html","comments":1,"_id":"cjn30m1ux0002fmagxa37dfjl","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"7个好用的在线YouTube视频下载工具","toc":false,"date":"2018-10-10T07:11:00.000Z","_content":"\n[**ClipConverter.CC**](https://www.gihosoft.com/hot-topics/4k-video-downloader.html)\n\n[**Converto.io**](https://www.converto.io/)\n\n[**Video Grabber**](http://www.videograbber.net/) \n\n[**SaveFrom.net**](http://en.savefrom.net/)\n\n[**Catchvideo**](http://catchvideo.net/)\n\n[**Y2mate**](https://y2mate.com/)\n\n[**Online Video Converter**](https://www.onlinevideoconverter.com/mp3-converter)\n\n<!-- more -->\n\n![ClipConverter.CC](https://www.gihosoft.com/wp-content/uploads/2016/12/clipconverter.cc.png)\n\n![Converto.io](https://www.gihosoft.com/wp-content/uploads/2018/04/youtube-to-mp4-online.jpg)\n\n![Video Grabber](https://www.gihosoft.com/wp-content/uploads/2016/12/video-grabber.png)\n\n![SaveFrom.net](https://www.gihosoft.com/wp-content/uploads/2016/12/savefrom.net_.png)\n\n![Catchvideo](https://www.gihosoft.com/wp-content/uploads/2016/12/catchvideo.png)\n\n![y2mate](https://www.gihosoft.com/wp-content/uploads/2018/04/y2mate.png)\n\n![Online Video Converter](https://www.gihosoft.com/wp-content/uploads/2018/08/online-video-converter.png)","source":"_posts/7个好用的在线YouTube视频下载工具.md","raw":"---\ntitle: 7个好用的在线YouTube视频下载工具\ntoc: false\ndate: 2018-10-10 15:11:00\ncategories:\n- methods\ntags:\n- youtube\n---\n\n[**ClipConverter.CC**](https://www.gihosoft.com/hot-topics/4k-video-downloader.html)\n\n[**Converto.io**](https://www.converto.io/)\n\n[**Video Grabber**](http://www.videograbber.net/) \n\n[**SaveFrom.net**](http://en.savefrom.net/)\n\n[**Catchvideo**](http://catchvideo.net/)\n\n[**Y2mate**](https://y2mate.com/)\n\n[**Online Video Converter**](https://www.onlinevideoconverter.com/mp3-converter)\n\n<!-- more -->\n\n![ClipConverter.CC](https://www.gihosoft.com/wp-content/uploads/2016/12/clipconverter.cc.png)\n\n![Converto.io](https://www.gihosoft.com/wp-content/uploads/2018/04/youtube-to-mp4-online.jpg)\n\n![Video Grabber](https://www.gihosoft.com/wp-content/uploads/2016/12/video-grabber.png)\n\n![SaveFrom.net](https://www.gihosoft.com/wp-content/uploads/2016/12/savefrom.net_.png)\n\n![Catchvideo](https://www.gihosoft.com/wp-content/uploads/2016/12/catchvideo.png)\n\n![y2mate](https://www.gihosoft.com/wp-content/uploads/2018/04/y2mate.png)\n\n![Online Video Converter](https://www.gihosoft.com/wp-content/uploads/2018/08/online-video-converter.png)","slug":"7个好用的在线YouTube视频下载工具","published":1,"updated":"2018-10-10T08:35:39.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1us0001fmagnubydlh4","content":"<p><a href=\"https://www.gihosoft.com/hot-topics/4k-video-downloader.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>ClipConverter.CC</strong></a></p><p><a href=\"https://www.converto.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Converto.io</strong></a></p><p><a href=\"http://www.videograbber.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Video Grabber</strong></a></p><p><a href=\"http://en.savefrom.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>SaveFrom.net</strong></a></p><p><a href=\"http://catchvideo.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Catchvideo</strong></a></p><p><a href=\"https://y2mate.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Y2mate</strong></a></p><p><a href=\"https://www.onlinevideoconverter.com/mp3-converter\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Online Video Converter</strong></a></p><a id=\"more\"></a><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/clipconverter.cc.png\" alt=\"ClipConverter.CC\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/04/youtube-to-mp4-online.jpg\" alt=\"Converto.io\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/video-grabber.png\" alt=\"Video Grabber\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/savefrom.net_.png\" alt=\"SaveFrom.net\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/catchvideo.png\" alt=\"Catchvideo\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/04/y2mate.png\" alt=\"y2mate\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/08/online-video-converter.png\" alt=\"Online Video Converter\"></p>","site":{"data":{}},"excerpt":"<p><a href=\"https://www.gihosoft.com/hot-topics/4k-video-downloader.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>ClipConverter.CC</strong></a></p><p><a href=\"https://www.converto.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Converto.io</strong></a></p><p><a href=\"http://www.videograbber.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Video Grabber</strong></a></p><p><a href=\"http://en.savefrom.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>SaveFrom.net</strong></a></p><p><a href=\"http://catchvideo.net/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Catchvideo</strong></a></p><p><a href=\"https://y2mate.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Y2mate</strong></a></p><p><a href=\"https://www.onlinevideoconverter.com/mp3-converter\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Online Video Converter</strong></a></p>","more":"<p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/clipconverter.cc.png\" alt=\"ClipConverter.CC\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/04/youtube-to-mp4-online.jpg\" alt=\"Converto.io\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/video-grabber.png\" alt=\"Video Grabber\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/savefrom.net_.png\" alt=\"SaveFrom.net\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2016/12/catchvideo.png\" alt=\"Catchvideo\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/04/y2mate.png\" alt=\"y2mate\"></p><p><img src=\"https://www.gihosoft.com/wp-content/uploads/2018/08/online-video-converter.png\" alt=\"Online Video Converter\"></p>"},{"title":"HTML5与CSS3权威指南之HTML5学习记录","toc":true,"date":"2018-09-11T08:08:11.000Z","_content":"\n学习资料——《HTML5与CSS3权威指南》（第3版）\n\n官方网站：\n\n[华章图书](http://www.hzbook.com/)\n\n书中所有代码下载链接：\n\n链接：http://pan.baidu.com/s/1c0oGMn2 密码：f7zt\n\n<!-- more -->\n\n[HTML5优缺点](https://blog.csdn.net/qq_34309704/article/details/80163001)\n\n---\n\n","source":"_posts/HTML5与CSS3权威指南之HTML5学习记录.md","raw":"---\ntitle: HTML5与CSS3权威指南之HTML5学习记录\ntoc: true\ndate: 2018-09-11 16:08:11\ncategories:\n- Web\ntags:\n- HTML\n---\n\n学习资料——《HTML5与CSS3权威指南》（第3版）\n\n官方网站：\n\n[华章图书](http://www.hzbook.com/)\n\n书中所有代码下载链接：\n\n链接：http://pan.baidu.com/s/1c0oGMn2 密码：f7zt\n\n<!-- more -->\n\n[HTML5优缺点](https://blog.csdn.net/qq_34309704/article/details/80163001)\n\n---\n\n","slug":"HTML5与CSS3权威指南之HTML5学习记录","published":1,"updated":"2018-10-10T08:37:25.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1uy0003fmagtirqd2w3","content":"<p>学习资料——《HTML5与CSS3权威指南》（第3版）</p><p>官方网站：</p><p><a href=\"http://www.hzbook.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">华章图书</a></p><p>书中所有代码下载链接：</p><p>链接：<a href=\"http://pan.baidu.com/s/1c0oGMn2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://pan.baidu.com/s/1c0oGMn2</a> 密码：f7zt</p><a id=\"more\"></a><p><a href=\"https://blog.csdn.net/qq_34309704/article/details/80163001\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML5优缺点</a></p><hr>","site":{"data":{}},"excerpt":"<p>学习资料——《HTML5与CSS3权威指南》（第3版）</p><p>官方网站：</p><p><a href=\"http://www.hzbook.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">华章图书</a></p><p>书中所有代码下载链接：</p><p>链接：<a href=\"http://pan.baidu.com/s/1c0oGMn2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://pan.baidu.com/s/1c0oGMn2</a> 密码：f7zt</p>","more":"<p><a href=\"https://blog.csdn.net/qq_34309704/article/details/80163001\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML5优缺点</a></p><hr>"},{"title":"HTML与CSS学习记录","toc":true,"date":"2018-09-10T06:04:59.000Z","_content":"\n\n\n《HTML与CSS进阶教程读书笔记》\n\n<!-- more -->\n\n---\n\n\n\n# HTML基础知识\n\n## HTML与XHTML\n\nHTML指超文本标记语言，是构成网页文档的主要语言。我们常说的HTML指HTML4.01。\n\nXHTML指扩展的超文本标记语言，是XML风格的、更严格、更纯净的HTML。\n\n两者的主要区别：\n\n- XHTML标签必须闭合。\n- XHTML标签和属性必须小写。\n- XHTML标签属性必须加引号。\n- XHTML标签用id属性代替name属性。\n\n## id和class\n\n由于id属性具有唯一性，因此W3C建议，对于页面关键的结构或大结构，才能使用id属性，其他地方使用class属性。\n\n<u>因为搜索引擎是根据标签的语义和id属性来识别的，因此id属性的使用和命名都需要谨慎。</u>\n\n一般来说，定义多个class的目的在于：一个class抽取公共样式，一个class定义单独样式。\n\n## 标题栏小图标\n\n在`head`标签内加入：\n\n```html\n<link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"图标路径.ico\" />\n```\n\n其中`rel`和`type`是固定属性不用更改，只需要修改图片路径即可。\n\n\n\n# 语义化\n\nHTML的精髓在于标签的语义。搜索引擎根据HTML代码识别页面结构。\n\n编写语意结构良好的页面的好处：\n\n- 利于开发调试和后期维护。\n- 利于搜索引擎优化。\n\n应优先使用正确的语义化标签，如果没有语义化标签可用，再考虑div或者span等无语义标签。\n\n## 标题语义化\n\nh1-h6是标题标签，相比于其他标签，它们在搜索引擎优化（SEO）中占有相当重要的地位。\n\n一般用到h4，h5和h6权重和普通标签差不多，很少使用。\n\n对于标题语义化，我们需要注意的是：\n\n- 一个页面只能有一个h1标签。\n- h1-h6之间不要出现断层。\n- 不要用标题标签来定义样式（如为了加粗字体而为文本加上标题标签）。\n- 不要用div来代替标题标签。\n\ndiv是无语义的标签，如果使用div代替标题标签会使网页在SEO中丢失大量权重。\n\n## 图片语义化\n\n### alt属性和title属性\n\nalt是给搜索引擎看的，title是给用户看的。\n\n搜索引擎根据alt属性或上下文判断图片内容。\n\n因此**img标签必须添加alt属性。**\n\n### figure元素和figcaption元素\n\n对于图片+图注的效果，使用figure和figcaption来增强图片语义化。\n\n例：\n\n```html\n<figure>\n    <img src=\"xxx\" alt=\"xxx\" />\n    <figcaption>这是一个图注</figcaption>\n</figure>\n```\n\n更详细的介绍可以看[这一篇博客](https://www.w3cplus.com/html5/quick-tip-the-right-way-to-use-figure-and-figcaption-elements.html)。\n\n## 表格语义化\n\n| 标签    | 说明             |\n| ------- | ---------------- |\n| table   | 表格             |\n| caption | 标题             |\n| thead   | 表头（语义划分） |\n| tbody   | 表身（语义划分） |\n| tfoot   | 表尾（语义划分） |\n| tr      | 行               |\n| th      | 表头单元格       |\n| td      | 表格单元格       |\n\n## 表单语义化\n\n### label标签\n\nlabel标签的for属性有两个作用：\n\n- 语义上绑定了label元素和表单元素。（\\<label for=\"*element_id*\">）\n- 当我们点击label中的文本时，其关联的表单元素也会获得焦点。\n\n例：\n\n```html\n<input id=\"rdo\" name=\"rdo\" type=\"radio\" /><label for=\"rdo\">单选框</label>\n```\n\n### fieldset标签和legend标签\n\nfieldset标签用于给表单元素进行分组并绘制一个边框，legend标签用于定义某一组表单的标题。\n\n例如这个[例子](http://www.runoob.com/tags/tag-fieldset.html)：\n\n```html\n<form>\n  <fieldset>\n    <legend>Personalia:</legend>\n    Name: <input type=\"text\"><br>\n    Email: <input type=\"text\"><br>\n    Date of birth: <input type=\"text\">\n  </fieldset>\n</form>\n```\n\n作用：\n\n- 增强表单语义。\n- 可以使用fieldset标签的disabled属性来禁用整个组中的表单元素。\n\n## 其他语义化\n\n### 换行符\\<br />\n\nW3C标准规定，\\<br />标签只能用于段落中的换行。即只能用于p标签内部。\n\n### 无序列表ul\n\n对于列表型数据，不建议使用div实现，而应用无序列表或有序列表实现。\n\n为了实现外观效果，一般使用无序列表而不是有序列表。\n\n### strong 标签和em标签\n\nW3C对这两个标签赋予了“强调”的语义。\n\n可以在CSS中重新定义它们的样式而不会改变它们的语义。\n\n### del标签和ins标签\n\n这两个标签一般是配合使用表示更新文本：“delete”和“insert”，被删除的文本和被更新的文本。\n\n一般会用CSS重新定义它们的样式。\n\n[实例链接](http://www.runoob.com/tags/tag-del.html)\n\n### img标签\n\n对于什么时候使用img标签，什么时候使用背景图片，应该根据HTML的语义来判断。\n\n- img标签：作为HTML的一部分，希望被搜索引擎识别。\n\n- 背景图片： 只起到修饰作用，不希望被搜索引擎识别。\n\n## 语义化验证\n\n通过去掉CSS样式，观察页面是否还有很好的可读性来判断一个页面是否语义良好。\n\n## HTML5舍弃的标签\n\n下边这些已经被舍弃的标签(仅为了定义样式的标签和很少使用或已经被新标签代替的标签)应停止使用：\n\n- `<acronym>`  定义首字母缩写，应用abbr代替。\n- `<applet>` 定义嵌入的applet，应用object代替。\n- `<basefont>`\n- `<big>`\n- `<center>`\n- `<dir>` 定义目录列表，应用ul代替。\n- `<font>`\n- `<frame>`\n- `<frameset>`\n- `<noframes>`\n- `<strike>`\n- `<tt>`\n\n# CSS基础知识\n\n## CSS单位\n\n### px\n\npixel，像素，一个图片或计算机屏幕中最小的点。\n\n### 百分比%\n\nCSS中支持百分比的属性：\n\n- **width、height、font-size**，它们的百分比是相对于父元素的“相同元素”的值来计算的。\n- **line-height**，它的百分比是相对于**父元素**的**font-size**值来计算的。\n- **vertical-align**，它的百分比是相对于**当前元素**继承的**line-height**值来计算的。\n\n### em\n\n1em等于当前元素的以px为单位的font-size值，\n\n若当前元素的font-size值没有定义，则从父元素继承，\n\n若当前元素的所有祖先元素都没有定义font-size，则继承浏览器默认的font-size值：16px。\n\n<u>使用em的小技巧：</u>首行缩进使用 `text-indent: 2em`实现。\n\n### rem\n\nCSS3新引入的单位，指相对根元素（即html元素）的字体大小。\n\n## CSS特性\n\n### 继承性\n\n指子元素继承了父元素的某些样式属性。\n\n在CSS中，具有继承性的样式有三大类：\n\n- **文本**相关属性： font--family，font-size，font-style，font-weight，font，line-height，text-align，text-indent，word-spacing。\n- **列表**相关属性： list-style-image，list-style-position，list-style-type，list-style。\n- **颜色**相关属性： color。\n\n### 层叠性\n\n“后者居上”原则。\n\nCSS的层叠性指样式的覆盖。对于具有**相同权重**的**相同属性**，以最后定义的值为准。\n\n## CSS优先级\n\n### 引用方式\n\n行内样式>(内部样式=外部样式)\n\n若同时存在权重相同内部样式和外部样式，则以最后引入的样式为准。\n\n### 继承方式\n\n以最近的祖先元素为准。\n\n### 指定样式\n\n常见的伪元素——:before、:after、:first-letter、:first-line。\n\n常见的伪类——:hover、:first-child等。\n\n常用的选择器优先级：行内样式>id选择器>class选择器>元素选择器。\n\n选择器权值表：\n\n| 选择器      | 权值 |\n| ----------- | ---- |\n| 通配符      | 0    |\n| 伪元素      | 1    |\n| 元素选择器  | 1    |\n| class选择器 | 10   |\n| 伪类        | 10   |\n| 属性选择器  | 10   |\n| id选择器    | 100  |\n| 行内样式    | 1000 |\n\n### 继承样式和和指定样式\n\n指定样式权重更高。\n\n### !important\n\n权值最高，不推荐使用。\n\n## CSS引入方式\n\n- 导入样式表（加载html后加载css，不推荐）\n- 外部样式表（link标签）\n- 内部样式表（style标签）\n- 行内样式表\n\n## CSS选择器\n\nCSS出去基本的选择器（元素选择器、id选择器、class选择器、群组或分组选择器），\n\n还有<u>层次选择器</u>：\n\n| 选择器 | 说明                                      |\n| ------ | ----------------------------------------- |\n| M N    | 后代选择器，选择M元素所有内部后代N元素    |\n| M>N    | 子代选择器，选择M元素所有内部子代N元素    |\n| M~N    | 兄弟选择器，选择M元素所有同级N元素        |\n| M+N    | 相邻选择器，选择M元素相邻的下一个同级元素 |\n\n# CSS规范\n\n## 命名规范\n\n### CSS文件命名\n\n开发阶段按照功能模块划分CSS文件。\n\n| 文件名      | 说明                                 |\n| ----------- | ------------------------------------ |\n| reset.css   | 重置样式，重置元素默认样式           |\n| global.css  | 全局样式，全站公用，定义页面基础样式 |\n| themes.css  | 主题样式，用于实现换肤功能           |\n| module.css  | 模块样式，用于模块的样式             |\n| master.css  | 母版样式，用于母版页的样式           |\n| columes.css | 专栏样式，用于专栏的样式             |\n| forms.css   | 表单样式，用于表单的样式             |\n| mend.css    | 补丁样式，用于维护、修改的样式       |\n| print.css   | 打印样式，用于打印的样式             |\n\n### id和class命名\n\n建议使用中划线命名，例如`column-title`。\n\n为了避免class命名的重复，一般取父元素的class名作为前缀，例如`column-title`。\n\n| 网页主体部分 | 命名                          |\n| ------------ | ----------------------------- |\n| 最外层       | wrapper(一般用于包裹整个页面) |\n| 头部         | header                        |\n| 内容         | content                       |\n| 侧栏         | sidebar                       |\n| 栏目         | column                        |\n| 热点         | hot                           |\n| 新闻         | news                          |\n| 下载         | download                      |\n| 标志         | logo                          |\n| 导航条       | nav                           |\n| 主体         | main                          |\n| 左侧         | main-left                     |\n| 右侧         | main-right                    |\n| 底部         | footer                        |\n| 友情链接     | friendlink                    |\n| 加入我们     | joinus                        |\n| 版权         | copyright                     |\n| 服务         | service                       |\n| 登录         | login                         |\n| 注册         | register                      |\n\n| 导航部分 | 命名          |\n| -------- | ------------- |\n| 主导航   | main-nav      |\n| 子导航   | sub-nav       |\n| 边导航   | side-nav      |\n| 左导航   | leftside-nav  |\n| 右导航   | rightside-nav |\n| 顶导航   | top-nav       |\n\n| 菜单部分 | 命名    |\n| -------- | ------- |\n| 菜单     | menu    |\n| 子菜单   | submenu |\n\n| 其他     | 命名          |\n| -------- | ------------- |\n| 标题     | title         |\n| 摘要     | summary       |\n| 登录条   | loginbar      |\n| 搜索     | search        |\n| 标签页   | tab           |\n| 广告     | banner        |\n| 小技巧   | tips          |\n| 图标     | icon          |\n| 法律声明 | siteinfolegal |\n| 网站地图 | sitemap       |\n| 工具条   | tool、toolbar |\n| 首页     | homepage      |\n| 子页     | subpage       |\n| 合作伙伴 | partner       |\n| 帮助     | help          |\n| 指南     | guide         |\n| 滚动     | scroll        |\n| 提示信息 | msg           |\n| 投票     | vote          |\n| 相关文章 | related       |\n| 文章列表 | list          |\n\n## 书写规范\n\n对于功能代码，应该集中放在一起，\n\n对于其他代码，应按照如下顺序：\n\n1. 影响文档流属性（布局属性）——display，position，float，clear等\n2. 自身盒模型属性——width，height，padding，margin，border，overflow等\n3. 文本性属性——font，line-height，text-align，text-indent，vertical-align等\n4. 装饰性属性——color，background-color，opacity等\n5. 其他属性——cursor，content，list-style，quotes等\n\n例如：\n\n```css\n#main {\n  /* 影响文档流属性 */\n  display: inline-block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* 盒子模型属性 */\n  width: 100px;\n  height: 100px;\n  border: 2px solid gray;\n  /* 文本性属性 */\n  font-size: 15px;\n  font-weight: bold;\n  text-indent: 2em;\n  /* 装饰性属性 */\n  color: white;\n  background-color: red;\n  /* 其他属性 */\n  cursor: pointer;\n}\n```\n\n## 注释规范\n\n由于压缩工具会删除所有的注释，因此有时为了保留版权声明等注释信息，需要在注释内容前加一个叹号，如`/*! 注释内容 */`，这样压缩工具就不会删除这条注释信息。\n\n### 顶部注释\n\n```css\n/*\n *@description:说明\n *@author:作者\n *@update:更新时间，如2018-09-10 17:42\n */\n```\n\n### 模块注释\n\n```css\n/* 导航部分，开始 */\n......\n/* 导航部分，结束 */\n```\n\n### 简单注释\n\n```css\n/* 单行注释 */\n```\n\n或者\n\n```css\n/*多行注释\n *多行注释\n *多行注释\n */\n```\n\n## CSS reset\n\n重置样式，去除元素在浏览器中的默认样式。\n\n是否使用CSS reset根据实际开发需求而定。\n\n# 盒子模型\n\n![标准盒子模型](https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=5ad0ba6a0c7b02080c9c37e752e9deeb/0824ab18972bd407012c41327d899e510eb30911.jpg)\n\n![IE盒子模型](https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=6cdf3ae9fbfaaf5184b689b9bc64b8d6/1b4c510fd9f9d72ac29d82d2d22a2834359bbb00.jpg)\n\n## 外边距叠加\n\n又称为“margin叠加”，指当两个外边距相遇时会“合二为一”。叠加后的外边距为两个外边距的最大值。\n\n<u>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</u>\n\n以下图片均来自[w3school](http://www.w3school.com.cn/css/css_margin_collapsing.asp)\n\n![同级元素](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif)\n\n![父子元素](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif)\n\n![空元素1](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif)\n\n![空元素2](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif)\n\n![外边距合并的意义](http://www.w3school.com.cn/i/ct_css_margin_collapsing.gif)\n\n## 负margin\n\n- 当margin-top或者margin-left为负数时，**当前元素**会被拉向指定方向。\n- 当margin-bottom或者margin-right为负数时，**后续元素**会被拉向指定方向。\n\n[这里有一篇文章](https://www.jianshu.com/p/549aaa5fabaa)讲得不错，可以参考一下。\n\n[圣杯布局、双飞翼布局](https://www.cnblogs.com/star91/p/5773436.html)就是利用这个实现的。\n\n## overflow\n\n当浮动引起父元素高度塌陷时，可以为父元素加上`overflow: hidden`来清除浮动。\n\n# display属性\n\n| 属性值       | 说明                               |\n| ------------ | ---------------------------------- |\n| inline       | 行内元素                           |\n| block        | 块元素                             |\n| inline-block | 行内块元素                         |\n| table        | 以表格形式显示，类似于table元素    |\n| table-row    | 以表格行形式显示，类似于tr元素     |\n| table-cell   | 以表格单元格形式显示，类似于td元素 |\n| none         | 隐藏元素                           |\n\n## 块元素\n\n- 独占一行\n- 内部可以容纳其他块元素或行元素\n- 可以定义width和height\n- 可以定义四个方向的margin\n\n## inline元素\n\n- 可以与其他行内元素位于同一行\n- 可以容纳行内元素，但不能容纳块元素\n- 无法定义width和height\n- 可以定义margin-left和margin-right，不能定义margin-top和margin-bottom\n\n## inline-block元素\n\n- 可以定义width和height\n- 可以与其他行内元素位于同一行\n\n常见的inline-block元素：img元素和input元素\n\n## display: table-cell\n\n可以用于实现：\n\n- [图片垂直居中](https://www.jianshu.com/p/a7ee7dd60166)于元素\n- 等高布局\n- 自动平均划分元素，并在同一行显示\n\n## 去除inline-block元素间距\n\n在父元素中添加`font-size: 0`\n\n# 文本效果\n\n| 文本属性        | 说明                         |\n| --------------- | ---------------------------- |\n| text-decoration | 下划线、删除线、顶划线       |\n| text-transform  | 文本大小写                   |\n| font-variant    | 将英文文本转换为小型大写字母 |\n| text-indent     | 段落首行缩进                 |\n| text-align      | 文本水平对齐                 |\n| vertical-align  | 文本垂直对齐                 |\n| line-height     | 行高                         |\n| letter-spacing  | 字距                         |\n| word-spacing    | 词距                         |\n\n## text-indent\n\n可以使用\t`text-indent: -9999px;`来隐藏文本。\n\n## text-align\n\n主要使用的值为left、right、center，对文字、inline元素、inline-block元素都起作用，对块元素不起作用。\n\n利用`margin: 0 auto`实现块元素的水平居中。\n\n`text-align: center`在父元素中定义，`margin: 0 auto`在当前元素中定义。\n\n## line-height\n\n关于顶线、中线、基线、底线可以自行查阅。\n\n行高（line-height）指的是两行基线之间的距离。\n\n- 将height和line-height设为相同值可以实现文字垂直居中。\n- 当取值为%或者em时，是相对与父元素的font-size计算的。\n- 当取值为无单位数字时，是相对于当前元素的font-size计算的。\n\n## vertical-align\n\nvertical-align对inline、inline-block、table-cell元素有效，对块元素无效。\n\n用于定义<u>周围的文字、inline元素、inline-block元素</u>相对于该元素**基线**的垂直对齐方式。\n\n可以取负长度值和百分比值。\n\n### 取值\n\n1. 负值 ： `vertical-align: -2px`指的是该元素相对于基线向下偏移2px；\n\n2. 百分比 ： 相对于当前元素继承的line-height值计算的，也是该元素相对于基线偏移的值；\n\n3. [关键字](http://www.runoob.com/cssref/pr-pos-vertical-align.html) （前四个比较常用）：\n\n\n\n| 值           | 描述                                           |\n| ------------ | ---------------------------------------------- |\n| **top**      | 把元素的顶端与行中最高元素的顶端对齐           |\n| **middle**   | 把此元素放置在父元素的中部。                   |\n| **baseline** | 默认。元素放置在父元素的基线上。               |\n| **bottom**   | 把元素的底端与行中最低的元素的顶端对齐。       |\n| text-top     | 把元素的顶端与父元素字体的顶端对齐             |\n| text-bottom  | 把元素的底端与父元素字体的底端对齐。           |\n| sub          | 垂直对齐文本的下标。                           |\n| super        | 垂直对齐文本的上标                             |\n| inherit      | 规定应该从父元素继承 vertical-align 属性的值。 |\n\n\n\n### 应用\n\n- 为img添加`vertical-align: middle`可以实现图片与周围的文字居中对齐\n- 要使块元素（如div）也可以使用此属性，可以为其先定义`display: table-cell`\n\n# 表单效果\n\n## radio与checkbox\n\n默认情况下由于是基线对齐因此视觉上会感觉单选框或复选框旁边的文字比它们低，这个时候可以使用vertical-align来让他们垂直居中对齐。\n\n可以使用关键字，也可以使用数值。\n\n## textarea\n\n- 可以使用max-width和max-height来限制拖拽大小\n- 可以使用`resize: none`来禁止拖拽\n\n要使textarea在不同浏览器中具有相同的外观，可以：\n\n- 使用CSS的width和height定义大小\n- 使用`overflow: auto`来定义textarea滚动条自适应\n\n## 表单对齐\n\n书上给了**注册**的例子：\n\n![图片来源于网络](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536639853274&di=16c88d63b9118620ba546c2f6237b78c&imgtype=0&src=http%3A%2F%2Fpic.orsoon.com%2Fuploads%2Fallimg%2F24631428484696.png)\n\n实现方法：\n\n1. 每一行表单分为左栏加若干右栏\n   1. 所有行的左栏长度相等\n   2. 所有行的右栏所有盒子长度之和相等\n   3. 左栏一般为一个label，右栏为若干文本框\n2. 所有左栏和右栏盒子都设为左浮动\n3. 左栏添加属性`text-align: right`使得文字右对齐\n4. 每一行左栏盒子长度加上所有右栏盒子长度之和等于行宽\n5. 每一行由一个p包裹住，并为p添加`overflow: hidden`来清除浮动\n\n然后我又去看了一下各网站的**登录**界面，基本上是一个icon+一个input的模式：\n\n![图片来源于网络](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536641005969&di=02e6a2469281303e926eb8878cf64db9&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fexp%2Fw%3D480%2Fsign%3D00237679845494ee87220e111df7e0e1%2Fa686c9177f3e67093ac0b23933c79f3df9dc5530.jpg)\n\n\n\n实现方法：\n\n- icon使用`position: absolute`脱离文档流并盖在input上\n- input将padding-left调到合适大小使得输入框不被icon盖住\n\n\n\n# 浮动布局\n\n## 文档流\n\n简单来说就是元素在页面中出现的先后顺序。\n\n- 正常文档流 ： “normal flow”，指默认情况下页面元素的布局情况。\n- 脱离文档流：脱离正常文档流。要改变正常文档流，使用浮动和定位方法。\n\n## 浮动\n\n可以使元素移到左边或者右边，并且允许后边的文字和元素环绕着它。\n\n浮动后使用margin来定义和其他元素之间的间距。\n\n绝对定位的元素忽略float属性。\n\nfloat的取值表如下，默认为**none**：\n\n| 值      | 描述                                                 |\n| ------- | ---------------------------------------------------- |\n| left    | 元素向左浮动。                                       |\n| right   | 元素向右浮动。                                       |\n| none    | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |\n| inherit | 规定应该从父元素继承 float 属性的值。                |\n\n\n\n- 当一个元素添加float属性为left或者right时，它将变为block类型。\n- 浮动元素脱离正常文档流，若其height大于父元素的height或者父元素的height未定义，会造成父元素高度塌陷。可以为父元素添加`overflow: hidden`来解决。\n- 若父元素和子元素都是浮动元素，则父元素会自适应地包含子元素。\n\n- 若兄弟元素不是浮动元素，由于浮动元素脱离文档流，可能会出现覆盖等情况。\n\n## 清除浮动\n\n- `clear: both`，用于浮动元素后边的元素，表示两边不允许出现浮动元素。\n- `overflow: hidden`，用于浮动元素的父元素，但会隐藏超出父元素的内容部分。\n- 实际开发中，更经常使用`:after`伪元素结合`clear: both`来实现。\n- 为了兼容ie，为父元素添加`zoom: 1`来消除浮动。\n\n# 定位布局\n\n## [属性值](http://www.runoob.com/cssref/pr-class-position.html)\n\n| 值                                                           | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [static](http://www.runoob.com/css/css-positioning.html#position-static) | <u>默认值</u>。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |\n| [absolute](http://www.runoob.com/css/css-positioning.html#position-absolute) | 生成绝对定位的元素，相对于 <u>static 定位以外的第一个父元素</u>进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n| [fixed](http://www.runoob.com/css/css-positioning.html#position-fixed) | 生成固定定位的元素，相对于<u>浏览器窗口</u>进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n| [relative](http://www.runoob.com/css/css-positioning.html#position-relative) | 生成相对定位的元素，相对于<u>其正常位置</u>进行定位。因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 |\n| [sticky](http://www.runoob.com/css/css-positioning.html#position-sticky) | 粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。 |\n| inherit                                                      | 规定应该从父元素继承 position 属性的值。                     |\n| initial                                                      | 设置该属性为默认值，详情查看 [CSS initial 关键字](http://www.runoob.com/cssref/css-inherit.html)。 |\n\n- absolute会将元素转换为块元素。\n- 若想要子元素相对于父元素定位，一般给父元素添加`position: relative`，给子元素定义`position: absolute`来实现。祖先元素同理。\n\n## z-index属性\n\n默认情况下设置z-index无效，只有当元素定义position为relative、absolute、fixed时才会激活，z-index值越大，其堆叠顺序越高，越靠上（z方向上的靠上）。\n\n# CSS图形\n\n由于图片大小比较大，数据传输量大且一张图片会引发一次HTTP请求，因此对徐图形效果，一般更倾向于用CSS实现。\n\n这里有一篇[CSS制作图形速查表](https://www.w3cplus.com/css/css-simple-shapes-cheat-sheet)总结得比较全面，可以参考。\n\n另外对于带有边框的图形，一般是用大小不同的两个相同图形实现，小的覆盖在大的上边。\n\n# 性能优化\n\n## 属性缩写\n\n- border：`border: 1px solid red`\n  - 若不想要底边框，可以加上`border-bottom: 0`\n  - 若只想要底边框，可以`border-bottom: 1px solid red`\n\n- padding： \n  - `padding: 10px`指上右下左均为10px\n  - `padding: 10px 20px`指上下为10px，左右为20px\n  - `padding: 10px 20px 30px 40px`的顺序为上右下左，从上开始按照顺时针顺序\n\n- margin： 类似于padding\n- background： `background: url('xxx.jpg') no-repeat 80px 40px`,最后为background-position\n- font： `font: \"微软雅黑\" 12px/1.5em bold`\n  - 顺序为`font-family`、`font-size`、`line-height`、`font-weight`\n  - 简写形式必须指定`font-family`和`font-size`的值，其他属性没有指定则为默认值\n  - 简写形式中`font-size`和`line-height`之间需要加入一个斜杠`/`\n\n- color： 十六进制的颜色值若每两位值相同，可以缩写一半，比如`color: #112233`可以缩写为`color: #123`\n\n## 语法压缩\n\n- 当一个CSS规则只有一两个属性的时候，使用横向书写\n- 可以省略最后一个属性的分号\n- background-image、cursor等属性url()中的路径不用加引号\n- 如果某一个属性值为0，则不需要加单位\n- 如果某一个属性值是以0为开头的小数，可以吧0省略\n- 使用群组选择器合并相同样式\n- 若同一个父元素的多个子元素都定义了相同的可继承属性，把这些属性定义在父元素中来精简代码\n\n## CSS压缩\n\n书中推荐了两个在线的压缩工具：[CSS Compressor](https://csscompressor.com) 和 [YUI Compressor](http://tool.oschina.net/jscompress)\n\n以YUI Compressor为例，它会对CSS文件执行如下操作：\n\n- 删除所有注释\n- 删除无用空白符\n- 删除结尾分号\n- 删除属性值为0的单位\n- 删除以0开头的小数前的0\n- 合并相似属性（属性缩写）\n- 将RGB颜色转换为十六进制颜色\n\n## 图片压缩\n\n书中推荐的图片压缩工具：\n\n在线的[JPEGmini](https://www.jpegmini.com)和[TinyPNG](https://tinypng.com)以及本地的[ImageOptim](https://imageoptim.com/versions.html)\n\n## 高性能的选择器\n\n浏览器对选择器规则是从右到左进行解析的。\n\nCSS选择的匹配效率：\n\n1. id选择器\n2. class选择器\n3. 元素选择器\n4. 相邻选择器\n5. 子选择器\n6. 后代选择器\n7. 通配符选择器\n8. 属性选择器\n9. 伪类选择器\n\n因此在使用选择器时应注意：\n\n- 尽量不要使用通配符\n- 不要在id选择器和class选择器前添加元素名\n- 选择器最好不要超过三层，靠右的选择条件应尽可能精确\n- 避免使用后代选择器，尽量少使用子选择器\n\n# CSS技巧\n\n## 水平居中\n\n- 文字、inline元素和inline-*元素： `text-align: center`\n- 块元素： `margin: 0 auto`\n\n## 垂直居中\n\n- 行内块元素使用`vertical-align: middle`\n- 块元素将display改为table-cell然后使用vertical-align\n- 多行文字使用一个标签将文字包起来并设为table-cell，然后再设置vertical-align\n- 单行文字设置line-height和height属性值相同来实现\n\n## CSS Sprite\n\n又称为CSS精灵或CSS**雪碧图**，它将零散的小背景图合并成一张大背景图，然后再利用background-position属性进行定位从而现实小背景图。\n\n使用CSS Sprite技术时，需要注意：\n\n- 在开发后期而不是开发前期使用此技术\n- 有条理地组织图片顺序，应将小背景图按照类别、风格、大小等分门别类地放好\n- 控制雪碧图的大小，当图片大小小于200KB时传输时间是差不多的，因此雪碧图应控制在200KB以内\n\n书中推荐了两个CSS Sprite工具：[CSS Sprite Generator](http://css.spritegen.com/) 和 [Sprite Cow](http://www.spritecow.com/)\n\n## Icon Font图标\n\n使用字体文件实现小图标效果，从而减少图片的使用。\n\n推荐的Icon Font网站：http://www.iconfont.cn/\n\n网站上就有[使用教程](http://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d0091c141&helptype=code)\n\n# 重要概念\n\n## 包含块\n\ncontaining block，决定一个元素大小和定位的元素。\n\n时视觉格式化模型中的一个重要概念，与CSS盒子模型类似。其作用主要是为其内部的后代元素提供一个参考。\n\n- 根元素（HTML元素）没有父元素，它存在的包含块被称为初始包含块\n- 定位为fixed的元素的包含块为浏览器窗口\n- 定位为是static和relative的元素的包含块是它最近的块级（block、inline-block或table-cell）祖先元素创建的\n- 定位为absolute的元素的包含块是它最近的定位不是static的祖先元素，可以是块元素也可以是行内元素\n\n## 层叠上下文\n\n![层叠级别图](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1537245373&di=c7455fbd6881b1a07ae8ac81a79f474e&imgtype=jpg&er=1&src=http%3A%2F%2Fwww.w3cplus.com%2Fsites%2Fdefault%2Ffiles%2Fblogs%2F2018%2F1808%2Fz-index-15.png)\n\n一个元素在z轴上的堆叠顺序：\n\n- 层叠级别越大越靠上\n- 同等层叠级别，后边的堆叠在前边的上边（后来者居上）\n- 不同的层叠上下文比较的是父级层叠上下文，与自身无关\n\n## BFC和IFC\n\nBFC： block formatting context， 块级格式上下文\n\nIFC： inline formatting context， 行级格式上下文\n\n若一个元素具备以下任何一个条件，则会创造创造一个新的BFC：\n\n- 根元素\n- float属性不是none\n- position属性是absolute或fixed\n- overflow属性值不是visible\n- display属性为inline-block、table-caption、table-cell\n\nW3C描述BFC的特点为：\n\n- 在一个BFC中，盒子从顶端开始垂直一个接着一个地排列。两个相邻盒子之间的垂直间距有margin决定。**同一个BFC中**，两个相邻块盒子之间**垂直方向上的外边距**会叠加。\n- 在一个BFC中，每一个盒子的左外边界（margin-left）会紧贴着容器的border-left，右边同理，即使存在浮动元素也是如此。\n\n可以得到结论：\n\n1. 在一个BFC内部，盒子会在垂直方向上一个接着一个地排列\n2. 在一个BFC内部，相邻的margin-top、margin-bottom会叠加\n3. 在一个BFC内部，每一个盒子的左外边界（margin-left）会紧贴着容器（包含盒子）的border-left，即使存在浮动元素也是如此\n4. 在一个BFC内部，如果存在内部元素是一个新的BFC，并且存在内部元素是浮动元素，则这个新的BFC的区域不会与浮动元素的区域重叠\n5. BFC就是页面上一个隔离的盒子，该盒子内部的子元素不会影响到外边的元素\n6. 计算一个BFC的高度时，其内部浮动元素的高度也会计算其中\n\nBFC的用途：\n\n- 创建BFC来避免垂直外边距叠加（例如使用div将一个盒子包起来并给这个div添加overflow属性）\n- 创建BFC来清除浮动（为父元素添加`overflow: hidden`，利用结论第六条）\n- 创建BFC来实现[自适应布局](https://blog.csdn.net/michael8512/article/details/76473835)\n\n\n\n---\n\n好了到这里，这本书就看完了，一些细节的东西了解到了很多，下面开始看html5+css3。\n\n\\- 2018 - 09 - 11 -","source":"_posts/HTML与CSS学习记录.md","raw":"---\ntitle: HTML与CSS学习记录\ntoc: true\ndate: 2018-09-10 14:04:59\ncategories:\n- Web\ntags:\n- HTML\n- CSS\n---\n\n\n\n《HTML与CSS进阶教程读书笔记》\n\n<!-- more -->\n\n---\n\n\n\n# HTML基础知识\n\n## HTML与XHTML\n\nHTML指超文本标记语言，是构成网页文档的主要语言。我们常说的HTML指HTML4.01。\n\nXHTML指扩展的超文本标记语言，是XML风格的、更严格、更纯净的HTML。\n\n两者的主要区别：\n\n- XHTML标签必须闭合。\n- XHTML标签和属性必须小写。\n- XHTML标签属性必须加引号。\n- XHTML标签用id属性代替name属性。\n\n## id和class\n\n由于id属性具有唯一性，因此W3C建议，对于页面关键的结构或大结构，才能使用id属性，其他地方使用class属性。\n\n<u>因为搜索引擎是根据标签的语义和id属性来识别的，因此id属性的使用和命名都需要谨慎。</u>\n\n一般来说，定义多个class的目的在于：一个class抽取公共样式，一个class定义单独样式。\n\n## 标题栏小图标\n\n在`head`标签内加入：\n\n```html\n<link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"图标路径.ico\" />\n```\n\n其中`rel`和`type`是固定属性不用更改，只需要修改图片路径即可。\n\n\n\n# 语义化\n\nHTML的精髓在于标签的语义。搜索引擎根据HTML代码识别页面结构。\n\n编写语意结构良好的页面的好处：\n\n- 利于开发调试和后期维护。\n- 利于搜索引擎优化。\n\n应优先使用正确的语义化标签，如果没有语义化标签可用，再考虑div或者span等无语义标签。\n\n## 标题语义化\n\nh1-h6是标题标签，相比于其他标签，它们在搜索引擎优化（SEO）中占有相当重要的地位。\n\n一般用到h4，h5和h6权重和普通标签差不多，很少使用。\n\n对于标题语义化，我们需要注意的是：\n\n- 一个页面只能有一个h1标签。\n- h1-h6之间不要出现断层。\n- 不要用标题标签来定义样式（如为了加粗字体而为文本加上标题标签）。\n- 不要用div来代替标题标签。\n\ndiv是无语义的标签，如果使用div代替标题标签会使网页在SEO中丢失大量权重。\n\n## 图片语义化\n\n### alt属性和title属性\n\nalt是给搜索引擎看的，title是给用户看的。\n\n搜索引擎根据alt属性或上下文判断图片内容。\n\n因此**img标签必须添加alt属性。**\n\n### figure元素和figcaption元素\n\n对于图片+图注的效果，使用figure和figcaption来增强图片语义化。\n\n例：\n\n```html\n<figure>\n    <img src=\"xxx\" alt=\"xxx\" />\n    <figcaption>这是一个图注</figcaption>\n</figure>\n```\n\n更详细的介绍可以看[这一篇博客](https://www.w3cplus.com/html5/quick-tip-the-right-way-to-use-figure-and-figcaption-elements.html)。\n\n## 表格语义化\n\n| 标签    | 说明             |\n| ------- | ---------------- |\n| table   | 表格             |\n| caption | 标题             |\n| thead   | 表头（语义划分） |\n| tbody   | 表身（语义划分） |\n| tfoot   | 表尾（语义划分） |\n| tr      | 行               |\n| th      | 表头单元格       |\n| td      | 表格单元格       |\n\n## 表单语义化\n\n### label标签\n\nlabel标签的for属性有两个作用：\n\n- 语义上绑定了label元素和表单元素。（\\<label for=\"*element_id*\">）\n- 当我们点击label中的文本时，其关联的表单元素也会获得焦点。\n\n例：\n\n```html\n<input id=\"rdo\" name=\"rdo\" type=\"radio\" /><label for=\"rdo\">单选框</label>\n```\n\n### fieldset标签和legend标签\n\nfieldset标签用于给表单元素进行分组并绘制一个边框，legend标签用于定义某一组表单的标题。\n\n例如这个[例子](http://www.runoob.com/tags/tag-fieldset.html)：\n\n```html\n<form>\n  <fieldset>\n    <legend>Personalia:</legend>\n    Name: <input type=\"text\"><br>\n    Email: <input type=\"text\"><br>\n    Date of birth: <input type=\"text\">\n  </fieldset>\n</form>\n```\n\n作用：\n\n- 增强表单语义。\n- 可以使用fieldset标签的disabled属性来禁用整个组中的表单元素。\n\n## 其他语义化\n\n### 换行符\\<br />\n\nW3C标准规定，\\<br />标签只能用于段落中的换行。即只能用于p标签内部。\n\n### 无序列表ul\n\n对于列表型数据，不建议使用div实现，而应用无序列表或有序列表实现。\n\n为了实现外观效果，一般使用无序列表而不是有序列表。\n\n### strong 标签和em标签\n\nW3C对这两个标签赋予了“强调”的语义。\n\n可以在CSS中重新定义它们的样式而不会改变它们的语义。\n\n### del标签和ins标签\n\n这两个标签一般是配合使用表示更新文本：“delete”和“insert”，被删除的文本和被更新的文本。\n\n一般会用CSS重新定义它们的样式。\n\n[实例链接](http://www.runoob.com/tags/tag-del.html)\n\n### img标签\n\n对于什么时候使用img标签，什么时候使用背景图片，应该根据HTML的语义来判断。\n\n- img标签：作为HTML的一部分，希望被搜索引擎识别。\n\n- 背景图片： 只起到修饰作用，不希望被搜索引擎识别。\n\n## 语义化验证\n\n通过去掉CSS样式，观察页面是否还有很好的可读性来判断一个页面是否语义良好。\n\n## HTML5舍弃的标签\n\n下边这些已经被舍弃的标签(仅为了定义样式的标签和很少使用或已经被新标签代替的标签)应停止使用：\n\n- `<acronym>`  定义首字母缩写，应用abbr代替。\n- `<applet>` 定义嵌入的applet，应用object代替。\n- `<basefont>`\n- `<big>`\n- `<center>`\n- `<dir>` 定义目录列表，应用ul代替。\n- `<font>`\n- `<frame>`\n- `<frameset>`\n- `<noframes>`\n- `<strike>`\n- `<tt>`\n\n# CSS基础知识\n\n## CSS单位\n\n### px\n\npixel，像素，一个图片或计算机屏幕中最小的点。\n\n### 百分比%\n\nCSS中支持百分比的属性：\n\n- **width、height、font-size**，它们的百分比是相对于父元素的“相同元素”的值来计算的。\n- **line-height**，它的百分比是相对于**父元素**的**font-size**值来计算的。\n- **vertical-align**，它的百分比是相对于**当前元素**继承的**line-height**值来计算的。\n\n### em\n\n1em等于当前元素的以px为单位的font-size值，\n\n若当前元素的font-size值没有定义，则从父元素继承，\n\n若当前元素的所有祖先元素都没有定义font-size，则继承浏览器默认的font-size值：16px。\n\n<u>使用em的小技巧：</u>首行缩进使用 `text-indent: 2em`实现。\n\n### rem\n\nCSS3新引入的单位，指相对根元素（即html元素）的字体大小。\n\n## CSS特性\n\n### 继承性\n\n指子元素继承了父元素的某些样式属性。\n\n在CSS中，具有继承性的样式有三大类：\n\n- **文本**相关属性： font--family，font-size，font-style，font-weight，font，line-height，text-align，text-indent，word-spacing。\n- **列表**相关属性： list-style-image，list-style-position，list-style-type，list-style。\n- **颜色**相关属性： color。\n\n### 层叠性\n\n“后者居上”原则。\n\nCSS的层叠性指样式的覆盖。对于具有**相同权重**的**相同属性**，以最后定义的值为准。\n\n## CSS优先级\n\n### 引用方式\n\n行内样式>(内部样式=外部样式)\n\n若同时存在权重相同内部样式和外部样式，则以最后引入的样式为准。\n\n### 继承方式\n\n以最近的祖先元素为准。\n\n### 指定样式\n\n常见的伪元素——:before、:after、:first-letter、:first-line。\n\n常见的伪类——:hover、:first-child等。\n\n常用的选择器优先级：行内样式>id选择器>class选择器>元素选择器。\n\n选择器权值表：\n\n| 选择器      | 权值 |\n| ----------- | ---- |\n| 通配符      | 0    |\n| 伪元素      | 1    |\n| 元素选择器  | 1    |\n| class选择器 | 10   |\n| 伪类        | 10   |\n| 属性选择器  | 10   |\n| id选择器    | 100  |\n| 行内样式    | 1000 |\n\n### 继承样式和和指定样式\n\n指定样式权重更高。\n\n### !important\n\n权值最高，不推荐使用。\n\n## CSS引入方式\n\n- 导入样式表（加载html后加载css，不推荐）\n- 外部样式表（link标签）\n- 内部样式表（style标签）\n- 行内样式表\n\n## CSS选择器\n\nCSS出去基本的选择器（元素选择器、id选择器、class选择器、群组或分组选择器），\n\n还有<u>层次选择器</u>：\n\n| 选择器 | 说明                                      |\n| ------ | ----------------------------------------- |\n| M N    | 后代选择器，选择M元素所有内部后代N元素    |\n| M>N    | 子代选择器，选择M元素所有内部子代N元素    |\n| M~N    | 兄弟选择器，选择M元素所有同级N元素        |\n| M+N    | 相邻选择器，选择M元素相邻的下一个同级元素 |\n\n# CSS规范\n\n## 命名规范\n\n### CSS文件命名\n\n开发阶段按照功能模块划分CSS文件。\n\n| 文件名      | 说明                                 |\n| ----------- | ------------------------------------ |\n| reset.css   | 重置样式，重置元素默认样式           |\n| global.css  | 全局样式，全站公用，定义页面基础样式 |\n| themes.css  | 主题样式，用于实现换肤功能           |\n| module.css  | 模块样式，用于模块的样式             |\n| master.css  | 母版样式，用于母版页的样式           |\n| columes.css | 专栏样式，用于专栏的样式             |\n| forms.css   | 表单样式，用于表单的样式             |\n| mend.css    | 补丁样式，用于维护、修改的样式       |\n| print.css   | 打印样式，用于打印的样式             |\n\n### id和class命名\n\n建议使用中划线命名，例如`column-title`。\n\n为了避免class命名的重复，一般取父元素的class名作为前缀，例如`column-title`。\n\n| 网页主体部分 | 命名                          |\n| ------------ | ----------------------------- |\n| 最外层       | wrapper(一般用于包裹整个页面) |\n| 头部         | header                        |\n| 内容         | content                       |\n| 侧栏         | sidebar                       |\n| 栏目         | column                        |\n| 热点         | hot                           |\n| 新闻         | news                          |\n| 下载         | download                      |\n| 标志         | logo                          |\n| 导航条       | nav                           |\n| 主体         | main                          |\n| 左侧         | main-left                     |\n| 右侧         | main-right                    |\n| 底部         | footer                        |\n| 友情链接     | friendlink                    |\n| 加入我们     | joinus                        |\n| 版权         | copyright                     |\n| 服务         | service                       |\n| 登录         | login                         |\n| 注册         | register                      |\n\n| 导航部分 | 命名          |\n| -------- | ------------- |\n| 主导航   | main-nav      |\n| 子导航   | sub-nav       |\n| 边导航   | side-nav      |\n| 左导航   | leftside-nav  |\n| 右导航   | rightside-nav |\n| 顶导航   | top-nav       |\n\n| 菜单部分 | 命名    |\n| -------- | ------- |\n| 菜单     | menu    |\n| 子菜单   | submenu |\n\n| 其他     | 命名          |\n| -------- | ------------- |\n| 标题     | title         |\n| 摘要     | summary       |\n| 登录条   | loginbar      |\n| 搜索     | search        |\n| 标签页   | tab           |\n| 广告     | banner        |\n| 小技巧   | tips          |\n| 图标     | icon          |\n| 法律声明 | siteinfolegal |\n| 网站地图 | sitemap       |\n| 工具条   | tool、toolbar |\n| 首页     | homepage      |\n| 子页     | subpage       |\n| 合作伙伴 | partner       |\n| 帮助     | help          |\n| 指南     | guide         |\n| 滚动     | scroll        |\n| 提示信息 | msg           |\n| 投票     | vote          |\n| 相关文章 | related       |\n| 文章列表 | list          |\n\n## 书写规范\n\n对于功能代码，应该集中放在一起，\n\n对于其他代码，应按照如下顺序：\n\n1. 影响文档流属性（布局属性）——display，position，float，clear等\n2. 自身盒模型属性——width，height，padding，margin，border，overflow等\n3. 文本性属性——font，line-height，text-align，text-indent，vertical-align等\n4. 装饰性属性——color，background-color，opacity等\n5. 其他属性——cursor，content，list-style，quotes等\n\n例如：\n\n```css\n#main {\n  /* 影响文档流属性 */\n  display: inline-block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* 盒子模型属性 */\n  width: 100px;\n  height: 100px;\n  border: 2px solid gray;\n  /* 文本性属性 */\n  font-size: 15px;\n  font-weight: bold;\n  text-indent: 2em;\n  /* 装饰性属性 */\n  color: white;\n  background-color: red;\n  /* 其他属性 */\n  cursor: pointer;\n}\n```\n\n## 注释规范\n\n由于压缩工具会删除所有的注释，因此有时为了保留版权声明等注释信息，需要在注释内容前加一个叹号，如`/*! 注释内容 */`，这样压缩工具就不会删除这条注释信息。\n\n### 顶部注释\n\n```css\n/*\n *@description:说明\n *@author:作者\n *@update:更新时间，如2018-09-10 17:42\n */\n```\n\n### 模块注释\n\n```css\n/* 导航部分，开始 */\n......\n/* 导航部分，结束 */\n```\n\n### 简单注释\n\n```css\n/* 单行注释 */\n```\n\n或者\n\n```css\n/*多行注释\n *多行注释\n *多行注释\n */\n```\n\n## CSS reset\n\n重置样式，去除元素在浏览器中的默认样式。\n\n是否使用CSS reset根据实际开发需求而定。\n\n# 盒子模型\n\n![标准盒子模型](https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=5ad0ba6a0c7b02080c9c37e752e9deeb/0824ab18972bd407012c41327d899e510eb30911.jpg)\n\n![IE盒子模型](https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=6cdf3ae9fbfaaf5184b689b9bc64b8d6/1b4c510fd9f9d72ac29d82d2d22a2834359bbb00.jpg)\n\n## 外边距叠加\n\n又称为“margin叠加”，指当两个外边距相遇时会“合二为一”。叠加后的外边距为两个外边距的最大值。\n\n<u>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</u>\n\n以下图片均来自[w3school](http://www.w3school.com.cn/css/css_margin_collapsing.asp)\n\n![同级元素](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif)\n\n![父子元素](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif)\n\n![空元素1](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif)\n\n![空元素2](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif)\n\n![外边距合并的意义](http://www.w3school.com.cn/i/ct_css_margin_collapsing.gif)\n\n## 负margin\n\n- 当margin-top或者margin-left为负数时，**当前元素**会被拉向指定方向。\n- 当margin-bottom或者margin-right为负数时，**后续元素**会被拉向指定方向。\n\n[这里有一篇文章](https://www.jianshu.com/p/549aaa5fabaa)讲得不错，可以参考一下。\n\n[圣杯布局、双飞翼布局](https://www.cnblogs.com/star91/p/5773436.html)就是利用这个实现的。\n\n## overflow\n\n当浮动引起父元素高度塌陷时，可以为父元素加上`overflow: hidden`来清除浮动。\n\n# display属性\n\n| 属性值       | 说明                               |\n| ------------ | ---------------------------------- |\n| inline       | 行内元素                           |\n| block        | 块元素                             |\n| inline-block | 行内块元素                         |\n| table        | 以表格形式显示，类似于table元素    |\n| table-row    | 以表格行形式显示，类似于tr元素     |\n| table-cell   | 以表格单元格形式显示，类似于td元素 |\n| none         | 隐藏元素                           |\n\n## 块元素\n\n- 独占一行\n- 内部可以容纳其他块元素或行元素\n- 可以定义width和height\n- 可以定义四个方向的margin\n\n## inline元素\n\n- 可以与其他行内元素位于同一行\n- 可以容纳行内元素，但不能容纳块元素\n- 无法定义width和height\n- 可以定义margin-left和margin-right，不能定义margin-top和margin-bottom\n\n## inline-block元素\n\n- 可以定义width和height\n- 可以与其他行内元素位于同一行\n\n常见的inline-block元素：img元素和input元素\n\n## display: table-cell\n\n可以用于实现：\n\n- [图片垂直居中](https://www.jianshu.com/p/a7ee7dd60166)于元素\n- 等高布局\n- 自动平均划分元素，并在同一行显示\n\n## 去除inline-block元素间距\n\n在父元素中添加`font-size: 0`\n\n# 文本效果\n\n| 文本属性        | 说明                         |\n| --------------- | ---------------------------- |\n| text-decoration | 下划线、删除线、顶划线       |\n| text-transform  | 文本大小写                   |\n| font-variant    | 将英文文本转换为小型大写字母 |\n| text-indent     | 段落首行缩进                 |\n| text-align      | 文本水平对齐                 |\n| vertical-align  | 文本垂直对齐                 |\n| line-height     | 行高                         |\n| letter-spacing  | 字距                         |\n| word-spacing    | 词距                         |\n\n## text-indent\n\n可以使用\t`text-indent: -9999px;`来隐藏文本。\n\n## text-align\n\n主要使用的值为left、right、center，对文字、inline元素、inline-block元素都起作用，对块元素不起作用。\n\n利用`margin: 0 auto`实现块元素的水平居中。\n\n`text-align: center`在父元素中定义，`margin: 0 auto`在当前元素中定义。\n\n## line-height\n\n关于顶线、中线、基线、底线可以自行查阅。\n\n行高（line-height）指的是两行基线之间的距离。\n\n- 将height和line-height设为相同值可以实现文字垂直居中。\n- 当取值为%或者em时，是相对与父元素的font-size计算的。\n- 当取值为无单位数字时，是相对于当前元素的font-size计算的。\n\n## vertical-align\n\nvertical-align对inline、inline-block、table-cell元素有效，对块元素无效。\n\n用于定义<u>周围的文字、inline元素、inline-block元素</u>相对于该元素**基线**的垂直对齐方式。\n\n可以取负长度值和百分比值。\n\n### 取值\n\n1. 负值 ： `vertical-align: -2px`指的是该元素相对于基线向下偏移2px；\n\n2. 百分比 ： 相对于当前元素继承的line-height值计算的，也是该元素相对于基线偏移的值；\n\n3. [关键字](http://www.runoob.com/cssref/pr-pos-vertical-align.html) （前四个比较常用）：\n\n\n\n| 值           | 描述                                           |\n| ------------ | ---------------------------------------------- |\n| **top**      | 把元素的顶端与行中最高元素的顶端对齐           |\n| **middle**   | 把此元素放置在父元素的中部。                   |\n| **baseline** | 默认。元素放置在父元素的基线上。               |\n| **bottom**   | 把元素的底端与行中最低的元素的顶端对齐。       |\n| text-top     | 把元素的顶端与父元素字体的顶端对齐             |\n| text-bottom  | 把元素的底端与父元素字体的底端对齐。           |\n| sub          | 垂直对齐文本的下标。                           |\n| super        | 垂直对齐文本的上标                             |\n| inherit      | 规定应该从父元素继承 vertical-align 属性的值。 |\n\n\n\n### 应用\n\n- 为img添加`vertical-align: middle`可以实现图片与周围的文字居中对齐\n- 要使块元素（如div）也可以使用此属性，可以为其先定义`display: table-cell`\n\n# 表单效果\n\n## radio与checkbox\n\n默认情况下由于是基线对齐因此视觉上会感觉单选框或复选框旁边的文字比它们低，这个时候可以使用vertical-align来让他们垂直居中对齐。\n\n可以使用关键字，也可以使用数值。\n\n## textarea\n\n- 可以使用max-width和max-height来限制拖拽大小\n- 可以使用`resize: none`来禁止拖拽\n\n要使textarea在不同浏览器中具有相同的外观，可以：\n\n- 使用CSS的width和height定义大小\n- 使用`overflow: auto`来定义textarea滚动条自适应\n\n## 表单对齐\n\n书上给了**注册**的例子：\n\n![图片来源于网络](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536639853274&di=16c88d63b9118620ba546c2f6237b78c&imgtype=0&src=http%3A%2F%2Fpic.orsoon.com%2Fuploads%2Fallimg%2F24631428484696.png)\n\n实现方法：\n\n1. 每一行表单分为左栏加若干右栏\n   1. 所有行的左栏长度相等\n   2. 所有行的右栏所有盒子长度之和相等\n   3. 左栏一般为一个label，右栏为若干文本框\n2. 所有左栏和右栏盒子都设为左浮动\n3. 左栏添加属性`text-align: right`使得文字右对齐\n4. 每一行左栏盒子长度加上所有右栏盒子长度之和等于行宽\n5. 每一行由一个p包裹住，并为p添加`overflow: hidden`来清除浮动\n\n然后我又去看了一下各网站的**登录**界面，基本上是一个icon+一个input的模式：\n\n![图片来源于网络](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536641005969&di=02e6a2469281303e926eb8878cf64db9&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fexp%2Fw%3D480%2Fsign%3D00237679845494ee87220e111df7e0e1%2Fa686c9177f3e67093ac0b23933c79f3df9dc5530.jpg)\n\n\n\n实现方法：\n\n- icon使用`position: absolute`脱离文档流并盖在input上\n- input将padding-left调到合适大小使得输入框不被icon盖住\n\n\n\n# 浮动布局\n\n## 文档流\n\n简单来说就是元素在页面中出现的先后顺序。\n\n- 正常文档流 ： “normal flow”，指默认情况下页面元素的布局情况。\n- 脱离文档流：脱离正常文档流。要改变正常文档流，使用浮动和定位方法。\n\n## 浮动\n\n可以使元素移到左边或者右边，并且允许后边的文字和元素环绕着它。\n\n浮动后使用margin来定义和其他元素之间的间距。\n\n绝对定位的元素忽略float属性。\n\nfloat的取值表如下，默认为**none**：\n\n| 值      | 描述                                                 |\n| ------- | ---------------------------------------------------- |\n| left    | 元素向左浮动。                                       |\n| right   | 元素向右浮动。                                       |\n| none    | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |\n| inherit | 规定应该从父元素继承 float 属性的值。                |\n\n\n\n- 当一个元素添加float属性为left或者right时，它将变为block类型。\n- 浮动元素脱离正常文档流，若其height大于父元素的height或者父元素的height未定义，会造成父元素高度塌陷。可以为父元素添加`overflow: hidden`来解决。\n- 若父元素和子元素都是浮动元素，则父元素会自适应地包含子元素。\n\n- 若兄弟元素不是浮动元素，由于浮动元素脱离文档流，可能会出现覆盖等情况。\n\n## 清除浮动\n\n- `clear: both`，用于浮动元素后边的元素，表示两边不允许出现浮动元素。\n- `overflow: hidden`，用于浮动元素的父元素，但会隐藏超出父元素的内容部分。\n- 实际开发中，更经常使用`:after`伪元素结合`clear: both`来实现。\n- 为了兼容ie，为父元素添加`zoom: 1`来消除浮动。\n\n# 定位布局\n\n## [属性值](http://www.runoob.com/cssref/pr-class-position.html)\n\n| 值                                                           | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [static](http://www.runoob.com/css/css-positioning.html#position-static) | <u>默认值</u>。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |\n| [absolute](http://www.runoob.com/css/css-positioning.html#position-absolute) | 生成绝对定位的元素，相对于 <u>static 定位以外的第一个父元素</u>进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n| [fixed](http://www.runoob.com/css/css-positioning.html#position-fixed) | 生成固定定位的元素，相对于<u>浏览器窗口</u>进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n| [relative](http://www.runoob.com/css/css-positioning.html#position-relative) | 生成相对定位的元素，相对于<u>其正常位置</u>进行定位。因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 |\n| [sticky](http://www.runoob.com/css/css-positioning.html#position-sticky) | 粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。 |\n| inherit                                                      | 规定应该从父元素继承 position 属性的值。                     |\n| initial                                                      | 设置该属性为默认值，详情查看 [CSS initial 关键字](http://www.runoob.com/cssref/css-inherit.html)。 |\n\n- absolute会将元素转换为块元素。\n- 若想要子元素相对于父元素定位，一般给父元素添加`position: relative`，给子元素定义`position: absolute`来实现。祖先元素同理。\n\n## z-index属性\n\n默认情况下设置z-index无效，只有当元素定义position为relative、absolute、fixed时才会激活，z-index值越大，其堆叠顺序越高，越靠上（z方向上的靠上）。\n\n# CSS图形\n\n由于图片大小比较大，数据传输量大且一张图片会引发一次HTTP请求，因此对徐图形效果，一般更倾向于用CSS实现。\n\n这里有一篇[CSS制作图形速查表](https://www.w3cplus.com/css/css-simple-shapes-cheat-sheet)总结得比较全面，可以参考。\n\n另外对于带有边框的图形，一般是用大小不同的两个相同图形实现，小的覆盖在大的上边。\n\n# 性能优化\n\n## 属性缩写\n\n- border：`border: 1px solid red`\n  - 若不想要底边框，可以加上`border-bottom: 0`\n  - 若只想要底边框，可以`border-bottom: 1px solid red`\n\n- padding： \n  - `padding: 10px`指上右下左均为10px\n  - `padding: 10px 20px`指上下为10px，左右为20px\n  - `padding: 10px 20px 30px 40px`的顺序为上右下左，从上开始按照顺时针顺序\n\n- margin： 类似于padding\n- background： `background: url('xxx.jpg') no-repeat 80px 40px`,最后为background-position\n- font： `font: \"微软雅黑\" 12px/1.5em bold`\n  - 顺序为`font-family`、`font-size`、`line-height`、`font-weight`\n  - 简写形式必须指定`font-family`和`font-size`的值，其他属性没有指定则为默认值\n  - 简写形式中`font-size`和`line-height`之间需要加入一个斜杠`/`\n\n- color： 十六进制的颜色值若每两位值相同，可以缩写一半，比如`color: #112233`可以缩写为`color: #123`\n\n## 语法压缩\n\n- 当一个CSS规则只有一两个属性的时候，使用横向书写\n- 可以省略最后一个属性的分号\n- background-image、cursor等属性url()中的路径不用加引号\n- 如果某一个属性值为0，则不需要加单位\n- 如果某一个属性值是以0为开头的小数，可以吧0省略\n- 使用群组选择器合并相同样式\n- 若同一个父元素的多个子元素都定义了相同的可继承属性，把这些属性定义在父元素中来精简代码\n\n## CSS压缩\n\n书中推荐了两个在线的压缩工具：[CSS Compressor](https://csscompressor.com) 和 [YUI Compressor](http://tool.oschina.net/jscompress)\n\n以YUI Compressor为例，它会对CSS文件执行如下操作：\n\n- 删除所有注释\n- 删除无用空白符\n- 删除结尾分号\n- 删除属性值为0的单位\n- 删除以0开头的小数前的0\n- 合并相似属性（属性缩写）\n- 将RGB颜色转换为十六进制颜色\n\n## 图片压缩\n\n书中推荐的图片压缩工具：\n\n在线的[JPEGmini](https://www.jpegmini.com)和[TinyPNG](https://tinypng.com)以及本地的[ImageOptim](https://imageoptim.com/versions.html)\n\n## 高性能的选择器\n\n浏览器对选择器规则是从右到左进行解析的。\n\nCSS选择的匹配效率：\n\n1. id选择器\n2. class选择器\n3. 元素选择器\n4. 相邻选择器\n5. 子选择器\n6. 后代选择器\n7. 通配符选择器\n8. 属性选择器\n9. 伪类选择器\n\n因此在使用选择器时应注意：\n\n- 尽量不要使用通配符\n- 不要在id选择器和class选择器前添加元素名\n- 选择器最好不要超过三层，靠右的选择条件应尽可能精确\n- 避免使用后代选择器，尽量少使用子选择器\n\n# CSS技巧\n\n## 水平居中\n\n- 文字、inline元素和inline-*元素： `text-align: center`\n- 块元素： `margin: 0 auto`\n\n## 垂直居中\n\n- 行内块元素使用`vertical-align: middle`\n- 块元素将display改为table-cell然后使用vertical-align\n- 多行文字使用一个标签将文字包起来并设为table-cell，然后再设置vertical-align\n- 单行文字设置line-height和height属性值相同来实现\n\n## CSS Sprite\n\n又称为CSS精灵或CSS**雪碧图**，它将零散的小背景图合并成一张大背景图，然后再利用background-position属性进行定位从而现实小背景图。\n\n使用CSS Sprite技术时，需要注意：\n\n- 在开发后期而不是开发前期使用此技术\n- 有条理地组织图片顺序，应将小背景图按照类别、风格、大小等分门别类地放好\n- 控制雪碧图的大小，当图片大小小于200KB时传输时间是差不多的，因此雪碧图应控制在200KB以内\n\n书中推荐了两个CSS Sprite工具：[CSS Sprite Generator](http://css.spritegen.com/) 和 [Sprite Cow](http://www.spritecow.com/)\n\n## Icon Font图标\n\n使用字体文件实现小图标效果，从而减少图片的使用。\n\n推荐的Icon Font网站：http://www.iconfont.cn/\n\n网站上就有[使用教程](http://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d0091c141&helptype=code)\n\n# 重要概念\n\n## 包含块\n\ncontaining block，决定一个元素大小和定位的元素。\n\n时视觉格式化模型中的一个重要概念，与CSS盒子模型类似。其作用主要是为其内部的后代元素提供一个参考。\n\n- 根元素（HTML元素）没有父元素，它存在的包含块被称为初始包含块\n- 定位为fixed的元素的包含块为浏览器窗口\n- 定位为是static和relative的元素的包含块是它最近的块级（block、inline-block或table-cell）祖先元素创建的\n- 定位为absolute的元素的包含块是它最近的定位不是static的祖先元素，可以是块元素也可以是行内元素\n\n## 层叠上下文\n\n![层叠级别图](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1537245373&di=c7455fbd6881b1a07ae8ac81a79f474e&imgtype=jpg&er=1&src=http%3A%2F%2Fwww.w3cplus.com%2Fsites%2Fdefault%2Ffiles%2Fblogs%2F2018%2F1808%2Fz-index-15.png)\n\n一个元素在z轴上的堆叠顺序：\n\n- 层叠级别越大越靠上\n- 同等层叠级别，后边的堆叠在前边的上边（后来者居上）\n- 不同的层叠上下文比较的是父级层叠上下文，与自身无关\n\n## BFC和IFC\n\nBFC： block formatting context， 块级格式上下文\n\nIFC： inline formatting context， 行级格式上下文\n\n若一个元素具备以下任何一个条件，则会创造创造一个新的BFC：\n\n- 根元素\n- float属性不是none\n- position属性是absolute或fixed\n- overflow属性值不是visible\n- display属性为inline-block、table-caption、table-cell\n\nW3C描述BFC的特点为：\n\n- 在一个BFC中，盒子从顶端开始垂直一个接着一个地排列。两个相邻盒子之间的垂直间距有margin决定。**同一个BFC中**，两个相邻块盒子之间**垂直方向上的外边距**会叠加。\n- 在一个BFC中，每一个盒子的左外边界（margin-left）会紧贴着容器的border-left，右边同理，即使存在浮动元素也是如此。\n\n可以得到结论：\n\n1. 在一个BFC内部，盒子会在垂直方向上一个接着一个地排列\n2. 在一个BFC内部，相邻的margin-top、margin-bottom会叠加\n3. 在一个BFC内部，每一个盒子的左外边界（margin-left）会紧贴着容器（包含盒子）的border-left，即使存在浮动元素也是如此\n4. 在一个BFC内部，如果存在内部元素是一个新的BFC，并且存在内部元素是浮动元素，则这个新的BFC的区域不会与浮动元素的区域重叠\n5. BFC就是页面上一个隔离的盒子，该盒子内部的子元素不会影响到外边的元素\n6. 计算一个BFC的高度时，其内部浮动元素的高度也会计算其中\n\nBFC的用途：\n\n- 创建BFC来避免垂直外边距叠加（例如使用div将一个盒子包起来并给这个div添加overflow属性）\n- 创建BFC来清除浮动（为父元素添加`overflow: hidden`，利用结论第六条）\n- 创建BFC来实现[自适应布局](https://blog.csdn.net/michael8512/article/details/76473835)\n\n\n\n---\n\n好了到这里，这本书就看完了，一些细节的东西了解到了很多，下面开始看html5+css3。\n\n\\- 2018 - 09 - 11 -","slug":"HTML与CSS学习记录","published":1,"updated":"2018-10-10T08:37:39.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1v30006fmagdopyjia2","content":"<p>《HTML与CSS进阶教程读书笔记》</p><a id=\"more\"></a><hr><h1 id=\"HTML基础知识\"><a href=\"#HTML基础知识\" class=\"headerlink\" title=\"HTML基础知识\"></a>HTML基础知识</h1><h2 id=\"HTML与XHTML\"><a href=\"#HTML与XHTML\" class=\"headerlink\" title=\"HTML与XHTML\"></a>HTML与XHTML</h2><p>HTML指超文本标记语言，是构成网页文档的主要语言。我们常说的HTML指HTML4.01。</p><p>XHTML指扩展的超文本标记语言，是XML风格的、更严格、更纯净的HTML。</p><p>两者的主要区别：</p><ul><li>XHTML标签必须闭合。</li><li>XHTML标签和属性必须小写。</li><li>XHTML标签属性必须加引号。</li><li>XHTML标签用id属性代替name属性。</li></ul><h2 id=\"id和class\"><a href=\"#id和class\" class=\"headerlink\" title=\"id和class\"></a>id和class</h2><p>由于id属性具有唯一性，因此W3C建议，对于页面关键的结构或大结构，才能使用id属性，其他地方使用class属性。</p><p><u>因为搜索引擎是根据标签的语义和id属性来识别的，因此id属性的使用和命名都需要谨慎。</u></p><p>一般来说，定义多个class的目的在于：一个class抽取公共样式，一个class定义单独样式。</p><h2 id=\"标题栏小图标\"><a href=\"#标题栏小图标\" class=\"headerlink\" title=\"标题栏小图标\"></a>标题栏小图标</h2><p>在<code>head</code>标签内加入：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>shortcut icon<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>image/x-icon<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>图标路径.ico<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n</code></pre><p>其中<code>rel</code>和<code>type</code>是固定属性不用更改，只需要修改图片路径即可。</p><h1 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h1><p>HTML的精髓在于标签的语义。搜索引擎根据HTML代码识别页面结构。</p><p>编写语意结构良好的页面的好处：</p><ul><li>利于开发调试和后期维护。</li><li>利于搜索引擎优化。</li></ul><p>应优先使用正确的语义化标签，如果没有语义化标签可用，再考虑div或者span等无语义标签。</p><h2 id=\"标题语义化\"><a href=\"#标题语义化\" class=\"headerlink\" title=\"标题语义化\"></a>标题语义化</h2><p>h1-h6是标题标签，相比于其他标签，它们在搜索引擎优化（SEO）中占有相当重要的地位。</p><p>一般用到h4，h5和h6权重和普通标签差不多，很少使用。</p><p>对于标题语义化，我们需要注意的是：</p><ul><li>一个页面只能有一个h1标签。</li><li>h1-h6之间不要出现断层。</li><li>不要用标题标签来定义样式（如为了加粗字体而为文本加上标题标签）。</li><li>不要用div来代替标题标签。</li></ul><p>div是无语义的标签，如果使用div代替标题标签会使网页在SEO中丢失大量权重。</p><h2 id=\"图片语义化\"><a href=\"#图片语义化\" class=\"headerlink\" title=\"图片语义化\"></a>图片语义化</h2><h3 id=\"alt属性和title属性\"><a href=\"#alt属性和title属性\" class=\"headerlink\" title=\"alt属性和title属性\"></a>alt属性和title属性</h3><p>alt是给搜索引擎看的，title是给用户看的。</p><p>搜索引擎根据alt属性或上下文判断图片内容。</p><p>因此<strong>img标签必须添加alt属性。</strong></p><h3 id=\"figure元素和figcaption元素\"><a href=\"#figure元素和figcaption元素\" class=\"headerlink\" title=\"figure元素和figcaption元素\"></a>figure元素和figcaption元素</h3><p>对于图片+图注的效果，使用figure和figcaption来增强图片语义化。</p><p>例：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>figure</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>figcaption</span><span class=\"token punctuation\">></span></span>这是一个图注<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>figcaption</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>figure</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>更详细的介绍可以看<a href=\"https://www.w3cplus.com/html5/quick-tip-the-right-way-to-use-figure-and-figcaption-elements.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这一篇博客</a>。</p><h2 id=\"表格语义化\"><a href=\"#表格语义化\" class=\"headerlink\" title=\"表格语义化\"></a>表格语义化</h2><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>表格</td></tr><tr><td>caption</td><td>标题</td></tr><tr><td>thead</td><td>表头（语义划分）</td></tr><tr><td>tbody</td><td>表身（语义划分）</td></tr><tr><td>tfoot</td><td>表尾（语义划分）</td></tr><tr><td>tr</td><td>行</td></tr><tr><td>th</td><td>表头单元格</td></tr><tr><td>td</td><td>表格单元格</td></tr></tbody></table><h2 id=\"表单语义化\"><a href=\"#表单语义化\" class=\"headerlink\" title=\"表单语义化\"></a>表单语义化</h2><h3 id=\"label标签\"><a href=\"#label标签\" class=\"headerlink\" title=\"label标签\"></a>label标签</h3><p>label标签的for属性有两个作用：</p><ul><li>语义上绑定了label元素和表单元素。（\\<label for=\"*element_id*\">）</label></li><li>当我们点击label中的文本时，其关联的表单元素也会获得焦点。</li></ul><p>例：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rdo<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rdo<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>radio<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span> <span class=\"token attr-name\">for</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rdo<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>单选框<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n</code></pre><h3 id=\"fieldset标签和legend标签\"><a href=\"#fieldset标签和legend标签\" class=\"headerlink\" title=\"fieldset标签和legend标签\"></a>fieldset标签和legend标签</h3><p>fieldset标签用于给表单元素进行分组并绘制一个边框，legend标签用于定义某一组表单的标题。</p><p>例如这个<a href=\"http://www.runoob.com/tags/tag-fieldset.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">例子</a>：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>fieldset</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>legend</span><span class=\"token punctuation\">></span></span>Personalia:<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>legend</span><span class=\"token punctuation\">></span></span>\n    Name: <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">></span></span>\n    Email: <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span><span class=\"token punctuation\">></span></span>\n    Date of birth: <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>fieldset</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>作用：</p><ul><li>增强表单语义。</li><li>可以使用fieldset标签的disabled属性来禁用整个组中的表单元素。</li></ul><h2 id=\"其他语义化\"><a href=\"#其他语义化\" class=\"headerlink\" title=\"其他语义化\"></a>其他语义化</h2><h3 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\\\"></a>换行符\\<br></h3><p>W3C标准规定，\\<br>标签只能用于段落中的换行。即只能用于p标签内部。</p><h3 id=\"无序列表ul\"><a href=\"#无序列表ul\" class=\"headerlink\" title=\"无序列表ul\"></a>无序列表ul</h3><p>对于列表型数据，不建议使用div实现，而应用无序列表或有序列表实现。</p><p>为了实现外观效果，一般使用无序列表而不是有序列表。</p><h3 id=\"strong-标签和em标签\"><a href=\"#strong-标签和em标签\" class=\"headerlink\" title=\"strong 标签和em标签\"></a>strong 标签和em标签</h3><p>W3C对这两个标签赋予了“强调”的语义。</p><p>可以在CSS中重新定义它们的样式而不会改变它们的语义。</p><h3 id=\"del标签和ins标签\"><a href=\"#del标签和ins标签\" class=\"headerlink\" title=\"del标签和ins标签\"></a>del标签和ins标签</h3><p>这两个标签一般是配合使用表示更新文本：“delete”和“insert”，被删除的文本和被更新的文本。</p><p>一般会用CSS重新定义它们的样式。</p><p><a href=\"http://www.runoob.com/tags/tag-del.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">实例链接</a></p><h3 id=\"img标签\"><a href=\"#img标签\" class=\"headerlink\" title=\"img标签\"></a>img标签</h3><p>对于什么时候使用img标签，什么时候使用背景图片，应该根据HTML的语义来判断。</p><ul><li><p>img标签：作为HTML的一部分，希望被搜索引擎识别。</p></li><li><p>背景图片： 只起到修饰作用，不希望被搜索引擎识别。</p></li></ul><h2 id=\"语义化验证\"><a href=\"#语义化验证\" class=\"headerlink\" title=\"语义化验证\"></a>语义化验证</h2><p>通过去掉CSS样式，观察页面是否还有很好的可读性来判断一个页面是否语义良好。</p><h2 id=\"HTML5舍弃的标签\"><a href=\"#HTML5舍弃的标签\" class=\"headerlink\" title=\"HTML5舍弃的标签\"></a>HTML5舍弃的标签</h2><p>下边这些已经被舍弃的标签(仅为了定义样式的标签和很少使用或已经被新标签代替的标签)应停止使用：</p><ul><li><code>&lt;acronym&gt;</code> 定义首字母缩写，应用abbr代替。</li><li><code>&lt;applet&gt;</code> 定义嵌入的applet，应用object代替。</li><li><code>&lt;basefont&gt;</code></li><li><code>&lt;big&gt;</code></li><li><code>&lt;center&gt;</code></li><li><code>&lt;dir&gt;</code> 定义目录列表，应用ul代替。</li><li><code>&lt;font&gt;</code></li><li><code>&lt;frame&gt;</code></li><li><code>&lt;frameset&gt;</code></li><li><code>&lt;noframes&gt;</code></li><li><code>&lt;strike&gt;</code></li><li><code>&lt;tt&gt;</code></li></ul><h1 id=\"CSS基础知识\"><a href=\"#CSS基础知识\" class=\"headerlink\" title=\"CSS基础知识\"></a>CSS基础知识</h1><h2 id=\"CSS单位\"><a href=\"#CSS单位\" class=\"headerlink\" title=\"CSS单位\"></a>CSS单位</h2><h3 id=\"px\"><a href=\"#px\" class=\"headerlink\" title=\"px\"></a>px</h3><p>pixel，像素，一个图片或计算机屏幕中最小的点。</p><h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比%\"></a>百分比%</h3><p>CSS中支持百分比的属性：</p><ul><li><strong>width、height、font-size</strong>，它们的百分比是相对于父元素的“相同元素”的值来计算的。</li><li><strong>line-height</strong>，它的百分比是相对于<strong>父元素</strong>的<strong>font-size</strong>值来计算的。</li><li><strong>vertical-align</strong>，它的百分比是相对于<strong>当前元素</strong>继承的<strong>line-height</strong>值来计算的。</li></ul><h3 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h3><p>1em等于当前元素的以px为单位的font-size值，</p><p>若当前元素的font-size值没有定义，则从父元素继承，</p><p>若当前元素的所有祖先元素都没有定义font-size，则继承浏览器默认的font-size值：16px。</p><p><u>使用em的小技巧：</u>首行缩进使用 <code>text-indent: 2em</code>实现。</p><h3 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h3><p>CSS3新引入的单位，指相对根元素（即html元素）的字体大小。</p><h2 id=\"CSS特性\"><a href=\"#CSS特性\" class=\"headerlink\" title=\"CSS特性\"></a>CSS特性</h2><h3 id=\"继承性\"><a href=\"#继承性\" class=\"headerlink\" title=\"继承性\"></a>继承性</h3><p>指子元素继承了父元素的某些样式属性。</p><p>在CSS中，具有继承性的样式有三大类：</p><ul><li><strong>文本</strong>相关属性： font–family，font-size，font-style，font-weight，font，line-height，text-align，text-indent，word-spacing。</li><li><strong>列表</strong>相关属性： list-style-image，list-style-position，list-style-type，list-style。</li><li><strong>颜色</strong>相关属性： color。</li></ul><h3 id=\"层叠性\"><a href=\"#层叠性\" class=\"headerlink\" title=\"层叠性\"></a>层叠性</h3><p>“后者居上”原则。</p><p>CSS的层叠性指样式的覆盖。对于具有<strong>相同权重</strong>的<strong>相同属性</strong>，以最后定义的值为准。</p><h2 id=\"CSS优先级\"><a href=\"#CSS优先级\" class=\"headerlink\" title=\"CSS优先级\"></a>CSS优先级</h2><h3 id=\"引用方式\"><a href=\"#引用方式\" class=\"headerlink\" title=\"引用方式\"></a>引用方式</h3><p>行内样式&gt;(内部样式=外部样式)</p><p>若同时存在权重相同内部样式和外部样式，则以最后引入的样式为准。</p><h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>以最近的祖先元素为准。</p><h3 id=\"指定样式\"><a href=\"#指定样式\" class=\"headerlink\" title=\"指定样式\"></a>指定样式</h3><p>常见的伪元素——:before、:after、:first-letter、:first-line。</p><p>常见的伪类——:hover、:first-child等。</p><p>常用的选择器优先级：行内样式&gt;id选择器&gt;class选择器&gt;元素选择器。</p><p>选择器权值表：</p><table><thead><tr><th>选择器</th><th>权值</th></tr></thead><tbody><tr><td>通配符</td><td>0</td></tr><tr><td>伪元素</td><td>1</td></tr><tr><td>元素选择器</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>伪类</td><td>10</td></tr><tr><td>属性选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>行内样式</td><td>1000</td></tr></tbody></table><h3 id=\"继承样式和和指定样式\"><a href=\"#继承样式和和指定样式\" class=\"headerlink\" title=\"继承样式和和指定样式\"></a>继承样式和和指定样式</h3><p>指定样式权重更高。</p><h3 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h3><p>权值最高，不推荐使用。</p><h2 id=\"CSS引入方式\"><a href=\"#CSS引入方式\" class=\"headerlink\" title=\"CSS引入方式\"></a>CSS引入方式</h2><ul><li>导入样式表（加载html后加载css，不推荐）</li><li>外部样式表（link标签）</li><li>内部样式表（style标签）</li><li>行内样式表</li></ul><h2 id=\"CSS选择器\"><a href=\"#CSS选择器\" class=\"headerlink\" title=\"CSS选择器\"></a>CSS选择器</h2><p>CSS出去基本的选择器（元素选择器、id选择器、class选择器、群组或分组选择器），</p><p>还有<u>层次选择器</u>：</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>M N</td><td>后代选择器，选择M元素所有内部后代N元素</td></tr><tr><td>M&gt;N</td><td>子代选择器，选择M元素所有内部子代N元素</td></tr><tr><td>M~N</td><td>兄弟选择器，选择M元素所有同级N元素</td></tr><tr><td>M+N</td><td>相邻选择器，选择M元素相邻的下一个同级元素</td></tr></tbody></table><h1 id=\"CSS规范\"><a href=\"#CSS规范\" class=\"headerlink\" title=\"CSS规范\"></a>CSS规范</h1><h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><h3 id=\"CSS文件命名\"><a href=\"#CSS文件命名\" class=\"headerlink\" title=\"CSS文件命名\"></a>CSS文件命名</h3><p>开发阶段按照功能模块划分CSS文件。</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>reset.css</td><td>重置样式，重置元素默认样式</td></tr><tr><td>global.css</td><td>全局样式，全站公用，定义页面基础样式</td></tr><tr><td>themes.css</td><td>主题样式，用于实现换肤功能</td></tr><tr><td>module.css</td><td>模块样式，用于模块的样式</td></tr><tr><td>master.css</td><td>母版样式，用于母版页的样式</td></tr><tr><td>columes.css</td><td>专栏样式，用于专栏的样式</td></tr><tr><td>forms.css</td><td>表单样式，用于表单的样式</td></tr><tr><td>mend.css</td><td>补丁样式，用于维护、修改的样式</td></tr><tr><td>print.css</td><td>打印样式，用于打印的样式</td></tr></tbody></table><h3 id=\"id和class命名\"><a href=\"#id和class命名\" class=\"headerlink\" title=\"id和class命名\"></a>id和class命名</h3><p>建议使用中划线命名，例如<code>column-title</code>。</p><p>为了避免class命名的重复，一般取父元素的class名作为前缀，例如<code>column-title</code>。</p><table><thead><tr><th>网页主体部分</th><th>命名</th></tr></thead><tbody><tr><td>最外层</td><td>wrapper(一般用于包裹整个页面)</td></tr><tr><td>头部</td><td>header</td></tr><tr><td>内容</td><td>content</td></tr><tr><td>侧栏</td><td>sidebar</td></tr><tr><td>栏目</td><td>column</td></tr><tr><td>热点</td><td>hot</td></tr><tr><td>新闻</td><td>news</td></tr><tr><td>下载</td><td>download</td></tr><tr><td>标志</td><td>logo</td></tr><tr><td>导航条</td><td>nav</td></tr><tr><td>主体</td><td>main</td></tr><tr><td>左侧</td><td>main-left</td></tr><tr><td>右侧</td><td>main-right</td></tr><tr><td>底部</td><td>footer</td></tr><tr><td>友情链接</td><td>friendlink</td></tr><tr><td>加入我们</td><td>joinus</td></tr><tr><td>版权</td><td>copyright</td></tr><tr><td>服务</td><td>service</td></tr><tr><td>登录</td><td>login</td></tr><tr><td>注册</td><td>register</td></tr></tbody></table><table><thead><tr><th>导航部分</th><th>命名</th></tr></thead><tbody><tr><td>主导航</td><td>main-nav</td></tr><tr><td>子导航</td><td>sub-nav</td></tr><tr><td>边导航</td><td>side-nav</td></tr><tr><td>左导航</td><td>leftside-nav</td></tr><tr><td>右导航</td><td>rightside-nav</td></tr><tr><td>顶导航</td><td>top-nav</td></tr></tbody></table><table><thead><tr><th>菜单部分</th><th>命名</th></tr></thead><tbody><tr><td>菜单</td><td>menu</td></tr><tr><td>子菜单</td><td>submenu</td></tr></tbody></table><table><thead><tr><th>其他</th><th>命名</th></tr></thead><tbody><tr><td>标题</td><td>title</td></tr><tr><td>摘要</td><td>summary</td></tr><tr><td>登录条</td><td>loginbar</td></tr><tr><td>搜索</td><td>search</td></tr><tr><td>标签页</td><td>tab</td></tr><tr><td>广告</td><td>banner</td></tr><tr><td>小技巧</td><td>tips</td></tr><tr><td>图标</td><td>icon</td></tr><tr><td>法律声明</td><td>siteinfolegal</td></tr><tr><td>网站地图</td><td>sitemap</td></tr><tr><td>工具条</td><td>tool、toolbar</td></tr><tr><td>首页</td><td>homepage</td></tr><tr><td>子页</td><td>subpage</td></tr><tr><td>合作伙伴</td><td>partner</td></tr><tr><td>帮助</td><td>help</td></tr><tr><td>指南</td><td>guide</td></tr><tr><td>滚动</td><td>scroll</td></tr><tr><td>提示信息</td><td>msg</td></tr><tr><td>投票</td><td>vote</td></tr><tr><td>相关文章</td><td>related</td></tr><tr><td>文章列表</td><td>list</td></tr></tbody></table><h2 id=\"书写规范\"><a href=\"#书写规范\" class=\"headerlink\" title=\"书写规范\"></a>书写规范</h2><p>对于功能代码，应该集中放在一起，</p><p>对于其他代码，应按照如下顺序：</p><ol><li>影响文档流属性（布局属性）——display，position，float，clear等</li><li>自身盒模型属性——width，height，padding，margin，border，overflow等</li><li>文本性属性——font，line-height，text-align，text-indent，vertical-align等</li><li>装饰性属性——color，background-color，opacity等</li><li>其他属性——cursor，content，list-style，quotes等</li></ol><p>例如：</p><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token id\">#main</span> </span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 影响文档流属性 */</span>\n  <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> inline-block<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 盒子模型属性 */</span>\n  <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>px solid gray<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 文本性属性 */</span>\n  <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">15</span>px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">font-weight</span><span class=\"token punctuation\">:</span> bold<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">text-indent</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>em<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 装饰性属性 */</span>\n  <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> white<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 其他属性 */</span>\n  <span class=\"token property\">cursor</span><span class=\"token punctuation\">:</span> pointer<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a>注释规范</h2><p>由于压缩工具会删除所有的注释，因此有时为了保留版权声明等注释信息，需要在注释内容前加一个叹号，如<code>/*! 注释内容 */</code>，这样压缩工具就不会删除这条注释信息。</p><h3 id=\"顶部注释\"><a href=\"#顶部注释\" class=\"headerlink\" title=\"顶部注释\"></a>顶部注释</h3><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token comment\" spellcheck=\"true\">/*\n *@description:说明\n *@author:作者\n *@update:更新时间，如2018-09-10 17:42\n */</span>\n</code></pre><h3 id=\"模块注释\"><a href=\"#模块注释\" class=\"headerlink\" title=\"模块注释\"></a>模块注释</h3><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token comment\" spellcheck=\"true\">/* 导航部分，开始 */</span>\n<span class=\"token number\">......</span>\n<span class=\"token comment\" spellcheck=\"true\">/* 导航部分，结束 */</span>\n</code></pre><h3 id=\"简单注释\"><a href=\"#简单注释\" class=\"headerlink\" title=\"简单注释\"></a>简单注释</h3><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token comment\" spellcheck=\"true\">/* 单行注释 */</span>\n</code></pre><p>或者</p><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token comment\" spellcheck=\"true\">/*多行注释\n *多行注释\n *多行注释\n */</span>\n</code></pre><h2 id=\"CSS-reset\"><a href=\"#CSS-reset\" class=\"headerlink\" title=\"CSS reset\"></a>CSS reset</h2><p>重置样式，去除元素在浏览器中的默认样式。</p><p>是否使用CSS reset根据实际开发需求而定。</p><h1 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h1><p><img src=\"https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=5ad0ba6a0c7b02080c9c37e752e9deeb/0824ab18972bd407012c41327d899e510eb30911.jpg\" alt=\"标准盒子模型\"></p><p><img src=\"https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=6cdf3ae9fbfaaf5184b689b9bc64b8d6/1b4c510fd9f9d72ac29d82d2d22a2834359bbb00.jpg\" alt=\"IE盒子模型\"></p><h2 id=\"外边距叠加\"><a href=\"#外边距叠加\" class=\"headerlink\" title=\"外边距叠加\"></a>外边距叠加</h2><p>又称为“margin叠加”，指当两个外边距相遇时会“合二为一”。叠加后的外边距为两个外边距的最大值。</p><p><u>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</u></p><p>以下图片均来自<a href=\"http://www.w3school.com.cn/css/css_margin_collapsing.asp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">w3school</a></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif\" alt=\"同级元素\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif\" alt=\"父子元素\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif\" alt=\"空元素1\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif\" alt=\"空元素2\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing.gif\" alt=\"外边距合并的意义\"></p><h2 id=\"负margin\"><a href=\"#负margin\" class=\"headerlink\" title=\"负margin\"></a>负margin</h2><ul><li>当margin-top或者margin-left为负数时，<strong>当前元素</strong>会被拉向指定方向。</li><li>当margin-bottom或者margin-right为负数时，<strong>后续元素</strong>会被拉向指定方向。</li></ul><p><a href=\"https://www.jianshu.com/p/549aaa5fabaa\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里有一篇文章</a>讲得不错，可以参考一下。</p><p><a href=\"https://www.cnblogs.com/star91/p/5773436.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">圣杯布局、双飞翼布局</a>就是利用这个实现的。</p><h2 id=\"overflow\"><a href=\"#overflow\" class=\"headerlink\" title=\"overflow\"></a>overflow</h2><p>当浮动引起父元素高度塌陷时，可以为父元素加上<code>overflow: hidden</code>来清除浮动。</p><h1 id=\"display属性\"><a href=\"#display属性\" class=\"headerlink\" title=\"display属性\"></a>display属性</h1><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>inline</td><td>行内元素</td></tr><tr><td>block</td><td>块元素</td></tr><tr><td>inline-block</td><td>行内块元素</td></tr><tr><td>table</td><td>以表格形式显示，类似于table元素</td></tr><tr><td>table-row</td><td>以表格行形式显示，类似于tr元素</td></tr><tr><td>table-cell</td><td>以表格单元格形式显示，类似于td元素</td></tr><tr><td>none</td><td>隐藏元素</td></tr></tbody></table><h2 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h2><ul><li>独占一行</li><li>内部可以容纳其他块元素或行元素</li><li>可以定义width和height</li><li>可以定义四个方向的margin</li></ul><h2 id=\"inline元素\"><a href=\"#inline元素\" class=\"headerlink\" title=\"inline元素\"></a>inline元素</h2><ul><li>可以与其他行内元素位于同一行</li><li>可以容纳行内元素，但不能容纳块元素</li><li>无法定义width和height</li><li>可以定义margin-left和margin-right，不能定义margin-top和margin-bottom</li></ul><h2 id=\"inline-block元素\"><a href=\"#inline-block元素\" class=\"headerlink\" title=\"inline-block元素\"></a>inline-block元素</h2><ul><li>可以定义width和height</li><li>可以与其他行内元素位于同一行</li></ul><p>常见的inline-block元素：img元素和input元素</p><h2 id=\"display-table-cell\"><a href=\"#display-table-cell\" class=\"headerlink\" title=\"display: table-cell\"></a>display: table-cell</h2><p>可以用于实现：</p><ul><li><a href=\"https://www.jianshu.com/p/a7ee7dd60166\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">图片垂直居中</a>于元素</li><li>等高布局</li><li>自动平均划分元素，并在同一行显示</li></ul><h2 id=\"去除inline-block元素间距\"><a href=\"#去除inline-block元素间距\" class=\"headerlink\" title=\"去除inline-block元素间距\"></a>去除inline-block元素间距</h2><p>在父元素中添加<code>font-size: 0</code></p><h1 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a>文本效果</h1><table><thead><tr><th>文本属性</th><th>说明</th></tr></thead><tbody><tr><td>text-decoration</td><td>下划线、删除线、顶划线</td></tr><tr><td>text-transform</td><td>文本大小写</td></tr><tr><td>font-variant</td><td>将英文文本转换为小型大写字母</td></tr><tr><td>text-indent</td><td>段落首行缩进</td></tr><tr><td>text-align</td><td>文本水平对齐</td></tr><tr><td>vertical-align</td><td>文本垂直对齐</td></tr><tr><td>line-height</td><td>行高</td></tr><tr><td>letter-spacing</td><td>字距</td></tr><tr><td>word-spacing</td><td>词距</td></tr></tbody></table><h2 id=\"text-indent\"><a href=\"#text-indent\" class=\"headerlink\" title=\"text-indent\"></a>text-indent</h2><p>可以使用 <code>text-indent: -9999px;</code>来隐藏文本。</p><h2 id=\"text-align\"><a href=\"#text-align\" class=\"headerlink\" title=\"text-align\"></a>text-align</h2><p>主要使用的值为left、right、center，对文字、inline元素、inline-block元素都起作用，对块元素不起作用。</p><p>利用<code>margin: 0 auto</code>实现块元素的水平居中。</p><p><code>text-align: center</code>在父元素中定义，<code>margin: 0 auto</code>在当前元素中定义。</p><h2 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h2><p>关于顶线、中线、基线、底线可以自行查阅。</p><p>行高（line-height）指的是两行基线之间的距离。</p><ul><li>将height和line-height设为相同值可以实现文字垂直居中。</li><li>当取值为%或者em时，是相对与父元素的font-size计算的。</li><li>当取值为无单位数字时，是相对于当前元素的font-size计算的。</li></ul><h2 id=\"vertical-align\"><a href=\"#vertical-align\" class=\"headerlink\" title=\"vertical-align\"></a>vertical-align</h2><p>vertical-align对inline、inline-block、table-cell元素有效，对块元素无效。</p><p>用于定义<u>周围的文字、inline元素、inline-block元素</u>相对于该元素<strong>基线</strong>的垂直对齐方式。</p><p>可以取负长度值和百分比值。</p><h3 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h3><ol><li><p>负值 ： <code>vertical-align: -2px</code>指的是该元素相对于基线向下偏移2px；</p></li><li><p>百分比 ： 相对于当前元素继承的line-height值计算的，也是该元素相对于基线偏移的值；</p></li><li><p><a href=\"http://www.runoob.com/cssref/pr-pos-vertical-align.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">关键字</a> （前四个比较常用）：</p></li></ol><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><strong>top</strong></td><td>把元素的顶端与行中最高元素的顶端对齐</td></tr><tr><td><strong>middle</strong></td><td>把此元素放置在父元素的中部。</td></tr><tr><td><strong>baseline</strong></td><td>默认。元素放置在父元素的基线上。</td></tr><tr><td><strong>bottom</strong></td><td>把元素的底端与行中最低的元素的顶端对齐。</td></tr><tr><td>text-top</td><td>把元素的顶端与父元素字体的顶端对齐</td></tr><tr><td>text-bottom</td><td>把元素的底端与父元素字体的底端对齐。</td></tr><tr><td>sub</td><td>垂直对齐文本的下标。</td></tr><tr><td>super</td><td>垂直对齐文本的上标</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 vertical-align 属性的值。</td></tr></tbody></table><h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ul><li>为img添加<code>vertical-align: middle</code>可以实现图片与周围的文字居中对齐</li><li>要使块元素（如div）也可以使用此属性，可以为其先定义<code>display: table-cell</code></li></ul><h1 id=\"表单效果\"><a href=\"#表单效果\" class=\"headerlink\" title=\"表单效果\"></a>表单效果</h1><h2 id=\"radio与checkbox\"><a href=\"#radio与checkbox\" class=\"headerlink\" title=\"radio与checkbox\"></a>radio与checkbox</h2><p>默认情况下由于是基线对齐因此视觉上会感觉单选框或复选框旁边的文字比它们低，这个时候可以使用vertical-align来让他们垂直居中对齐。</p><p>可以使用关键字，也可以使用数值。</p><h2 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h2><ul><li>可以使用max-width和max-height来限制拖拽大小</li><li>可以使用<code>resize: none</code>来禁止拖拽</li></ul><p>要使textarea在不同浏览器中具有相同的外观，可以：</p><ul><li>使用CSS的width和height定义大小</li><li>使用<code>overflow: auto</code>来定义textarea滚动条自适应</li></ul><h2 id=\"表单对齐\"><a href=\"#表单对齐\" class=\"headerlink\" title=\"表单对齐\"></a>表单对齐</h2><p>书上给了<strong>注册</strong>的例子：</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536639853274&amp;di=16c88d63b9118620ba546c2f6237b78c&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.orsoon.com%2Fuploads%2Fallimg%2F24631428484696.png\" alt=\"图片来源于网络\"></p><p>实现方法：</p><ol><li>每一行表单分为左栏加若干右栏<ol><li>所有行的左栏长度相等</li><li>所有行的右栏所有盒子长度之和相等</li><li>左栏一般为一个label，右栏为若干文本框</li></ol></li><li>所有左栏和右栏盒子都设为左浮动</li><li>左栏添加属性<code>text-align: right</code>使得文字右对齐</li><li>每一行左栏盒子长度加上所有右栏盒子长度之和等于行宽</li><li>每一行由一个p包裹住，并为p添加<code>overflow: hidden</code>来清除浮动</li></ol><p>然后我又去看了一下各网站的<strong>登录</strong>界面，基本上是一个icon+一个input的模式：</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536641005969&amp;di=02e6a2469281303e926eb8878cf64db9&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fexp%2Fw%3D480%2Fsign%3D00237679845494ee87220e111df7e0e1%2Fa686c9177f3e67093ac0b23933c79f3df9dc5530.jpg\" alt=\"图片来源于网络\"></p><p>实现方法：</p><ul><li>icon使用<code>position: absolute</code>脱离文档流并盖在input上</li><li>input将padding-left调到合适大小使得输入框不被icon盖住</li></ul><h1 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h1><h2 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a>文档流</h2><p>简单来说就是元素在页面中出现的先后顺序。</p><ul><li>正常文档流 ： “normal flow”，指默认情况下页面元素的布局情况。</li><li>脱离文档流：脱离正常文档流。要改变正常文档流，使用浮动和定位方法。</li></ul><h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>可以使元素移到左边或者右边，并且允许后边的文字和元素环绕着它。</p><p>浮动后使用margin来定义和其他元素之间的间距。</p><p>绝对定位的元素忽略float属性。</p><p>float的取值表如下，默认为<strong>none</strong>：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动。</td></tr><tr><td>right</td><td>元素向右浮动。</td></tr><tr><td>none</td><td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 float 属性的值。</td></tr></tbody></table><ul><li>当一个元素添加float属性为left或者right时，它将变为block类型。</li><li>浮动元素脱离正常文档流，若其height大于父元素的height或者父元素的height未定义，会造成父元素高度塌陷。可以为父元素添加<code>overflow: hidden</code>来解决。</li><li><p>若父元素和子元素都是浮动元素，则父元素会自适应地包含子元素。</p></li><li><p>若兄弟元素不是浮动元素，由于浮动元素脱离文档流，可能会出现覆盖等情况。</p></li></ul><h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><ul><li><code>clear: both</code>，用于浮动元素后边的元素，表示两边不允许出现浮动元素。</li><li><code>overflow: hidden</code>，用于浮动元素的父元素，但会隐藏超出父元素的内容部分。</li><li>实际开发中，更经常使用<code>:after</code>伪元素结合<code>clear: both</code>来实现。</li><li>为了兼容ie，为父元素添加<code>zoom: 1</code>来消除浮动。</li></ul><h1 id=\"定位布局\"><a href=\"#定位布局\" class=\"headerlink\" title=\"定位布局\"></a>定位布局</h1><h2 id=\"属性值\"><a href=\"#属性值\" class=\"headerlink\" title=\"属性值\"></a><a href=\"http://www.runoob.com/cssref/pr-class-position.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">属性值</a></h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-static\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">static</a></td><td><u>默认值</u>。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-absolute\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">absolute</a></td><td>生成绝对定位的元素，相对于 <u>static 定位以外的第一个父元素</u>进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-fixed\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">fixed</a></td><td>生成固定定位的元素，相对于<u>浏览器窗口</u>进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-relative\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">relative</a></td><td>生成相对定位的元素，相对于<u>其正常位置</u>进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-sticky\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">sticky</a></td><td>粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。<strong>注意:</strong> Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值。</td></tr><tr><td>initial</td><td>设置该属性为默认值，详情查看 <a href=\"http://www.runoob.com/cssref/css-inherit.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS initial 关键字</a>。</td></tr></tbody></table><ul><li>absolute会将元素转换为块元素。</li><li>若想要子元素相对于父元素定位，一般给父元素添加<code>position: relative</code>，给子元素定义<code>position: absolute</code>来实现。祖先元素同理。</li></ul><h2 id=\"z-index属性\"><a href=\"#z-index属性\" class=\"headerlink\" title=\"z-index属性\"></a>z-index属性</h2><p>默认情况下设置z-index无效，只有当元素定义position为relative、absolute、fixed时才会激活，z-index值越大，其堆叠顺序越高，越靠上（z方向上的靠上）。</p><h1 id=\"CSS图形\"><a href=\"#CSS图形\" class=\"headerlink\" title=\"CSS图形\"></a>CSS图形</h1><p>由于图片大小比较大，数据传输量大且一张图片会引发一次HTTP请求，因此对徐图形效果，一般更倾向于用CSS实现。</p><p>这里有一篇<a href=\"https://www.w3cplus.com/css/css-simple-shapes-cheat-sheet\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS制作图形速查表</a>总结得比较全面，可以参考。</p><p>另外对于带有边框的图形，一般是用大小不同的两个相同图形实现，小的覆盖在大的上边。</p><h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1><h2 id=\"属性缩写\"><a href=\"#属性缩写\" class=\"headerlink\" title=\"属性缩写\"></a>属性缩写</h2><ul><li><p>border：<code>border: 1px solid red</code></p><ul><li>若不想要底边框，可以加上<code>border-bottom: 0</code></li><li>若只想要底边框，可以<code>border-bottom: 1px solid red</code></li></ul></li><li><p>padding：</p><ul><li><code>padding: 10px</code>指上右下左均为10px</li><li><code>padding: 10px 20px</code>指上下为10px，左右为20px</li><li><code>padding: 10px 20px 30px 40px</code>的顺序为上右下左，从上开始按照顺时针顺序</li></ul></li><li><p>margin： 类似于padding</p></li><li>background： <code>background: url(&#39;xxx.jpg&#39;) no-repeat 80px 40px</code>,最后为background-position</li><li><p>font： <code>font: &quot;微软雅黑&quot; 12px/1.5em bold</code></p><ul><li>顺序为<code>font-family</code>、<code>font-size</code>、<code>line-height</code>、<code>font-weight</code></li><li>简写形式必须指定<code>font-family</code>和<code>font-size</code>的值，其他属性没有指定则为默认值</li><li>简写形式中<code>font-size</code>和<code>line-height</code>之间需要加入一个斜杠<code>/</code></li></ul></li><li><p>color： 十六进制的颜色值若每两位值相同，可以缩写一半，比如<code>color: #112233</code>可以缩写为<code>color: #123</code></p></li></ul><h2 id=\"语法压缩\"><a href=\"#语法压缩\" class=\"headerlink\" title=\"语法压缩\"></a>语法压缩</h2><ul><li>当一个CSS规则只有一两个属性的时候，使用横向书写</li><li>可以省略最后一个属性的分号</li><li>background-image、cursor等属性url()中的路径不用加引号</li><li>如果某一个属性值为0，则不需要加单位</li><li>如果某一个属性值是以0为开头的小数，可以吧0省略</li><li>使用群组选择器合并相同样式</li><li>若同一个父元素的多个子元素都定义了相同的可继承属性，把这些属性定义在父元素中来精简代码</li></ul><h2 id=\"CSS压缩\"><a href=\"#CSS压缩\" class=\"headerlink\" title=\"CSS压缩\"></a>CSS压缩</h2><p>书中推荐了两个在线的压缩工具：<a href=\"https://csscompressor.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS Compressor</a> 和 <a href=\"http://tool.oschina.net/jscompress\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">YUI Compressor</a></p><p>以YUI Compressor为例，它会对CSS文件执行如下操作：</p><ul><li>删除所有注释</li><li>删除无用空白符</li><li>删除结尾分号</li><li>删除属性值为0的单位</li><li>删除以0开头的小数前的0</li><li>合并相似属性（属性缩写）</li><li>将RGB颜色转换为十六进制颜色</li></ul><h2 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h2><p>书中推荐的图片压缩工具：</p><p>在线的<a href=\"https://www.jpegmini.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">JPEGmini</a>和<a href=\"https://tinypng.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TinyPNG</a>以及本地的<a href=\"https://imageoptim.com/versions.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ImageOptim</a></p><h2 id=\"高性能的选择器\"><a href=\"#高性能的选择器\" class=\"headerlink\" title=\"高性能的选择器\"></a>高性能的选择器</h2><p>浏览器对选择器规则是从右到左进行解析的。</p><p>CSS选择的匹配效率：</p><ol><li>id选择器</li><li>class选择器</li><li>元素选择器</li><li>相邻选择器</li><li>子选择器</li><li>后代选择器</li><li>通配符选择器</li><li>属性选择器</li><li>伪类选择器</li></ol><p>因此在使用选择器时应注意：</p><ul><li>尽量不要使用通配符</li><li>不要在id选择器和class选择器前添加元素名</li><li>选择器最好不要超过三层，靠右的选择条件应尽可能精确</li><li>避免使用后代选择器，尽量少使用子选择器</li></ul><h1 id=\"CSS技巧\"><a href=\"#CSS技巧\" class=\"headerlink\" title=\"CSS技巧\"></a>CSS技巧</h1><h2 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h2><ul><li>文字、inline元素和inline-*元素： <code>text-align: center</code></li><li>块元素： <code>margin: 0 auto</code></li></ul><h2 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h2><ul><li>行内块元素使用<code>vertical-align: middle</code></li><li>块元素将display改为table-cell然后使用vertical-align</li><li>多行文字使用一个标签将文字包起来并设为table-cell，然后再设置vertical-align</li><li>单行文字设置line-height和height属性值相同来实现</li></ul><h2 id=\"CSS-Sprite\"><a href=\"#CSS-Sprite\" class=\"headerlink\" title=\"CSS Sprite\"></a>CSS Sprite</h2><p>又称为CSS精灵或CSS<strong>雪碧图</strong>，它将零散的小背景图合并成一张大背景图，然后再利用background-position属性进行定位从而现实小背景图。</p><p>使用CSS Sprite技术时，需要注意：</p><ul><li>在开发后期而不是开发前期使用此技术</li><li>有条理地组织图片顺序，应将小背景图按照类别、风格、大小等分门别类地放好</li><li>控制雪碧图的大小，当图片大小小于200KB时传输时间是差不多的，因此雪碧图应控制在200KB以内</li></ul><p>书中推荐了两个CSS Sprite工具：<a href=\"http://css.spritegen.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS Sprite Generator</a> 和 <a href=\"http://www.spritecow.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Sprite Cow</a></p><h2 id=\"Icon-Font图标\"><a href=\"#Icon-Font图标\" class=\"headerlink\" title=\"Icon Font图标\"></a>Icon Font图标</h2><p>使用字体文件实现小图标效果，从而减少图片的使用。</p><p>推荐的Icon Font网站：<a href=\"http://www.iconfont.cn/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.iconfont.cn/</a></p><p>网站上就有<a href=\"http://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d0091c141&amp;helptype=code\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">使用教程</a></p><h1 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h1><h2 id=\"包含块\"><a href=\"#包含块\" class=\"headerlink\" title=\"包含块\"></a>包含块</h2><p>containing block，决定一个元素大小和定位的元素。</p><p>时视觉格式化模型中的一个重要概念，与CSS盒子模型类似。其作用主要是为其内部的后代元素提供一个参考。</p><ul><li>根元素（HTML元素）没有父元素，它存在的包含块被称为初始包含块</li><li>定位为fixed的元素的包含块为浏览器窗口</li><li>定位为是static和relative的元素的包含块是它最近的块级（block、inline-block或table-cell）祖先元素创建的</li><li>定位为absolute的元素的包含块是它最近的定位不是static的祖先元素，可以是块元素也可以是行内元素</li></ul><h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a>层叠上下文</h2><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1537245373&amp;di=c7455fbd6881b1a07ae8ac81a79f474e&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.w3cplus.com%2Fsites%2Fdefault%2Ffiles%2Fblogs%2F2018%2F1808%2Fz-index-15.png\" alt=\"层叠级别图\"></p><p>一个元素在z轴上的堆叠顺序：</p><ul><li>层叠级别越大越靠上</li><li>同等层叠级别，后边的堆叠在前边的上边（后来者居上）</li><li>不同的层叠上下文比较的是父级层叠上下文，与自身无关</li></ul><h2 id=\"BFC和IFC\"><a href=\"#BFC和IFC\" class=\"headerlink\" title=\"BFC和IFC\"></a>BFC和IFC</h2><p>BFC： block formatting context， 块级格式上下文</p><p>IFC： inline formatting context， 行级格式上下文</p><p>若一个元素具备以下任何一个条件，则会创造创造一个新的BFC：</p><ul><li>根元素</li><li>float属性不是none</li><li>position属性是absolute或fixed</li><li>overflow属性值不是visible</li><li>display属性为inline-block、table-caption、table-cell</li></ul><p>W3C描述BFC的特点为：</p><ul><li>在一个BFC中，盒子从顶端开始垂直一个接着一个地排列。两个相邻盒子之间的垂直间距有margin决定。<strong>同一个BFC中</strong>，两个相邻块盒子之间<strong>垂直方向上的外边距</strong>会叠加。</li><li>在一个BFC中，每一个盒子的左外边界（margin-left）会紧贴着容器的border-left，右边同理，即使存在浮动元素也是如此。</li></ul><p>可以得到结论：</p><ol><li>在一个BFC内部，盒子会在垂直方向上一个接着一个地排列</li><li>在一个BFC内部，相邻的margin-top、margin-bottom会叠加</li><li>在一个BFC内部，每一个盒子的左外边界（margin-left）会紧贴着容器（包含盒子）的border-left，即使存在浮动元素也是如此</li><li>在一个BFC内部，如果存在内部元素是一个新的BFC，并且存在内部元素是浮动元素，则这个新的BFC的区域不会与浮动元素的区域重叠</li><li>BFC就是页面上一个隔离的盒子，该盒子内部的子元素不会影响到外边的元素</li><li>计算一个BFC的高度时，其内部浮动元素的高度也会计算其中</li></ol><p>BFC的用途：</p><ul><li>创建BFC来避免垂直外边距叠加（例如使用div将一个盒子包起来并给这个div添加overflow属性）</li><li>创建BFC来清除浮动（为父元素添加<code>overflow: hidden</code>，利用结论第六条）</li><li>创建BFC来实现<a href=\"https://blog.csdn.net/michael8512/article/details/76473835\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">自适应布局</a></li></ul><hr><p>好了到这里，这本书就看完了，一些细节的东西了解到了很多，下面开始看html5+css3。</p><p>- 2018 - 09 - 11 -</p>","site":{"data":{}},"excerpt":"<p>《HTML与CSS进阶教程读书笔记》</p>","more":"<hr><h1 id=\"HTML基础知识\"><a href=\"#HTML基础知识\" class=\"headerlink\" title=\"HTML基础知识\"></a>HTML基础知识</h1><h2 id=\"HTML与XHTML\"><a href=\"#HTML与XHTML\" class=\"headerlink\" title=\"HTML与XHTML\"></a>HTML与XHTML</h2><p>HTML指超文本标记语言，是构成网页文档的主要语言。我们常说的HTML指HTML4.01。</p><p>XHTML指扩展的超文本标记语言，是XML风格的、更严格、更纯净的HTML。</p><p>两者的主要区别：</p><ul><li>XHTML标签必须闭合。</li><li>XHTML标签和属性必须小写。</li><li>XHTML标签属性必须加引号。</li><li>XHTML标签用id属性代替name属性。</li></ul><h2 id=\"id和class\"><a href=\"#id和class\" class=\"headerlink\" title=\"id和class\"></a>id和class</h2><p>由于id属性具有唯一性，因此W3C建议，对于页面关键的结构或大结构，才能使用id属性，其他地方使用class属性。</p><p><u>因为搜索引擎是根据标签的语义和id属性来识别的，因此id属性的使用和命名都需要谨慎。</u></p><p>一般来说，定义多个class的目的在于：一个class抽取公共样式，一个class定义单独样式。</p><h2 id=\"标题栏小图标\"><a href=\"#标题栏小图标\" class=\"headerlink\" title=\"标题栏小图标\"></a>标题栏小图标</h2><p>在<code>head</code>标签内加入：</p><pre><code class=\"html\">&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;图标路径.ico&quot; /&gt;\n</code></pre><p>其中<code>rel</code>和<code>type</code>是固定属性不用更改，只需要修改图片路径即可。</p><h1 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h1><p>HTML的精髓在于标签的语义。搜索引擎根据HTML代码识别页面结构。</p><p>编写语意结构良好的页面的好处：</p><ul><li>利于开发调试和后期维护。</li><li>利于搜索引擎优化。</li></ul><p>应优先使用正确的语义化标签，如果没有语义化标签可用，再考虑div或者span等无语义标签。</p><h2 id=\"标题语义化\"><a href=\"#标题语义化\" class=\"headerlink\" title=\"标题语义化\"></a>标题语义化</h2><p>h1-h6是标题标签，相比于其他标签，它们在搜索引擎优化（SEO）中占有相当重要的地位。</p><p>一般用到h4，h5和h6权重和普通标签差不多，很少使用。</p><p>对于标题语义化，我们需要注意的是：</p><ul><li>一个页面只能有一个h1标签。</li><li>h1-h6之间不要出现断层。</li><li>不要用标题标签来定义样式（如为了加粗字体而为文本加上标题标签）。</li><li>不要用div来代替标题标签。</li></ul><p>div是无语义的标签，如果使用div代替标题标签会使网页在SEO中丢失大量权重。</p><h2 id=\"图片语义化\"><a href=\"#图片语义化\" class=\"headerlink\" title=\"图片语义化\"></a>图片语义化</h2><h3 id=\"alt属性和title属性\"><a href=\"#alt属性和title属性\" class=\"headerlink\" title=\"alt属性和title属性\"></a>alt属性和title属性</h3><p>alt是给搜索引擎看的，title是给用户看的。</p><p>搜索引擎根据alt属性或上下文判断图片内容。</p><p>因此<strong>img标签必须添加alt属性。</strong></p><h3 id=\"figure元素和figcaption元素\"><a href=\"#figure元素和figcaption元素\" class=\"headerlink\" title=\"figure元素和figcaption元素\"></a>figure元素和figcaption元素</h3><p>对于图片+图注的效果，使用figure和figcaption来增强图片语义化。</p><p>例：</p><pre><code class=\"html\">&lt;figure&gt;\n    &lt;img src=&quot;xxx&quot; alt=&quot;xxx&quot; /&gt;\n    &lt;figcaption&gt;这是一个图注&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre><p>更详细的介绍可以看<a href=\"https://www.w3cplus.com/html5/quick-tip-the-right-way-to-use-figure-and-figcaption-elements.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这一篇博客</a>。</p><h2 id=\"表格语义化\"><a href=\"#表格语义化\" class=\"headerlink\" title=\"表格语义化\"></a>表格语义化</h2><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>表格</td></tr><tr><td>caption</td><td>标题</td></tr><tr><td>thead</td><td>表头（语义划分）</td></tr><tr><td>tbody</td><td>表身（语义划分）</td></tr><tr><td>tfoot</td><td>表尾（语义划分）</td></tr><tr><td>tr</td><td>行</td></tr><tr><td>th</td><td>表头单元格</td></tr><tr><td>td</td><td>表格单元格</td></tr></tbody></table><h2 id=\"表单语义化\"><a href=\"#表单语义化\" class=\"headerlink\" title=\"表单语义化\"></a>表单语义化</h2><h3 id=\"label标签\"><a href=\"#label标签\" class=\"headerlink\" title=\"label标签\"></a>label标签</h3><p>label标签的for属性有两个作用：</p><ul><li>语义上绑定了label元素和表单元素。（\\<label for=\"*element_id*\">）</label></li><li>当我们点击label中的文本时，其关联的表单元素也会获得焦点。</li></ul><p>例：</p><pre><code class=\"html\">&lt;input id=&quot;rdo&quot; name=&quot;rdo&quot; type=&quot;radio&quot; /&gt;&lt;label for=&quot;rdo&quot;&gt;单选框&lt;/label&gt;\n</code></pre><h3 id=\"fieldset标签和legend标签\"><a href=\"#fieldset标签和legend标签\" class=\"headerlink\" title=\"fieldset标签和legend标签\"></a>fieldset标签和legend标签</h3><p>fieldset标签用于给表单元素进行分组并绘制一个边框，legend标签用于定义某一组表单的标题。</p><p>例如这个<a href=\"http://www.runoob.com/tags/tag-fieldset.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">例子</a>：</p><pre><code class=\"html\">&lt;form&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;Personalia:&lt;/legend&gt;\n    Name: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;\n    Email: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;\n    Date of birth: &lt;input type=&quot;text&quot;&gt;\n  &lt;/fieldset&gt;\n&lt;/form&gt;\n</code></pre><p>作用：</p><ul><li>增强表单语义。</li><li>可以使用fieldset标签的disabled属性来禁用整个组中的表单元素。</li></ul><h2 id=\"其他语义化\"><a href=\"#其他语义化\" class=\"headerlink\" title=\"其他语义化\"></a>其他语义化</h2><h3 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\\\"></a>换行符\\<br></h3><p>W3C标准规定，\\<br>标签只能用于段落中的换行。即只能用于p标签内部。</p><h3 id=\"无序列表ul\"><a href=\"#无序列表ul\" class=\"headerlink\" title=\"无序列表ul\"></a>无序列表ul</h3><p>对于列表型数据，不建议使用div实现，而应用无序列表或有序列表实现。</p><p>为了实现外观效果，一般使用无序列表而不是有序列表。</p><h3 id=\"strong-标签和em标签\"><a href=\"#strong-标签和em标签\" class=\"headerlink\" title=\"strong 标签和em标签\"></a>strong 标签和em标签</h3><p>W3C对这两个标签赋予了“强调”的语义。</p><p>可以在CSS中重新定义它们的样式而不会改变它们的语义。</p><h3 id=\"del标签和ins标签\"><a href=\"#del标签和ins标签\" class=\"headerlink\" title=\"del标签和ins标签\"></a>del标签和ins标签</h3><p>这两个标签一般是配合使用表示更新文本：“delete”和“insert”，被删除的文本和被更新的文本。</p><p>一般会用CSS重新定义它们的样式。</p><p><a href=\"http://www.runoob.com/tags/tag-del.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">实例链接</a></p><h3 id=\"img标签\"><a href=\"#img标签\" class=\"headerlink\" title=\"img标签\"></a>img标签</h3><p>对于什么时候使用img标签，什么时候使用背景图片，应该根据HTML的语义来判断。</p><ul><li><p>img标签：作为HTML的一部分，希望被搜索引擎识别。</p></li><li><p>背景图片： 只起到修饰作用，不希望被搜索引擎识别。</p></li></ul><h2 id=\"语义化验证\"><a href=\"#语义化验证\" class=\"headerlink\" title=\"语义化验证\"></a>语义化验证</h2><p>通过去掉CSS样式，观察页面是否还有很好的可读性来判断一个页面是否语义良好。</p><h2 id=\"HTML5舍弃的标签\"><a href=\"#HTML5舍弃的标签\" class=\"headerlink\" title=\"HTML5舍弃的标签\"></a>HTML5舍弃的标签</h2><p>下边这些已经被舍弃的标签(仅为了定义样式的标签和很少使用或已经被新标签代替的标签)应停止使用：</p><ul><li><code>&lt;acronym&gt;</code> 定义首字母缩写，应用abbr代替。</li><li><code>&lt;applet&gt;</code> 定义嵌入的applet，应用object代替。</li><li><code>&lt;basefont&gt;</code></li><li><code>&lt;big&gt;</code></li><li><code>&lt;center&gt;</code></li><li><code>&lt;dir&gt;</code> 定义目录列表，应用ul代替。</li><li><code>&lt;font&gt;</code></li><li><code>&lt;frame&gt;</code></li><li><code>&lt;frameset&gt;</code></li><li><code>&lt;noframes&gt;</code></li><li><code>&lt;strike&gt;</code></li><li><code>&lt;tt&gt;</code></li></ul><h1 id=\"CSS基础知识\"><a href=\"#CSS基础知识\" class=\"headerlink\" title=\"CSS基础知识\"></a>CSS基础知识</h1><h2 id=\"CSS单位\"><a href=\"#CSS单位\" class=\"headerlink\" title=\"CSS单位\"></a>CSS单位</h2><h3 id=\"px\"><a href=\"#px\" class=\"headerlink\" title=\"px\"></a>px</h3><p>pixel，像素，一个图片或计算机屏幕中最小的点。</p><h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比%\"></a>百分比%</h3><p>CSS中支持百分比的属性：</p><ul><li><strong>width、height、font-size</strong>，它们的百分比是相对于父元素的“相同元素”的值来计算的。</li><li><strong>line-height</strong>，它的百分比是相对于<strong>父元素</strong>的<strong>font-size</strong>值来计算的。</li><li><strong>vertical-align</strong>，它的百分比是相对于<strong>当前元素</strong>继承的<strong>line-height</strong>值来计算的。</li></ul><h3 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h3><p>1em等于当前元素的以px为单位的font-size值，</p><p>若当前元素的font-size值没有定义，则从父元素继承，</p><p>若当前元素的所有祖先元素都没有定义font-size，则继承浏览器默认的font-size值：16px。</p><p><u>使用em的小技巧：</u>首行缩进使用 <code>text-indent: 2em</code>实现。</p><h3 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h3><p>CSS3新引入的单位，指相对根元素（即html元素）的字体大小。</p><h2 id=\"CSS特性\"><a href=\"#CSS特性\" class=\"headerlink\" title=\"CSS特性\"></a>CSS特性</h2><h3 id=\"继承性\"><a href=\"#继承性\" class=\"headerlink\" title=\"继承性\"></a>继承性</h3><p>指子元素继承了父元素的某些样式属性。</p><p>在CSS中，具有继承性的样式有三大类：</p><ul><li><strong>文本</strong>相关属性： font–family，font-size，font-style，font-weight，font，line-height，text-align，text-indent，word-spacing。</li><li><strong>列表</strong>相关属性： list-style-image，list-style-position，list-style-type，list-style。</li><li><strong>颜色</strong>相关属性： color。</li></ul><h3 id=\"层叠性\"><a href=\"#层叠性\" class=\"headerlink\" title=\"层叠性\"></a>层叠性</h3><p>“后者居上”原则。</p><p>CSS的层叠性指样式的覆盖。对于具有<strong>相同权重</strong>的<strong>相同属性</strong>，以最后定义的值为准。</p><h2 id=\"CSS优先级\"><a href=\"#CSS优先级\" class=\"headerlink\" title=\"CSS优先级\"></a>CSS优先级</h2><h3 id=\"引用方式\"><a href=\"#引用方式\" class=\"headerlink\" title=\"引用方式\"></a>引用方式</h3><p>行内样式&gt;(内部样式=外部样式)</p><p>若同时存在权重相同内部样式和外部样式，则以最后引入的样式为准。</p><h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>以最近的祖先元素为准。</p><h3 id=\"指定样式\"><a href=\"#指定样式\" class=\"headerlink\" title=\"指定样式\"></a>指定样式</h3><p>常见的伪元素——:before、:after、:first-letter、:first-line。</p><p>常见的伪类——:hover、:first-child等。</p><p>常用的选择器优先级：行内样式&gt;id选择器&gt;class选择器&gt;元素选择器。</p><p>选择器权值表：</p><table><thead><tr><th>选择器</th><th>权值</th></tr></thead><tbody><tr><td>通配符</td><td>0</td></tr><tr><td>伪元素</td><td>1</td></tr><tr><td>元素选择器</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>伪类</td><td>10</td></tr><tr><td>属性选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>行内样式</td><td>1000</td></tr></tbody></table><h3 id=\"继承样式和和指定样式\"><a href=\"#继承样式和和指定样式\" class=\"headerlink\" title=\"继承样式和和指定样式\"></a>继承样式和和指定样式</h3><p>指定样式权重更高。</p><h3 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h3><p>权值最高，不推荐使用。</p><h2 id=\"CSS引入方式\"><a href=\"#CSS引入方式\" class=\"headerlink\" title=\"CSS引入方式\"></a>CSS引入方式</h2><ul><li>导入样式表（加载html后加载css，不推荐）</li><li>外部样式表（link标签）</li><li>内部样式表（style标签）</li><li>行内样式表</li></ul><h2 id=\"CSS选择器\"><a href=\"#CSS选择器\" class=\"headerlink\" title=\"CSS选择器\"></a>CSS选择器</h2><p>CSS出去基本的选择器（元素选择器、id选择器、class选择器、群组或分组选择器），</p><p>还有<u>层次选择器</u>：</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>M N</td><td>后代选择器，选择M元素所有内部后代N元素</td></tr><tr><td>M&gt;N</td><td>子代选择器，选择M元素所有内部子代N元素</td></tr><tr><td>M~N</td><td>兄弟选择器，选择M元素所有同级N元素</td></tr><tr><td>M+N</td><td>相邻选择器，选择M元素相邻的下一个同级元素</td></tr></tbody></table><h1 id=\"CSS规范\"><a href=\"#CSS规范\" class=\"headerlink\" title=\"CSS规范\"></a>CSS规范</h1><h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><h3 id=\"CSS文件命名\"><a href=\"#CSS文件命名\" class=\"headerlink\" title=\"CSS文件命名\"></a>CSS文件命名</h3><p>开发阶段按照功能模块划分CSS文件。</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>reset.css</td><td>重置样式，重置元素默认样式</td></tr><tr><td>global.css</td><td>全局样式，全站公用，定义页面基础样式</td></tr><tr><td>themes.css</td><td>主题样式，用于实现换肤功能</td></tr><tr><td>module.css</td><td>模块样式，用于模块的样式</td></tr><tr><td>master.css</td><td>母版样式，用于母版页的样式</td></tr><tr><td>columes.css</td><td>专栏样式，用于专栏的样式</td></tr><tr><td>forms.css</td><td>表单样式，用于表单的样式</td></tr><tr><td>mend.css</td><td>补丁样式，用于维护、修改的样式</td></tr><tr><td>print.css</td><td>打印样式，用于打印的样式</td></tr></tbody></table><h3 id=\"id和class命名\"><a href=\"#id和class命名\" class=\"headerlink\" title=\"id和class命名\"></a>id和class命名</h3><p>建议使用中划线命名，例如<code>column-title</code>。</p><p>为了避免class命名的重复，一般取父元素的class名作为前缀，例如<code>column-title</code>。</p><table><thead><tr><th>网页主体部分</th><th>命名</th></tr></thead><tbody><tr><td>最外层</td><td>wrapper(一般用于包裹整个页面)</td></tr><tr><td>头部</td><td>header</td></tr><tr><td>内容</td><td>content</td></tr><tr><td>侧栏</td><td>sidebar</td></tr><tr><td>栏目</td><td>column</td></tr><tr><td>热点</td><td>hot</td></tr><tr><td>新闻</td><td>news</td></tr><tr><td>下载</td><td>download</td></tr><tr><td>标志</td><td>logo</td></tr><tr><td>导航条</td><td>nav</td></tr><tr><td>主体</td><td>main</td></tr><tr><td>左侧</td><td>main-left</td></tr><tr><td>右侧</td><td>main-right</td></tr><tr><td>底部</td><td>footer</td></tr><tr><td>友情链接</td><td>friendlink</td></tr><tr><td>加入我们</td><td>joinus</td></tr><tr><td>版权</td><td>copyright</td></tr><tr><td>服务</td><td>service</td></tr><tr><td>登录</td><td>login</td></tr><tr><td>注册</td><td>register</td></tr></tbody></table><table><thead><tr><th>导航部分</th><th>命名</th></tr></thead><tbody><tr><td>主导航</td><td>main-nav</td></tr><tr><td>子导航</td><td>sub-nav</td></tr><tr><td>边导航</td><td>side-nav</td></tr><tr><td>左导航</td><td>leftside-nav</td></tr><tr><td>右导航</td><td>rightside-nav</td></tr><tr><td>顶导航</td><td>top-nav</td></tr></tbody></table><table><thead><tr><th>菜单部分</th><th>命名</th></tr></thead><tbody><tr><td>菜单</td><td>menu</td></tr><tr><td>子菜单</td><td>submenu</td></tr></tbody></table><table><thead><tr><th>其他</th><th>命名</th></tr></thead><tbody><tr><td>标题</td><td>title</td></tr><tr><td>摘要</td><td>summary</td></tr><tr><td>登录条</td><td>loginbar</td></tr><tr><td>搜索</td><td>search</td></tr><tr><td>标签页</td><td>tab</td></tr><tr><td>广告</td><td>banner</td></tr><tr><td>小技巧</td><td>tips</td></tr><tr><td>图标</td><td>icon</td></tr><tr><td>法律声明</td><td>siteinfolegal</td></tr><tr><td>网站地图</td><td>sitemap</td></tr><tr><td>工具条</td><td>tool、toolbar</td></tr><tr><td>首页</td><td>homepage</td></tr><tr><td>子页</td><td>subpage</td></tr><tr><td>合作伙伴</td><td>partner</td></tr><tr><td>帮助</td><td>help</td></tr><tr><td>指南</td><td>guide</td></tr><tr><td>滚动</td><td>scroll</td></tr><tr><td>提示信息</td><td>msg</td></tr><tr><td>投票</td><td>vote</td></tr><tr><td>相关文章</td><td>related</td></tr><tr><td>文章列表</td><td>list</td></tr></tbody></table><h2 id=\"书写规范\"><a href=\"#书写规范\" class=\"headerlink\" title=\"书写规范\"></a>书写规范</h2><p>对于功能代码，应该集中放在一起，</p><p>对于其他代码，应按照如下顺序：</p><ol><li>影响文档流属性（布局属性）——display，position，float，clear等</li><li>自身盒模型属性——width，height，padding，margin，border，overflow等</li><li>文本性属性——font，line-height，text-align，text-indent，vertical-align等</li><li>装饰性属性——color，background-color，opacity等</li><li>其他属性——cursor，content，list-style，quotes等</li></ol><p>例如：</p><pre><code class=\"css\">#main {\n  /* 影响文档流属性 */\n  display: inline-block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* 盒子模型属性 */\n  width: 100px;\n  height: 100px;\n  border: 2px solid gray;\n  /* 文本性属性 */\n  font-size: 15px;\n  font-weight: bold;\n  text-indent: 2em;\n  /* 装饰性属性 */\n  color: white;\n  background-color: red;\n  /* 其他属性 */\n  cursor: pointer;\n}\n</code></pre><h2 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a>注释规范</h2><p>由于压缩工具会删除所有的注释，因此有时为了保留版权声明等注释信息，需要在注释内容前加一个叹号，如<code>/*! 注释内容 */</code>，这样压缩工具就不会删除这条注释信息。</p><h3 id=\"顶部注释\"><a href=\"#顶部注释\" class=\"headerlink\" title=\"顶部注释\"></a>顶部注释</h3><pre><code class=\"css\">/*\n *@description:说明\n *@author:作者\n *@update:更新时间，如2018-09-10 17:42\n */\n</code></pre><h3 id=\"模块注释\"><a href=\"#模块注释\" class=\"headerlink\" title=\"模块注释\"></a>模块注释</h3><pre><code class=\"css\">/* 导航部分，开始 */\n......\n/* 导航部分，结束 */\n</code></pre><h3 id=\"简单注释\"><a href=\"#简单注释\" class=\"headerlink\" title=\"简单注释\"></a>简单注释</h3><pre><code class=\"css\">/* 单行注释 */\n</code></pre><p>或者</p><pre><code class=\"css\">/*多行注释\n *多行注释\n *多行注释\n */\n</code></pre><h2 id=\"CSS-reset\"><a href=\"#CSS-reset\" class=\"headerlink\" title=\"CSS reset\"></a>CSS reset</h2><p>重置样式，去除元素在浏览器中的默认样式。</p><p>是否使用CSS reset根据实际开发需求而定。</p><h1 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h1><p><img src=\"https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=5ad0ba6a0c7b02080c9c37e752e9deeb/0824ab18972bd407012c41327d899e510eb30911.jpg\" alt=\"标准盒子模型\"></p><p><img src=\"https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=6cdf3ae9fbfaaf5184b689b9bc64b8d6/1b4c510fd9f9d72ac29d82d2d22a2834359bbb00.jpg\" alt=\"IE盒子模型\"></p><h2 id=\"外边距叠加\"><a href=\"#外边距叠加\" class=\"headerlink\" title=\"外边距叠加\"></a>外边距叠加</h2><p>又称为“margin叠加”，指当两个外边距相遇时会“合二为一”。叠加后的外边距为两个外边距的最大值。</p><p><u>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</u></p><p>以下图片均来自<a href=\"http://www.w3school.com.cn/css/css_margin_collapsing.asp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">w3school</a></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif\" alt=\"同级元素\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif\" alt=\"父子元素\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif\" alt=\"空元素1\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif\" alt=\"空元素2\"></p><p><img src=\"http://www.w3school.com.cn/i/ct_css_margin_collapsing.gif\" alt=\"外边距合并的意义\"></p><h2 id=\"负margin\"><a href=\"#负margin\" class=\"headerlink\" title=\"负margin\"></a>负margin</h2><ul><li>当margin-top或者margin-left为负数时，<strong>当前元素</strong>会被拉向指定方向。</li><li>当margin-bottom或者margin-right为负数时，<strong>后续元素</strong>会被拉向指定方向。</li></ul><p><a href=\"https://www.jianshu.com/p/549aaa5fabaa\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里有一篇文章</a>讲得不错，可以参考一下。</p><p><a href=\"https://www.cnblogs.com/star91/p/5773436.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">圣杯布局、双飞翼布局</a>就是利用这个实现的。</p><h2 id=\"overflow\"><a href=\"#overflow\" class=\"headerlink\" title=\"overflow\"></a>overflow</h2><p>当浮动引起父元素高度塌陷时，可以为父元素加上<code>overflow: hidden</code>来清除浮动。</p><h1 id=\"display属性\"><a href=\"#display属性\" class=\"headerlink\" title=\"display属性\"></a>display属性</h1><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>inline</td><td>行内元素</td></tr><tr><td>block</td><td>块元素</td></tr><tr><td>inline-block</td><td>行内块元素</td></tr><tr><td>table</td><td>以表格形式显示，类似于table元素</td></tr><tr><td>table-row</td><td>以表格行形式显示，类似于tr元素</td></tr><tr><td>table-cell</td><td>以表格单元格形式显示，类似于td元素</td></tr><tr><td>none</td><td>隐藏元素</td></tr></tbody></table><h2 id=\"块元素\"><a href=\"#块元素\" class=\"headerlink\" title=\"块元素\"></a>块元素</h2><ul><li>独占一行</li><li>内部可以容纳其他块元素或行元素</li><li>可以定义width和height</li><li>可以定义四个方向的margin</li></ul><h2 id=\"inline元素\"><a href=\"#inline元素\" class=\"headerlink\" title=\"inline元素\"></a>inline元素</h2><ul><li>可以与其他行内元素位于同一行</li><li>可以容纳行内元素，但不能容纳块元素</li><li>无法定义width和height</li><li>可以定义margin-left和margin-right，不能定义margin-top和margin-bottom</li></ul><h2 id=\"inline-block元素\"><a href=\"#inline-block元素\" class=\"headerlink\" title=\"inline-block元素\"></a>inline-block元素</h2><ul><li>可以定义width和height</li><li>可以与其他行内元素位于同一行</li></ul><p>常见的inline-block元素：img元素和input元素</p><h2 id=\"display-table-cell\"><a href=\"#display-table-cell\" class=\"headerlink\" title=\"display: table-cell\"></a>display: table-cell</h2><p>可以用于实现：</p><ul><li><a href=\"https://www.jianshu.com/p/a7ee7dd60166\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">图片垂直居中</a>于元素</li><li>等高布局</li><li>自动平均划分元素，并在同一行显示</li></ul><h2 id=\"去除inline-block元素间距\"><a href=\"#去除inline-block元素间距\" class=\"headerlink\" title=\"去除inline-block元素间距\"></a>去除inline-block元素间距</h2><p>在父元素中添加<code>font-size: 0</code></p><h1 id=\"文本效果\"><a href=\"#文本效果\" class=\"headerlink\" title=\"文本效果\"></a>文本效果</h1><table><thead><tr><th>文本属性</th><th>说明</th></tr></thead><tbody><tr><td>text-decoration</td><td>下划线、删除线、顶划线</td></tr><tr><td>text-transform</td><td>文本大小写</td></tr><tr><td>font-variant</td><td>将英文文本转换为小型大写字母</td></tr><tr><td>text-indent</td><td>段落首行缩进</td></tr><tr><td>text-align</td><td>文本水平对齐</td></tr><tr><td>vertical-align</td><td>文本垂直对齐</td></tr><tr><td>line-height</td><td>行高</td></tr><tr><td>letter-spacing</td><td>字距</td></tr><tr><td>word-spacing</td><td>词距</td></tr></tbody></table><h2 id=\"text-indent\"><a href=\"#text-indent\" class=\"headerlink\" title=\"text-indent\"></a>text-indent</h2><p>可以使用 <code>text-indent: -9999px;</code>来隐藏文本。</p><h2 id=\"text-align\"><a href=\"#text-align\" class=\"headerlink\" title=\"text-align\"></a>text-align</h2><p>主要使用的值为left、right、center，对文字、inline元素、inline-block元素都起作用，对块元素不起作用。</p><p>利用<code>margin: 0 auto</code>实现块元素的水平居中。</p><p><code>text-align: center</code>在父元素中定义，<code>margin: 0 auto</code>在当前元素中定义。</p><h2 id=\"line-height\"><a href=\"#line-height\" class=\"headerlink\" title=\"line-height\"></a>line-height</h2><p>关于顶线、中线、基线、底线可以自行查阅。</p><p>行高（line-height）指的是两行基线之间的距离。</p><ul><li>将height和line-height设为相同值可以实现文字垂直居中。</li><li>当取值为%或者em时，是相对与父元素的font-size计算的。</li><li>当取值为无单位数字时，是相对于当前元素的font-size计算的。</li></ul><h2 id=\"vertical-align\"><a href=\"#vertical-align\" class=\"headerlink\" title=\"vertical-align\"></a>vertical-align</h2><p>vertical-align对inline、inline-block、table-cell元素有效，对块元素无效。</p><p>用于定义<u>周围的文字、inline元素、inline-block元素</u>相对于该元素<strong>基线</strong>的垂直对齐方式。</p><p>可以取负长度值和百分比值。</p><h3 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h3><ol><li><p>负值 ： <code>vertical-align: -2px</code>指的是该元素相对于基线向下偏移2px；</p></li><li><p>百分比 ： 相对于当前元素继承的line-height值计算的，也是该元素相对于基线偏移的值；</p></li><li><p><a href=\"http://www.runoob.com/cssref/pr-pos-vertical-align.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">关键字</a> （前四个比较常用）：</p></li></ol><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><strong>top</strong></td><td>把元素的顶端与行中最高元素的顶端对齐</td></tr><tr><td><strong>middle</strong></td><td>把此元素放置在父元素的中部。</td></tr><tr><td><strong>baseline</strong></td><td>默认。元素放置在父元素的基线上。</td></tr><tr><td><strong>bottom</strong></td><td>把元素的底端与行中最低的元素的顶端对齐。</td></tr><tr><td>text-top</td><td>把元素的顶端与父元素字体的顶端对齐</td></tr><tr><td>text-bottom</td><td>把元素的底端与父元素字体的底端对齐。</td></tr><tr><td>sub</td><td>垂直对齐文本的下标。</td></tr><tr><td>super</td><td>垂直对齐文本的上标</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 vertical-align 属性的值。</td></tr></tbody></table><h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ul><li>为img添加<code>vertical-align: middle</code>可以实现图片与周围的文字居中对齐</li><li>要使块元素（如div）也可以使用此属性，可以为其先定义<code>display: table-cell</code></li></ul><h1 id=\"表单效果\"><a href=\"#表单效果\" class=\"headerlink\" title=\"表单效果\"></a>表单效果</h1><h2 id=\"radio与checkbox\"><a href=\"#radio与checkbox\" class=\"headerlink\" title=\"radio与checkbox\"></a>radio与checkbox</h2><p>默认情况下由于是基线对齐因此视觉上会感觉单选框或复选框旁边的文字比它们低，这个时候可以使用vertical-align来让他们垂直居中对齐。</p><p>可以使用关键字，也可以使用数值。</p><h2 id=\"textarea\"><a href=\"#textarea\" class=\"headerlink\" title=\"textarea\"></a>textarea</h2><ul><li>可以使用max-width和max-height来限制拖拽大小</li><li>可以使用<code>resize: none</code>来禁止拖拽</li></ul><p>要使textarea在不同浏览器中具有相同的外观，可以：</p><ul><li>使用CSS的width和height定义大小</li><li>使用<code>overflow: auto</code>来定义textarea滚动条自适应</li></ul><h2 id=\"表单对齐\"><a href=\"#表单对齐\" class=\"headerlink\" title=\"表单对齐\"></a>表单对齐</h2><p>书上给了<strong>注册</strong>的例子：</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536639853274&amp;di=16c88d63b9118620ba546c2f6237b78c&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.orsoon.com%2Fuploads%2Fallimg%2F24631428484696.png\" alt=\"图片来源于网络\"></p><p>实现方法：</p><ol><li>每一行表单分为左栏加若干右栏<ol><li>所有行的左栏长度相等</li><li>所有行的右栏所有盒子长度之和相等</li><li>左栏一般为一个label，右栏为若干文本框</li></ol></li><li>所有左栏和右栏盒子都设为左浮动</li><li>左栏添加属性<code>text-align: right</code>使得文字右对齐</li><li>每一行左栏盒子长度加上所有右栏盒子长度之和等于行宽</li><li>每一行由一个p包裹住，并为p添加<code>overflow: hidden</code>来清除浮动</li></ol><p>然后我又去看了一下各网站的<strong>登录</strong>界面，基本上是一个icon+一个input的模式：</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536641005969&amp;di=02e6a2469281303e926eb8878cf64db9&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fexp%2Fw%3D480%2Fsign%3D00237679845494ee87220e111df7e0e1%2Fa686c9177f3e67093ac0b23933c79f3df9dc5530.jpg\" alt=\"图片来源于网络\"></p><p>实现方法：</p><ul><li>icon使用<code>position: absolute</code>脱离文档流并盖在input上</li><li>input将padding-left调到合适大小使得输入框不被icon盖住</li></ul><h1 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h1><h2 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a>文档流</h2><p>简单来说就是元素在页面中出现的先后顺序。</p><ul><li>正常文档流 ： “normal flow”，指默认情况下页面元素的布局情况。</li><li>脱离文档流：脱离正常文档流。要改变正常文档流，使用浮动和定位方法。</li></ul><h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>可以使元素移到左边或者右边，并且允许后边的文字和元素环绕着它。</p><p>浮动后使用margin来定义和其他元素之间的间距。</p><p>绝对定位的元素忽略float属性。</p><p>float的取值表如下，默认为<strong>none</strong>：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>元素向左浮动。</td></tr><tr><td>right</td><td>元素向右浮动。</td></tr><tr><td>none</td><td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 float 属性的值。</td></tr></tbody></table><ul><li>当一个元素添加float属性为left或者right时，它将变为block类型。</li><li>浮动元素脱离正常文档流，若其height大于父元素的height或者父元素的height未定义，会造成父元素高度塌陷。可以为父元素添加<code>overflow: hidden</code>来解决。</li><li><p>若父元素和子元素都是浮动元素，则父元素会自适应地包含子元素。</p></li><li><p>若兄弟元素不是浮动元素，由于浮动元素脱离文档流，可能会出现覆盖等情况。</p></li></ul><h2 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h2><ul><li><code>clear: both</code>，用于浮动元素后边的元素，表示两边不允许出现浮动元素。</li><li><code>overflow: hidden</code>，用于浮动元素的父元素，但会隐藏超出父元素的内容部分。</li><li>实际开发中，更经常使用<code>:after</code>伪元素结合<code>clear: both</code>来实现。</li><li>为了兼容ie，为父元素添加<code>zoom: 1</code>来消除浮动。</li></ul><h1 id=\"定位布局\"><a href=\"#定位布局\" class=\"headerlink\" title=\"定位布局\"></a>定位布局</h1><h2 id=\"属性值\"><a href=\"#属性值\" class=\"headerlink\" title=\"属性值\"></a><a href=\"http://www.runoob.com/cssref/pr-class-position.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">属性值</a></h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-static\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">static</a></td><td><u>默认值</u>。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-absolute\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">absolute</a></td><td>生成绝对定位的元素，相对于 <u>static 定位以外的第一个父元素</u>进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-fixed\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">fixed</a></td><td>生成固定定位的元素，相对于<u>浏览器窗口</u>进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-relative\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">relative</a></td><td>生成相对定位的元素，相对于<u>其正常位置</u>进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td><a href=\"http://www.runoob.com/css/css-positioning.html#position-sticky\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">sticky</a></td><td>粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。<strong>注意:</strong> Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值。</td></tr><tr><td>initial</td><td>设置该属性为默认值，详情查看 <a href=\"http://www.runoob.com/cssref/css-inherit.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS initial 关键字</a>。</td></tr></tbody></table><ul><li>absolute会将元素转换为块元素。</li><li>若想要子元素相对于父元素定位，一般给父元素添加<code>position: relative</code>，给子元素定义<code>position: absolute</code>来实现。祖先元素同理。</li></ul><h2 id=\"z-index属性\"><a href=\"#z-index属性\" class=\"headerlink\" title=\"z-index属性\"></a>z-index属性</h2><p>默认情况下设置z-index无效，只有当元素定义position为relative、absolute、fixed时才会激活，z-index值越大，其堆叠顺序越高，越靠上（z方向上的靠上）。</p><h1 id=\"CSS图形\"><a href=\"#CSS图形\" class=\"headerlink\" title=\"CSS图形\"></a>CSS图形</h1><p>由于图片大小比较大，数据传输量大且一张图片会引发一次HTTP请求，因此对徐图形效果，一般更倾向于用CSS实现。</p><p>这里有一篇<a href=\"https://www.w3cplus.com/css/css-simple-shapes-cheat-sheet\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS制作图形速查表</a>总结得比较全面，可以参考。</p><p>另外对于带有边框的图形，一般是用大小不同的两个相同图形实现，小的覆盖在大的上边。</p><h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1><h2 id=\"属性缩写\"><a href=\"#属性缩写\" class=\"headerlink\" title=\"属性缩写\"></a>属性缩写</h2><ul><li><p>border：<code>border: 1px solid red</code></p><ul><li>若不想要底边框，可以加上<code>border-bottom: 0</code></li><li>若只想要底边框，可以<code>border-bottom: 1px solid red</code></li></ul></li><li><p>padding：</p><ul><li><code>padding: 10px</code>指上右下左均为10px</li><li><code>padding: 10px 20px</code>指上下为10px，左右为20px</li><li><code>padding: 10px 20px 30px 40px</code>的顺序为上右下左，从上开始按照顺时针顺序</li></ul></li><li><p>margin： 类似于padding</p></li><li>background： <code>background: url(&#39;xxx.jpg&#39;) no-repeat 80px 40px</code>,最后为background-position</li><li><p>font： <code>font: &quot;微软雅黑&quot; 12px/1.5em bold</code></p><ul><li>顺序为<code>font-family</code>、<code>font-size</code>、<code>line-height</code>、<code>font-weight</code></li><li>简写形式必须指定<code>font-family</code>和<code>font-size</code>的值，其他属性没有指定则为默认值</li><li>简写形式中<code>font-size</code>和<code>line-height</code>之间需要加入一个斜杠<code>/</code></li></ul></li><li><p>color： 十六进制的颜色值若每两位值相同，可以缩写一半，比如<code>color: #112233</code>可以缩写为<code>color: #123</code></p></li></ul><h2 id=\"语法压缩\"><a href=\"#语法压缩\" class=\"headerlink\" title=\"语法压缩\"></a>语法压缩</h2><ul><li>当一个CSS规则只有一两个属性的时候，使用横向书写</li><li>可以省略最后一个属性的分号</li><li>background-image、cursor等属性url()中的路径不用加引号</li><li>如果某一个属性值为0，则不需要加单位</li><li>如果某一个属性值是以0为开头的小数，可以吧0省略</li><li>使用群组选择器合并相同样式</li><li>若同一个父元素的多个子元素都定义了相同的可继承属性，把这些属性定义在父元素中来精简代码</li></ul><h2 id=\"CSS压缩\"><a href=\"#CSS压缩\" class=\"headerlink\" title=\"CSS压缩\"></a>CSS压缩</h2><p>书中推荐了两个在线的压缩工具：<a href=\"https://csscompressor.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS Compressor</a> 和 <a href=\"http://tool.oschina.net/jscompress\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">YUI Compressor</a></p><p>以YUI Compressor为例，它会对CSS文件执行如下操作：</p><ul><li>删除所有注释</li><li>删除无用空白符</li><li>删除结尾分号</li><li>删除属性值为0的单位</li><li>删除以0开头的小数前的0</li><li>合并相似属性（属性缩写）</li><li>将RGB颜色转换为十六进制颜色</li></ul><h2 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h2><p>书中推荐的图片压缩工具：</p><p>在线的<a href=\"https://www.jpegmini.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">JPEGmini</a>和<a href=\"https://tinypng.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TinyPNG</a>以及本地的<a href=\"https://imageoptim.com/versions.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ImageOptim</a></p><h2 id=\"高性能的选择器\"><a href=\"#高性能的选择器\" class=\"headerlink\" title=\"高性能的选择器\"></a>高性能的选择器</h2><p>浏览器对选择器规则是从右到左进行解析的。</p><p>CSS选择的匹配效率：</p><ol><li>id选择器</li><li>class选择器</li><li>元素选择器</li><li>相邻选择器</li><li>子选择器</li><li>后代选择器</li><li>通配符选择器</li><li>属性选择器</li><li>伪类选择器</li></ol><p>因此在使用选择器时应注意：</p><ul><li>尽量不要使用通配符</li><li>不要在id选择器和class选择器前添加元素名</li><li>选择器最好不要超过三层，靠右的选择条件应尽可能精确</li><li>避免使用后代选择器，尽量少使用子选择器</li></ul><h1 id=\"CSS技巧\"><a href=\"#CSS技巧\" class=\"headerlink\" title=\"CSS技巧\"></a>CSS技巧</h1><h2 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h2><ul><li>文字、inline元素和inline-*元素： <code>text-align: center</code></li><li>块元素： <code>margin: 0 auto</code></li></ul><h2 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h2><ul><li>行内块元素使用<code>vertical-align: middle</code></li><li>块元素将display改为table-cell然后使用vertical-align</li><li>多行文字使用一个标签将文字包起来并设为table-cell，然后再设置vertical-align</li><li>单行文字设置line-height和height属性值相同来实现</li></ul><h2 id=\"CSS-Sprite\"><a href=\"#CSS-Sprite\" class=\"headerlink\" title=\"CSS Sprite\"></a>CSS Sprite</h2><p>又称为CSS精灵或CSS<strong>雪碧图</strong>，它将零散的小背景图合并成一张大背景图，然后再利用background-position属性进行定位从而现实小背景图。</p><p>使用CSS Sprite技术时，需要注意：</p><ul><li>在开发后期而不是开发前期使用此技术</li><li>有条理地组织图片顺序，应将小背景图按照类别、风格、大小等分门别类地放好</li><li>控制雪碧图的大小，当图片大小小于200KB时传输时间是差不多的，因此雪碧图应控制在200KB以内</li></ul><p>书中推荐了两个CSS Sprite工具：<a href=\"http://css.spritegen.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CSS Sprite Generator</a> 和 <a href=\"http://www.spritecow.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Sprite Cow</a></p><h2 id=\"Icon-Font图标\"><a href=\"#Icon-Font图标\" class=\"headerlink\" title=\"Icon Font图标\"></a>Icon Font图标</h2><p>使用字体文件实现小图标效果，从而减少图片的使用。</p><p>推荐的Icon Font网站：<a href=\"http://www.iconfont.cn/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.iconfont.cn/</a></p><p>网站上就有<a href=\"http://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d0091c141&amp;helptype=code\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">使用教程</a></p><h1 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h1><h2 id=\"包含块\"><a href=\"#包含块\" class=\"headerlink\" title=\"包含块\"></a>包含块</h2><p>containing block，决定一个元素大小和定位的元素。</p><p>时视觉格式化模型中的一个重要概念，与CSS盒子模型类似。其作用主要是为其内部的后代元素提供一个参考。</p><ul><li>根元素（HTML元素）没有父元素，它存在的包含块被称为初始包含块</li><li>定位为fixed的元素的包含块为浏览器窗口</li><li>定位为是static和relative的元素的包含块是它最近的块级（block、inline-block或table-cell）祖先元素创建的</li><li>定位为absolute的元素的包含块是它最近的定位不是static的祖先元素，可以是块元素也可以是行内元素</li></ul><h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a>层叠上下文</h2><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1537245373&amp;di=c7455fbd6881b1a07ae8ac81a79f474e&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.w3cplus.com%2Fsites%2Fdefault%2Ffiles%2Fblogs%2F2018%2F1808%2Fz-index-15.png\" alt=\"层叠级别图\"></p><p>一个元素在z轴上的堆叠顺序：</p><ul><li>层叠级别越大越靠上</li><li>同等层叠级别，后边的堆叠在前边的上边（后来者居上）</li><li>不同的层叠上下文比较的是父级层叠上下文，与自身无关</li></ul><h2 id=\"BFC和IFC\"><a href=\"#BFC和IFC\" class=\"headerlink\" title=\"BFC和IFC\"></a>BFC和IFC</h2><p>BFC： block formatting context， 块级格式上下文</p><p>IFC： inline formatting context， 行级格式上下文</p><p>若一个元素具备以下任何一个条件，则会创造创造一个新的BFC：</p><ul><li>根元素</li><li>float属性不是none</li><li>position属性是absolute或fixed</li><li>overflow属性值不是visible</li><li>display属性为inline-block、table-caption、table-cell</li></ul><p>W3C描述BFC的特点为：</p><ul><li>在一个BFC中，盒子从顶端开始垂直一个接着一个地排列。两个相邻盒子之间的垂直间距有margin决定。<strong>同一个BFC中</strong>，两个相邻块盒子之间<strong>垂直方向上的外边距</strong>会叠加。</li><li>在一个BFC中，每一个盒子的左外边界（margin-left）会紧贴着容器的border-left，右边同理，即使存在浮动元素也是如此。</li></ul><p>可以得到结论：</p><ol><li>在一个BFC内部，盒子会在垂直方向上一个接着一个地排列</li><li>在一个BFC内部，相邻的margin-top、margin-bottom会叠加</li><li>在一个BFC内部，每一个盒子的左外边界（margin-left）会紧贴着容器（包含盒子）的border-left，即使存在浮动元素也是如此</li><li>在一个BFC内部，如果存在内部元素是一个新的BFC，并且存在内部元素是浮动元素，则这个新的BFC的区域不会与浮动元素的区域重叠</li><li>BFC就是页面上一个隔离的盒子，该盒子内部的子元素不会影响到外边的元素</li><li>计算一个BFC的高度时，其内部浮动元素的高度也会计算其中</li></ol><p>BFC的用途：</p><ul><li>创建BFC来避免垂直外边距叠加（例如使用div将一个盒子包起来并给这个div添加overflow属性）</li><li>创建BFC来清除浮动（为父元素添加<code>overflow: hidden</code>，利用结论第六条）</li><li>创建BFC来实现<a href=\"https://blog.csdn.net/michael8512/article/details/76473835\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">自适应布局</a></li></ul><hr><p>好了到这里，这本书就看完了，一些细节的东西了解到了很多，下面开始看html5+css3。</p><p>- 2018 - 09 - 11 -</p>"},{"title":"HTTP学习记录","toc":true,"date":"2018-09-21T12:40:48.000Z","_content":"\nHTTP协议，HyperText Transfer Protocol，超文本传输协议，是因特网上应用最为 广泛的一种网络传输协议。\n\n<!-- more -->\n\n## 版本\n\n### HTTP/0.9\n\n已过时，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n\n因为这个版本不支持POST方法，因此客户端无法向服务器传递太多信息。\n\n### HTTP/1.0\n\n第一个在通讯中指定版本号的版本，至今仍被广泛采用，特别是在代理服务器中。\n\n### HTTP/1.1\n\n当前版本，默认采用持久连接，并能很好地配合代理服务器工作。\n\n支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n\n### SPDY\n\n[SPDY](https://zh.wikipedia.org/wiki/SPDY) (发音为\"speedy\") ，是一个由 [Google](https://zh.wikipedia.org/wiki/Google) 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。\n\n### HTTP/2.0\n\n简称为**h2**（基于TLS/1.2或以上版本的加密连接）或**h2c**（非加密连接）。\n\n### 协议之间的比较\n\n**HTTP/1.1相较于HTTP/1.0的主要区别**\n\n- 缓存处理\n- 带宽优化及网络连接的使用\n- 错误通知的管理\n- 消息在网络中的发送\n- 互联网地址的维护\n- 安全性及完整性\n\n**HTTP/2与HTTP/1.1比较**\n\nHTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以藉由新特性得到更好的速度。\n\nHTTP/2 保留了 HTTP/1.1 的大部分语义，例如[请求方法](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)、[状态码](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%A0%81)乃至[URI](https://zh.wikipedia.org/wiki/URI)和绝大多数[HTTP头部](https://zh.wikipedia.org/w/index.php?title=HTTP%E5%A4%B4%E9%83%A8&action=edit&redlink=1)字段一致。\n\n但是 HTTP/2 采用了新的方法来编码、传输客户端/服务器间的数据。\n\n**HTTP/1.1与SPDY的区别**\n\n其与HTTP/1.1相比，SPDY主要的改变有：\n\n- 实现无需先入先出的[多路复用](https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)\n- 为简化客户端和服务器开发的消息—帧机制\n- 强制性压缩（包括HTTP头部）\n- 优先级排序\n- 双向通讯\n\n**HTTP/2与SPDY的比较**\n\nHTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于[霍夫曼编码](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81)，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以[CRIME](https://zh.wikipedia.org/wiki/CRIME)为代表。此外，HTTP/2禁用了诸多加密套件，以保证基于TLS的连接的前向安全。\n\n\n\n## 简介\n\n基于TCP/IP通信协议传递数据。\n\n### 工作原理\n\nHTTP协议工作在客户端-服务端架构（C/S）上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\n\nWeb服务器有Apache服务器、IIS（Internet Informatica Services）服务器等。\n\nWeb服务器根据接收到的请求，向客户端发送响应信息。\n\nHTTP默认端口号为80，我们也可以改为8080或者其他端口。\n\nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）定位互联网上的资源。\n\n### 注意事项\n\nHTTP是：\n\n- **无连接的**：每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后就断开连接。采用这种方式可以节省传输时间。\n- **媒体独立的**：只要客户端和服务端都知道如何处理数据内容，任何类型都可以通过HTTP发送。客户端和服务器指定合适的MIME-tyoe内容类型。\n- **无状态的**：协议对于事务处理没有记忆能力。HTTP协议自身不对请求和响应之间的通信状态进行保存。\n  - <u>这是为了更快地处理大量事务，确保协议的可伸缩性而特意设计的</u>。但这也导致业务处理变得棘手的情况增多，比如要保持登录状态，因为HTTP无状态，因此需要额外保存用户状态。\n  - HTTP/1.1虽然也是无状态协议，但是为了实现比如保持状态的功能，引入了Cookie技术，这让管理状态变得简单。\n  - Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。\n\nHTTP协议通信流程：\n\nWeb浏览器<=HTTP协议=>HTTP服务器<=>CGI（通用网关接口）应用程序<=>数据库\n\n其中CGI：\n\n是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。\n\n![HTTP协议通信流程](https://7n.w3cschool.cn/attachments/image/20160225/1456372014816657.gif)\n\n## HTTP报文\n\n用于HTTP协议交互的信息称为HTTP报文。请求端(客户端)的HTTP报文称为请求报文，响应端（服务器端）的叫响应报文．\n\nHTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。\n\nHTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）来划分。\n\n通常并不一定要有报文主体。\n\n**报文首部**\n\n服务器端或客户端需处理的请求或响应的内容及内容\n\n**请求报文**的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段、其他组成\n\n**响应报文**的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段、其他组成\n\n**CR+LF**\n\nCR，Carriage Return，回车符，16进制0x0d\n\nLF，Line Feed，换行符，16进制0x0a\n\n**报文主体**\n\n应被发送的数据\n\n![图片来源于网络](http://ocs628urt.bkt.clouddn.com/http%E6%8A%A5%E6%96%87.png)\n\n## 常用请求首部信息\n\n（参考自红宝书）\n\n虽然不同浏览器实际发送的头部信息会有所不同，但下边这些基本上是所有浏览器都会发送的：\n\n- Accept：浏览器能够处理的内容类型\n- Accept-Charset：浏览器能够显示的字符集\n- Accept-Encoding：浏览器能够处理的压缩编码\n- Accept-Language：浏览器当前设置的语言\n- Connection：浏览器与服务器之间连接的类型\n- Cookie：当前页面设置的任何Cookie\n- Host：发出请求的页面所在的域\n- Referer：发出请求的页面的URI。注意HTTP规范将这个字段拼写错了（正确拼法为Referrer），但为了保证与规范一致，也只能将错就错了。\n- User-Agent：浏览器的代理用户字段。\n\n注意，这些字段名是一个字母都不应有区别的，一旦有区别，那它就不是首部字段。\n\n## 请求方法\n\n根据HTTP标准，HTTP请求可以使用多种请求方法。\n\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n`GET`\n\nGET方法请求指定的页面信息. 使用GET的请求应该只被用于获取数据.\n\n`HEAD`\n\nHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.\n\n`POST`\n\nPOST方法用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n\n`PUT`\n\nPUT方法从客户端向服务器传送的数据取代指定的文档的内容。\n\n**注意**：因为HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。\n\n`DELETE`\n\nDELETE方法删除指定的资源。\n\n**注意**：和PUT一样，因为HTTP/1.1的DELETE方法自身不带验证机制，存在安全性问题，因此一般的web网站不使用该方法。\n\n`CONNECT`\n\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n`OPTIONS`\n\n询问支持的方法，查询请求URI指定的资源支持的方法。\n\n`TRACE`\n\n回显服务器收到的请求，查询发送出去的请求是怎样被加工/修改的，主要用于测试或诊断（因为从代理服务器路由中转时请求可能被篡改）。不常用。\n\n`PATCH`\n\nPATCH方法用于对资源进行部分修改。（PUT为对资源进行整体覆盖）\n\n## HTTP状态码\n\n- 1XX信息，服务器收到请求，需要请求者继续执行操作\n- 2XX成功，操作被成功接收并处理\n- 3XX重定向，需要进一步的操作以完成请求\n- 4XX客户端错误，请求包含语法错误或无法完成请求\n- 5XX服务器错误，服务器在处理请求的过程中发生了错误\n\n常见状态码：\n\n- **200 OK**， 一切正常，对GET和POST请求的应答文档跟在后面\n- 301 Moved Permanently，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。\n- 302 Found，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。\n- 304 Not Modified，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n- 307 Temporary Redirect，和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清楚地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。\n- **400 Bad Request**，请求出现语法错误。\n- 401 Unauthorized，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求\n- **403 Forbidden**， 资源不可用。\n- **404 Not Found**，无法找到指定位置的资源\n- 410 Gone， 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用\n- **500 Internal Server Error**，服务器遇到了意料不到的情况，不能完成客户的请求\n- 501 Not Implemented，服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求\n- **503 Service Unavailable**  ，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头\n\n## Content-Type\n\n`Content-Type: text/html; charset=UTF-8`\n\n实体首部字段，表示实体主体的媒体类型。\n\n字段值采用type/subtype形式赋值。\n\n对照表链接：https://www.w3cschool.cn/http/ahkmgfmz.html\n\n\n\n\n\n---\n\n[W3C的教程](https://www.w3cschool.cn/http/)的学习笔记，过两天再啃一下MDN和《图解HTTP》，还要再复习一下计网，很多都忘了...\n\nemmmW3C有的是错的...使用网络教程需谨慎....\n\n关于HTTP/2.0以及SPDY等均来自维基百科。\n\n这里只是重新回忆一下什么是HTTP，还是要看文档！啃《图解HTTP》！复习计网！","source":"_posts/HTTP学习记录.md","raw":"---\ntitle: HTTP学习记录\ntoc: true\ndate: 2018-09-21 20:40:48\ncategories:\n- Web\ntags:\n- HTTP\n---\n\nHTTP协议，HyperText Transfer Protocol，超文本传输协议，是因特网上应用最为 广泛的一种网络传输协议。\n\n<!-- more -->\n\n## 版本\n\n### HTTP/0.9\n\n已过时，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n\n因为这个版本不支持POST方法，因此客户端无法向服务器传递太多信息。\n\n### HTTP/1.0\n\n第一个在通讯中指定版本号的版本，至今仍被广泛采用，特别是在代理服务器中。\n\n### HTTP/1.1\n\n当前版本，默认采用持久连接，并能很好地配合代理服务器工作。\n\n支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n\n### SPDY\n\n[SPDY](https://zh.wikipedia.org/wiki/SPDY) (发音为\"speedy\") ，是一个由 [Google](https://zh.wikipedia.org/wiki/Google) 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。\n\n### HTTP/2.0\n\n简称为**h2**（基于TLS/1.2或以上版本的加密连接）或**h2c**（非加密连接）。\n\n### 协议之间的比较\n\n**HTTP/1.1相较于HTTP/1.0的主要区别**\n\n- 缓存处理\n- 带宽优化及网络连接的使用\n- 错误通知的管理\n- 消息在网络中的发送\n- 互联网地址的维护\n- 安全性及完整性\n\n**HTTP/2与HTTP/1.1比较**\n\nHTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以藉由新特性得到更好的速度。\n\nHTTP/2 保留了 HTTP/1.1 的大部分语义，例如[请求方法](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)、[状态码](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%A0%81)乃至[URI](https://zh.wikipedia.org/wiki/URI)和绝大多数[HTTP头部](https://zh.wikipedia.org/w/index.php?title=HTTP%E5%A4%B4%E9%83%A8&action=edit&redlink=1)字段一致。\n\n但是 HTTP/2 采用了新的方法来编码、传输客户端/服务器间的数据。\n\n**HTTP/1.1与SPDY的区别**\n\n其与HTTP/1.1相比，SPDY主要的改变有：\n\n- 实现无需先入先出的[多路复用](https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)\n- 为简化客户端和服务器开发的消息—帧机制\n- 强制性压缩（包括HTTP头部）\n- 优先级排序\n- 双向通讯\n\n**HTTP/2与SPDY的比较**\n\nHTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于[霍夫曼编码](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81)，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以[CRIME](https://zh.wikipedia.org/wiki/CRIME)为代表。此外，HTTP/2禁用了诸多加密套件，以保证基于TLS的连接的前向安全。\n\n\n\n## 简介\n\n基于TCP/IP通信协议传递数据。\n\n### 工作原理\n\nHTTP协议工作在客户端-服务端架构（C/S）上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\n\nWeb服务器有Apache服务器、IIS（Internet Informatica Services）服务器等。\n\nWeb服务器根据接收到的请求，向客户端发送响应信息。\n\nHTTP默认端口号为80，我们也可以改为8080或者其他端口。\n\nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）定位互联网上的资源。\n\n### 注意事项\n\nHTTP是：\n\n- **无连接的**：每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后就断开连接。采用这种方式可以节省传输时间。\n- **媒体独立的**：只要客户端和服务端都知道如何处理数据内容，任何类型都可以通过HTTP发送。客户端和服务器指定合适的MIME-tyoe内容类型。\n- **无状态的**：协议对于事务处理没有记忆能力。HTTP协议自身不对请求和响应之间的通信状态进行保存。\n  - <u>这是为了更快地处理大量事务，确保协议的可伸缩性而特意设计的</u>。但这也导致业务处理变得棘手的情况增多，比如要保持登录状态，因为HTTP无状态，因此需要额外保存用户状态。\n  - HTTP/1.1虽然也是无状态协议，但是为了实现比如保持状态的功能，引入了Cookie技术，这让管理状态变得简单。\n  - Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。\n\nHTTP协议通信流程：\n\nWeb浏览器<=HTTP协议=>HTTP服务器<=>CGI（通用网关接口）应用程序<=>数据库\n\n其中CGI：\n\n是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。\n\n![HTTP协议通信流程](https://7n.w3cschool.cn/attachments/image/20160225/1456372014816657.gif)\n\n## HTTP报文\n\n用于HTTP协议交互的信息称为HTTP报文。请求端(客户端)的HTTP报文称为请求报文，响应端（服务器端）的叫响应报文．\n\nHTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。\n\nHTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）来划分。\n\n通常并不一定要有报文主体。\n\n**报文首部**\n\n服务器端或客户端需处理的请求或响应的内容及内容\n\n**请求报文**的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段、其他组成\n\n**响应报文**的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段、其他组成\n\n**CR+LF**\n\nCR，Carriage Return，回车符，16进制0x0d\n\nLF，Line Feed，换行符，16进制0x0a\n\n**报文主体**\n\n应被发送的数据\n\n![图片来源于网络](http://ocs628urt.bkt.clouddn.com/http%E6%8A%A5%E6%96%87.png)\n\n## 常用请求首部信息\n\n（参考自红宝书）\n\n虽然不同浏览器实际发送的头部信息会有所不同，但下边这些基本上是所有浏览器都会发送的：\n\n- Accept：浏览器能够处理的内容类型\n- Accept-Charset：浏览器能够显示的字符集\n- Accept-Encoding：浏览器能够处理的压缩编码\n- Accept-Language：浏览器当前设置的语言\n- Connection：浏览器与服务器之间连接的类型\n- Cookie：当前页面设置的任何Cookie\n- Host：发出请求的页面所在的域\n- Referer：发出请求的页面的URI。注意HTTP规范将这个字段拼写错了（正确拼法为Referrer），但为了保证与规范一致，也只能将错就错了。\n- User-Agent：浏览器的代理用户字段。\n\n注意，这些字段名是一个字母都不应有区别的，一旦有区别，那它就不是首部字段。\n\n## 请求方法\n\n根据HTTP标准，HTTP请求可以使用多种请求方法。\n\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n`GET`\n\nGET方法请求指定的页面信息. 使用GET的请求应该只被用于获取数据.\n\n`HEAD`\n\nHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.\n\n`POST`\n\nPOST方法用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n\n`PUT`\n\nPUT方法从客户端向服务器传送的数据取代指定的文档的内容。\n\n**注意**：因为HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。\n\n`DELETE`\n\nDELETE方法删除指定的资源。\n\n**注意**：和PUT一样，因为HTTP/1.1的DELETE方法自身不带验证机制，存在安全性问题，因此一般的web网站不使用该方法。\n\n`CONNECT`\n\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n`OPTIONS`\n\n询问支持的方法，查询请求URI指定的资源支持的方法。\n\n`TRACE`\n\n回显服务器收到的请求，查询发送出去的请求是怎样被加工/修改的，主要用于测试或诊断（因为从代理服务器路由中转时请求可能被篡改）。不常用。\n\n`PATCH`\n\nPATCH方法用于对资源进行部分修改。（PUT为对资源进行整体覆盖）\n\n## HTTP状态码\n\n- 1XX信息，服务器收到请求，需要请求者继续执行操作\n- 2XX成功，操作被成功接收并处理\n- 3XX重定向，需要进一步的操作以完成请求\n- 4XX客户端错误，请求包含语法错误或无法完成请求\n- 5XX服务器错误，服务器在处理请求的过程中发生了错误\n\n常见状态码：\n\n- **200 OK**， 一切正常，对GET和POST请求的应答文档跟在后面\n- 301 Moved Permanently，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。\n- 302 Found，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。\n- 304 Not Modified，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n- 307 Temporary Redirect，和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清楚地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。\n- **400 Bad Request**，请求出现语法错误。\n- 401 Unauthorized，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求\n- **403 Forbidden**， 资源不可用。\n- **404 Not Found**，无法找到指定位置的资源\n- 410 Gone， 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用\n- **500 Internal Server Error**，服务器遇到了意料不到的情况，不能完成客户的请求\n- 501 Not Implemented，服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求\n- **503 Service Unavailable**  ，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头\n\n## Content-Type\n\n`Content-Type: text/html; charset=UTF-8`\n\n实体首部字段，表示实体主体的媒体类型。\n\n字段值采用type/subtype形式赋值。\n\n对照表链接：https://www.w3cschool.cn/http/ahkmgfmz.html\n\n\n\n\n\n---\n\n[W3C的教程](https://www.w3cschool.cn/http/)的学习笔记，过两天再啃一下MDN和《图解HTTP》，还要再复习一下计网，很多都忘了...\n\nemmmW3C有的是错的...使用网络教程需谨慎....\n\n关于HTTP/2.0以及SPDY等均来自维基百科。\n\n这里只是重新回忆一下什么是HTTP，还是要看文档！啃《图解HTTP》！复习计网！","slug":"HTTP学习记录","published":1,"updated":"2018-10-10T08:37:44.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1v40007fmagj0nivtbb","content":"<p>HTTP协议，HyperText Transfer Protocol，超文本传输协议，是因特网上应用最为 广泛的一种网络传输协议。</p><a id=\"more\"></a><h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><h3 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3><p>已过时，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。</p><p>因为这个版本不支持POST方法，因此客户端无法向服务器传递太多信息。</p><h3 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3><p>第一个在通讯中指定版本号的版本，至今仍被广泛采用，特别是在代理服务器中。</p><h3 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3><p>当前版本，默认采用持久连接，并能很好地配合代理服务器工作。</p><p>支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。</p><h3 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h3><p><a href=\"https://zh.wikipedia.org/wiki/SPDY\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SPDY</a> (发音为”speedy”) ，是一个由 <a href=\"https://zh.wikipedia.org/wiki/Google\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Google</a> 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。</p><h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><p>简称为<strong>h2</strong>（基于TLS/1.2或以上版本的加密连接）或<strong>h2c</strong>（非加密连接）。</p><h3 id=\"协议之间的比较\"><a href=\"#协议之间的比较\" class=\"headerlink\" title=\"协议之间的比较\"></a>协议之间的比较</h3><p><strong>HTTP/1.1相较于HTTP/1.0的主要区别</strong></p><ul><li>缓存处理</li><li>带宽优化及网络连接的使用</li><li>错误通知的管理</li><li>消息在网络中的发送</li><li>互联网地址的维护</li><li>安全性及完整性</li></ul><p><strong>HTTP/2与HTTP/1.1比较</strong></p><p>HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以藉由新特性得到更好的速度。</p><p>HTTP/2 保留了 HTTP/1.1 的大部分语义，例如<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">请求方法</a>、<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%A0%81\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">状态码</a>乃至<a href=\"https://zh.wikipedia.org/wiki/URI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">URI</a>和绝大多数<a href=\"https://zh.wikipedia.org/w/index.php?title=HTTP%E5%A4%B4%E9%83%A8&amp;action=edit&amp;redlink=1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTTP头部</a>字段一致。</p><p>但是 HTTP/2 采用了新的方法来编码、传输客户端/服务器间的数据。</p><p><strong>HTTP/1.1与SPDY的区别</strong></p><p>其与HTTP/1.1相比，SPDY主要的改变有：</p><ul><li>实现无需先入先出的<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">多路复用</a></li><li>为简化客户端和服务器开发的消息—帧机制</li><li>强制性压缩（包括HTTP头部）</li><li>优先级排序</li><li>双向通讯</li></ul><p><strong>HTTP/2与SPDY的比较</strong></p><p>HTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于<a href=\"https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">霍夫曼编码</a>，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以<a href=\"https://zh.wikipedia.org/wiki/CRIME\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CRIME</a>为代表。此外，HTTP/2禁用了诸多加密套件，以保证基于TLS的连接的前向安全。</p><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>基于TCP/IP通信协议传递数据。</p><h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作在客户端-服务端架构（C/S）上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有Apache服务器、IIS（Internet Informatica Services）服务器等。</p><p>Web服务器根据接收到的请求，向客户端发送响应信息。</p><p>HTTP默认端口号为80，我们也可以改为8080或者其他端口。</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）定位互联网上的资源。</p><h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>HTTP是：</p><ul><li><strong>无连接的</strong>：每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后就断开连接。采用这种方式可以节省传输时间。</li><li><strong>媒体独立的</strong>：只要客户端和服务端都知道如何处理数据内容，任何类型都可以通过HTTP发送。客户端和服务器指定合适的MIME-tyoe内容类型。</li><li><strong>无状态的</strong>：协议对于事务处理没有记忆能力。HTTP协议自身不对请求和响应之间的通信状态进行保存。<ul><li><u>这是为了更快地处理大量事务，确保协议的可伸缩性而特意设计的</u>。但这也导致业务处理变得棘手的情况增多，比如要保持登录状态，因为HTTP无状态，因此需要额外保存用户状态。</li><li>HTTP/1.1虽然也是无状态协议，但是为了实现比如保持状态的功能，引入了Cookie技术，这让管理状态变得简单。</li><li>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</li></ul></li></ul><p>HTTP协议通信流程：</p><p>Web浏览器&lt;=HTTP协议=&gt;HTTP服务器&lt;=&gt;CGI（通用网关接口）应用程序&lt;=&gt;数据库</p><p>其中CGI：</p><p>是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。</p><p><img src=\"https://7n.w3cschool.cn/attachments/image/20160225/1456372014816657.gif\" alt=\"HTTP协议通信流程\"></p><h2 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h2><p>用于HTTP协议交互的信息称为HTTP报文。请求端(客户端)的HTTP报文称为请求报文，响应端（服务器端）的叫响应报文．</p><p>HTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。</p><p>HTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）来划分。</p><p>通常并不一定要有报文主体。</p><p><strong>报文首部</strong></p><p>服务器端或客户端需处理的请求或响应的内容及内容</p><p><strong>请求报文</strong>的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段、其他组成</p><p><strong>响应报文</strong>的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段、其他组成</p><p><strong>CR+LF</strong></p><p>CR，Carriage Return，回车符，16进制0x0d</p><p>LF，Line Feed，换行符，16进制0x0a</p><p><strong>报文主体</strong></p><p>应被发送的数据</p><p><img src=\"http://ocs628urt.bkt.clouddn.com/http%E6%8A%A5%E6%96%87.png\" alt=\"图片来源于网络\"></p><h2 id=\"常用请求首部信息\"><a href=\"#常用请求首部信息\" class=\"headerlink\" title=\"常用请求首部信息\"></a>常用请求首部信息</h2><p>（参考自红宝书）</p><p>虽然不同浏览器实际发送的头部信息会有所不同，但下边这些基本上是所有浏览器都会发送的：</p><ul><li>Accept：浏览器能够处理的内容类型</li><li>Accept-Charset：浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URI。注意HTTP规范将这个字段拼写错了（正确拼法为Referrer），但为了保证与规范一致，也只能将错就错了。</li><li>User-Agent：浏览器的代理用户字段。</li></ul><p>注意，这些字段名是一个字母都不应有区别的，一旦有区别，那它就不是首部字段。</p><h2 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><p><code>GET</code></p><p>GET方法请求指定的页面信息. 使用GET的请求应该只被用于获取数据.</p><p><code>HEAD</code></p><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p><p><code>POST</code></p><p>POST方法用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p><code>PUT</code></p><p>PUT方法从客户端向服务器传送的数据取代指定的文档的内容。</p><p><strong>注意</strong>：因为HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。</p><p><code>DELETE</code></p><p>DELETE方法删除指定的资源。</p><p><strong>注意</strong>：和PUT一样，因为HTTP/1.1的DELETE方法自身不带验证机制，存在安全性问题，因此一般的web网站不使用该方法。</p><p><code>CONNECT</code></p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p><code>OPTIONS</code></p><p>询问支持的方法，查询请求URI指定的资源支持的方法。</p><p><code>TRACE</code></p><p>回显服务器收到的请求，查询发送出去的请求是怎样被加工/修改的，主要用于测试或诊断（因为从代理服务器路由中转时请求可能被篡改）。不常用。</p><p><code>PATCH</code></p><p>PATCH方法用于对资源进行部分修改。（PUT为对资源进行整体覆盖）</p><h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><ul><li>1XX信息，服务器收到请求，需要请求者继续执行操作</li><li>2XX成功，操作被成功接收并处理</li><li>3XX重定向，需要进一步的操作以完成请求</li><li>4XX客户端错误，请求包含语法错误或无法完成请求</li><li>5XX服务器错误，服务器在处理请求的过程中发生了错误</li></ul><p>常见状态码：</p><ul><li><strong>200 OK</strong>， 一切正常，对GET和POST请求的应答文档跟在后面</li><li>301 Moved Permanently，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</li><li>302 Found，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。</li><li>304 Not Modified，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li><li>307 Temporary Redirect，和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清楚地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</li><li><strong>400 Bad Request</strong>，请求出现语法错误。</li><li>401 Unauthorized，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求</li><li><strong>403 Forbidden</strong>， 资源不可用。</li><li><strong>404 Not Found</strong>，无法找到指定位置的资源</li><li>410 Gone， 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用</li><li><strong>500 Internal Server Error</strong>，服务器遇到了意料不到的情况，不能完成客户的请求</li><li>501 Not Implemented，服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</li><li><strong>503 Service Unavailable</strong> ，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头</li></ul><h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p><code>Content-Type: text/html; charset=UTF-8</code></p><p>实体首部字段，表示实体主体的媒体类型。</p><p>字段值采用type/subtype形式赋值。</p><p>对照表链接：<a href=\"https://www.w3cschool.cn/http/ahkmgfmz.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.w3cschool.cn/http/ahkmgfmz.html</a></p><hr><p><a href=\"https://www.w3cschool.cn/http/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">W3C的教程</a>的学习笔记，过两天再啃一下MDN和《图解HTTP》，还要再复习一下计网，很多都忘了…</p><p>emmmW3C有的是错的…使用网络教程需谨慎….</p><p>关于HTTP/2.0以及SPDY等均来自维基百科。</p><p>这里只是重新回忆一下什么是HTTP，还是要看文档！啃《图解HTTP》！复习计网！</p>","site":{"data":{}},"excerpt":"<p>HTTP协议，HyperText Transfer Protocol，超文本传输协议，是因特网上应用最为 广泛的一种网络传输协议。</p>","more":"<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><h3 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3><p>已过时，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。</p><p>因为这个版本不支持POST方法，因此客户端无法向服务器传递太多信息。</p><h3 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3><p>第一个在通讯中指定版本号的版本，至今仍被广泛采用，特别是在代理服务器中。</p><h3 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3><p>当前版本，默认采用持久连接，并能很好地配合代理服务器工作。</p><p>支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。</p><h3 id=\"SPDY\"><a href=\"#SPDY\" class=\"headerlink\" title=\"SPDY\"></a>SPDY</h3><p><a href=\"https://zh.wikipedia.org/wiki/SPDY\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SPDY</a> (发音为”speedy”) ，是一个由 <a href=\"https://zh.wikipedia.org/wiki/Google\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Google</a> 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。</p><h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><p>简称为<strong>h2</strong>（基于TLS/1.2或以上版本的加密连接）或<strong>h2c</strong>（非加密连接）。</p><h3 id=\"协议之间的比较\"><a href=\"#协议之间的比较\" class=\"headerlink\" title=\"协议之间的比较\"></a>协议之间的比较</h3><p><strong>HTTP/1.1相较于HTTP/1.0的主要区别</strong></p><ul><li>缓存处理</li><li>带宽优化及网络连接的使用</li><li>错误通知的管理</li><li>消息在网络中的发送</li><li>互联网地址的维护</li><li>安全性及完整性</li></ul><p><strong>HTTP/2与HTTP/1.1比较</strong></p><p>HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以藉由新特性得到更好的速度。</p><p>HTTP/2 保留了 HTTP/1.1 的大部分语义，例如<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">请求方法</a>、<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%8A%B6%E6%80%81%E7%A0%81\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">状态码</a>乃至<a href=\"https://zh.wikipedia.org/wiki/URI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">URI</a>和绝大多数<a href=\"https://zh.wikipedia.org/w/index.php?title=HTTP%E5%A4%B4%E9%83%A8&amp;action=edit&amp;redlink=1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTTP头部</a>字段一致。</p><p>但是 HTTP/2 采用了新的方法来编码、传输客户端/服务器间的数据。</p><p><strong>HTTP/1.1与SPDY的区别</strong></p><p>其与HTTP/1.1相比，SPDY主要的改变有：</p><ul><li>实现无需先入先出的<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">多路复用</a></li><li>为简化客户端和服务器开发的消息—帧机制</li><li>强制性压缩（包括HTTP头部）</li><li>优先级排序</li><li>双向通讯</li></ul><p><strong>HTTP/2与SPDY的比较</strong></p><p>HTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于<a href=\"https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">霍夫曼编码</a>，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以<a href=\"https://zh.wikipedia.org/wiki/CRIME\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">CRIME</a>为代表。此外，HTTP/2禁用了诸多加密套件，以保证基于TLS的连接的前向安全。</p><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>基于TCP/IP通信协议传递数据。</p><h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作在客户端-服务端架构（C/S）上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有Apache服务器、IIS（Internet Informatica Services）服务器等。</p><p>Web服务器根据接收到的请求，向客户端发送响应信息。</p><p>HTTP默认端口号为80，我们也可以改为8080或者其他端口。</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）定位互联网上的资源。</p><h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>HTTP是：</p><ul><li><strong>无连接的</strong>：每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后就断开连接。采用这种方式可以节省传输时间。</li><li><strong>媒体独立的</strong>：只要客户端和服务端都知道如何处理数据内容，任何类型都可以通过HTTP发送。客户端和服务器指定合适的MIME-tyoe内容类型。</li><li><strong>无状态的</strong>：协议对于事务处理没有记忆能力。HTTP协议自身不对请求和响应之间的通信状态进行保存。<ul><li><u>这是为了更快地处理大量事务，确保协议的可伸缩性而特意设计的</u>。但这也导致业务处理变得棘手的情况增多，比如要保持登录状态，因为HTTP无状态，因此需要额外保存用户状态。</li><li>HTTP/1.1虽然也是无状态协议，但是为了实现比如保持状态的功能，引入了Cookie技术，这让管理状态变得简单。</li><li>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</li></ul></li></ul><p>HTTP协议通信流程：</p><p>Web浏览器&lt;=HTTP协议=&gt;HTTP服务器&lt;=&gt;CGI（通用网关接口）应用程序&lt;=&gt;数据库</p><p>其中CGI：</p><p>是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。</p><p><img src=\"https://7n.w3cschool.cn/attachments/image/20160225/1456372014816657.gif\" alt=\"HTTP协议通信流程\"></p><h2 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h2><p>用于HTTP协议交互的信息称为HTTP报文。请求端(客户端)的HTTP报文称为请求报文，响应端（服务器端）的叫响应报文．</p><p>HTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。</p><p>HTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）来划分。</p><p>通常并不一定要有报文主体。</p><p><strong>报文首部</strong></p><p>服务器端或客户端需处理的请求或响应的内容及内容</p><p><strong>请求报文</strong>的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段、其他组成</p><p><strong>响应报文</strong>的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段、其他组成</p><p><strong>CR+LF</strong></p><p>CR，Carriage Return，回车符，16进制0x0d</p><p>LF，Line Feed，换行符，16进制0x0a</p><p><strong>报文主体</strong></p><p>应被发送的数据</p><p><img src=\"http://ocs628urt.bkt.clouddn.com/http%E6%8A%A5%E6%96%87.png\" alt=\"图片来源于网络\"></p><h2 id=\"常用请求首部信息\"><a href=\"#常用请求首部信息\" class=\"headerlink\" title=\"常用请求首部信息\"></a>常用请求首部信息</h2><p>（参考自红宝书）</p><p>虽然不同浏览器实际发送的头部信息会有所不同，但下边这些基本上是所有浏览器都会发送的：</p><ul><li>Accept：浏览器能够处理的内容类型</li><li>Accept-Charset：浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URI。注意HTTP规范将这个字段拼写错了（正确拼法为Referrer），但为了保证与规范一致，也只能将错就错了。</li><li>User-Agent：浏览器的代理用户字段。</li></ul><p>注意，这些字段名是一个字母都不应有区别的，一旦有区别，那它就不是首部字段。</p><h2 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><p><code>GET</code></p><p>GET方法请求指定的页面信息. 使用GET的请求应该只被用于获取数据.</p><p><code>HEAD</code></p><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</p><p><code>POST</code></p><p>POST方法用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p><code>PUT</code></p><p>PUT方法从客户端向服务器传送的数据取代指定的文档的内容。</p><p><strong>注意</strong>：因为HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。</p><p><code>DELETE</code></p><p>DELETE方法删除指定的资源。</p><p><strong>注意</strong>：和PUT一样，因为HTTP/1.1的DELETE方法自身不带验证机制，存在安全性问题，因此一般的web网站不使用该方法。</p><p><code>CONNECT</code></p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p><code>OPTIONS</code></p><p>询问支持的方法，查询请求URI指定的资源支持的方法。</p><p><code>TRACE</code></p><p>回显服务器收到的请求，查询发送出去的请求是怎样被加工/修改的，主要用于测试或诊断（因为从代理服务器路由中转时请求可能被篡改）。不常用。</p><p><code>PATCH</code></p><p>PATCH方法用于对资源进行部分修改。（PUT为对资源进行整体覆盖）</p><h2 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h2><ul><li>1XX信息，服务器收到请求，需要请求者继续执行操作</li><li>2XX成功，操作被成功接收并处理</li><li>3XX重定向，需要进一步的操作以完成请求</li><li>4XX客户端错误，请求包含语法错误或无法完成请求</li><li>5XX服务器错误，服务器在处理请求的过程中发生了错误</li></ul><p>常见状态码：</p><ul><li><strong>200 OK</strong>， 一切正常，对GET和POST请求的应答文档跟在后面</li><li>301 Moved Permanently，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</li><li>302 Found，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。</li><li>304 Not Modified，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li><li>307 Temporary Redirect，和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清楚地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</li><li><strong>400 Bad Request</strong>，请求出现语法错误。</li><li>401 Unauthorized，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求</li><li><strong>403 Forbidden</strong>， 资源不可用。</li><li><strong>404 Not Found</strong>，无法找到指定位置的资源</li><li>410 Gone， 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用</li><li><strong>500 Internal Server Error</strong>，服务器遇到了意料不到的情况，不能完成客户的请求</li><li>501 Not Implemented，服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</li><li><strong>503 Service Unavailable</strong> ，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头</li></ul><h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p><code>Content-Type: text/html; charset=UTF-8</code></p><p>实体首部字段，表示实体主体的媒体类型。</p><p>字段值采用type/subtype形式赋值。</p><p>对照表链接：<a href=\"https://www.w3cschool.cn/http/ahkmgfmz.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.w3cschool.cn/http/ahkmgfmz.html</a></p><hr><p><a href=\"https://www.w3cschool.cn/http/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">W3C的教程</a>的学习笔记，过两天再啃一下MDN和《图解HTTP》，还要再复习一下计网，很多都忘了…</p><p>emmmW3C有的是错的…使用网络教程需谨慎….</p><p>关于HTTP/2.0以及SPDY等均来自维基百科。</p><p>这里只是重新回忆一下什么是HTTP，还是要看文档！啃《图解HTTP》！复习计网！</p>"},{"title":"JavaScript原型链:prototype与__proto__","toc":false,"date":"2018-09-04T03:16:54.000Z","_content":"\n\n\n主要看了[这一篇](https://www.w3cschool.cn/javascript/javascript-5isn2lax.html)，讲解的很清晰，最主要的一点为：\n\n\n\n若：\n\n```js\nvar Person = function () { };\nvar p = new Person();\n```\n\n则：\n\n```js\np.__proto__ = Person.prototype;\n```\n\n<!-- more -->\n\n当调用`p.xxx()`时，首先在`p`中找`xxx`这个属性，没有的话从`p`的`__proto__`(即`Person`的`prototype`)中寻找，如果没有，则继续向上寻找（`p.__proto__.__proto__`即`Person.prototype.__proto__`, ...）。\n\n\n\n\n\n例如下面这个例子：\n\n```js\nvar Person = function() {\n    Person.prototype.Say = function () {\n        alert(\"Person say\");\n    }\n}\n\nvar Programmer = function() {}\nProgrammer.prototype = new Person();\nvar p = new Programmer();\n```\n\n我们可以得出：\n\n`p.__proto__ = Programmer.prototype`\n\n`p.__proto__.__proto__ = Programmer.prototype.__proto__ = Person.prototype`\n\n所以在调用`p.Say()`方法时，现在`p`中寻找这个属性，如果没有就在`p.__proto__`中寻找，然后一步一步往上，最后在`Person.prototype`找到这个方法。\n\n\n\n","source":"_posts/JavaScript原型链-prototype与-proto.md","raw":"---\ntitle: 'JavaScript原型链:prototype与__proto__'\ntoc: false\ndate: 2018-09-04 11:16:54\ncategories:\n- Web\ntags:\n- JavaScript\n- prototype\n---\n\n\n\n主要看了[这一篇](https://www.w3cschool.cn/javascript/javascript-5isn2lax.html)，讲解的很清晰，最主要的一点为：\n\n\n\n若：\n\n```js\nvar Person = function () { };\nvar p = new Person();\n```\n\n则：\n\n```js\np.__proto__ = Person.prototype;\n```\n\n<!-- more -->\n\n当调用`p.xxx()`时，首先在`p`中找`xxx`这个属性，没有的话从`p`的`__proto__`(即`Person`的`prototype`)中寻找，如果没有，则继续向上寻找（`p.__proto__.__proto__`即`Person.prototype.__proto__`, ...）。\n\n\n\n\n\n例如下面这个例子：\n\n```js\nvar Person = function() {\n    Person.prototype.Say = function () {\n        alert(\"Person say\");\n    }\n}\n\nvar Programmer = function() {}\nProgrammer.prototype = new Person();\nvar p = new Programmer();\n```\n\n我们可以得出：\n\n`p.__proto__ = Programmer.prototype`\n\n`p.__proto__.__proto__ = Programmer.prototype.__proto__ = Person.prototype`\n\n所以在调用`p.Say()`方法时，现在`p`中寻找这个属性，如果没有就在`p.__proto__`中寻找，然后一步一步往上，最后在`Person.prototype`找到这个方法。\n\n\n\n","slug":"JavaScript原型链-prototype与-proto","published":1,"updated":"2018-10-10T08:37:53.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1v60008fmag8hldfzeb","content":"<p>主要看了<a href=\"https://www.w3cschool.cn/javascript/javascript-5isn2lax.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这一篇</a>，讲解的很清晰，最主要的一点为：</p><p>若：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Person <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>则：</p><pre class=\" language-js\"><code class=\"language-js\">p<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n</code></pre><a id=\"more\"></a><p>当调用<code>p.xxx()</code>时，首先在<code>p</code>中找<code>xxx</code>这个属性，没有的话从<code>p</code>的<code>__proto__</code>(即<code>Person</code>的<code>prototype</code>)中寻找，如果没有，则继续向上寻找（<code>p.__proto__.__proto__</code>即<code>Person.prototype.__proto__</code>, …）。</p><p>例如下面这个例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Person <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>Say <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Person say\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> Programmer <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nProgrammer<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Programmer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>我们可以得出：</p><p><code>p.__proto__ = Programmer.prototype</code></p><p><code>p.__proto__.__proto__ = Programmer.prototype.__proto__ = Person.prototype</code></p><p>所以在调用<code>p.Say()</code>方法时，现在<code>p</code>中寻找这个属性，如果没有就在<code>p.__proto__</code>中寻找，然后一步一步往上，最后在<code>Person.prototype</code>找到这个方法。</p>","site":{"data":{}},"excerpt":"<p>主要看了<a href=\"https://www.w3cschool.cn/javascript/javascript-5isn2lax.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这一篇</a>，讲解的很清晰，最主要的一点为：</p><p>若：</p><pre><code class=\"js\">var Person = function () { };\nvar p = new Person();\n</code></pre><p>则：</p><pre><code class=\"js\">p.__proto__ = Person.prototype;\n</code></pre>","more":"<p>当调用<code>p.xxx()</code>时，首先在<code>p</code>中找<code>xxx</code>这个属性，没有的话从<code>p</code>的<code>__proto__</code>(即<code>Person</code>的<code>prototype</code>)中寻找，如果没有，则继续向上寻找（<code>p.__proto__.__proto__</code>即<code>Person.prototype.__proto__</code>, …）。</p><p>例如下面这个例子：</p><pre><code class=\"js\">var Person = function() {\n    Person.prototype.Say = function () {\n        alert(&quot;Person say&quot;);\n    }\n}\n\nvar Programmer = function() {}\nProgrammer.prototype = new Person();\nvar p = new Programmer();\n</code></pre><p>我们可以得出：</p><p><code>p.__proto__ = Programmer.prototype</code></p><p><code>p.__proto__.__proto__ = Programmer.prototype.__proto__ = Person.prototype</code></p><p>所以在调用<code>p.Say()</code>方法时，现在<code>p</code>中寻找这个属性，如果没有就在<code>p.__proto__</code>中寻找，然后一步一步往上，最后在<code>Person.prototype</code>找到这个方法。</p>"},{"title":"JavaScript学习记录一","toc":true,"date":"2018-09-11T10:26:52.000Z","_content":"\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n------\n\n# 简介\n\nJavaScript是一种专门为网页交互而设计的脚本语言，由以下三个不同的部分组成：\n\n- ECMAScript（发音 ek-ma-script，伪语言），由ECMA-262定义，提供核心语言功能；\n- 文档对象模型（DOM，Document Object Model），提供访问和操作网页内容的方法和接口；\n- 浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口；\n\n在HTML中使用JavaScript：\n\n- 现代Web应用一般都把全部JavaScript引用放在`<body>`元素中，放在页面内容的后边来最后加载JavaScript代码（虽然defer属性可以实现同样的效果，但是不是所有浏览器都支持这个属性，因此一般不使用这个属性）；\n\n# 基本概念\n\n## 语法\n\n1. 区分大小写\n2. <b>标识符</b>，指变量、函数、属性的名字，或函数的参数，需要满足：\n   1. 第一个字符必须是字母、下划线(_)或者一个美元符号($)\n   2. 其他字符可以是数字、字母、下划线、美元符号\n   3. 按照惯例，采用**驼峰**大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写\n   4. 不能把**关键字、保留字、true、false、null**用作标识符\n3. 注释，跟C++相同\n4. 以分号结尾，可以不加分号，但是不推荐\n\n## 关键字和保留字\n\n- 关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with\n- 保留字： abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile\n\n## 变量\n\n- ECMAScript的变量是松散类型（弱类型）的，无需明确的类型声明，可以用来保存任何类型的数据。\n- 未初始化的变量值为`undefined`\n- 使用var操作符定义的变量将成为定义该变量的作用域中举局部变量\n- 不使用var操作符定义的变量是全局变量（不推荐）\n\n## 数据类型\n\nECMAScript有五种简单（基本/原始）数据类型：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n和一种复杂数据类型：\n\n- Object\n\n因为ECMAScript数据类型具有动态性，因此没有再定义其他数据类型的必要。\n\n### typeof操作符\n\n因为typeof是操作符，因此括号不是必需的，也就是可以`typeof 126`也可以`typeof(126)`。\n\n对一个值使用typeof操作符可能返回下列某个字符串：\n\n- undefined\n- boolean\n- string\n- number\n- object\n- function\n\n### Undefined类型\n\n只有一个值——undefined。\n\n虽然对声明未初始化的变量（假设为a）和未声明的变量（假设为b）使用typeof均返回undefined，但是对他们使用alert会得到不同的结果：\n\n对于a : 会弹出undefined\n\n对于b : 会返回错误Uncaught ReferenceError: b is not defined\n\n因此建议在声明时就进行初始化，以此来分别a和b。\n\n### Null类型\n\n只有一个值——null。\n\n从逻辑角度来看，null值表示一个空对象指针，因此：\n\n```javascript\nvar a = null;\nalert(typeof a); // \"object\"\n```\n\n因为undefined派生自null，因此ECMA-262规定`undefined == null`为true。\n\n只要意在保存对象的变量还没有真正的保存对象，都应该让它保存为null。\n\n### Boolean类型\n\n只有两个值——true和false。\n\n转换为Boolean的转换规则：\n\n| 数据类型  | 转换为true的值          | 转换为false的值 |\n| --------- | ----------------------- | --------------- |\n| Boolean   | true                    | false           |\n| Stirng    | 任何非空字符串          | “”（空字符串）  |\n| Number    | 任何非0值（包括无穷大） | 0和NaN          |\n| Object    | 任何对象                | null            |\n| Undefined | n/a（不适用）           | undefined       |\n\n### Number类型\n\n使用IEEE754格式表示整数和浮点数。\n\n- 八进制数以`0`开头如`070`表示八进制的56\n- 十六进制数以`0x`开头如`0xA`或`0xa`表示十六进制的10\n- 浮点数必须包含一个小数点，小数点前若为0则可以省略，但不推荐这么做\n- 若小数点后没有跟任何数字如`1.`或本身就是一个整数如`1.0`则会被保存为整数（因为保存浮点数值需要的内存空间是整数值的两倍）\n- 可以用科学计数法表示浮点数：例如使用`1.26e-9`表示1.26乘以10的-9次方\n- 浮点数最高精度为17位小数，但计算精度不如整数，例如0.1加0.2的计算结果不为0.3\n- Number.MAX_VALUE = 1.7976931348623157e+308, 超出值转换为Infinity\n- Number.MIN_VALUE = 5e-324， 超出值转换为-Infinity\n- 可以使用isFinite()函数判断一个数是否有穷\n- NaN, Not a Number，非数值，如任何数值除以0都会得到NaN\n- NaN与任何值都不相等，`NaN == NaN`返回false，因此可以用函数isNaN()判断是否为NaN，true和false可以转换为数值，因此都不是NaN，字符串无法转换为数值，因此是NaN\n- Number()可以将任何数据类型的非数值转换为数值，parseInt()和parseFloat()用于把字符串转换为数值\n\nNumber()转换规则：\n\n- true和false分别转换为1和0\n- 数值只是简单的传入传出\n- null返回0\n- undefined返回NaN\n- 字符串遵循以下规则：\n  - 若字符串只包含数字，则转换为十进制数值，忽略前置0\n  - 若字符串为有效的浮点格式，如“1.1”，不包含数字、小数点、负号以外的字符，则转换为对应的浮点数，忽略前置0\n  - 若字符串为有效的十六进制格式，如“0xf”，除了其他字符外还不可以有负号，转换为相同大小的十进制整数值\n  - 若字符串是空的，则返回0\n  - 其他格式返回NaN\n\n对于parseInt()和parseFloat()：\n\n- 关于前置0，我在Chrome里试了一下：\n  - parseInt(\"070\")返回的是70，并不会看做八进制数\n  - parseInt(070)返回的是56，看做八进制数\n- 有效的格式如有效的浮点格式指浮点数处于字符串开头，若字符串开头既不是数字也不是负号则不是有效格式，若以小数点开头，小数点跟有数字则是有效的浮点格式，小数点后跟的不是数字则不是有效的格式\n- 可以指定基数（进制）为第二个参数\n\n### String类型\n\n由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n- 字符串用双引号或单引号表示都是有效且没有区别的，但左右引号必须匹配。\n- 字符串a的长度可以用它的属性`length`即`a.length`来获得。\n- JavaScript字符以UTF-16存储，即每个字符要么存储为2个字节，要么存储为4个字节（每个字节8位）；二String的length属性返回的是字符串中两个字节字符的数目，也就是说对于一个4个字节的字符，length会把它当做两个字符。\n- 字符串不能修改，只能销毁再填充。\n- 数的toString()可以传入基数（进制）为参数。\n- null和undefined没有toString()方法，但可以使用String()方法。\n\n字符字面量（转义序列）：\n\n| 字面量  | 含义                                                         |\n| ------- | ------------------------------------------------------------ |\n| \\n      | 换行                                                         |\n| \\t      | 制表                                                         |\n| \\b      | 空格                                                         |\n| \\r      | 回车                                                         |\n| \\f      | 进纸                                                         |\n| \\\\\\     | 斜杠                                                         |\n| \\\\'     | 单引号                                                       |\n| \\\\\"     | 双引号                                                       |\n| \\\\xnn   | 以16进制代码nn表示的一个字符（其中n为0-F），例如\\\\x41表示“A”。 |\n| \\\\unnnn | 以16进制代码nnnn表示的一个Unicode字符（其中n为0-F），\\\\u03a3表示希腊字符∑ |\n\n### Object类型\n\n对象是一组数据和功能的集合。具体的后边的章节会学到，这里就不展开了。\n\n## 操作符\n\n### 一元操作符\n\n- ++、--对整数、浮点数、字符串、布尔值、对象都适用\n  - 对非数值，先使用Number()将其转换为数值再进行加减1\n- +、- 同样对整数、浮点数、字符串、布尔值、对象都适用，规则和++、--的差不多\n\n### 位操作符\n\n先将64位的数值转换为32位数值，然后进行位操作，最后再转换为64位数值：\n\n- 对undefined、null、NaN和Infinity应用位操作这两者会被当成0来处理\n- 对非数值，先使用Number()将其转换为数值再应用位操作\n- 按位非(NOT) : `~`，返回反码，等于原值的负数减1\n- 按位与(AND) : `&`\n- 按位或(OR) : `|`\n- 按位异或(XOR) : `^`，异或指操作的两个位均为1或均为0则返回0，一个是1一个是0则返回1\n- 左移 : `<<`，左移不会影响符号位，左移出现的空位用0填充\n- 有符号右移 : `>>`，用符号位的值来填充右移出现的空位\n- 无符号右移 : `>>>`，所有32位都向右移动（包括符号位），并用0填充右移出现的空位\n\n### 布尔操作符\n\n- 逻辑非：`!`，先将操作数转换为布尔值，然后求反\n  - 对一个对象进行逻辑非操作，返回false\n  - 对一个空字符串进行逻辑非操作，返回true\n  - 对非空字符串进行逻辑非操作，返回false\n  - 对0、null、NaN、undefined进行逻辑非操作，返回true\n  - 对任意非0数值包括Infinity进行逻辑非操作，返回false\n  - 同时使用两个逻辑非操作符`!!`，实际上模拟了Boolean()转型函数的行为，0、空字符串、null、NaN、undefined返回false\n- 逻辑与：`&&`，逻辑与操作不一定返回布尔值\n  - 如果有一个操作数是null，则返回null\n  - 如果有一个操作数是NaN，则返回NaN\n  - 如果有一个操作数是undefined，则返回undefined\n  - 如果第一个操作数是对象或者两个都是对象，返回第二个操作数\n  - 如果第二个操作数是对象，则返回第一个操作数\n  - 如果第一个操作数为false，则返回false\n- 逻辑或：`||`\n  - 如果两个操作数都是null，则返回null\n  - 如果两个操作数都是NaN，则返回NaN\n  - 如果两个操作数都是undefined，则返回undefined\n  - 如果第一个操作数是对象或者两个都是对象，返回第一个操作数\n  - 如果第一个操作数求值结果为false，则返回第二个操作数\n  - 如果第一个操作数求值结果为true，则返回第一个操作数\n\n### 乘性操作符\n\n若操作数不是数值，则后台会先使用Number()将其转换为数值再进行计算\n\n- 乘法：`*`\n  - 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity\n  - 若一个操作数为NaN，则结果为NaN\n  - Infinity * 0 等于 NaN\n  - Infinity与非0值相乘，结果还是Infinity或-Infinity\n- 除法：`/`\n  - 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity\n  - 若一个操作数为NaN，则结果为NaN\n  - Infinity / Infinity 等于 NaN\n  - Infinity被任意数值除，结果仍为Infinity\n  - 0 / 0 等于 NaN\n  - 非零数（包括Infinity）除以0结果为Infinity或-Infinity\n- 求模：`%`\n  - Infinity % 有限值 的结果为NaN\n  - 任意值 % 0 的结果为NaN\n  - Infinity % Infinity 的结果为NaN\n  - 有限大值a % Infinity 的结果为a\n  - 0 % 任意值 的结果为0\n\n### 加性操作符\n\n- 加法：`+`\n  - 如果有一个操作符为NaN，则结果为NaN\n  - Infinity加-Infinity，结果为NaN\n  - +0加+0为+0，-0加-0结果为-0\n  - +0加-0结果为+0\n  - 如果两个操作数都为字符串，则拼接起来\n  - 若有一个操作数不是数值，则将两个都转换（toString()）为字符串，然后两个字符串拼接起来\n- 减法：`-`\n  - 如果有一个操作符为NaN，则结果为NaN\n  - Infinity减Infinity或者-Infinity减-Infinity结果为NaN\n  - +0减+0为+0，+0减-0为-0，-0减-0为+0\n  - 如果有操作数为字符串、布尔值、null、undefined，则先调用Number()函数将其转换为数值，若有一个转换后为NaN，则结果为NaN\n  - 如果有操作数为对象，则调用其valueOf()方法获取其数值，若值为NaN，则结果为NaN，若没有valueOf()方法，则调用其toString()方法并将得到的字符串转化为数值\n\n### 关系操作符\n\n`<`、`>`、`<=`、`>=`\n\n- 若两个操作数都是数值则进行数值比较\n- 若两个操作数都是字符串，则比较两个字符串的字符编码值\n- 如果一个是数值，则将另一个操作数转换为一个数值，然后执行数值比较\n- 如果一个操作数是对象，则先用valueOf()换取数值进行比较，若对象没有valueOf()方法，则调用toString()，然后转换为数值进行比较\n- 如果一个操作数是布尔值，则将其转换为数值然后进行比较\n- 如果一个操作数是NaN，则返回false\n\n### 相等操作符\n\n#### 相等和不相等\n\n`==`、`!=`，先转换再比较\n\n- 如果一个操作数为布尔值，则将其转换为数值进行比较\n- 如果一个操作数是字符串，一个操作符是数值，则将字符串转换成数值再进行比较\n- 如果一个操作数是对象而另一个不是，则调用对象的valueOf()方法，用得到的数值按照前边的规则进行比较\n- null和undefined是相等的\n- 在比较相等性之前，不能将null和undefined转换成其他任何值\n- NaN和任何值（包括NaN）都不相等\n- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则`==`返回true，`!=`返回false\n\n特殊情况结果：\n\n```javascript\nnull == undefined // true\n\"NaN\" == NaN // false\n5 == NaN // fale\nNaN == NaN // false\nNaN != NaN // true\nfalse == 0 // true\ntrue == 1 // true\ntrue == 2 // false\nundefined == 0 // false\nnull == 0 // false\n\"5\" == 5 // true\n```\n\n#### 全等和不全等\n\n`===`、`!==`，仅比较不转换，首先类型相同然后值相同\n\n### 条件操作符\n\n`variable = boolean_expression ? true_value : false_value`\n\n### 赋值操作符\n\n`=`\n\n复合操作符： `*=`,`/=`,`%=`,`+=`,`-=`,`<<=`,`>>=`,`>>>=`\n\n例如复合操作符加等于`+=`：\n\n```javascript\nvar num = 10;\nnum += 5;\n```\n\n相当于：\n\n```javascript\nvar num = 10;\nnum = num + 5;\n```\n\n### 逗号操作符\n\n声明多个变量、一条语句中执行多个操作用逗号隔开；\n\n在赋值时，逗号操作符总会返回表达式中的最后一项：\n\n```javascript\nvar num = (1, 2, 6, 5, 3, 0); // num的值为0\n```\n\n## 语句\n\n### if、while、for语句\n\n即使要执行的只有一句代码也要用`{}`括起来；\n\n关于循环的块作用域后边的章节会有讲解。\n\n### do-while语句\n\n在对条件表达式求值之前，循环体内的代码至少会执行一次，这种后测试语句最常用语循环体内的代码至少要执行一次的情形。\n\n### for-in语句\n\n`for (property in expression) statement`\n\n例如：\n\n```javascript\nfor (var propName in window) {\n  console.log(propName);\n}\n```\n\n### label、break、continue语句\n\nlabel语句的语法为`label: statement`，可以由`break`和`continue`语句引用，常用与和循环语句配合使用。\n\n例子可以看[这里](https://blog.csdn.net/x386277405/article/details/78673757)\n\n### with语句\n\n**由于大量使用with语句会导致性能下降，还会给调试代码造成困难，因此开发大型应用程序时不建议使用with语句。**\n\n`with (expression) statement`，将代码的作用于设置到一个特定的对象中。\n\n例如\n\n```javascript\nvar qs = location.search.substring(1);\nvar hostName = location.hostname;\nvar url = location.href;\n```\n\n等价于\n\n```javascript\nwith (location) {\n  var qs = search.substring(1);\n  var hostName = hostname;\n  var url = href;\n}\n```\n\n### switch语句\n\n- switch语句中可以使用任何数据类型\n- 每个case的值不一定是常量，可以是变量甚至是表达式\n- switch在比较值时使用的是全等操作符，因此不会发生类型转换（例如“10”不等于10）\n\n## 函数\n\n```js\nfunction functionName(arg0, arg1, ..., argN) {\n\tstatements\n}\n```\n\n返回值不是必需的。\n\n关于参数可以看[这篇文章](https://www.cnblogs.com/hanhanhan/p/5765920.html)中的例子来理解。需要注意的是：没有传递值的命名参数自动赋予undefined值，关于引用传递可以看[这里](https://www.cnblogs.com/refe/p/5101744.html)。\n\n因为ECMAScript函数没有签名（因为其参数是由包含零或多个值的数组来表示的），因此不能像传统意义上那样实现重载。但可以通过检查传入函数的参数类型和数量进行不同的操作来模拟重载。","source":"_posts/JavaScript学习记录一.md","raw":"---\ntitle: JavaScript学习记录一\ntoc: true\ndate: 2018-09-11 18:26:52\ncategories:\n- Web\ntags:\n- JavaScript\n\n---\n\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n------\n\n# 简介\n\nJavaScript是一种专门为网页交互而设计的脚本语言，由以下三个不同的部分组成：\n\n- ECMAScript（发音 ek-ma-script，伪语言），由ECMA-262定义，提供核心语言功能；\n- 文档对象模型（DOM，Document Object Model），提供访问和操作网页内容的方法和接口；\n- 浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口；\n\n在HTML中使用JavaScript：\n\n- 现代Web应用一般都把全部JavaScript引用放在`<body>`元素中，放在页面内容的后边来最后加载JavaScript代码（虽然defer属性可以实现同样的效果，但是不是所有浏览器都支持这个属性，因此一般不使用这个属性）；\n\n# 基本概念\n\n## 语法\n\n1. 区分大小写\n2. <b>标识符</b>，指变量、函数、属性的名字，或函数的参数，需要满足：\n   1. 第一个字符必须是字母、下划线(_)或者一个美元符号($)\n   2. 其他字符可以是数字、字母、下划线、美元符号\n   3. 按照惯例，采用**驼峰**大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写\n   4. 不能把**关键字、保留字、true、false、null**用作标识符\n3. 注释，跟C++相同\n4. 以分号结尾，可以不加分号，但是不推荐\n\n## 关键字和保留字\n\n- 关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with\n- 保留字： abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile\n\n## 变量\n\n- ECMAScript的变量是松散类型（弱类型）的，无需明确的类型声明，可以用来保存任何类型的数据。\n- 未初始化的变量值为`undefined`\n- 使用var操作符定义的变量将成为定义该变量的作用域中举局部变量\n- 不使用var操作符定义的变量是全局变量（不推荐）\n\n## 数据类型\n\nECMAScript有五种简单（基本/原始）数据类型：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n和一种复杂数据类型：\n\n- Object\n\n因为ECMAScript数据类型具有动态性，因此没有再定义其他数据类型的必要。\n\n### typeof操作符\n\n因为typeof是操作符，因此括号不是必需的，也就是可以`typeof 126`也可以`typeof(126)`。\n\n对一个值使用typeof操作符可能返回下列某个字符串：\n\n- undefined\n- boolean\n- string\n- number\n- object\n- function\n\n### Undefined类型\n\n只有一个值——undefined。\n\n虽然对声明未初始化的变量（假设为a）和未声明的变量（假设为b）使用typeof均返回undefined，但是对他们使用alert会得到不同的结果：\n\n对于a : 会弹出undefined\n\n对于b : 会返回错误Uncaught ReferenceError: b is not defined\n\n因此建议在声明时就进行初始化，以此来分别a和b。\n\n### Null类型\n\n只有一个值——null。\n\n从逻辑角度来看，null值表示一个空对象指针，因此：\n\n```javascript\nvar a = null;\nalert(typeof a); // \"object\"\n```\n\n因为undefined派生自null，因此ECMA-262规定`undefined == null`为true。\n\n只要意在保存对象的变量还没有真正的保存对象，都应该让它保存为null。\n\n### Boolean类型\n\n只有两个值——true和false。\n\n转换为Boolean的转换规则：\n\n| 数据类型  | 转换为true的值          | 转换为false的值 |\n| --------- | ----------------------- | --------------- |\n| Boolean   | true                    | false           |\n| Stirng    | 任何非空字符串          | “”（空字符串）  |\n| Number    | 任何非0值（包括无穷大） | 0和NaN          |\n| Object    | 任何对象                | null            |\n| Undefined | n/a（不适用）           | undefined       |\n\n### Number类型\n\n使用IEEE754格式表示整数和浮点数。\n\n- 八进制数以`0`开头如`070`表示八进制的56\n- 十六进制数以`0x`开头如`0xA`或`0xa`表示十六进制的10\n- 浮点数必须包含一个小数点，小数点前若为0则可以省略，但不推荐这么做\n- 若小数点后没有跟任何数字如`1.`或本身就是一个整数如`1.0`则会被保存为整数（因为保存浮点数值需要的内存空间是整数值的两倍）\n- 可以用科学计数法表示浮点数：例如使用`1.26e-9`表示1.26乘以10的-9次方\n- 浮点数最高精度为17位小数，但计算精度不如整数，例如0.1加0.2的计算结果不为0.3\n- Number.MAX_VALUE = 1.7976931348623157e+308, 超出值转换为Infinity\n- Number.MIN_VALUE = 5e-324， 超出值转换为-Infinity\n- 可以使用isFinite()函数判断一个数是否有穷\n- NaN, Not a Number，非数值，如任何数值除以0都会得到NaN\n- NaN与任何值都不相等，`NaN == NaN`返回false，因此可以用函数isNaN()判断是否为NaN，true和false可以转换为数值，因此都不是NaN，字符串无法转换为数值，因此是NaN\n- Number()可以将任何数据类型的非数值转换为数值，parseInt()和parseFloat()用于把字符串转换为数值\n\nNumber()转换规则：\n\n- true和false分别转换为1和0\n- 数值只是简单的传入传出\n- null返回0\n- undefined返回NaN\n- 字符串遵循以下规则：\n  - 若字符串只包含数字，则转换为十进制数值，忽略前置0\n  - 若字符串为有效的浮点格式，如“1.1”，不包含数字、小数点、负号以外的字符，则转换为对应的浮点数，忽略前置0\n  - 若字符串为有效的十六进制格式，如“0xf”，除了其他字符外还不可以有负号，转换为相同大小的十进制整数值\n  - 若字符串是空的，则返回0\n  - 其他格式返回NaN\n\n对于parseInt()和parseFloat()：\n\n- 关于前置0，我在Chrome里试了一下：\n  - parseInt(\"070\")返回的是70，并不会看做八进制数\n  - parseInt(070)返回的是56，看做八进制数\n- 有效的格式如有效的浮点格式指浮点数处于字符串开头，若字符串开头既不是数字也不是负号则不是有效格式，若以小数点开头，小数点跟有数字则是有效的浮点格式，小数点后跟的不是数字则不是有效的格式\n- 可以指定基数（进制）为第二个参数\n\n### String类型\n\n由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n- 字符串用双引号或单引号表示都是有效且没有区别的，但左右引号必须匹配。\n- 字符串a的长度可以用它的属性`length`即`a.length`来获得。\n- JavaScript字符以UTF-16存储，即每个字符要么存储为2个字节，要么存储为4个字节（每个字节8位）；二String的length属性返回的是字符串中两个字节字符的数目，也就是说对于一个4个字节的字符，length会把它当做两个字符。\n- 字符串不能修改，只能销毁再填充。\n- 数的toString()可以传入基数（进制）为参数。\n- null和undefined没有toString()方法，但可以使用String()方法。\n\n字符字面量（转义序列）：\n\n| 字面量  | 含义                                                         |\n| ------- | ------------------------------------------------------------ |\n| \\n      | 换行                                                         |\n| \\t      | 制表                                                         |\n| \\b      | 空格                                                         |\n| \\r      | 回车                                                         |\n| \\f      | 进纸                                                         |\n| \\\\\\     | 斜杠                                                         |\n| \\\\'     | 单引号                                                       |\n| \\\\\"     | 双引号                                                       |\n| \\\\xnn   | 以16进制代码nn表示的一个字符（其中n为0-F），例如\\\\x41表示“A”。 |\n| \\\\unnnn | 以16进制代码nnnn表示的一个Unicode字符（其中n为0-F），\\\\u03a3表示希腊字符∑ |\n\n### Object类型\n\n对象是一组数据和功能的集合。具体的后边的章节会学到，这里就不展开了。\n\n## 操作符\n\n### 一元操作符\n\n- ++、--对整数、浮点数、字符串、布尔值、对象都适用\n  - 对非数值，先使用Number()将其转换为数值再进行加减1\n- +、- 同样对整数、浮点数、字符串、布尔值、对象都适用，规则和++、--的差不多\n\n### 位操作符\n\n先将64位的数值转换为32位数值，然后进行位操作，最后再转换为64位数值：\n\n- 对undefined、null、NaN和Infinity应用位操作这两者会被当成0来处理\n- 对非数值，先使用Number()将其转换为数值再应用位操作\n- 按位非(NOT) : `~`，返回反码，等于原值的负数减1\n- 按位与(AND) : `&`\n- 按位或(OR) : `|`\n- 按位异或(XOR) : `^`，异或指操作的两个位均为1或均为0则返回0，一个是1一个是0则返回1\n- 左移 : `<<`，左移不会影响符号位，左移出现的空位用0填充\n- 有符号右移 : `>>`，用符号位的值来填充右移出现的空位\n- 无符号右移 : `>>>`，所有32位都向右移动（包括符号位），并用0填充右移出现的空位\n\n### 布尔操作符\n\n- 逻辑非：`!`，先将操作数转换为布尔值，然后求反\n  - 对一个对象进行逻辑非操作，返回false\n  - 对一个空字符串进行逻辑非操作，返回true\n  - 对非空字符串进行逻辑非操作，返回false\n  - 对0、null、NaN、undefined进行逻辑非操作，返回true\n  - 对任意非0数值包括Infinity进行逻辑非操作，返回false\n  - 同时使用两个逻辑非操作符`!!`，实际上模拟了Boolean()转型函数的行为，0、空字符串、null、NaN、undefined返回false\n- 逻辑与：`&&`，逻辑与操作不一定返回布尔值\n  - 如果有一个操作数是null，则返回null\n  - 如果有一个操作数是NaN，则返回NaN\n  - 如果有一个操作数是undefined，则返回undefined\n  - 如果第一个操作数是对象或者两个都是对象，返回第二个操作数\n  - 如果第二个操作数是对象，则返回第一个操作数\n  - 如果第一个操作数为false，则返回false\n- 逻辑或：`||`\n  - 如果两个操作数都是null，则返回null\n  - 如果两个操作数都是NaN，则返回NaN\n  - 如果两个操作数都是undefined，则返回undefined\n  - 如果第一个操作数是对象或者两个都是对象，返回第一个操作数\n  - 如果第一个操作数求值结果为false，则返回第二个操作数\n  - 如果第一个操作数求值结果为true，则返回第一个操作数\n\n### 乘性操作符\n\n若操作数不是数值，则后台会先使用Number()将其转换为数值再进行计算\n\n- 乘法：`*`\n  - 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity\n  - 若一个操作数为NaN，则结果为NaN\n  - Infinity * 0 等于 NaN\n  - Infinity与非0值相乘，结果还是Infinity或-Infinity\n- 除法：`/`\n  - 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity\n  - 若一个操作数为NaN，则结果为NaN\n  - Infinity / Infinity 等于 NaN\n  - Infinity被任意数值除，结果仍为Infinity\n  - 0 / 0 等于 NaN\n  - 非零数（包括Infinity）除以0结果为Infinity或-Infinity\n- 求模：`%`\n  - Infinity % 有限值 的结果为NaN\n  - 任意值 % 0 的结果为NaN\n  - Infinity % Infinity 的结果为NaN\n  - 有限大值a % Infinity 的结果为a\n  - 0 % 任意值 的结果为0\n\n### 加性操作符\n\n- 加法：`+`\n  - 如果有一个操作符为NaN，则结果为NaN\n  - Infinity加-Infinity，结果为NaN\n  - +0加+0为+0，-0加-0结果为-0\n  - +0加-0结果为+0\n  - 如果两个操作数都为字符串，则拼接起来\n  - 若有一个操作数不是数值，则将两个都转换（toString()）为字符串，然后两个字符串拼接起来\n- 减法：`-`\n  - 如果有一个操作符为NaN，则结果为NaN\n  - Infinity减Infinity或者-Infinity减-Infinity结果为NaN\n  - +0减+0为+0，+0减-0为-0，-0减-0为+0\n  - 如果有操作数为字符串、布尔值、null、undefined，则先调用Number()函数将其转换为数值，若有一个转换后为NaN，则结果为NaN\n  - 如果有操作数为对象，则调用其valueOf()方法获取其数值，若值为NaN，则结果为NaN，若没有valueOf()方法，则调用其toString()方法并将得到的字符串转化为数值\n\n### 关系操作符\n\n`<`、`>`、`<=`、`>=`\n\n- 若两个操作数都是数值则进行数值比较\n- 若两个操作数都是字符串，则比较两个字符串的字符编码值\n- 如果一个是数值，则将另一个操作数转换为一个数值，然后执行数值比较\n- 如果一个操作数是对象，则先用valueOf()换取数值进行比较，若对象没有valueOf()方法，则调用toString()，然后转换为数值进行比较\n- 如果一个操作数是布尔值，则将其转换为数值然后进行比较\n- 如果一个操作数是NaN，则返回false\n\n### 相等操作符\n\n#### 相等和不相等\n\n`==`、`!=`，先转换再比较\n\n- 如果一个操作数为布尔值，则将其转换为数值进行比较\n- 如果一个操作数是字符串，一个操作符是数值，则将字符串转换成数值再进行比较\n- 如果一个操作数是对象而另一个不是，则调用对象的valueOf()方法，用得到的数值按照前边的规则进行比较\n- null和undefined是相等的\n- 在比较相等性之前，不能将null和undefined转换成其他任何值\n- NaN和任何值（包括NaN）都不相等\n- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则`==`返回true，`!=`返回false\n\n特殊情况结果：\n\n```javascript\nnull == undefined // true\n\"NaN\" == NaN // false\n5 == NaN // fale\nNaN == NaN // false\nNaN != NaN // true\nfalse == 0 // true\ntrue == 1 // true\ntrue == 2 // false\nundefined == 0 // false\nnull == 0 // false\n\"5\" == 5 // true\n```\n\n#### 全等和不全等\n\n`===`、`!==`，仅比较不转换，首先类型相同然后值相同\n\n### 条件操作符\n\n`variable = boolean_expression ? true_value : false_value`\n\n### 赋值操作符\n\n`=`\n\n复合操作符： `*=`,`/=`,`%=`,`+=`,`-=`,`<<=`,`>>=`,`>>>=`\n\n例如复合操作符加等于`+=`：\n\n```javascript\nvar num = 10;\nnum += 5;\n```\n\n相当于：\n\n```javascript\nvar num = 10;\nnum = num + 5;\n```\n\n### 逗号操作符\n\n声明多个变量、一条语句中执行多个操作用逗号隔开；\n\n在赋值时，逗号操作符总会返回表达式中的最后一项：\n\n```javascript\nvar num = (1, 2, 6, 5, 3, 0); // num的值为0\n```\n\n## 语句\n\n### if、while、for语句\n\n即使要执行的只有一句代码也要用`{}`括起来；\n\n关于循环的块作用域后边的章节会有讲解。\n\n### do-while语句\n\n在对条件表达式求值之前，循环体内的代码至少会执行一次，这种后测试语句最常用语循环体内的代码至少要执行一次的情形。\n\n### for-in语句\n\n`for (property in expression) statement`\n\n例如：\n\n```javascript\nfor (var propName in window) {\n  console.log(propName);\n}\n```\n\n### label、break、continue语句\n\nlabel语句的语法为`label: statement`，可以由`break`和`continue`语句引用，常用与和循环语句配合使用。\n\n例子可以看[这里](https://blog.csdn.net/x386277405/article/details/78673757)\n\n### with语句\n\n**由于大量使用with语句会导致性能下降，还会给调试代码造成困难，因此开发大型应用程序时不建议使用with语句。**\n\n`with (expression) statement`，将代码的作用于设置到一个特定的对象中。\n\n例如\n\n```javascript\nvar qs = location.search.substring(1);\nvar hostName = location.hostname;\nvar url = location.href;\n```\n\n等价于\n\n```javascript\nwith (location) {\n  var qs = search.substring(1);\n  var hostName = hostname;\n  var url = href;\n}\n```\n\n### switch语句\n\n- switch语句中可以使用任何数据类型\n- 每个case的值不一定是常量，可以是变量甚至是表达式\n- switch在比较值时使用的是全等操作符，因此不会发生类型转换（例如“10”不等于10）\n\n## 函数\n\n```js\nfunction functionName(arg0, arg1, ..., argN) {\n\tstatements\n}\n```\n\n返回值不是必需的。\n\n关于参数可以看[这篇文章](https://www.cnblogs.com/hanhanhan/p/5765920.html)中的例子来理解。需要注意的是：没有传递值的命名参数自动赋予undefined值，关于引用传递可以看[这里](https://www.cnblogs.com/refe/p/5101744.html)。\n\n因为ECMAScript函数没有签名（因为其参数是由包含零或多个值的数组来表示的），因此不能像传统意义上那样实现重载。但可以通过检查传入函数的参数类型和数量进行不同的操作来模拟重载。","slug":"JavaScript学习记录一","published":1,"updated":"2018-10-10T08:38:00.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1v8000cfmagsit4nw0y","content":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p><a id=\"more\"></a><hr><h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>JavaScript是一种专门为网页交互而设计的脚本语言，由以下三个不同的部分组成：</p><ul><li>ECMAScript（发音 ek-ma-script，伪语言），由ECMA-262定义，提供核心语言功能；</li><li>文档对象模型（DOM，Document Object Model），提供访问和操作网页内容的方法和接口；</li><li>浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口；</li></ul><p>在HTML中使用JavaScript：</p><ul><li>现代Web应用一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中，放在页面内容的后边来最后加载JavaScript代码（虽然defer属性可以实现同样的效果，但是不是所有浏览器都支持这个属性，因此一般不使用这个属性）；</li></ul><h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ol><li>区分大小写</li><li><b>标识符</b>，指变量、函数、属性的名字，或函数的参数，需要满足：<ol><li>第一个字符必须是字母、下划线(_)或者一个美元符号($)</li><li>其他字符可以是数字、字母、下划线、美元符号</li><li>按照惯例，采用<strong>驼峰</strong>大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写</li><li>不能把<strong>关键字、保留字、true、false、null</strong>用作标识符</li></ol></li><li>注释，跟C++相同</li><li>以分号结尾，可以不加分号，但是不推荐</li></ol><h2 id=\"关键字和保留字\"><a href=\"#关键字和保留字\" class=\"headerlink\" title=\"关键字和保留字\"></a>关键字和保留字</h2><ul><li>关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with</li><li>保留字： abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile</li></ul><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul><li>ECMAScript的变量是松散类型（弱类型）的，无需明确的类型声明，可以用来保存任何类型的数据。</li><li>未初始化的变量值为<code>undefined</code></li><li>使用var操作符定义的变量将成为定义该变量的作用域中举局部变量</li><li>不使用var操作符定义的变量是全局变量（不推荐）</li></ul><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>ECMAScript有五种简单（基本/原始）数据类型：</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li></ul><p>和一种复杂数据类型：</p><ul><li>Object</li></ul><p>因为ECMAScript数据类型具有动态性，因此没有再定义其他数据类型的必要。</p><h3 id=\"typeof操作符\"><a href=\"#typeof操作符\" class=\"headerlink\" title=\"typeof操作符\"></a>typeof操作符</h3><p>因为typeof是操作符，因此括号不是必需的，也就是可以<code>typeof 126</code>也可以<code>typeof(126)</code>。</p><p>对一个值使用typeof操作符可能返回下列某个字符串：</p><ul><li>undefined</li><li>boolean</li><li>string</li><li>number</li><li>object</li><li>function</li></ul><h3 id=\"Undefined类型\"><a href=\"#Undefined类型\" class=\"headerlink\" title=\"Undefined类型\"></a>Undefined类型</h3><p>只有一个值——undefined。</p><p>虽然对声明未初始化的变量（假设为a）和未声明的变量（假设为b）使用typeof均返回undefined，但是对他们使用alert会得到不同的结果：</p><p>对于a : 会弹出undefined</p><p>对于b : 会返回错误Uncaught ReferenceError: b is not defined</p><p>因此建议在声明时就进行初始化，以此来分别a和b。</p><h3 id=\"Null类型\"><a href=\"#Null类型\" class=\"headerlink\" title=\"Null类型\"></a>Null类型</h3><p>只有一个值——null。</p><p>从逻辑角度来看，null值表示一个空对象指针，因此：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"object\"</span>\n</code></pre><p>因为undefined派生自null，因此ECMA-262规定<code>undefined == null</code>为true。</p><p>只要意在保存对象的变量还没有真正的保存对象，都应该让它保存为null。</p><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3><p>只有两个值——true和false。</p><p>转换为Boolean的转换规则：</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>Stirng</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非0值（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>n/a（不适用）</td><td>undefined</td></tr></tbody></table><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3><p>使用IEEE754格式表示整数和浮点数。</p><ul><li>八进制数以<code>0</code>开头如<code>070</code>表示八进制的56</li><li>十六进制数以<code>0x</code>开头如<code>0xA</code>或<code>0xa</code>表示十六进制的10</li><li>浮点数必须包含一个小数点，小数点前若为0则可以省略，但不推荐这么做</li><li>若小数点后没有跟任何数字如<code>1.</code>或本身就是一个整数如<code>1.0</code>则会被保存为整数（因为保存浮点数值需要的内存空间是整数值的两倍）</li><li>可以用科学计数法表示浮点数：例如使用<code>1.26e-9</code>表示1.26乘以10的-9次方</li><li>浮点数最高精度为17位小数，但计算精度不如整数，例如0.1加0.2的计算结果不为0.3</li><li>Number.MAX_VALUE = 1.7976931348623157e+308, 超出值转换为Infinity</li><li>Number.MIN_VALUE = 5e-324， 超出值转换为-Infinity</li><li>可以使用isFinite()函数判断一个数是否有穷</li><li>NaN, Not a Number，非数值，如任何数值除以0都会得到NaN</li><li>NaN与任何值都不相等，<code>NaN == NaN</code>返回false，因此可以用函数isNaN()判断是否为NaN，true和false可以转换为数值，因此都不是NaN，字符串无法转换为数值，因此是NaN</li><li>Number()可以将任何数据类型的非数值转换为数值，parseInt()和parseFloat()用于把字符串转换为数值</li></ul><p>Number()转换规则：</p><ul><li>true和false分别转换为1和0</li><li>数值只是简单的传入传出</li><li>null返回0</li><li>undefined返回NaN</li><li>字符串遵循以下规则：<ul><li>若字符串只包含数字，则转换为十进制数值，忽略前置0</li><li>若字符串为有效的浮点格式，如“1.1”，不包含数字、小数点、负号以外的字符，则转换为对应的浮点数，忽略前置0</li><li>若字符串为有效的十六进制格式，如“0xf”，除了其他字符外还不可以有负号，转换为相同大小的十进制整数值</li><li>若字符串是空的，则返回0</li><li>其他格式返回NaN</li></ul></li></ul><p>对于parseInt()和parseFloat()：</p><ul><li>关于前置0，我在Chrome里试了一下：<ul><li>parseInt(“070”)返回的是70，并不会看做八进制数</li><li>parseInt(070)返回的是56，看做八进制数</li></ul></li><li>有效的格式如有效的浮点格式指浮点数处于字符串开头，若字符串开头既不是数字也不是负号则不是有效格式，若以小数点开头，小数点跟有数字则是有效的浮点格式，小数点后跟的不是数字则不是有效的格式</li><li>可以指定基数（进制）为第二个参数</li></ul><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><p>由零或多个16位Unicode字符组成的字符序列，即字符串。</p><ul><li>字符串用双引号或单引号表示都是有效且没有区别的，但左右引号必须匹配。</li><li>字符串a的长度可以用它的属性<code>length</code>即<code>a.length</code>来获得。</li><li>JavaScript字符以UTF-16存储，即每个字符要么存储为2个字节，要么存储为4个字节（每个字节8位）；二String的length属性返回的是字符串中两个字节字符的数目，也就是说对于一个4个字节的字符，length会把它当做两个字符。</li><li>字符串不能修改，只能销毁再填充。</li><li>数的toString()可以传入基数（进制）为参数。</li><li>null和undefined没有toString()方法，但可以使用String()方法。</li></ul><p>字符字面量（转义序列）：</p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\\n</td><td>换行</td></tr><tr><td>\\t</td><td>制表</td></tr><tr><td>\\b</td><td>空格</td></tr><tr><td>\\r</td><td>回车</td></tr><tr><td>\\f</td><td>进纸</td></tr><tr><td>\\\\</td><td>斜杠</td></tr><tr><td>\\‘</td><td>单引号</td></tr><tr><td>\\“</td><td>双引号</td></tr><tr><td>\\xnn</td><td>以16进制代码nn表示的一个字符（其中n为0-F），例如\\x41表示“A”。</td></tr><tr><td>\\unnnn</td><td>以16进制代码nnnn表示的一个Unicode字符（其中n为0-F），\\u03a3表示希腊字符∑</td></tr></tbody></table><h3 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h3><p>对象是一组数据和功能的集合。具体的后边的章节会学到，这里就不展开了。</p><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"一元操作符\"><a href=\"#一元操作符\" class=\"headerlink\" title=\"一元操作符\"></a>一元操作符</h3><ul><li>++、–对整数、浮点数、字符串、布尔值、对象都适用<ul><li>对非数值，先使用Number()将其转换为数值再进行加减1</li></ul></li><li>+、- 同样对整数、浮点数、字符串、布尔值、对象都适用，规则和++、–的差不多</li></ul><h3 id=\"位操作符\"><a href=\"#位操作符\" class=\"headerlink\" title=\"位操作符\"></a>位操作符</h3><p>先将64位的数值转换为32位数值，然后进行位操作，最后再转换为64位数值：</p><ul><li>对undefined、null、NaN和Infinity应用位操作这两者会被当成0来处理</li><li>对非数值，先使用Number()将其转换为数值再应用位操作</li><li>按位非(NOT) : <code>~</code>，返回反码，等于原值的负数减1</li><li>按位与(AND) : <code>&amp;</code></li><li>按位或(OR) : <code>|</code></li><li>按位异或(XOR) : <code>^</code>，异或指操作的两个位均为1或均为0则返回0，一个是1一个是0则返回1</li><li>左移 : <code>&lt;&lt;</code>，左移不会影响符号位，左移出现的空位用0填充</li><li>有符号右移 : <code>&gt;&gt;</code>，用符号位的值来填充右移出现的空位</li><li>无符号右移 : <code>&gt;&gt;&gt;</code>，所有32位都向右移动（包括符号位），并用0填充右移出现的空位</li></ul><h3 id=\"布尔操作符\"><a href=\"#布尔操作符\" class=\"headerlink\" title=\"布尔操作符\"></a>布尔操作符</h3><ul><li>逻辑非：<code>!</code>，先将操作数转换为布尔值，然后求反<ul><li>对一个对象进行逻辑非操作，返回false</li><li>对一个空字符串进行逻辑非操作，返回true</li><li>对非空字符串进行逻辑非操作，返回false</li><li>对0、null、NaN、undefined进行逻辑非操作，返回true</li><li>对任意非0数值包括Infinity进行逻辑非操作，返回false</li><li>同时使用两个逻辑非操作符<code>!!</code>，实际上模拟了Boolean()转型函数的行为，0、空字符串、null、NaN、undefined返回false</li></ul></li><li>逻辑与：<code>&amp;&amp;</code>，逻辑与操作不一定返回布尔值<ul><li>如果有一个操作数是null，则返回null</li><li>如果有一个操作数是NaN，则返回NaN</li><li>如果有一个操作数是undefined，则返回undefined</li><li>如果第一个操作数是对象或者两个都是对象，返回第二个操作数</li><li>如果第二个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数为false，则返回false</li></ul></li><li>逻辑或：<code>||</code><ul><li>如果两个操作数都是null，则返回null</li><li>如果两个操作数都是NaN，则返回NaN</li><li>如果两个操作数都是undefined，则返回undefined</li><li>如果第一个操作数是对象或者两个都是对象，返回第一个操作数</li><li>如果第一个操作数求值结果为false，则返回第二个操作数</li><li>如果第一个操作数求值结果为true，则返回第一个操作数</li></ul></li></ul><h3 id=\"乘性操作符\"><a href=\"#乘性操作符\" class=\"headerlink\" title=\"乘性操作符\"></a>乘性操作符</h3><p>若操作数不是数值，则后台会先使用Number()将其转换为数值再进行计算</p><ul><li>乘法：<code>*</code><ul><li>若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity</li><li>若一个操作数为NaN，则结果为NaN</li><li>Infinity * 0 等于 NaN</li><li>Infinity与非0值相乘，结果还是Infinity或-Infinity</li></ul></li><li>除法：<code>/</code><ul><li>若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity</li><li>若一个操作数为NaN，则结果为NaN</li><li>Infinity / Infinity 等于 NaN</li><li>Infinity被任意数值除，结果仍为Infinity</li><li>0 / 0 等于 NaN</li><li>非零数（包括Infinity）除以0结果为Infinity或-Infinity</li></ul></li><li>求模：<code>%</code><ul><li>Infinity % 有限值 的结果为NaN</li><li>任意值 % 0 的结果为NaN</li><li>Infinity % Infinity 的结果为NaN</li><li>有限大值a % Infinity 的结果为a</li><li>0 % 任意值 的结果为0</li></ul></li></ul><h3 id=\"加性操作符\"><a href=\"#加性操作符\" class=\"headerlink\" title=\"加性操作符\"></a>加性操作符</h3><ul><li>加法：<code>+</code><ul><li>如果有一个操作符为NaN，则结果为NaN</li><li>Infinity加-Infinity，结果为NaN</li><li>+0加+0为+0，-0加-0结果为-0</li><li>+0加-0结果为+0</li><li>如果两个操作数都为字符串，则拼接起来</li><li>若有一个操作数不是数值，则将两个都转换（toString()）为字符串，然后两个字符串拼接起来</li></ul></li><li>减法：<code>-</code><ul><li>如果有一个操作符为NaN，则结果为NaN</li><li>Infinity减Infinity或者-Infinity减-Infinity结果为NaN</li><li>+0减+0为+0，+0减-0为-0，-0减-0为+0</li><li>如果有操作数为字符串、布尔值、null、undefined，则先调用Number()函数将其转换为数值，若有一个转换后为NaN，则结果为NaN</li><li>如果有操作数为对象，则调用其valueOf()方法获取其数值，若值为NaN，则结果为NaN，若没有valueOf()方法，则调用其toString()方法并将得到的字符串转化为数值</li></ul></li></ul><h3 id=\"关系操作符\"><a href=\"#关系操作符\" class=\"headerlink\" title=\"关系操作符\"></a>关系操作符</h3><p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></p><ul><li>若两个操作数都是数值则进行数值比较</li><li>若两个操作数都是字符串，则比较两个字符串的字符编码值</li><li>如果一个是数值，则将另一个操作数转换为一个数值，然后执行数值比较</li><li>如果一个操作数是对象，则先用valueOf()换取数值进行比较，若对象没有valueOf()方法，则调用toString()，然后转换为数值进行比较</li><li>如果一个操作数是布尔值，则将其转换为数值然后进行比较</li><li>如果一个操作数是NaN，则返回false</li></ul><h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符\"></a>相等操作符</h3><h4 id=\"相等和不相等\"><a href=\"#相等和不相等\" class=\"headerlink\" title=\"相等和不相等\"></a>相等和不相等</h4><p><code>==</code>、<code>!=</code>，先转换再比较</p><ul><li>如果一个操作数为布尔值，则将其转换为数值进行比较</li><li>如果一个操作数是字符串，一个操作符是数值，则将字符串转换成数值再进行比较</li><li>如果一个操作数是对象而另一个不是，则调用对象的valueOf()方法，用得到的数值按照前边的规则进行比较</li><li>null和undefined是相等的</li><li>在比较相等性之前，不能将null和undefined转换成其他任何值</li><li>NaN和任何值（包括NaN）都不相等</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则<code>==</code>返回true，<code>!=</code>返回false</li></ul><p>特殊情况结果：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> undefined <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token string\">\"NaN\"</span> <span class=\"token operator\">==</span> <span class=\"token number\">NaN</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token number\">5</span> <span class=\"token operator\">==</span> <span class=\"token number\">NaN</span> <span class=\"token comment\" spellcheck=\"true\">// fale</span>\n<span class=\"token number\">NaN</span> <span class=\"token operator\">==</span> <span class=\"token number\">NaN</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token number\">NaN</span> <span class=\"token operator\">!=</span> <span class=\"token number\">NaN</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token boolean\">false</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token boolean\">true</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token boolean\">true</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\nundefined <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token string\">\"5\"</span> <span class=\"token operator\">==</span> <span class=\"token number\">5</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><h4 id=\"全等和不全等\"><a href=\"#全等和不全等\" class=\"headerlink\" title=\"全等和不全等\"></a>全等和不全等</h4><p><code>===</code>、<code>!==</code>，仅比较不转换，首先类型相同然后值相同</p><h3 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h3><p><code>variable = boolean_expression ? true_value : false_value</code></p><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p><code>=</code></p><p>复合操作符： <code>*=</code>,<code>/=</code>,<code>%=</code>,<code>+=</code>,<code>-=</code>,<code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>,<code>&gt;&gt;&gt;=</code></p><p>例如复合操作符加等于<code>+=</code>：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nnum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre><p>相当于：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nnum <span class=\"token operator\">=</span> num <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"逗号操作符\"><a href=\"#逗号操作符\" class=\"headerlink\" title=\"逗号操作符\"></a>逗号操作符</h3><p>声明多个变量、一条语句中执行多个操作用逗号隔开；</p><p>在赋值时，逗号操作符总会返回表达式中的最后一项：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// num的值为0</span>\n</code></pre><h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><h3 id=\"if、while、for语句\"><a href=\"#if、while、for语句\" class=\"headerlink\" title=\"if、while、for语句\"></a>if、while、for语句</h3><p>即使要执行的只有一句代码也要用<code>{}</code>括起来；</p><p>关于循环的块作用域后边的章节会有讲解。</p><h3 id=\"do-while语句\"><a href=\"#do-while语句\" class=\"headerlink\" title=\"do-while语句\"></a>do-while语句</h3><p>在对条件表达式求值之前，循环体内的代码至少会执行一次，这种后测试语句最常用语循环体内的代码至少要执行一次的情形。</p><h3 id=\"for-in语句\"><a href=\"#for-in语句\" class=\"headerlink\" title=\"for-in语句\"></a>for-in语句</h3><p><code>for (property in expression) statement</code></p><p>例如：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> propName <span class=\"token keyword\">in</span> window<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"label、break、continue语句\"><a href=\"#label、break、continue语句\" class=\"headerlink\" title=\"label、break、continue语句\"></a>label、break、continue语句</h3><p>label语句的语法为<code>label: statement</code>，可以由<code>break</code>和<code>continue</code>语句引用，常用与和循环语句配合使用。</p><p>例子可以看<a href=\"https://blog.csdn.net/x386277405/article/details/78673757\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a></p><h3 id=\"with语句\"><a href=\"#with语句\" class=\"headerlink\" title=\"with语句\"></a>with语句</h3><p><strong>由于大量使用with语句会导致性能下降，还会给调试代码造成困难，因此开发大型应用程序时不建议使用with语句。</strong></p><p><code>with (expression) statement</code>，将代码的作用于设置到一个特定的对象中。</p><p>例如</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> qs <span class=\"token operator\">=</span> location<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> hostName <span class=\"token operator\">=</span> location<span class=\"token punctuation\">.</span>hostname<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> location<span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">;</span>\n</code></pre><p>等价于</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">with</span> <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> qs <span class=\"token operator\">=</span> search<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> hostName <span class=\"token operator\">=</span> hostname<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> href<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul><li>switch语句中可以使用任何数据类型</li><li>每个case的值不一定是常量，可以是变量甚至是表达式</li><li>switch在比较值时使用的是全等操作符，因此不会发生类型转换（例如“10”不等于10）</li></ul><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">functionName</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span> argN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    statements\n<span class=\"token punctuation\">}</span>\n</code></pre><p>返回值不是必需的。</p><p>关于参数可以看<a href=\"https://www.cnblogs.com/hanhanhan/p/5765920.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇文章</a>中的例子来理解。需要注意的是：没有传递值的命名参数自动赋予undefined值，关于引用传递可以看<a href=\"https://www.cnblogs.com/refe/p/5101744.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>因为ECMAScript函数没有签名（因为其参数是由包含零或多个值的数组来表示的），因此不能像传统意义上那样实现重载。但可以通过检查传入函数的参数类型和数量进行不同的操作来模拟重载。</p>","site":{"data":{}},"excerpt":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p>","more":"<hr><h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>JavaScript是一种专门为网页交互而设计的脚本语言，由以下三个不同的部分组成：</p><ul><li>ECMAScript（发音 ek-ma-script，伪语言），由ECMA-262定义，提供核心语言功能；</li><li>文档对象模型（DOM，Document Object Model），提供访问和操作网页内容的方法和接口；</li><li>浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口；</li></ul><p>在HTML中使用JavaScript：</p><ul><li>现代Web应用一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中，放在页面内容的后边来最后加载JavaScript代码（虽然defer属性可以实现同样的效果，但是不是所有浏览器都支持这个属性，因此一般不使用这个属性）；</li></ul><h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><ol><li>区分大小写</li><li><b>标识符</b>，指变量、函数、属性的名字，或函数的参数，需要满足：<ol><li>第一个字符必须是字母、下划线(_)或者一个美元符号($)</li><li>其他字符可以是数字、字母、下划线、美元符号</li><li>按照惯例，采用<strong>驼峰</strong>大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写</li><li>不能把<strong>关键字、保留字、true、false、null</strong>用作标识符</li></ol></li><li>注释，跟C++相同</li><li>以分号结尾，可以不加分号，但是不推荐</li></ol><h2 id=\"关键字和保留字\"><a href=\"#关键字和保留字\" class=\"headerlink\" title=\"关键字和保留字\"></a>关键字和保留字</h2><ul><li>关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with</li><li>保留字： abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile</li></ul><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul><li>ECMAScript的变量是松散类型（弱类型）的，无需明确的类型声明，可以用来保存任何类型的数据。</li><li>未初始化的变量值为<code>undefined</code></li><li>使用var操作符定义的变量将成为定义该变量的作用域中举局部变量</li><li>不使用var操作符定义的变量是全局变量（不推荐）</li></ul><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>ECMAScript有五种简单（基本/原始）数据类型：</p><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li></ul><p>和一种复杂数据类型：</p><ul><li>Object</li></ul><p>因为ECMAScript数据类型具有动态性，因此没有再定义其他数据类型的必要。</p><h3 id=\"typeof操作符\"><a href=\"#typeof操作符\" class=\"headerlink\" title=\"typeof操作符\"></a>typeof操作符</h3><p>因为typeof是操作符，因此括号不是必需的，也就是可以<code>typeof 126</code>也可以<code>typeof(126)</code>。</p><p>对一个值使用typeof操作符可能返回下列某个字符串：</p><ul><li>undefined</li><li>boolean</li><li>string</li><li>number</li><li>object</li><li>function</li></ul><h3 id=\"Undefined类型\"><a href=\"#Undefined类型\" class=\"headerlink\" title=\"Undefined类型\"></a>Undefined类型</h3><p>只有一个值——undefined。</p><p>虽然对声明未初始化的变量（假设为a）和未声明的变量（假设为b）使用typeof均返回undefined，但是对他们使用alert会得到不同的结果：</p><p>对于a : 会弹出undefined</p><p>对于b : 会返回错误Uncaught ReferenceError: b is not defined</p><p>因此建议在声明时就进行初始化，以此来分别a和b。</p><h3 id=\"Null类型\"><a href=\"#Null类型\" class=\"headerlink\" title=\"Null类型\"></a>Null类型</h3><p>只有一个值——null。</p><p>从逻辑角度来看，null值表示一个空对象指针，因此：</p><pre><code class=\"javascript\">var a = null;\nalert(typeof a); // &quot;object&quot;\n</code></pre><p>因为undefined派生自null，因此ECMA-262规定<code>undefined == null</code>为true。</p><p>只要意在保存对象的变量还没有真正的保存对象，都应该让它保存为null。</p><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3><p>只有两个值——true和false。</p><p>转换为Boolean的转换规则：</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>Stirng</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非0值（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>n/a（不适用）</td><td>undefined</td></tr></tbody></table><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3><p>使用IEEE754格式表示整数和浮点数。</p><ul><li>八进制数以<code>0</code>开头如<code>070</code>表示八进制的56</li><li>十六进制数以<code>0x</code>开头如<code>0xA</code>或<code>0xa</code>表示十六进制的10</li><li>浮点数必须包含一个小数点，小数点前若为0则可以省略，但不推荐这么做</li><li>若小数点后没有跟任何数字如<code>1.</code>或本身就是一个整数如<code>1.0</code>则会被保存为整数（因为保存浮点数值需要的内存空间是整数值的两倍）</li><li>可以用科学计数法表示浮点数：例如使用<code>1.26e-9</code>表示1.26乘以10的-9次方</li><li>浮点数最高精度为17位小数，但计算精度不如整数，例如0.1加0.2的计算结果不为0.3</li><li>Number.MAX_VALUE = 1.7976931348623157e+308, 超出值转换为Infinity</li><li>Number.MIN_VALUE = 5e-324， 超出值转换为-Infinity</li><li>可以使用isFinite()函数判断一个数是否有穷</li><li>NaN, Not a Number，非数值，如任何数值除以0都会得到NaN</li><li>NaN与任何值都不相等，<code>NaN == NaN</code>返回false，因此可以用函数isNaN()判断是否为NaN，true和false可以转换为数值，因此都不是NaN，字符串无法转换为数值，因此是NaN</li><li>Number()可以将任何数据类型的非数值转换为数值，parseInt()和parseFloat()用于把字符串转换为数值</li></ul><p>Number()转换规则：</p><ul><li>true和false分别转换为1和0</li><li>数值只是简单的传入传出</li><li>null返回0</li><li>undefined返回NaN</li><li>字符串遵循以下规则：<ul><li>若字符串只包含数字，则转换为十进制数值，忽略前置0</li><li>若字符串为有效的浮点格式，如“1.1”，不包含数字、小数点、负号以外的字符，则转换为对应的浮点数，忽略前置0</li><li>若字符串为有效的十六进制格式，如“0xf”，除了其他字符外还不可以有负号，转换为相同大小的十进制整数值</li><li>若字符串是空的，则返回0</li><li>其他格式返回NaN</li></ul></li></ul><p>对于parseInt()和parseFloat()：</p><ul><li>关于前置0，我在Chrome里试了一下：<ul><li>parseInt(“070”)返回的是70，并不会看做八进制数</li><li>parseInt(070)返回的是56，看做八进制数</li></ul></li><li>有效的格式如有效的浮点格式指浮点数处于字符串开头，若字符串开头既不是数字也不是负号则不是有效格式，若以小数点开头，小数点跟有数字则是有效的浮点格式，小数点后跟的不是数字则不是有效的格式</li><li>可以指定基数（进制）为第二个参数</li></ul><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><p>由零或多个16位Unicode字符组成的字符序列，即字符串。</p><ul><li>字符串用双引号或单引号表示都是有效且没有区别的，但左右引号必须匹配。</li><li>字符串a的长度可以用它的属性<code>length</code>即<code>a.length</code>来获得。</li><li>JavaScript字符以UTF-16存储，即每个字符要么存储为2个字节，要么存储为4个字节（每个字节8位）；二String的length属性返回的是字符串中两个字节字符的数目，也就是说对于一个4个字节的字符，length会把它当做两个字符。</li><li>字符串不能修改，只能销毁再填充。</li><li>数的toString()可以传入基数（进制）为参数。</li><li>null和undefined没有toString()方法，但可以使用String()方法。</li></ul><p>字符字面量（转义序列）：</p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\\n</td><td>换行</td></tr><tr><td>\\t</td><td>制表</td></tr><tr><td>\\b</td><td>空格</td></tr><tr><td>\\r</td><td>回车</td></tr><tr><td>\\f</td><td>进纸</td></tr><tr><td>\\\\</td><td>斜杠</td></tr><tr><td>\\‘</td><td>单引号</td></tr><tr><td>\\“</td><td>双引号</td></tr><tr><td>\\xnn</td><td>以16进制代码nn表示的一个字符（其中n为0-F），例如\\x41表示“A”。</td></tr><tr><td>\\unnnn</td><td>以16进制代码nnnn表示的一个Unicode字符（其中n为0-F），\\u03a3表示希腊字符∑</td></tr></tbody></table><h3 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h3><p>对象是一组数据和功能的集合。具体的后边的章节会学到，这里就不展开了。</p><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"一元操作符\"><a href=\"#一元操作符\" class=\"headerlink\" title=\"一元操作符\"></a>一元操作符</h3><ul><li>++、–对整数、浮点数、字符串、布尔值、对象都适用<ul><li>对非数值，先使用Number()将其转换为数值再进行加减1</li></ul></li><li>+、- 同样对整数、浮点数、字符串、布尔值、对象都适用，规则和++、–的差不多</li></ul><h3 id=\"位操作符\"><a href=\"#位操作符\" class=\"headerlink\" title=\"位操作符\"></a>位操作符</h3><p>先将64位的数值转换为32位数值，然后进行位操作，最后再转换为64位数值：</p><ul><li>对undefined、null、NaN和Infinity应用位操作这两者会被当成0来处理</li><li>对非数值，先使用Number()将其转换为数值再应用位操作</li><li>按位非(NOT) : <code>~</code>，返回反码，等于原值的负数减1</li><li>按位与(AND) : <code>&amp;</code></li><li>按位或(OR) : <code>|</code></li><li>按位异或(XOR) : <code>^</code>，异或指操作的两个位均为1或均为0则返回0，一个是1一个是0则返回1</li><li>左移 : <code>&lt;&lt;</code>，左移不会影响符号位，左移出现的空位用0填充</li><li>有符号右移 : <code>&gt;&gt;</code>，用符号位的值来填充右移出现的空位</li><li>无符号右移 : <code>&gt;&gt;&gt;</code>，所有32位都向右移动（包括符号位），并用0填充右移出现的空位</li></ul><h3 id=\"布尔操作符\"><a href=\"#布尔操作符\" class=\"headerlink\" title=\"布尔操作符\"></a>布尔操作符</h3><ul><li>逻辑非：<code>!</code>，先将操作数转换为布尔值，然后求反<ul><li>对一个对象进行逻辑非操作，返回false</li><li>对一个空字符串进行逻辑非操作，返回true</li><li>对非空字符串进行逻辑非操作，返回false</li><li>对0、null、NaN、undefined进行逻辑非操作，返回true</li><li>对任意非0数值包括Infinity进行逻辑非操作，返回false</li><li>同时使用两个逻辑非操作符<code>!!</code>，实际上模拟了Boolean()转型函数的行为，0、空字符串、null、NaN、undefined返回false</li></ul></li><li>逻辑与：<code>&amp;&amp;</code>，逻辑与操作不一定返回布尔值<ul><li>如果有一个操作数是null，则返回null</li><li>如果有一个操作数是NaN，则返回NaN</li><li>如果有一个操作数是undefined，则返回undefined</li><li>如果第一个操作数是对象或者两个都是对象，返回第二个操作数</li><li>如果第二个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数为false，则返回false</li></ul></li><li>逻辑或：<code>||</code><ul><li>如果两个操作数都是null，则返回null</li><li>如果两个操作数都是NaN，则返回NaN</li><li>如果两个操作数都是undefined，则返回undefined</li><li>如果第一个操作数是对象或者两个都是对象，返回第一个操作数</li><li>如果第一个操作数求值结果为false，则返回第二个操作数</li><li>如果第一个操作数求值结果为true，则返回第一个操作数</li></ul></li></ul><h3 id=\"乘性操作符\"><a href=\"#乘性操作符\" class=\"headerlink\" title=\"乘性操作符\"></a>乘性操作符</h3><p>若操作数不是数值，则后台会先使用Number()将其转换为数值再进行计算</p><ul><li>乘法：<code>*</code><ul><li>若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity</li><li>若一个操作数为NaN，则结果为NaN</li><li>Infinity * 0 等于 NaN</li><li>Infinity与非0值相乘，结果还是Infinity或-Infinity</li></ul></li><li>除法：<code>/</code><ul><li>若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity</li><li>若一个操作数为NaN，则结果为NaN</li><li>Infinity / Infinity 等于 NaN</li><li>Infinity被任意数值除，结果仍为Infinity</li><li>0 / 0 等于 NaN</li><li>非零数（包括Infinity）除以0结果为Infinity或-Infinity</li></ul></li><li>求模：<code>%</code><ul><li>Infinity % 有限值 的结果为NaN</li><li>任意值 % 0 的结果为NaN</li><li>Infinity % Infinity 的结果为NaN</li><li>有限大值a % Infinity 的结果为a</li><li>0 % 任意值 的结果为0</li></ul></li></ul><h3 id=\"加性操作符\"><a href=\"#加性操作符\" class=\"headerlink\" title=\"加性操作符\"></a>加性操作符</h3><ul><li>加法：<code>+</code><ul><li>如果有一个操作符为NaN，则结果为NaN</li><li>Infinity加-Infinity，结果为NaN</li><li>+0加+0为+0，-0加-0结果为-0</li><li>+0加-0结果为+0</li><li>如果两个操作数都为字符串，则拼接起来</li><li>若有一个操作数不是数值，则将两个都转换（toString()）为字符串，然后两个字符串拼接起来</li></ul></li><li>减法：<code>-</code><ul><li>如果有一个操作符为NaN，则结果为NaN</li><li>Infinity减Infinity或者-Infinity减-Infinity结果为NaN</li><li>+0减+0为+0，+0减-0为-0，-0减-0为+0</li><li>如果有操作数为字符串、布尔值、null、undefined，则先调用Number()函数将其转换为数值，若有一个转换后为NaN，则结果为NaN</li><li>如果有操作数为对象，则调用其valueOf()方法获取其数值，若值为NaN，则结果为NaN，若没有valueOf()方法，则调用其toString()方法并将得到的字符串转化为数值</li></ul></li></ul><h3 id=\"关系操作符\"><a href=\"#关系操作符\" class=\"headerlink\" title=\"关系操作符\"></a>关系操作符</h3><p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></p><ul><li>若两个操作数都是数值则进行数值比较</li><li>若两个操作数都是字符串，则比较两个字符串的字符编码值</li><li>如果一个是数值，则将另一个操作数转换为一个数值，然后执行数值比较</li><li>如果一个操作数是对象，则先用valueOf()换取数值进行比较，若对象没有valueOf()方法，则调用toString()，然后转换为数值进行比较</li><li>如果一个操作数是布尔值，则将其转换为数值然后进行比较</li><li>如果一个操作数是NaN，则返回false</li></ul><h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符\"></a>相等操作符</h3><h4 id=\"相等和不相等\"><a href=\"#相等和不相等\" class=\"headerlink\" title=\"相等和不相等\"></a>相等和不相等</h4><p><code>==</code>、<code>!=</code>，先转换再比较</p><ul><li>如果一个操作数为布尔值，则将其转换为数值进行比较</li><li>如果一个操作数是字符串，一个操作符是数值，则将字符串转换成数值再进行比较</li><li>如果一个操作数是对象而另一个不是，则调用对象的valueOf()方法，用得到的数值按照前边的规则进行比较</li><li>null和undefined是相等的</li><li>在比较相等性之前，不能将null和undefined转换成其他任何值</li><li>NaN和任何值（包括NaN）都不相等</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则<code>==</code>返回true，<code>!=</code>返回false</li></ul><p>特殊情况结果：</p><pre><code class=\"javascript\">null == undefined // true\n&quot;NaN&quot; == NaN // false\n5 == NaN // fale\nNaN == NaN // false\nNaN != NaN // true\nfalse == 0 // true\ntrue == 1 // true\ntrue == 2 // false\nundefined == 0 // false\nnull == 0 // false\n&quot;5&quot; == 5 // true\n</code></pre><h4 id=\"全等和不全等\"><a href=\"#全等和不全等\" class=\"headerlink\" title=\"全等和不全等\"></a>全等和不全等</h4><p><code>===</code>、<code>!==</code>，仅比较不转换，首先类型相同然后值相同</p><h3 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a>条件操作符</h3><p><code>variable = boolean_expression ? true_value : false_value</code></p><h3 id=\"赋值操作符\"><a href=\"#赋值操作符\" class=\"headerlink\" title=\"赋值操作符\"></a>赋值操作符</h3><p><code>=</code></p><p>复合操作符： <code>*=</code>,<code>/=</code>,<code>%=</code>,<code>+=</code>,<code>-=</code>,<code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>,<code>&gt;&gt;&gt;=</code></p><p>例如复合操作符加等于<code>+=</code>：</p><pre><code class=\"javascript\">var num = 10;\nnum += 5;\n</code></pre><p>相当于：</p><pre><code class=\"javascript\">var num = 10;\nnum = num + 5;\n</code></pre><h3 id=\"逗号操作符\"><a href=\"#逗号操作符\" class=\"headerlink\" title=\"逗号操作符\"></a>逗号操作符</h3><p>声明多个变量、一条语句中执行多个操作用逗号隔开；</p><p>在赋值时，逗号操作符总会返回表达式中的最后一项：</p><pre><code class=\"javascript\">var num = (1, 2, 6, 5, 3, 0); // num的值为0\n</code></pre><h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><h3 id=\"if、while、for语句\"><a href=\"#if、while、for语句\" class=\"headerlink\" title=\"if、while、for语句\"></a>if、while、for语句</h3><p>即使要执行的只有一句代码也要用<code>{}</code>括起来；</p><p>关于循环的块作用域后边的章节会有讲解。</p><h3 id=\"do-while语句\"><a href=\"#do-while语句\" class=\"headerlink\" title=\"do-while语句\"></a>do-while语句</h3><p>在对条件表达式求值之前，循环体内的代码至少会执行一次，这种后测试语句最常用语循环体内的代码至少要执行一次的情形。</p><h3 id=\"for-in语句\"><a href=\"#for-in语句\" class=\"headerlink\" title=\"for-in语句\"></a>for-in语句</h3><p><code>for (property in expression) statement</code></p><p>例如：</p><pre><code class=\"javascript\">for (var propName in window) {\n  console.log(propName);\n}\n</code></pre><h3 id=\"label、break、continue语句\"><a href=\"#label、break、continue语句\" class=\"headerlink\" title=\"label、break、continue语句\"></a>label、break、continue语句</h3><p>label语句的语法为<code>label: statement</code>，可以由<code>break</code>和<code>continue</code>语句引用，常用与和循环语句配合使用。</p><p>例子可以看<a href=\"https://blog.csdn.net/x386277405/article/details/78673757\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a></p><h3 id=\"with语句\"><a href=\"#with语句\" class=\"headerlink\" title=\"with语句\"></a>with语句</h3><p><strong>由于大量使用with语句会导致性能下降，还会给调试代码造成困难，因此开发大型应用程序时不建议使用with语句。</strong></p><p><code>with (expression) statement</code>，将代码的作用于设置到一个特定的对象中。</p><p>例如</p><pre><code class=\"javascript\">var qs = location.search.substring(1);\nvar hostName = location.hostname;\nvar url = location.href;\n</code></pre><p>等价于</p><pre><code class=\"javascript\">with (location) {\n  var qs = search.substring(1);\n  var hostName = hostname;\n  var url = href;\n}\n</code></pre><h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><ul><li>switch语句中可以使用任何数据类型</li><li>每个case的值不一定是常量，可以是变量甚至是表达式</li><li>switch在比较值时使用的是全等操作符，因此不会发生类型转换（例如“10”不等于10）</li></ul><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><pre><code class=\"js\">function functionName(arg0, arg1, ..., argN) {\n    statements\n}\n</code></pre><p>返回值不是必需的。</p><p>关于参数可以看<a href=\"https://www.cnblogs.com/hanhanhan/p/5765920.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇文章</a>中的例子来理解。需要注意的是：没有传递值的命名参数自动赋予undefined值，关于引用传递可以看<a href=\"https://www.cnblogs.com/refe/p/5101744.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>因为ECMAScript函数没有签名（因为其参数是由包含零或多个值的数组来表示的），因此不能像传统意义上那样实现重载。但可以通过检查传入函数的参数类型和数量进行不同的操作来模拟重载。</p>"},{"title":"JavaScript学习记录三","toc":true,"date":"2018-09-14T15:51:22.000Z","_content":"\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# 面向对象的程序设计\n\n## 创建对象\n\n### 工厂模式\n\n工厂模式是软件工程领域广为人知的一种设计模式，这种模式抽象了创建具体对象的过程。\n\n用函数来封装以特定接口创建对象的细节：\n\n```js\nfunction createPerson(name, age, job) {\n  var o = new Object;\n  o.name = name;\n  o.age = age;\n  o.jpb = job;\n  o.sayName = function() {\n    alert(this.name);\n  };\n  return o;\n}\n\nvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n\nperson1.sayName(); // \"Nicholas\"\nperson2.sayName(); // \"Greg\"\n```\n\n工厂模式虽然解决了创建多个相似对的问题，却没有解决对象识别的问题。\n\n### 构造函数模式\n\n我们可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = function() {\n    alert(this.name);\n  };\n}\n\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n\nperson1.sayName(); // \"Nicholas\"\nperson2.sayName(); // \"Greg\"\n```\n\n构造函数模式与工厂模式的区别：\n\n- 没有显示地创建对象(new Object())\n\n- 直接将属性和方法赋给了this对象\n- 没有return语句\n- 函数名首字母大写\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历4个步骤：\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给新对象（因此this指向了这个新对象）\n3. 执行构造函数中的代码（为这个新对象添加属性）\n4. 返回新对象\n\n这样通过构造函数模式创建的两个对象都有一个constructor（构造函数）属性，该属性指向Person：\n\n```js\nperson1.constructor == Person; // true\nperson1 instanceof Person; // true\nperson1 instanceof Object; // true， 因为所有对象均继承自Object\n```\n\n创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式优于工厂模式的地方。\n\n#### 将构造函数当做函数\n\n前边例子中的Person()函数可以通过下边任何一种方式来调用：\n\n```js\n// 当做构造函数使用\nvar person = new Person(\"Nicholas\", 29, \"Software Engineer\");\nperson.sayName();\n\n// 作为普通函数调用\nPerson(\"Greg\", 27, \"Doctor\"); // 添加到window\nwindow.sayName(); // \"Greg\"\n\n//在另一个对象的作用域中调用\nvar o = new Obeject();\nPerson.call(o, \"Kristen\", 25, \"Nurse\");\no.sayName(); // \"Kristen\"\n```\n\n#### 构造函数的问题\n\n使用构造函数的主要问题，是每个方法都要在每个实例上重新创建一遍，这是没有必要的，因此Person()可以像下边这样定义：\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = sayName;\n}\n\nfunction sayName() {\n  alert(this.name);\n}\n```\n\n但是这样的话，在全局作用域中定义的函数(sayName())只能被 某个对象调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就要定义很多个全局函数，这样我们自定义的引用类型就毫无封装性可言。\n\n但是这些问题可以通过使用原型模式解决。\n\n### 原型模式\n\n关于prototype可以先看[这一篇](https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html)。\n\n然后看下边这个例子：\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicolas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); // \"Nicolas\"\nvar person2 = new Person();\nperson2.sayName(); // \"Nicolas\"\n\nperson1.sayName == person2.sayName; // true\n```\n\n在原型模式下，对象调用这些属性和方法时，实际上是调用prototype的属性和方法。\n\n#### 理解原型\n\n默认情况下，所有prototype属性都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype所在函数的指针。\n\n如果person1的`__proto`指向Person的`prototype`，则\n\n```js\nPerson.prototype.isPrototypeOf(person); // true\n```\n\n当为对象实例添加一个属性时，这个属性就会屏蔽源性对象中保存的同名属性，但不会修改那个属性。\n\n如果将为对象实例添加的这个属性设为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。\n\n要想重新访问原型中的属性，可以使用delete操作符完全删除实例属性，\n\n使用hasOwnProperty()可以检测一个属性是否存在于实例中（这个方法是从Object继承来的），如果是原型属性则返回false：\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicolas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.hasOwnProperty(\"name\"); // false\n\nperson1.name = \"Greg\";\nperson1.name; // \"Greg\"————来自实例\nperson2.name; // \"Nicolas\"————来自原型\nperson1.hasOwnProperty(\"name\"); // true\nperson2.hasOwnProperty(\"name\"); // false\n\n\ndelete person1.name;\nperson1.name; // \"Nicolas\"————来自原型\nperson1.hasOwnProperty(\"name\"); // false\n\n```\n\n#### 原型与in操作符\n\nin操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。因此对于上面的例子，在person1和person2声明后，无论何时调用`\"name\" in person1`或`\"name\" in person2`都会得到true。\n\n因此，在hasOwnPrototype()返回false而使用in操作符返回true时，就说明这个属性是原型属性。\n\nin操作符还可以通过for-in循环使用，返回的是所有能通过对象访问的、可枚举的（enumerated）属性和方法。\n\n原型中不可枚举的属性和方法（即设置了[[DontEnum]]标记的属性和方法）有hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()和valueOf()，有的浏览器也为constructor和prototype打上标记，\n\n但是当我们在实例中添加这些属性和方法从而屏蔽了原型中的这些属性和方法时，那么这些属性和方法就会被认为是可枚举的（IE中除外）：\n\n```js\nvar o = {\n  toString: function() {\n    return \"My Object\";\n  }\n};\n\nfor (var prop in o) {\n  if (prop == \"toString\") {\n    alert(\"Found toString\"); // 在IE中不会显示，其他浏览器显示\n  }\n}\n```\n\n#### 更简单的原型方法\n\n每添加一个属性和方法就要敲一遍Person.prototype是不必要的，同事也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：\n\n```js\nfunction Person() {}\nPerson.prototype = {\n  /* 重写prototype会导致其constructor等于Object，\n   * 若constructor的值很重要，可以给constructor设置回适当的值\n   */\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  sayName: function(){\n    alert(this.name);\n  }\n};\nvar person = new Person();\nperson.constructor == Person;\n// 若是添加了上边constructor那一句则为true\n```\n\n#### 原型的动态性\n\n由于在原型中查找值的过程是一次搜索，因此对原型对象的修改都能够立即从实例中反映出来，\n\n但是如果像上边的例子一样重写了原型，在重写原型之前声明的实例的`__proto__`指向的仍是最初的原型：\n\n```js\nfunction Person() {}\n\nvar person = new Person();\n\nPerson.prototype.sayHi = function() {\n  alert(\"hi\");\n};\n\nperson.sayHi(); // \"hi\"，没有问题\n\nPerson.prototype = {\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nperson.sayHi(); // \"hi\"，没有问题\nperson.sayName(); //error\n```\n\n#### 原生对象的原型\n\n所有原生的引用类型，都是采用原型模式创建的。因此我们亦可以对原生引用类型的prototype添加属性或方法。\n\n以String为例：\n\n```js\nString.prototype.startsWith = function(text) {\n  return this.indexOf(text) == 0;\n};\n\nvar msg = \"Hello World!\";\nmsg.startsWith(\"Hello\"); // true\n```\n\n但是不建议在产品化的程序中修改原生对象的原型。\n\n#### 原型对象的问题\n\n如果一个原型的属性包含引用类型值时，实例对该属性进行操作时，实际上修改的就是原型中的属性（引用类型对象名可以看做指针），因此当其他实例访问该属性时，得到的就是这个实例修改后的值：\n\n```js\nfunction Person() {}\n\nPerson.prototype = {\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  friends: [\"Shelby\", \"Court\"], // 属性值为引用类型\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"Van\");\n\nperson1.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson2.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson1.friends == person2.friends; // true\n```\n\n### 组合使用构造函数模式和原型模式\n\n使用构造函数模式定义实例属性，原型模式定义方法和共享的属性，\n\n这样每个实例都会有自已的一份实例属性的副本，又共享着对方法的引用，最大限度地节省了内存，还可以向构造函数传递参数：\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.friends = [\"Shelby\", \"Court\"];\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n\nperson1.friends.push(\"Van\");\n\nperson1.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson2.friends; // [\"Shelby\", \"Court\"]\nperson1.friends == person2.friends; // false\nperson1.sayName == person2.sayName; // true\n```\n\n这种混合使用的模式是ECMAScript中使用最广泛、认同度最高的自定义类型的方法。可以说是一种默认模式。\n\n### 动态原型模式\n\n这种模式把所有信息都封装在了构造函数中，并在构造函数中通过检查某个应该存在的方法是否有效，来决定是否需要初始化模型：\n\n```js\nfunction Person(name, age, job) {\n  // 属性\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  \n  // 方法\n  // 只有在sayName()方法不存在时才将其添加到原型中\n  // 即只有在初次调用构造函数时才会执行下面的代码\n  // if语句只需要判断一个方法（例如sayName）是否存在\n  if (typeof this.sayName != \"function\") {\n    Person.prototype = {\n      constructor: Person,\n      sayName: function() {\n      alert(this.name);\n      },\n      sayHi: function() {\n      alert(\"hi\");\n      }\n    };\n  }\n}\n```\n\n### 其他构造函数模式\n\n寄生构造函数模式和[稳妥构造函数模式](https://blog.csdn.net/zqs111/article/details/50650324)，寄生构造模式没有什么意义这里就不再赘述，稳妥构造函数模式相当于为引用类型添加了private属性，有兴趣可以自行搜索。\n\n## 继承\n\n在ECMAScript中无法实现接口继承（与函数无法重载的理由相同，ECMAScript中的函数没有签名），\n\n但是可以利用原型链实现实现继承。\n\n### 原型链\n\n除了[这一篇](https://blog.zmj97.top/2018/09/04/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto/)讲到的，还应注意：\n\n- 别忘记默认的原型：Object.prototype\n- 确认原型和实例的关系：利用`instanceof`和`isPrototypeOf()`\n- 谨慎地定义方法\n  - 给原型添加方法的代码一定要放在替换原型的语句之后\n  - 在通过原型链实现继承时，不同通过对象字面量创建原型方法（重写原型会切断原型链）\n- 原型链的问题\n  - 与原型的问题相同，如果原型包含引用类型值，那么所有同一个继承类型的实例都会共享一个引用类型值\n  - 在创建子类型的实例时，不能像超类型的构造函数传递参数\n\n### 借用构造函数\n\n又叫伪造继承或经典继承。\n\n在子类型构造函数得到内部利用调用超类型的构造函数，还可以传递参数。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\nfunction SubType() {\n  // 继承了SuperType，同时还传递了参数\n  SuperType.call(this, \"Nicholas\");\n  // 实例属性\n  this.age = 29;\n}\n\nvar instance = new SubType();\ninstance.name; // \"Nicholas\"\ninstance.age; // 29\n```\n\n但是如果方法都在构造函数中定义，函数复用就无从谈起了。\n\n### 组合继承\n\ncombination inheritance，伪经典继承，组合使用原型链和借用构造函数。\n\n使用原型链实现原型属性和方法的继承，通过借用构造函数实现实例属性的继承，\n\n这样既可以实现函数复用，又能保证每个实例都有它自己的属性。\n\n同时，`instanceof`和`isPrototypeOf`也能识别基于组合继承创建的对象。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"green\", \"blue\"];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\ninstance1.colors; // [\"red\", \"green\", \"blue\", \"black\"]\ninstance1.sayName(); // \"Nicholas\"\ninstance1.sayAge(); // 29\n\nvar instance2 = new SubType(\"Greg\", 27);\ninstance1.colors; // [\"red\", \"green\", \"blue]\ninstance1.sayName(); // \"Greg\"\ninstance1.sayAge(); // 27\n```\n\n组合继承融合了前两者的优点，因此成为JavaScript中最常用的继承模式。\n\n### 原型式继承\n\n主要用于只是想让一个对象与另一个对象保持类似，没有必要兴师动众地创建构造函数。\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n```\n\n这样子实际上是object()函数对传入的对象执行了一次浅复制：\n\n```js\nvar person = {\n  name: \"Nicholas\",\n  friends: [\"Shelby\", \"Court\", \"Van\"];\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\n\nperson.friends; // [\"Shelby\", \"Court\", \"Van\", \"Rob\"]\nperson.name; // \"Nicholas\"\nanotherPerson.name; // \"Greg\"\n```\n\n### 寄生式继承\n\n寄生式，parasitic。\n\n思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象。\n\n但是也会因为做不到函数复用而降低效率。\n\n适用于主要考虑对象而不是自定义类型和构造函数的情况：\n\n```js\nfunction createAnother(original) {\n  // 通过调用函数创建一个新对象，不一定使用object()函数\n  var clone = object(original);\n  // 以某种方式增强这个对象\n  clone.sayHi = function() {\n    alert(\"hi\");\n  };\n  // 返回这个对象\n  return clone;\n}\n\nvar person = {\n  name: \"Nicholas\",\n  friends: [\"Shelby\", \"Court\", \"Van\"];\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); // \"hi\"\n```\n\n### 寄生组合式继承\n\n对于为什么要寄生组合式继承，看了[这篇](https://www.cnblogs.com/ghostwu/p/7440691.html)文章还有知乎上的一些回答，主要的优势是组合继承两次调用了构造函数，而寄生只使用了一次。\n\n刚开始不理解的是，为什么在创建超类型原型副本时对超类型原型的实例化就不算调用构造函数呢？\n\n后来仔细想了一下，的确可以不算调用了构造函数——\n\nobject()函数内的临时类型F的构造函数为空（`function F() {}`），因此可以忽略不计。\n\n以下是代码：\n\n```js\nfunction object(o) {\n  // 主要区别就是这里，构造函数的不同\n  function F() {} \n  F.prototype = o;\n  return new F();\n}\n\nfunction inheritPrototype(subType, superType) {\n  var prototype = object(superType.prototype); // 拷贝原型\n  prototype.constructor = subType; // 弥补因重写prototype而失去的默认的constructor属性\n  subType.prototype = prototype; // 替换子类型原型\n}\n\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"green\", \"blue\"];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 寄生组合式继承\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n```\n\n# 匿名函数\n\n没有名字的函数，也成为拉姆达(lamda)函数。\n\n像\n\n```js\nvar functionName = function(arg0, arg1, arg2) {\n  // 函数体\n}\n```\n\n这样的函数表达式相当于创建了一个匿名函数，然后将这个匿名函数赋给一个变量。\n\n将函数作为参数传入另一个函数，或者从一个函数中返回另一个函数时，通常都是用匿名函数。\n\n## 递归\n\n（虽然不知道为什么这本书要在这里再讲一遍这个，也许可能意思是callee指向的实际上是匿名函数，不管怎么样复习一下callee吧）\n\n前边在讲到函数内部对象arguments的属性callee(指向拥有这个arguments的函数)时有提到过递归阶乘函数这个例子：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 建议\n    // return num * factorial(num-1);   // 不建议\n  }\n}\n\nvar anotherFactorial = factorial;\nfactorial = null;\nanotherFactorial(4);\n// 使用callee这里结果为24， 函数内使用factorial这里会出错\n```\n\n## 闭包\n\n有些人会分不清**闭包**和**匿名函数**。\n\n**闭包**指的是有权访问另一个函数作用域的函数。\n\n创建闭包的常见方式是在一个函数内部创建另一个函数。\n\n### 作用域链\n\n首先先回顾一下作用域链（scope chain）。\n\n当一个函数第一次被调用时，会创建一个执行环境（execute context）及相应的作用域链，并将作用域链赋值给一个特殊的内部属性[[Scope]]。\n\n然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。\n\n这个活动对象处于作用域链的顶端，外部函数的活动对象处于第二位，外部函数的外部函数的活动对象处于第三位，... ... 直到全局执行环境的变量对象处于作用域链终点。\n\n一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。\n\n**但是，闭包的情况又有所不同。**\n\n在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中，当外部函数执行完毕后，如果内部的这个函数还未执行，即其作用域链还在引用外部函数的活动对象时，这个活动对象就不会被销毁。\n\n知道内部的这个函数执行完毕，外部函数的活动对象才会随之一起销毁。\n\n由于闭包会携带包含它的函数的作用域，因此回比其它函数占用更多内存，因此建议只有在必要时再考虑使用闭包。\n\n### 闭包与变量\n\n作用域链的这种配置机制有一个副作用：闭包只能取得包含函数的任何变量的最后一个值。\n\n```js\nfunction createFunctions() {\n  var result = new Array();\n  \n  for (var i = 0; i < 10; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  \n  return result;\n}\n\nvar funcs = createFunctions();\n\n// 每个函数都输出10\nfor (var i = 0; i < funcs.length; i++) {\n  document.write(funcs[i]() + \"<br />\");\n}\n```\n\n因为每个函数的作用域链都保存着createFunctions()的活动对象，因此它们引用的都是同一个变量i，\n\n当createFunctions()函数返回后，变量i的值为10，\n\n所以每个函数内部的i都是10。\n\n可以通过创建另一个匿名函数强制让闭包行为符合预期：\n\n```js\nfor (var i = 0; i < 10; i++) {\n    result[i] = (function(num) {\n      return function(){\n        return num;\n      };\n    })(i);\n  }\n```\n\n在这里，定义了一个立即执行的匿名函数，并将它的结果赋给数组。\n\n在立即执行时，传入了变量i，又因为函数参数是按值传递的，因此就会将i的当前值赋给num。\n\n而这个函数内部，又创建并返回了一个访问num的闭包。\n\n这样，result数组中每个函数都有一个自己的num变量的副本，就可以返回不同的值了。\n\n### 关于this对象\n\n在闭包中使用this对象也可能导致一些问题。\n\nthis对象是在运行时基于函数的运行环境绑定的：\n\n- 在全局函数中，this等于window\n- 当函数被作为某个对象的方法调用时，this等于那个对象\n\n匿名函数的执行环境具有全局性，如果通过call()或者apply()改变环境执行环境，this会指向其他环境，但通常this指向window。\n\narguments也有同样的问题，\n\n因此如果想访问作用域中的this和arguments对象，必须将对它们的引用保存到另一个闭包能够访问的变量中，然后就可以让闭包访问该对象了，以this为例：\n\n```js\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n  \n  getNameFunc1: function() {\n    return function() {\n      return this.name;\n    }\n  },\n  getNameFunc2: function() {\n    var that = this;\n    return function() {\n      return that.name;\n    }\n  }\n};\n\nobject.getNameFunc1(); // \"The Window\"\nobject.getNameFunc2(); // \"My Object\"\n```\n\n### 内存泄露\n\n由于IE对JScript对象和COM（组件对象模型）对象**使用不同的垃圾收集例程**，因此闭包在IE中可能会导致问题。\n\n如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁：\n\n```js\nfunction assignHansdler() {\n  var element = document.getElementById(\"someElement\");\n  element.onclick = function() {\n    alert(element.id);\n  };\n}\n```\n\n以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。\n\n由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。\n\n只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远都不会被回收。\n\n可以用如下方式解决：\n\n```js\nfunction assignHansdler() {\n  var element = document.getElementById(\"someElement\");\n  var id = element.id;\n  \n  element.onclick = function() {\n    alert(id);\n  };\n  \n  element = null;\n}\n```\n\n这样就消除了循环引用。\n\n需要注意的是，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。\n\n因此 ，有必要把element设为null。\n\n## 模仿块级作用域\n\nJavaScript在遇到多次声明一个变量的情况时，会自动忽略后边的声明，但是会执行后边声明中的初始化。\n\nJavaScript没有块级作用域的概念，\n\n因此块语句中定义的变量，实际上是在包含函数中而不是语句中创建的。\n\n可以用匿名函数来模仿块级作用域（私有作用域）来避免这个问题：\n\n```js\n(function() {\n  // 块级作用域\n})();\n```\n\n需要注意的是，JavaScript将function当做一个函数声明的开始，而函数声明后边是不能跟括号的。\n\n因此上边代码中函数外面包括的括号不能省略。这样可以把函数声明转换成函数表达式。\n\n无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。\n\n在匿名函数中的任何变量，都会在执行结束时销毁。\n\n我们应该通过创造私有作用域来尽量少地向全局作用域添加变量和函数，以免导致命名冲突。\n\n## 私有变量\n\n除了前边提到的稳妥构造函数模式，还可以：\n\n在构造函数中定义特权方法：\n\n```js\nfunction MyObject() {\n  // 函数的私有变量\n  var privateVariable = 10;\n  // 函数的私有函数\n  function privateFunction() {\n    return false;\n  }\n  // 特权方法\n  this.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n}\n```\n\n在创建MyObject实例后，除了publicMethod没有任何方法可以直接访问privateVariable和privateFunction()。\n\n或者利用私有和特权成员，隐藏那些不应该被直接修改的数据：\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\nvar person = new Person(\"Nicholas\");\nperson.getName(); // \"Nicholas\"\nperson.setName(\"Greg\");\nperson.getName(); // \"Greg\"\n```\n\n私有变量name在每一个实例的作用域中都不相同，因为每次调用构造函数都会重新创建这两个方法。\n\n但是这样使用构造函数会有构造函数模式的缺陷：无法方法复用。每次创建实例都会创建同样一组方法，用静态私有变量来实现特权方法就可以解决这个问题。\n\n### 静态私有变量\n\n```js\n(function() {\n  var name = \"\";\n  // 没有使用var声明，因此为全局变量\n  Person = function(value) {\n    name = value;\n  }\n  Person.prototype.getName = function() {\n    return name;\n  }\n  Person.prototype.setName = function(value) {\n    name = value;\n  }\n})();\n\nvar person1 = new Person(\"Nicholas\");\nperson1.getName(); // \"NIcholas\"\nperson1.setName(\"Greg\");\nperson1.getName(); // \"Greg\"\n\nvar person2 = new Person(\"MIchael\");\nperson1.getName(); // \"MIchael\"\nperson2.getName(); // \"MIchael\"\n```\n\n在这种模式下，name就变成了静态的、由所有实例共享的属性。\n\n因此每次改变name改变的是所有实例的name。\n\n这样创造静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。\n\n因此使用哪个方法还要视具体情况而定。\n\n> 多查找作用域链的一个层次会一定程度上影响查找速度，这正是闭包和私有变量的一个明显的不足之处。\n\n对于私有变量，我认为可以使用两者组合的模式，不知道对不对，这里贴出想法，欢迎指正（zmj原创，转载需注明出处）：\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\n(function() {\n  var teacher = \"Nicholas\"; // 初始化\n  Person.prototype.getTeacher = function() {\n    return teacher;\n  }\n  Person.prototype.setTeacher = function(value) {\n    teacher = value;\n  }\n})();\n```\n\n这样，就既有实例自己的私有变量，也有静态私有变量了。\n\n### 模块模式\n\n模块模式（module pattern）是为单例（singleton）创建私有变量和私有方法。\n\n所谓单例就是只有一个实例的对象，一般以对象字面量的方式来创建：\n\n```js\nvar singleton = {\n  name: value,\n  method: function() {\n    // 这里是方法的代码\n  }\n};\n```\n\n模块模式通过为单例添加私有变量和特权方法来使其增强：\n\n```js\nvar singleton = function() {\n  // 私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  \n  // 特权/公有方法和属性\n  return {\n    publicProperty: true,\n    publicMethod: function() {\n      privateVariable++;\n      return privateFunction();\n    }\n  };\n}();\n```\n\n这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是十分有用的：\n\n```js\nfunction BaseComponent() {}\nfunction OtherComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 公共\n  return {\n    getComponentCount: function() {\n      return components.length;\n    },\n    registerComponent: function(component) {\n      if (typeof component == \"object\") {\n        components.push(component);\n      }\n    }\n  };\n}();\n\napplication.registerComponent(new OtherComponent());\napplication.getComponentCount(); // 2\n```\n\n在Web应用程序中，经常使用一个单例来管理应用程序级的信息。\n\n以这种模式创建的单例都是Object的实例。\n\n### 增强的模块模式\n\n如果单例必须是某种类型的实例，还必须添加某些属性和/或方法加以增强，可以使用增强的模块模式：\n\n```js\nfunction BaseComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 创造application的一个局部副本\n  var app = new BaseComponent();\n  // 公共接口\n  app.getComponentCount: function() {\n    return components.length;\n  }；\n  app.registerComponent: function(component) {\n    if (typeof component == \"object\") {\n      components.push(component);\n    }\n  }；\n  // 返回这个副本\n  return app;\n}();\n```\n\n","source":"_posts/JavaScript学习记录三.md","raw":"---\ntitle: JavaScript学习记录三\ntoc: true\ndate: 2018-09-14 23:51:22\ncategories:\n- Web\ntags:\n- JavaScript\n---\n\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# 面向对象的程序设计\n\n## 创建对象\n\n### 工厂模式\n\n工厂模式是软件工程领域广为人知的一种设计模式，这种模式抽象了创建具体对象的过程。\n\n用函数来封装以特定接口创建对象的细节：\n\n```js\nfunction createPerson(name, age, job) {\n  var o = new Object;\n  o.name = name;\n  o.age = age;\n  o.jpb = job;\n  o.sayName = function() {\n    alert(this.name);\n  };\n  return o;\n}\n\nvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n\nperson1.sayName(); // \"Nicholas\"\nperson2.sayName(); // \"Greg\"\n```\n\n工厂模式虽然解决了创建多个相似对的问题，却没有解决对象识别的问题。\n\n### 构造函数模式\n\n我们可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = function() {\n    alert(this.name);\n  };\n}\n\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n\nperson1.sayName(); // \"Nicholas\"\nperson2.sayName(); // \"Greg\"\n```\n\n构造函数模式与工厂模式的区别：\n\n- 没有显示地创建对象(new Object())\n\n- 直接将属性和方法赋给了this对象\n- 没有return语句\n- 函数名首字母大写\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历4个步骤：\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给新对象（因此this指向了这个新对象）\n3. 执行构造函数中的代码（为这个新对象添加属性）\n4. 返回新对象\n\n这样通过构造函数模式创建的两个对象都有一个constructor（构造函数）属性，该属性指向Person：\n\n```js\nperson1.constructor == Person; // true\nperson1 instanceof Person; // true\nperson1 instanceof Object; // true， 因为所有对象均继承自Object\n```\n\n创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式优于工厂模式的地方。\n\n#### 将构造函数当做函数\n\n前边例子中的Person()函数可以通过下边任何一种方式来调用：\n\n```js\n// 当做构造函数使用\nvar person = new Person(\"Nicholas\", 29, \"Software Engineer\");\nperson.sayName();\n\n// 作为普通函数调用\nPerson(\"Greg\", 27, \"Doctor\"); // 添加到window\nwindow.sayName(); // \"Greg\"\n\n//在另一个对象的作用域中调用\nvar o = new Obeject();\nPerson.call(o, \"Kristen\", 25, \"Nurse\");\no.sayName(); // \"Kristen\"\n```\n\n#### 构造函数的问题\n\n使用构造函数的主要问题，是每个方法都要在每个实例上重新创建一遍，这是没有必要的，因此Person()可以像下边这样定义：\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = sayName;\n}\n\nfunction sayName() {\n  alert(this.name);\n}\n```\n\n但是这样的话，在全局作用域中定义的函数(sayName())只能被 某个对象调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就要定义很多个全局函数，这样我们自定义的引用类型就毫无封装性可言。\n\n但是这些问题可以通过使用原型模式解决。\n\n### 原型模式\n\n关于prototype可以先看[这一篇](https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html)。\n\n然后看下边这个例子：\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicolas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); // \"Nicolas\"\nvar person2 = new Person();\nperson2.sayName(); // \"Nicolas\"\n\nperson1.sayName == person2.sayName; // true\n```\n\n在原型模式下，对象调用这些属性和方法时，实际上是调用prototype的属性和方法。\n\n#### 理解原型\n\n默认情况下，所有prototype属性都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype所在函数的指针。\n\n如果person1的`__proto`指向Person的`prototype`，则\n\n```js\nPerson.prototype.isPrototypeOf(person); // true\n```\n\n当为对象实例添加一个属性时，这个属性就会屏蔽源性对象中保存的同名属性，但不会修改那个属性。\n\n如果将为对象实例添加的这个属性设为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。\n\n要想重新访问原型中的属性，可以使用delete操作符完全删除实例属性，\n\n使用hasOwnProperty()可以检测一个属性是否存在于实例中（这个方法是从Object继承来的），如果是原型属性则返回false：\n\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicolas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.hasOwnProperty(\"name\"); // false\n\nperson1.name = \"Greg\";\nperson1.name; // \"Greg\"————来自实例\nperson2.name; // \"Nicolas\"————来自原型\nperson1.hasOwnProperty(\"name\"); // true\nperson2.hasOwnProperty(\"name\"); // false\n\n\ndelete person1.name;\nperson1.name; // \"Nicolas\"————来自原型\nperson1.hasOwnProperty(\"name\"); // false\n\n```\n\n#### 原型与in操作符\n\nin操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。因此对于上面的例子，在person1和person2声明后，无论何时调用`\"name\" in person1`或`\"name\" in person2`都会得到true。\n\n因此，在hasOwnPrototype()返回false而使用in操作符返回true时，就说明这个属性是原型属性。\n\nin操作符还可以通过for-in循环使用，返回的是所有能通过对象访问的、可枚举的（enumerated）属性和方法。\n\n原型中不可枚举的属性和方法（即设置了[[DontEnum]]标记的属性和方法）有hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()和valueOf()，有的浏览器也为constructor和prototype打上标记，\n\n但是当我们在实例中添加这些属性和方法从而屏蔽了原型中的这些属性和方法时，那么这些属性和方法就会被认为是可枚举的（IE中除外）：\n\n```js\nvar o = {\n  toString: function() {\n    return \"My Object\";\n  }\n};\n\nfor (var prop in o) {\n  if (prop == \"toString\") {\n    alert(\"Found toString\"); // 在IE中不会显示，其他浏览器显示\n  }\n}\n```\n\n#### 更简单的原型方法\n\n每添加一个属性和方法就要敲一遍Person.prototype是不必要的，同事也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：\n\n```js\nfunction Person() {}\nPerson.prototype = {\n  /* 重写prototype会导致其constructor等于Object，\n   * 若constructor的值很重要，可以给constructor设置回适当的值\n   */\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  sayName: function(){\n    alert(this.name);\n  }\n};\nvar person = new Person();\nperson.constructor == Person;\n// 若是添加了上边constructor那一句则为true\n```\n\n#### 原型的动态性\n\n由于在原型中查找值的过程是一次搜索，因此对原型对象的修改都能够立即从实例中反映出来，\n\n但是如果像上边的例子一样重写了原型，在重写原型之前声明的实例的`__proto__`指向的仍是最初的原型：\n\n```js\nfunction Person() {}\n\nvar person = new Person();\n\nPerson.prototype.sayHi = function() {\n  alert(\"hi\");\n};\n\nperson.sayHi(); // \"hi\"，没有问题\n\nPerson.prototype = {\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nperson.sayHi(); // \"hi\"，没有问题\nperson.sayName(); //error\n```\n\n#### 原生对象的原型\n\n所有原生的引用类型，都是采用原型模式创建的。因此我们亦可以对原生引用类型的prototype添加属性或方法。\n\n以String为例：\n\n```js\nString.prototype.startsWith = function(text) {\n  return this.indexOf(text) == 0;\n};\n\nvar msg = \"Hello World!\";\nmsg.startsWith(\"Hello\"); // true\n```\n\n但是不建议在产品化的程序中修改原生对象的原型。\n\n#### 原型对象的问题\n\n如果一个原型的属性包含引用类型值时，实例对该属性进行操作时，实际上修改的就是原型中的属性（引用类型对象名可以看做指针），因此当其他实例访问该属性时，得到的就是这个实例修改后的值：\n\n```js\nfunction Person() {}\n\nPerson.prototype = {\n  constructor: Person,\n  name: \"Nicholas\",\n  age: 29,\n  job: \"Software Engineer\",\n  friends: [\"Shelby\", \"Court\"], // 属性值为引用类型\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"Van\");\n\nperson1.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson2.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson1.friends == person2.friends; // true\n```\n\n### 组合使用构造函数模式和原型模式\n\n使用构造函数模式定义实例属性，原型模式定义方法和共享的属性，\n\n这样每个实例都会有自已的一份实例属性的副本，又共享着对方法的引用，最大限度地节省了内存，还可以向构造函数传递参数：\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.friends = [\"Shelby\", \"Court\"];\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n\nperson1.friends.push(\"Van\");\n\nperson1.friends; // [\"Shelby\", \"Court\", \"Van\"]\nperson2.friends; // [\"Shelby\", \"Court\"]\nperson1.friends == person2.friends; // false\nperson1.sayName == person2.sayName; // true\n```\n\n这种混合使用的模式是ECMAScript中使用最广泛、认同度最高的自定义类型的方法。可以说是一种默认模式。\n\n### 动态原型模式\n\n这种模式把所有信息都封装在了构造函数中，并在构造函数中通过检查某个应该存在的方法是否有效，来决定是否需要初始化模型：\n\n```js\nfunction Person(name, age, job) {\n  // 属性\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  \n  // 方法\n  // 只有在sayName()方法不存在时才将其添加到原型中\n  // 即只有在初次调用构造函数时才会执行下面的代码\n  // if语句只需要判断一个方法（例如sayName）是否存在\n  if (typeof this.sayName != \"function\") {\n    Person.prototype = {\n      constructor: Person,\n      sayName: function() {\n      alert(this.name);\n      },\n      sayHi: function() {\n      alert(\"hi\");\n      }\n    };\n  }\n}\n```\n\n### 其他构造函数模式\n\n寄生构造函数模式和[稳妥构造函数模式](https://blog.csdn.net/zqs111/article/details/50650324)，寄生构造模式没有什么意义这里就不再赘述，稳妥构造函数模式相当于为引用类型添加了private属性，有兴趣可以自行搜索。\n\n## 继承\n\n在ECMAScript中无法实现接口继承（与函数无法重载的理由相同，ECMAScript中的函数没有签名），\n\n但是可以利用原型链实现实现继承。\n\n### 原型链\n\n除了[这一篇](https://blog.zmj97.top/2018/09/04/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto/)讲到的，还应注意：\n\n- 别忘记默认的原型：Object.prototype\n- 确认原型和实例的关系：利用`instanceof`和`isPrototypeOf()`\n- 谨慎地定义方法\n  - 给原型添加方法的代码一定要放在替换原型的语句之后\n  - 在通过原型链实现继承时，不同通过对象字面量创建原型方法（重写原型会切断原型链）\n- 原型链的问题\n  - 与原型的问题相同，如果原型包含引用类型值，那么所有同一个继承类型的实例都会共享一个引用类型值\n  - 在创建子类型的实例时，不能像超类型的构造函数传递参数\n\n### 借用构造函数\n\n又叫伪造继承或经典继承。\n\n在子类型构造函数得到内部利用调用超类型的构造函数，还可以传递参数。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\nfunction SubType() {\n  // 继承了SuperType，同时还传递了参数\n  SuperType.call(this, \"Nicholas\");\n  // 实例属性\n  this.age = 29;\n}\n\nvar instance = new SubType();\ninstance.name; // \"Nicholas\"\ninstance.age; // 29\n```\n\n但是如果方法都在构造函数中定义，函数复用就无从谈起了。\n\n### 组合继承\n\ncombination inheritance，伪经典继承，组合使用原型链和借用构造函数。\n\n使用原型链实现原型属性和方法的继承，通过借用构造函数实现实例属性的继承，\n\n这样既可以实现函数复用，又能保证每个实例都有它自己的属性。\n\n同时，`instanceof`和`isPrototypeOf`也能识别基于组合继承创建的对象。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"green\", \"blue\"];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\ninstance1.colors; // [\"red\", \"green\", \"blue\", \"black\"]\ninstance1.sayName(); // \"Nicholas\"\ninstance1.sayAge(); // 29\n\nvar instance2 = new SubType(\"Greg\", 27);\ninstance1.colors; // [\"red\", \"green\", \"blue]\ninstance1.sayName(); // \"Greg\"\ninstance1.sayAge(); // 27\n```\n\n组合继承融合了前两者的优点，因此成为JavaScript中最常用的继承模式。\n\n### 原型式继承\n\n主要用于只是想让一个对象与另一个对象保持类似，没有必要兴师动众地创建构造函数。\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n```\n\n这样子实际上是object()函数对传入的对象执行了一次浅复制：\n\n```js\nvar person = {\n  name: \"Nicholas\",\n  friends: [\"Shelby\", \"Court\", \"Van\"];\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\n\nperson.friends; // [\"Shelby\", \"Court\", \"Van\", \"Rob\"]\nperson.name; // \"Nicholas\"\nanotherPerson.name; // \"Greg\"\n```\n\n### 寄生式继承\n\n寄生式，parasitic。\n\n思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象。\n\n但是也会因为做不到函数复用而降低效率。\n\n适用于主要考虑对象而不是自定义类型和构造函数的情况：\n\n```js\nfunction createAnother(original) {\n  // 通过调用函数创建一个新对象，不一定使用object()函数\n  var clone = object(original);\n  // 以某种方式增强这个对象\n  clone.sayHi = function() {\n    alert(\"hi\");\n  };\n  // 返回这个对象\n  return clone;\n}\n\nvar person = {\n  name: \"Nicholas\",\n  friends: [\"Shelby\", \"Court\", \"Van\"];\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); // \"hi\"\n```\n\n### 寄生组合式继承\n\n对于为什么要寄生组合式继承，看了[这篇](https://www.cnblogs.com/ghostwu/p/7440691.html)文章还有知乎上的一些回答，主要的优势是组合继承两次调用了构造函数，而寄生只使用了一次。\n\n刚开始不理解的是，为什么在创建超类型原型副本时对超类型原型的实例化就不算调用构造函数呢？\n\n后来仔细想了一下，的确可以不算调用了构造函数——\n\nobject()函数内的临时类型F的构造函数为空（`function F() {}`），因此可以忽略不计。\n\n以下是代码：\n\n```js\nfunction object(o) {\n  // 主要区别就是这里，构造函数的不同\n  function F() {} \n  F.prototype = o;\n  return new F();\n}\n\nfunction inheritPrototype(subType, superType) {\n  var prototype = object(superType.prototype); // 拷贝原型\n  prototype.constructor = subType; // 弥补因重写prototype而失去的默认的constructor属性\n  subType.prototype = prototype; // 替换子类型原型\n}\n\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [\"red\", \"green\", \"blue\"];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 寄生组合式继承\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n```\n\n# 匿名函数\n\n没有名字的函数，也成为拉姆达(lamda)函数。\n\n像\n\n```js\nvar functionName = function(arg0, arg1, arg2) {\n  // 函数体\n}\n```\n\n这样的函数表达式相当于创建了一个匿名函数，然后将这个匿名函数赋给一个变量。\n\n将函数作为参数传入另一个函数，或者从一个函数中返回另一个函数时，通常都是用匿名函数。\n\n## 递归\n\n（虽然不知道为什么这本书要在这里再讲一遍这个，也许可能意思是callee指向的实际上是匿名函数，不管怎么样复习一下callee吧）\n\n前边在讲到函数内部对象arguments的属性callee(指向拥有这个arguments的函数)时有提到过递归阶乘函数这个例子：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 建议\n    // return num * factorial(num-1);   // 不建议\n  }\n}\n\nvar anotherFactorial = factorial;\nfactorial = null;\nanotherFactorial(4);\n// 使用callee这里结果为24， 函数内使用factorial这里会出错\n```\n\n## 闭包\n\n有些人会分不清**闭包**和**匿名函数**。\n\n**闭包**指的是有权访问另一个函数作用域的函数。\n\n创建闭包的常见方式是在一个函数内部创建另一个函数。\n\n### 作用域链\n\n首先先回顾一下作用域链（scope chain）。\n\n当一个函数第一次被调用时，会创建一个执行环境（execute context）及相应的作用域链，并将作用域链赋值给一个特殊的内部属性[[Scope]]。\n\n然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。\n\n这个活动对象处于作用域链的顶端，外部函数的活动对象处于第二位，外部函数的外部函数的活动对象处于第三位，... ... 直到全局执行环境的变量对象处于作用域链终点。\n\n一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。\n\n**但是，闭包的情况又有所不同。**\n\n在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中，当外部函数执行完毕后，如果内部的这个函数还未执行，即其作用域链还在引用外部函数的活动对象时，这个活动对象就不会被销毁。\n\n知道内部的这个函数执行完毕，外部函数的活动对象才会随之一起销毁。\n\n由于闭包会携带包含它的函数的作用域，因此回比其它函数占用更多内存，因此建议只有在必要时再考虑使用闭包。\n\n### 闭包与变量\n\n作用域链的这种配置机制有一个副作用：闭包只能取得包含函数的任何变量的最后一个值。\n\n```js\nfunction createFunctions() {\n  var result = new Array();\n  \n  for (var i = 0; i < 10; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n  \n  return result;\n}\n\nvar funcs = createFunctions();\n\n// 每个函数都输出10\nfor (var i = 0; i < funcs.length; i++) {\n  document.write(funcs[i]() + \"<br />\");\n}\n```\n\n因为每个函数的作用域链都保存着createFunctions()的活动对象，因此它们引用的都是同一个变量i，\n\n当createFunctions()函数返回后，变量i的值为10，\n\n所以每个函数内部的i都是10。\n\n可以通过创建另一个匿名函数强制让闭包行为符合预期：\n\n```js\nfor (var i = 0; i < 10; i++) {\n    result[i] = (function(num) {\n      return function(){\n        return num;\n      };\n    })(i);\n  }\n```\n\n在这里，定义了一个立即执行的匿名函数，并将它的结果赋给数组。\n\n在立即执行时，传入了变量i，又因为函数参数是按值传递的，因此就会将i的当前值赋给num。\n\n而这个函数内部，又创建并返回了一个访问num的闭包。\n\n这样，result数组中每个函数都有一个自己的num变量的副本，就可以返回不同的值了。\n\n### 关于this对象\n\n在闭包中使用this对象也可能导致一些问题。\n\nthis对象是在运行时基于函数的运行环境绑定的：\n\n- 在全局函数中，this等于window\n- 当函数被作为某个对象的方法调用时，this等于那个对象\n\n匿名函数的执行环境具有全局性，如果通过call()或者apply()改变环境执行环境，this会指向其他环境，但通常this指向window。\n\narguments也有同样的问题，\n\n因此如果想访问作用域中的this和arguments对象，必须将对它们的引用保存到另一个闭包能够访问的变量中，然后就可以让闭包访问该对象了，以this为例：\n\n```js\nvar name = \"The Window\";\n\nvar object = {\n  name: \"My Object\",\n  \n  getNameFunc1: function() {\n    return function() {\n      return this.name;\n    }\n  },\n  getNameFunc2: function() {\n    var that = this;\n    return function() {\n      return that.name;\n    }\n  }\n};\n\nobject.getNameFunc1(); // \"The Window\"\nobject.getNameFunc2(); // \"My Object\"\n```\n\n### 内存泄露\n\n由于IE对JScript对象和COM（组件对象模型）对象**使用不同的垃圾收集例程**，因此闭包在IE中可能会导致问题。\n\n如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁：\n\n```js\nfunction assignHansdler() {\n  var element = document.getElementById(\"someElement\");\n  element.onclick = function() {\n    alert(element.id);\n  };\n}\n```\n\n以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。\n\n由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。\n\n只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远都不会被回收。\n\n可以用如下方式解决：\n\n```js\nfunction assignHansdler() {\n  var element = document.getElementById(\"someElement\");\n  var id = element.id;\n  \n  element.onclick = function() {\n    alert(id);\n  };\n  \n  element = null;\n}\n```\n\n这样就消除了循环引用。\n\n需要注意的是，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。\n\n因此 ，有必要把element设为null。\n\n## 模仿块级作用域\n\nJavaScript在遇到多次声明一个变量的情况时，会自动忽略后边的声明，但是会执行后边声明中的初始化。\n\nJavaScript没有块级作用域的概念，\n\n因此块语句中定义的变量，实际上是在包含函数中而不是语句中创建的。\n\n可以用匿名函数来模仿块级作用域（私有作用域）来避免这个问题：\n\n```js\n(function() {\n  // 块级作用域\n})();\n```\n\n需要注意的是，JavaScript将function当做一个函数声明的开始，而函数声明后边是不能跟括号的。\n\n因此上边代码中函数外面包括的括号不能省略。这样可以把函数声明转换成函数表达式。\n\n无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。\n\n在匿名函数中的任何变量，都会在执行结束时销毁。\n\n我们应该通过创造私有作用域来尽量少地向全局作用域添加变量和函数，以免导致命名冲突。\n\n## 私有变量\n\n除了前边提到的稳妥构造函数模式，还可以：\n\n在构造函数中定义特权方法：\n\n```js\nfunction MyObject() {\n  // 函数的私有变量\n  var privateVariable = 10;\n  // 函数的私有函数\n  function privateFunction() {\n    return false;\n  }\n  // 特权方法\n  this.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n}\n```\n\n在创建MyObject实例后，除了publicMethod没有任何方法可以直接访问privateVariable和privateFunction()。\n\n或者利用私有和特权成员，隐藏那些不应该被直接修改的数据：\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\nvar person = new Person(\"Nicholas\");\nperson.getName(); // \"Nicholas\"\nperson.setName(\"Greg\");\nperson.getName(); // \"Greg\"\n```\n\n私有变量name在每一个实例的作用域中都不相同，因为每次调用构造函数都会重新创建这两个方法。\n\n但是这样使用构造函数会有构造函数模式的缺陷：无法方法复用。每次创建实例都会创建同样一组方法，用静态私有变量来实现特权方法就可以解决这个问题。\n\n### 静态私有变量\n\n```js\n(function() {\n  var name = \"\";\n  // 没有使用var声明，因此为全局变量\n  Person = function(value) {\n    name = value;\n  }\n  Person.prototype.getName = function() {\n    return name;\n  }\n  Person.prototype.setName = function(value) {\n    name = value;\n  }\n})();\n\nvar person1 = new Person(\"Nicholas\");\nperson1.getName(); // \"NIcholas\"\nperson1.setName(\"Greg\");\nperson1.getName(); // \"Greg\"\n\nvar person2 = new Person(\"MIchael\");\nperson1.getName(); // \"MIchael\"\nperson2.getName(); // \"MIchael\"\n```\n\n在这种模式下，name就变成了静态的、由所有实例共享的属性。\n\n因此每次改变name改变的是所有实例的name。\n\n这样创造静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。\n\n因此使用哪个方法还要视具体情况而定。\n\n> 多查找作用域链的一个层次会一定程度上影响查找速度，这正是闭包和私有变量的一个明显的不足之处。\n\n对于私有变量，我认为可以使用两者组合的模式，不知道对不对，这里贴出想法，欢迎指正（zmj原创，转载需注明出处）：\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\n(function() {\n  var teacher = \"Nicholas\"; // 初始化\n  Person.prototype.getTeacher = function() {\n    return teacher;\n  }\n  Person.prototype.setTeacher = function(value) {\n    teacher = value;\n  }\n})();\n```\n\n这样，就既有实例自己的私有变量，也有静态私有变量了。\n\n### 模块模式\n\n模块模式（module pattern）是为单例（singleton）创建私有变量和私有方法。\n\n所谓单例就是只有一个实例的对象，一般以对象字面量的方式来创建：\n\n```js\nvar singleton = {\n  name: value,\n  method: function() {\n    // 这里是方法的代码\n  }\n};\n```\n\n模块模式通过为单例添加私有变量和特权方法来使其增强：\n\n```js\nvar singleton = function() {\n  // 私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  \n  // 特权/公有方法和属性\n  return {\n    publicProperty: true,\n    publicMethod: function() {\n      privateVariable++;\n      return privateFunction();\n    }\n  };\n}();\n```\n\n这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是十分有用的：\n\n```js\nfunction BaseComponent() {}\nfunction OtherComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 公共\n  return {\n    getComponentCount: function() {\n      return components.length;\n    },\n    registerComponent: function(component) {\n      if (typeof component == \"object\") {\n        components.push(component);\n      }\n    }\n  };\n}();\n\napplication.registerComponent(new OtherComponent());\napplication.getComponentCount(); // 2\n```\n\n在Web应用程序中，经常使用一个单例来管理应用程序级的信息。\n\n以这种模式创建的单例都是Object的实例。\n\n### 增强的模块模式\n\n如果单例必须是某种类型的实例，还必须添加某些属性和/或方法加以增强，可以使用增强的模块模式：\n\n```js\nfunction BaseComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 创造application的一个局部副本\n  var app = new BaseComponent();\n  // 公共接口\n  app.getComponentCount: function() {\n    return components.length;\n  }；\n  app.registerComponent: function(component) {\n    if (typeof component == \"object\") {\n      components.push(component);\n    }\n  }；\n  // 返回这个副本\n  return app;\n}();\n```\n\n","slug":"JavaScript学习记录三","published":1,"updated":"2018-10-10T08:52:49.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vb000dfmag5z45rx86","content":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p><a id=\"more\"></a><hr><h1 id=\"面向对象的程序设计\"><a href=\"#面向对象的程序设计\" class=\"headerlink\" title=\"面向对象的程序设计\"></a>面向对象的程序设计</h1><h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式是软件工程领域广为人知的一种设计模式，这种模式抽象了创建具体对象的过程。</p><p>用函数来封装以特定接口创建对象的细节：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span>\n  o<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  o<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  o<span class=\"token punctuation\">.</span>jpb <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n  o<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> o<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Doctor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n</code></pre><p>工厂模式虽然解决了创建多个相似对的问题，却没有解决对象识别的问题。</p><h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><p>我们可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>jpb <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Doctor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n</code></pre><p>构造函数模式与工厂模式的区别：</p><ul><li><p>没有显示地创建对象(new Object())</p></li><li><p>直接将属性和方法赋给了this对象</p></li><li>没有return语句</li><li>函数名首字母大写</li></ul><p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历4个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>这样通过构造函数模式创建的两个对象都有一个constructor（构造函数）属性，该属性指向Person：</p><pre class=\" language-js\"><code class=\"language-js\">person1<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Person<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\nperson1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\nperson1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true， 因为所有对象均继承自Object</span>\n</code></pre><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式优于工厂模式的地方。</p><h4 id=\"将构造函数当做函数\"><a href=\"#将构造函数当做函数\" class=\"headerlink\" title=\"将构造函数当做函数\"></a>将构造函数当做函数</h4><p>前边例子中的Person()函数可以通过下边任何一种方式来调用：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 当做构造函数使用</span>\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 作为普通函数调用</span>\n<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Doctor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 添加到window</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//在另一个对象的作用域中调用</span>\n<span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Obeject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Kristen\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Nurse\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\no<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Kristen\"</span>\n</code></pre><h4 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h4><p>使用构造函数的主要问题，是每个方法都要在每个实例上重新创建一遍，这是没有必要的，因此Person()可以像下边这样定义：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>jpb <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> sayName<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>但是这样的话，在全局作用域中定义的函数(sayName())只能被 某个对象调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就要定义很多个全局函数，这样我们自定义的引用类型就毫无封装性可言。</p><p>但是这些问题可以通过使用原型模式解决。</p><h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>关于prototype可以先看<a href=\"https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html\" target=\"_blank\" rel=\"noopener\">这一篇</a>。</p><p>然后看下边这个例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicolas\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicolas\"</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicolas\"</span>\n\nperson1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><p>在原型模式下，对象调用这些属性和方法时，实际上是调用prototype的属性和方法。</p><h4 id=\"理解原型\"><a href=\"#理解原型\" class=\"headerlink\" title=\"理解原型\"></a>理解原型</h4><p>默认情况下，所有prototype属性都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype所在函数的指针。</p><p>如果person1的<code>__proto</code>指向Person的<code>prototype</code>，则</p><pre class=\" language-js\"><code class=\"language-js\">Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">isPrototypeOf</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><p>当为对象实例添加一个属性时，这个属性就会屏蔽源性对象中保存的同名属性，但不会修改那个属性。</p><p>如果将为对象实例添加的这个属性设为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。</p><p>要想重新访问原型中的属性，可以使用delete操作符完全删除实例属性，</p><p>使用hasOwnProperty()可以检测一个属性是否存在于实例中（这个方法是从Object继承来的），如果是原型属性则返回false：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicolas\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n\nperson1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"————来自实例</span>\nperson2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicolas\"————来自原型</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n\n\n<span class=\"token keyword\">delete</span> person1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicolas\"————来自原型</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n\n</code></pre><h4 id=\"原型与in操作符\"><a href=\"#原型与in操作符\" class=\"headerlink\" title=\"原型与in操作符\"></a>原型与in操作符</h4><p>in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。因此对于上面的例子，在person1和person2声明后，无论何时调用<code>&quot;name&quot; in person1</code>或<code>&quot;name&quot; in person2</code>都会得到true。</p><p>因此，在hasOwnPrototype()返回false而使用in操作符返回true时，就说明这个属性是原型属性。</p><p>in操作符还可以通过for-in循环使用，返回的是所有能通过对象访问的、可枚举的（enumerated）属性和方法。</p><p>原型中不可枚举的属性和方法（即设置了[[DontEnum]]标记的属性和方法）有hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()和valueOf()，有的浏览器也为constructor和prototype打上标记，</p><p>但是当我们在实例中添加这些属性和方法从而屏蔽了原型中的这些属性和方法时，那么这些属性和方法就会被认为是可枚举的（IE中除外）：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  toString<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"My Object\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> prop <span class=\"token keyword\">in</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prop <span class=\"token operator\">==</span> <span class=\"token string\">\"toString\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Found toString\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 在IE中不会显示，其他浏览器显示</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"更简单的原型方法\"><a href=\"#更简单的原型方法\" class=\"headerlink\" title=\"更简单的原型方法\"></a>更简单的原型方法</h4><p>每添加一个属性和方法就要敲一遍Person.prototype是不必要的，同事也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* 重写prototype会导致其constructor等于Object，\n   * 若constructor的值很重要，可以给constructor设置回适当的值\n   */</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">,</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Person<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 若是添加了上边constructor那一句则为true</span>\n</code></pre><h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><p>由于在原型中查找值的过程是一次搜索，因此对原型对象的修改都能够立即从实例中反映出来，</p><p>但是如果像上边的例子一样重写了原型，在重写原型之前声明的实例的<code>__proto__</code>指向的仍是最初的原型：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayHi <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"hi\"，没有问题</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">,</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"hi\"，没有问题</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//error</span>\n</code></pre><h4 id=\"原生对象的原型\"><a href=\"#原生对象的原型\" class=\"headerlink\" title=\"原生对象的原型\"></a>原生对象的原型</h4><p>所有原生的引用类型，都是采用原型模式创建的。因此我们亦可以对原生引用类型的prototype添加属性或方法。</p><p>以String为例：</p><pre class=\" language-js\"><code class=\"language-js\">String<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>startsWith <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World!\"</span><span class=\"token punctuation\">;</span>\nmsg<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><p>但是不建议在产品化的程序中修改原生对象的原型。</p><h4 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h4><p>如果一个原型的属性包含引用类型值时，实例对该属性进行操作时，实际上修改的就是原型中的属性（引用类型对象名可以看做指针），因此当其他实例访问该属性时，得到的就是这个实例修改后的值：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">,</span>\n  friends<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"Shelby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Court\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 属性值为引用类型</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Van\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Shelby\", \"Court\", \"Van\"]</span>\nperson2<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Shelby\", \"Court\", \"Van\"]</span>\nperson1<span class=\"token punctuation\">.</span>friends <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><h3 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h3><p>使用构造函数模式定义实例属性，原型模式定义方法和共享的属性，</p><p>这样每个实例都会有自已的一份实例属性的副本，又共享着对方法的引用，最大限度地节省了内存，还可以向构造函数传递参数：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"Shelby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Court\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Doctor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Van\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Shelby\", \"Court\", \"Van\"]</span>\nperson2<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Shelby\", \"Court\"]</span>\nperson1<span class=\"token punctuation\">.</span>friends <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\nperson1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre><p>这种混合使用的模式是ECMAScript中使用最广泛、认同度最高的自定义类型的方法。可以说是一种默认模式。</p><h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><p>这种模式把所有信息都封装在了构造函数中，并在构造函数中通过检查某个应该存在的方法是否有效，来决定是否需要初始化模型：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 属性</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 方法</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 只有在sayName()方法不存在时才将其添加到原型中</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 即只有在初次调用构造函数时才会执行下面的代码</span>\n  <span class=\"token comment\" spellcheck=\"true\">// if语句只需要判断一个方法（例如sayName）是否存在</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">!=</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Person<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>\n      sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      sayHi<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"其他构造函数模式\"><a href=\"#其他构造函数模式\" class=\"headerlink\" title=\"其他构造函数模式\"></a>其他构造函数模式</h3><p>寄生构造函数模式和<a href=\"https://blog.csdn.net/zqs111/article/details/50650324\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">稳妥构造函数模式</a>，寄生构造模式没有什么意义这里就不再赘述，稳妥构造函数模式相当于为引用类型添加了private属性，有兴趣可以自行搜索。</p><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在ECMAScript中无法实现接口继承（与函数无法重载的理由相同，ECMAScript中的函数没有签名），</p><p>但是可以利用原型链实现实现继承。</p><h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>除了<a href=\"https://blog.zmj97.top/2018/09/04/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto/\" target=\"_blank\" rel=\"noopener\">这一篇</a>讲到的，还应注意：</p><ul><li>别忘记默认的原型：Object.prototype</li><li>确认原型和实例的关系：利用<code>instanceof</code>和<code>isPrototypeOf()</code></li><li>谨慎地定义方法<ul><li>给原型添加方法的代码一定要放在替换原型的语句之后</li><li>在通过原型链实现继承时，不同通过对象字面量创建原型方法（重写原型会切断原型链）</li></ul></li><li>原型链的问题<ul><li>与原型的问题相同，如果原型包含引用类型值，那么所有同一个继承类型的实例都会共享一个引用类型值</li><li>在创建子类型的实例时，不能像超类型的构造函数传递参数</li></ul></li></ul><h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><p>又叫伪造继承或经典继承。</p><p>在子类型构造函数得到内部利用调用超类型的构造函数，还可以传递参数。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SuperType</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">SubType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 继承了SuperType，同时还传递了参数</span>\n  SuperType<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 实例属性</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\ninstance<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 29</span>\n</code></pre><p>但是如果方法都在构造函数中定义，函数复用就无从谈起了。</p><h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>combination inheritance，伪经典继承，组合使用原型链和借用构造函数。</p><p>使用原型链实现原型属性和方法的继承，通过借用构造函数实现实例属性的继承，</p><p>这样既可以实现函数复用，又能保证每个实例都有它自己的属性。</p><p>同时，<code>instanceof</code>和<code>isPrototypeOf</code>也能识别基于组合继承创建的对象。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SuperType</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nSuperType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">SubType</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 继承属性</span>\n  SuperType<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 继承方法</span>\nSubType<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SuperType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nSubType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayAge <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> instance1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubType</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance1<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"black\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance1<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"red\", \"green\", \"blue\", \"black\"]</span>\ninstance1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\ninstance1<span class=\"token punctuation\">.</span><span class=\"token function\">sayAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 29</span>\n\n<span class=\"token keyword\">var</span> instance2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubType</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance1<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"red\", \"green\", \"blue]</span>\ninstance1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\ninstance1<span class=\"token punctuation\">.</span><span class=\"token function\">sayAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 27</span>\n</code></pre><p>组合继承融合了前两者的优点，因此成为JavaScript中最常用的继承模式。</p><h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><p>主要用于只是想让一个对象与另一个对象保持类似，没有必要兴师动众地创建构造函数。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  F<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>这样子实际上是object()函数对传入的对象执行了一次浅复制：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span>\n  friends<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"Shelby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Court\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Van\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> anotherPerson <span class=\"token operator\">=</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nanotherPerson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">;</span>\nanotherPerson<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Rob\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Shelby\", \"Court\", \"Van\", \"Rob\"]</span>\nperson<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\nanotherPerson<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n</code></pre><h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>寄生式，parasitic。</p><p>思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象。</p><p>但是也会因为做不到函数复用而降低效率。</p><p>适用于主要考虑对象而不是自定义类型和构造函数的情况：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createAnother</span><span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 通过调用函数创建一个新对象，不一定使用object()函数</span>\n  <span class=\"token keyword\">var</span> clone <span class=\"token operator\">=</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 以某种方式增强这个对象</span>\n  clone<span class=\"token punctuation\">.</span>sayHi <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回这个对象</span>\n  <span class=\"token keyword\">return</span> clone<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span>\n  friends<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"Shelby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Court\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Van\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> anotherPerson <span class=\"token operator\">=</span> <span class=\"token function\">createAnother</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nanotherPerson<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"hi\"</span>\n</code></pre><h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><p>对于为什么要寄生组合式继承，看了<a href=\"https://www.cnblogs.com/ghostwu/p/7440691.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇</a>文章还有知乎上的一些回答，主要的优势是组合继承两次调用了构造函数，而寄生只使用了一次。</p><p>刚开始不理解的是，为什么在创建超类型原型副本时对超类型原型的实例化就不算调用构造函数呢？</p><p>后来仔细想了一下，的确可以不算调用了构造函数——</p><p>object()函数内的临时类型F的构造函数为空（<code>function F() {}</code>），因此可以忽略不计。</p><p>以下是代码：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 主要区别就是这里，构造函数的不同</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> \n  F<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">inheritPrototype</span><span class=\"token punctuation\">(</span>subType<span class=\"token punctuation\">,</span> superType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> prototype <span class=\"token operator\">=</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>superType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 拷贝原型</span>\n  prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> subType<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 弥补因重写prototype而失去的默认的constructor属性</span>\n  subType<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 替换子类型原型</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">SuperType</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nSuperType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">SubType</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 继承属性</span>\n  SuperType<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 寄生组合式继承</span>\n<span class=\"token function\">inheritPrototype</span><span class=\"token punctuation\">(</span>SubType<span class=\"token punctuation\">,</span> SuperType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nSubType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayAge <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre><h1 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h1><p>没有名字的函数，也成为拉姆达(lamda)函数。</p><p>像</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> functionName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg0<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 函数体</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>这样的函数表达式相当于创建了一个匿名函数，然后将这个匿名函数赋给一个变量。</p><p>将函数作为参数传入另一个函数，或者从一个函数中返回另一个函数时，通常都是用匿名函数。</p><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>（虽然不知道为什么这本书要在这里再讲一遍这个，也许可能意思是callee指向的实际上是匿名函数，不管怎么样复习一下callee吧）</p><p>前边在讲到函数内部对象arguments的属性callee(指向拥有这个arguments的函数)时有提到过递归阶乘函数这个例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 建议</span>\n    <span class=\"token comment\" spellcheck=\"true\">// return num * factorial(num-1);   // 不建议</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> anotherFactorial <span class=\"token operator\">=</span> factorial<span class=\"token punctuation\">;</span>\nfactorial <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">anotherFactorial</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 使用callee这里结果为24， 函数内使用factorial这里会出错</span>\n</code></pre><h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>有些人会分不清<strong>闭包</strong>和<strong>匿名函数</strong>。</p><p><strong>闭包</strong>指的是有权访问另一个函数作用域的函数。</p><p>创建闭包的常见方式是在一个函数内部创建另一个函数。</p><h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>首先先回顾一下作用域链（scope chain）。</p><p>当一个函数第一次被调用时，会创建一个执行环境（execute context）及相应的作用域链，并将作用域链赋值给一个特殊的内部属性[[Scope]]。</p><p>然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。</p><p>这个活动对象处于作用域链的顶端，外部函数的活动对象处于第二位，外部函数的外部函数的活动对象处于第三位，… … 直到全局执行环境的变量对象处于作用域链终点。</p><p>一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</p><p><strong>但是，闭包的情况又有所不同。</strong></p><p>在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中，当外部函数执行完毕后，如果内部的这个函数还未执行，即其作用域链还在引用外部函数的活动对象时，这个活动对象就不会被销毁。</p><p>知道内部的这个函数执行完毕，外部函数的活动对象才会随之一起销毁。</p><p>由于闭包会携带包含它的函数的作用域，因此回比其它函数占用更多内存，因此建议只有在必要时再考虑使用闭包。</p><h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p>作用域链的这种配置机制有一个副作用：闭包只能取得包含函数的任何变量的最后一个值。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> funcs <span class=\"token operator\">=</span> <span class=\"token function\">createFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 每个函数都输出10</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> funcs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>funcs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"&lt;br />\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>因为每个函数的作用域链都保存着createFunctions()的活动对象，因此它们引用的都是同一个变量i，</p><p>当createFunctions()函数返回后，变量i的值为10，</p><p>所以每个函数内部的i都是10。</p><p>可以通过创建另一个匿名函数强制让闭包行为符合预期：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre><p>在这里，定义了一个立即执行的匿名函数，并将它的结果赋给数组。</p><p>在立即执行时，传入了变量i，又因为函数参数是按值传递的，因此就会将i的当前值赋给num。</p><p>而这个函数内部，又创建并返回了一个访问num的闭包。</p><p>这样，result数组中每个函数都有一个自己的num变量的副本，就可以返回不同的值了。</p><h3 id=\"关于this对象\"><a href=\"#关于this对象\" class=\"headerlink\" title=\"关于this对象\"></a>关于this对象</h3><p>在闭包中使用this对象也可能导致一些问题。</p><p>this对象是在运行时基于函数的运行环境绑定的：</p><ul><li>在全局函数中，this等于window</li><li>当函数被作为某个对象的方法调用时，this等于那个对象</li></ul><p>匿名函数的执行环境具有全局性，如果通过call()或者apply()改变环境执行环境，this会指向其他环境，但通常this指向window。</p><p>arguments也有同样的问题，</p><p>因此如果想访问作用域中的this和arguments对象，必须将对它们的引用保存到另一个闭包能够访问的变量中，然后就可以让闭包访问该对象了，以this为例：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"The Window\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"My Object\"</span><span class=\"token punctuation\">,</span>\n\n  getNameFunc1<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getNameFunc2<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> that <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> that<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nobject<span class=\"token punctuation\">.</span><span class=\"token function\">getNameFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"The Window\"</span>\nobject<span class=\"token punctuation\">.</span><span class=\"token function\">getNameFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"My Object\"</span>\n</code></pre><h3 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h3><p>由于IE对JScript对象和COM（组件对象模型）对象<strong>使用不同的垃圾收集例程</strong>，因此闭包在IE中可能会导致问题。</p><p>如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">assignHansdler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"someElement\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  element<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。</p><p>由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。</p><p>只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远都不会被回收。</p><p>可以用如下方式解决：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">assignHansdler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"someElement\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> id <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n\n  element<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  element <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>这样就消除了循环引用。</p><p>需要注意的是，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。</p><p>因此 ，有必要把element设为null。</p><h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>JavaScript在遇到多次声明一个变量的情况时，会自动忽略后边的声明，但是会执行后边声明中的初始化。</p><p>JavaScript没有块级作用域的概念，</p><p>因此块语句中定义的变量，实际上是在包含函数中而不是语句中创建的。</p><p>可以用匿名函数来模仿块级作用域（私有作用域）来避免这个问题：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 块级作用域</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>需要注意的是，JavaScript将function当做一个函数声明的开始，而函数声明后边是不能跟括号的。</p><p>因此上边代码中函数外面包括的括号不能省略。这样可以把函数声明转换成函数表达式。</p><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。</p><p>在匿名函数中的任何变量，都会在执行结束时销毁。</p><p>我们应该通过创造私有作用域来尽量少地向全局作用域添加变量和函数，以免导致命名冲突。</p><h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><p>除了前边提到的稳妥构造函数模式，还可以：</p><p>在构造函数中定义特权方法：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">MyObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 函数的私有变量</span>\n  <span class=\"token keyword\">var</span> privateVariable <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 函数的私有函数</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">privateFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 特权方法</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publicMethod <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    privateVariable<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">privateFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>在创建MyObject实例后，除了publicMethod没有任何方法可以直接访问privateVariable和privateFunction()。</p><p>或者利用私有和特权成员，隐藏那些不应该被直接修改的数据：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>setName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n</code></pre><p>私有变量name在每一个实例的作用域中都不相同，因为每次调用构造函数都会重新创建这两个方法。</p><p>但是这样使用构造函数会有构造函数模式的缺陷：无法方法复用。每次创建实例都会创建同样一组方法，用静态私有变量来实现特权方法就可以解决这个问题。</p><h3 id=\"静态私有变量\"><a href=\"#静态私有变量\" class=\"headerlink\" title=\"静态私有变量\"></a>静态私有变量</h3><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 没有使用var声明，因此为全局变量</span>\n  Person <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>getName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>setName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"NIcholas\"</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Greg\"</span>\n\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MIchael\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"MIchael\"</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"MIchael\"</span>\n</code></pre><p>在这种模式下，name就变成了静态的、由所有实例共享的属性。</p><p>因此每次改变name改变的是所有实例的name。</p><p>这样创造静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。</p><p>因此使用哪个方法还要视具体情况而定。</p><blockquote><p>多查找作用域链的一个层次会一定程度上影响查找速度，这正是闭包和私有变量的一个明显的不足之处。</p></blockquote><p>对于私有变量，我认为可以使用两者组合的模式，不知道对不对，这里贴出想法，欢迎指正（zmj原创，转载需注明出处）：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>setName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> teacher <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化</span>\n  Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>getTeacher <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> teacher<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>setTeacher <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    teacher <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>这样，就既有实例自己的私有变量，也有静态私有变量了。</p><h3 id=\"模块模式\"><a href=\"#模块模式\" class=\"headerlink\" title=\"模块模式\"></a>模块模式</h3><p>模块模式（module pattern）是为单例（singleton）创建私有变量和私有方法。</p><p>所谓单例就是只有一个实例的对象，一般以对象字面量的方式来创建：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> singleton <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> value<span class=\"token punctuation\">,</span>\n  method<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里是方法的代码</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre><p>模块模式通过为单例添加私有变量和特权方法来使其增强：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 私有变量和私有函数</span>\n  <span class=\"token keyword\">var</span> privateVariable <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">privateFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 特权/公有方法和属性</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    publicProperty<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    publicMethod<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      privateVariable<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">privateFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是十分有用的：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">BaseComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">OtherComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> application <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 私有变量和函数</span>\n  <span class=\"token keyword\">var</span> components <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化</span>\n  components<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BaseComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 公共</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    getComponentCount<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> components<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    registerComponent<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> component <span class=\"token operator\">==</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        components<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\napplication<span class=\"token punctuation\">.</span><span class=\"token function\">registerComponent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OtherComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napplication<span class=\"token punctuation\">.</span><span class=\"token function\">getComponentCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 2</span>\n</code></pre><p>在Web应用程序中，经常使用一个单例来管理应用程序级的信息。</p><p>以这种模式创建的单例都是Object的实例。</p><h3 id=\"增强的模块模式\"><a href=\"#增强的模块模式\" class=\"headerlink\" title=\"增强的模块模式\"></a>增强的模块模式</h3><p>如果单例必须是某种类型的实例，还必须添加某些属性和/或方法加以增强，可以使用增强的模块模式：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">BaseComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> application <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 私有变量和函数</span>\n  <span class=\"token keyword\">var</span> components <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化</span>\n  components<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BaseComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 创造application的一个局部副本</span>\n  <span class=\"token keyword\">var</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BaseComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 公共接口</span>\n  app<span class=\"token punctuation\">.</span>getComponentCount<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> components<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>；\n  app<span class=\"token punctuation\">.</span>registerComponent<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> component <span class=\"token operator\">==</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      components<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>；\n  <span class=\"token comment\" spellcheck=\"true\">// 返回这个副本</span>\n  <span class=\"token keyword\">return</span> app<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>","site":{"data":{}},"excerpt":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p>","more":"<hr><h1 id=\"面向对象的程序设计\"><a href=\"#面向对象的程序设计\" class=\"headerlink\" title=\"面向对象的程序设计\"></a>面向对象的程序设计</h1><h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式是软件工程领域广为人知的一种设计模式，这种模式抽象了创建具体对象的过程。</p><p>用函数来封装以特定接口创建对象的细节：</p><pre><code class=\"js\">function createPerson(name, age, job) {\n  var o = new Object;\n  o.name = name;\n  o.age = age;\n  o.jpb = job;\n  o.sayName = function() {\n    alert(this.name);\n  };\n  return o;\n}\n\nvar person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.sayName(); // &quot;Nicholas&quot;\nperson2.sayName(); // &quot;Greg&quot;\n</code></pre><p>工厂模式虽然解决了创建多个相似对的问题，却没有解决对象识别的问题。</p><h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><p>我们可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p><pre><code class=\"js\">function Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = function() {\n    alert(this.name);\n  };\n}\n\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.sayName(); // &quot;Nicholas&quot;\nperson2.sayName(); // &quot;Greg&quot;\n</code></pre><p>构造函数模式与工厂模式的区别：</p><ul><li><p>没有显示地创建对象(new Object())</p></li><li><p>直接将属性和方法赋给了this对象</p></li><li>没有return语句</li><li>函数名首字母大写</li></ul><p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历4个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>这样通过构造函数模式创建的两个对象都有一个constructor（构造函数）属性，该属性指向Person：</p><pre><code class=\"js\">person1.constructor == Person; // true\nperson1 instanceof Person; // true\nperson1 instanceof Object; // true， 因为所有对象均继承自Object\n</code></pre><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式优于工厂模式的地方。</p><h4 id=\"将构造函数当做函数\"><a href=\"#将构造函数当做函数\" class=\"headerlink\" title=\"将构造函数当做函数\"></a>将构造函数当做函数</h4><p>前边例子中的Person()函数可以通过下边任何一种方式来调用：</p><pre><code class=\"js\">// 当做构造函数使用\nvar person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nperson.sayName();\n\n// 作为普通函数调用\nPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到window\nwindow.sayName(); // &quot;Greg&quot;\n\n//在另一个对象的作用域中调用\nvar o = new Obeject();\nPerson.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);\no.sayName(); // &quot;Kristen&quot;\n</code></pre><h4 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h4><p>使用构造函数的主要问题，是每个方法都要在每个实例上重新创建一遍，这是没有必要的，因此Person()可以像下边这样定义：</p><pre><code class=\"js\">function Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.jpb = job;\n  this.sayName = sayName;\n}\n\nfunction sayName() {\n  alert(this.name);\n}\n</code></pre><p>但是这样的话，在全局作用域中定义的函数(sayName())只能被 某个对象调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就要定义很多个全局函数，这样我们自定义的引用类型就毫无封装性可言。</p><p>但是这些问题可以通过使用原型模式解决。</p><h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>关于prototype可以先看<a href=\"https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html\" target=\"_blank\" rel=\"noopener\">这一篇</a>。</p><p>然后看下边这个例子：</p><pre><code class=\"js\">function Person() {}\nPerson.prototype.name = &quot;Nicolas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); // &quot;Nicolas&quot;\nvar person2 = new Person();\nperson2.sayName(); // &quot;Nicolas&quot;\n\nperson1.sayName == person2.sayName; // true\n</code></pre><p>在原型模式下，对象调用这些属性和方法时，实际上是调用prototype的属性和方法。</p><h4 id=\"理解原型\"><a href=\"#理解原型\" class=\"headerlink\" title=\"理解原型\"></a>理解原型</h4><p>默认情况下，所有prototype属性都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype所在函数的指针。</p><p>如果person1的<code>__proto</code>指向Person的<code>prototype</code>，则</p><pre><code class=\"js\">Person.prototype.isPrototypeOf(person); // true\n</code></pre><p>当为对象实例添加一个属性时，这个属性就会屏蔽源性对象中保存的同名属性，但不会修改那个属性。</p><p>如果将为对象实例添加的这个属性设为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。</p><p>要想重新访问原型中的属性，可以使用delete操作符完全删除实例属性，</p><p>使用hasOwnProperty()可以检测一个属性是否存在于实例中（这个方法是从Object继承来的），如果是原型属性则返回false：</p><pre><code class=\"js\">function Person() {}\nPerson.prototype.name = &quot;Nicolas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n  alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.hasOwnProperty(&quot;name&quot;); // false\n\nperson1.name = &quot;Greg&quot;;\nperson1.name; // &quot;Greg&quot;————来自实例\nperson2.name; // &quot;Nicolas&quot;————来自原型\nperson1.hasOwnProperty(&quot;name&quot;); // true\nperson2.hasOwnProperty(&quot;name&quot;); // false\n\n\ndelete person1.name;\nperson1.name; // &quot;Nicolas&quot;————来自原型\nperson1.hasOwnProperty(&quot;name&quot;); // false\n\n</code></pre><h4 id=\"原型与in操作符\"><a href=\"#原型与in操作符\" class=\"headerlink\" title=\"原型与in操作符\"></a>原型与in操作符</h4><p>in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。因此对于上面的例子，在person1和person2声明后，无论何时调用<code>&quot;name&quot; in person1</code>或<code>&quot;name&quot; in person2</code>都会得到true。</p><p>因此，在hasOwnPrototype()返回false而使用in操作符返回true时，就说明这个属性是原型属性。</p><p>in操作符还可以通过for-in循环使用，返回的是所有能通过对象访问的、可枚举的（enumerated）属性和方法。</p><p>原型中不可枚举的属性和方法（即设置了[[DontEnum]]标记的属性和方法）有hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()和valueOf()，有的浏览器也为constructor和prototype打上标记，</p><p>但是当我们在实例中添加这些属性和方法从而屏蔽了原型中的这些属性和方法时，那么这些属性和方法就会被认为是可枚举的（IE中除外）：</p><pre><code class=\"js\">var o = {\n  toString: function() {\n    return &quot;My Object&quot;;\n  }\n};\n\nfor (var prop in o) {\n  if (prop == &quot;toString&quot;) {\n    alert(&quot;Found toString&quot;); // 在IE中不会显示，其他浏览器显示\n  }\n}\n</code></pre><h4 id=\"更简单的原型方法\"><a href=\"#更简单的原型方法\" class=\"headerlink\" title=\"更简单的原型方法\"></a>更简单的原型方法</h4><p>每添加一个属性和方法就要敲一遍Person.prototype是不必要的，同事也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p><pre><code class=\"js\">function Person() {}\nPerson.prototype = {\n  /* 重写prototype会导致其constructor等于Object，\n   * 若constructor的值很重要，可以给constructor设置回适当的值\n   */\n  constructor: Person,\n  name: &quot;Nicholas&quot;,\n  age: 29,\n  job: &quot;Software Engineer&quot;,\n  sayName: function(){\n    alert(this.name);\n  }\n};\nvar person = new Person();\nperson.constructor == Person;\n// 若是添加了上边constructor那一句则为true\n</code></pre><h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><p>由于在原型中查找值的过程是一次搜索，因此对原型对象的修改都能够立即从实例中反映出来，</p><p>但是如果像上边的例子一样重写了原型，在重写原型之前声明的实例的<code>__proto__</code>指向的仍是最初的原型：</p><pre><code class=\"js\">function Person() {}\n\nvar person = new Person();\n\nPerson.prototype.sayHi = function() {\n  alert(&quot;hi&quot;);\n};\n\nperson.sayHi(); // &quot;hi&quot;，没有问题\n\nPerson.prototype = {\n  constructor: Person,\n  name: &quot;Nicholas&quot;,\n  age: 29,\n  job: &quot;Software Engineer&quot;,\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nperson.sayHi(); // &quot;hi&quot;，没有问题\nperson.sayName(); //error\n</code></pre><h4 id=\"原生对象的原型\"><a href=\"#原生对象的原型\" class=\"headerlink\" title=\"原生对象的原型\"></a>原生对象的原型</h4><p>所有原生的引用类型，都是采用原型模式创建的。因此我们亦可以对原生引用类型的prototype添加属性或方法。</p><p>以String为例：</p><pre><code class=\"js\">String.prototype.startsWith = function(text) {\n  return this.indexOf(text) == 0;\n};\n\nvar msg = &quot;Hello World!&quot;;\nmsg.startsWith(&quot;Hello&quot;); // true\n</code></pre><p>但是不建议在产品化的程序中修改原生对象的原型。</p><h4 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h4><p>如果一个原型的属性包含引用类型值时，实例对该属性进行操作时，实际上修改的就是原型中的属性（引用类型对象名可以看做指针），因此当其他实例访问该属性时，得到的就是这个实例修改后的值：</p><pre><code class=\"js\">function Person() {}\n\nPerson.prototype = {\n  constructor: Person,\n  name: &quot;Nicholas&quot;,\n  age: 29,\n  job: &quot;Software Engineer&quot;,\n  friends: [&quot;Shelby&quot;, &quot;Court&quot;], // 属性值为引用类型\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(&quot;Van&quot;);\n\nperson1.friends; // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]\nperson2.friends; // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]\nperson1.friends == person2.friends; // true\n</code></pre><h3 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h3><p>使用构造函数模式定义实例属性，原型模式定义方法和共享的属性，</p><p>这样每个实例都会有自已的一份实例属性的副本，又共享着对方法的引用，最大限度地节省了内存，还可以向构造函数传递参数：</p><pre><code class=\"js\">function Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayName: function(){\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.friends.push(&quot;Van&quot;);\n\nperson1.friends; // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]\nperson2.friends; // [&quot;Shelby&quot;, &quot;Court&quot;]\nperson1.friends == person2.friends; // false\nperson1.sayName == person2.sayName; // true\n</code></pre><p>这种混合使用的模式是ECMAScript中使用最广泛、认同度最高的自定义类型的方法。可以说是一种默认模式。</p><h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><p>这种模式把所有信息都封装在了构造函数中，并在构造函数中通过检查某个应该存在的方法是否有效，来决定是否需要初始化模型：</p><pre><code class=\"js\">function Person(name, age, job) {\n  // 属性\n  this.name = name;\n  this.age = age;\n  this.job = job;\n\n  // 方法\n  // 只有在sayName()方法不存在时才将其添加到原型中\n  // 即只有在初次调用构造函数时才会执行下面的代码\n  // if语句只需要判断一个方法（例如sayName）是否存在\n  if (typeof this.sayName != &quot;function&quot;) {\n    Person.prototype = {\n      constructor: Person,\n      sayName: function() {\n      alert(this.name);\n      },\n      sayHi: function() {\n      alert(&quot;hi&quot;);\n      }\n    };\n  }\n}\n</code></pre><h3 id=\"其他构造函数模式\"><a href=\"#其他构造函数模式\" class=\"headerlink\" title=\"其他构造函数模式\"></a>其他构造函数模式</h3><p>寄生构造函数模式和<a href=\"https://blog.csdn.net/zqs111/article/details/50650324\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">稳妥构造函数模式</a>，寄生构造模式没有什么意义这里就不再赘述，稳妥构造函数模式相当于为引用类型添加了private属性，有兴趣可以自行搜索。</p><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在ECMAScript中无法实现接口继承（与函数无法重载的理由相同，ECMAScript中的函数没有签名），</p><p>但是可以利用原型链实现实现继承。</p><h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>除了<a href=\"https://blog.zmj97.top/2018/09/04/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto/\" target=\"_blank\" rel=\"noopener\">这一篇</a>讲到的，还应注意：</p><ul><li>别忘记默认的原型：Object.prototype</li><li>确认原型和实例的关系：利用<code>instanceof</code>和<code>isPrototypeOf()</code></li><li>谨慎地定义方法<ul><li>给原型添加方法的代码一定要放在替换原型的语句之后</li><li>在通过原型链实现继承时，不同通过对象字面量创建原型方法（重写原型会切断原型链）</li></ul></li><li>原型链的问题<ul><li>与原型的问题相同，如果原型包含引用类型值，那么所有同一个继承类型的实例都会共享一个引用类型值</li><li>在创建子类型的实例时，不能像超类型的构造函数传递参数</li></ul></li></ul><h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><p>又叫伪造继承或经典继承。</p><p>在子类型构造函数得到内部利用调用超类型的构造函数，还可以传递参数。</p><pre><code class=\"js\">function SuperType(name) {\n  this.name = name;\n}\nfunction SubType() {\n  // 继承了SuperType，同时还传递了参数\n  SuperType.call(this, &quot;Nicholas&quot;);\n  // 实例属性\n  this.age = 29;\n}\n\nvar instance = new SubType();\ninstance.name; // &quot;Nicholas&quot;\ninstance.age; // 29\n</code></pre><p>但是如果方法都在构造函数中定义，函数复用就无从谈起了。</p><h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>combination inheritance，伪经典继承，组合使用原型链和借用构造函数。</p><p>使用原型链实现原型属性和方法的继承，通过借用构造函数实现实例属性的继承，</p><p>这样既可以实现函数复用，又能保证每个实例都有它自己的属性。</p><p>同时，<code>instanceof</code>和<code>isPrototypeOf</code>也能识别基于组合继承创建的对象。</p><pre><code class=\"js\">function SuperType(name) {\n  this.name = name;\n  this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n\nvar instance1 = new SubType(&quot;Nicholas&quot;, 29);\ninstance1.colors.push(&quot;black&quot;);\ninstance1.colors; // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;]\ninstance1.sayName(); // &quot;Nicholas&quot;\ninstance1.sayAge(); // 29\n\nvar instance2 = new SubType(&quot;Greg&quot;, 27);\ninstance1.colors; // [&quot;red&quot;, &quot;green&quot;, &quot;blue]\ninstance1.sayName(); // &quot;Greg&quot;\ninstance1.sayAge(); // 27\n</code></pre><p>组合继承融合了前两者的优点，因此成为JavaScript中最常用的继承模式。</p><h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3><p>主要用于只是想让一个对象与另一个对象保持类似，没有必要兴师动众地创建构造函数。</p><pre><code class=\"js\">function object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n</code></pre><p>这样子实际上是object()函数对传入的对象执行了一次浅复制：</p><pre><code class=\"js\">var person = {\n  name: &quot;Nicholas&quot;,\n  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;];\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = &quot;Greg&quot;;\nanotherPerson.friends.push(&quot;Rob&quot;);\n\nperson.friends; // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;]\nperson.name; // &quot;Nicholas&quot;\nanotherPerson.name; // &quot;Greg&quot;\n</code></pre><h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3><p>寄生式，parasitic。</p><p>思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象。</p><p>但是也会因为做不到函数复用而降低效率。</p><p>适用于主要考虑对象而不是自定义类型和构造函数的情况：</p><pre><code class=\"js\">function createAnother(original) {\n  // 通过调用函数创建一个新对象，不一定使用object()函数\n  var clone = object(original);\n  // 以某种方式增强这个对象\n  clone.sayHi = function() {\n    alert(&quot;hi&quot;);\n  };\n  // 返回这个对象\n  return clone;\n}\n\nvar person = {\n  name: &quot;Nicholas&quot;,\n  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;];\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi(); // &quot;hi&quot;\n</code></pre><h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><p>对于为什么要寄生组合式继承，看了<a href=\"https://www.cnblogs.com/ghostwu/p/7440691.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇</a>文章还有知乎上的一些回答，主要的优势是组合继承两次调用了构造函数，而寄生只使用了一次。</p><p>刚开始不理解的是，为什么在创建超类型原型副本时对超类型原型的实例化就不算调用构造函数呢？</p><p>后来仔细想了一下，的确可以不算调用了构造函数——</p><p>object()函数内的临时类型F的构造函数为空（<code>function F() {}</code>），因此可以忽略不计。</p><p>以下是代码：</p><pre><code class=\"js\">function object(o) {\n  // 主要区别就是这里，构造函数的不同\n  function F() {} \n  F.prototype = o;\n  return new F();\n}\n\nfunction inheritPrototype(subType, superType) {\n  var prototype = object(superType.prototype); // 拷贝原型\n  prototype.constructor = subType; // 弥补因重写prototype而失去的默认的constructor属性\n  subType.prototype = prototype; // 替换子类型原型\n}\n\nfunction SuperType(name) {\n  this.name = name;\n  this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n}\n\nSuperType.prototype.sayName = function() {\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 寄生组合式继承\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function(){\n  alert(this.age);\n};\n</code></pre><h1 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h1><p>没有名字的函数，也成为拉姆达(lamda)函数。</p><p>像</p><pre><code class=\"js\">var functionName = function(arg0, arg1, arg2) {\n  // 函数体\n}\n</code></pre><p>这样的函数表达式相当于创建了一个匿名函数，然后将这个匿名函数赋给一个变量。</p><p>将函数作为参数传入另一个函数，或者从一个函数中返回另一个函数时，通常都是用匿名函数。</p><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>（虽然不知道为什么这本书要在这里再讲一遍这个，也许可能意思是callee指向的实际上是匿名函数，不管怎么样复习一下callee吧）</p><p>前边在讲到函数内部对象arguments的属性callee(指向拥有这个arguments的函数)时有提到过递归阶乘函数这个例子：</p><pre><code class=\"js\">function factorial(num) {\n  if (num &lt;= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 建议\n    // return num * factorial(num-1);   // 不建议\n  }\n}\n\nvar anotherFactorial = factorial;\nfactorial = null;\nanotherFactorial(4);\n// 使用callee这里结果为24， 函数内使用factorial这里会出错\n</code></pre><h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>有些人会分不清<strong>闭包</strong>和<strong>匿名函数</strong>。</p><p><strong>闭包</strong>指的是有权访问另一个函数作用域的函数。</p><p>创建闭包的常见方式是在一个函数内部创建另一个函数。</p><h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>首先先回顾一下作用域链（scope chain）。</p><p>当一个函数第一次被调用时，会创建一个执行环境（execute context）及相应的作用域链，并将作用域链赋值给一个特殊的内部属性[[Scope]]。</p><p>然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。</p><p>这个活动对象处于作用域链的顶端，外部函数的活动对象处于第二位，外部函数的外部函数的活动对象处于第三位，… … 直到全局执行环境的变量对象处于作用域链终点。</p><p>一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</p><p><strong>但是，闭包的情况又有所不同。</strong></p><p>在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中，当外部函数执行完毕后，如果内部的这个函数还未执行，即其作用域链还在引用外部函数的活动对象时，这个活动对象就不会被销毁。</p><p>知道内部的这个函数执行完毕，外部函数的活动对象才会随之一起销毁。</p><p>由于闭包会携带包含它的函数的作用域，因此回比其它函数占用更多内存，因此建议只有在必要时再考虑使用闭包。</p><h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p>作用域链的这种配置机制有一个副作用：闭包只能取得包含函数的任何变量的最后一个值。</p><pre><code class=\"js\">function createFunctions() {\n  var result = new Array();\n\n  for (var i = 0; i &lt; 10; i++) {\n    result[i] = function() {\n      return i;\n    };\n  }\n\n  return result;\n}\n\nvar funcs = createFunctions();\n\n// 每个函数都输出10\nfor (var i = 0; i &lt; funcs.length; i++) {\n  document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);\n}\n</code></pre><p>因为每个函数的作用域链都保存着createFunctions()的活动对象，因此它们引用的都是同一个变量i，</p><p>当createFunctions()函数返回后，变量i的值为10，</p><p>所以每个函数内部的i都是10。</p><p>可以通过创建另一个匿名函数强制让闭包行为符合预期：</p><pre><code class=\"js\">for (var i = 0; i &lt; 10; i++) {\n    result[i] = (function(num) {\n      return function(){\n        return num;\n      };\n    })(i);\n  }\n</code></pre><p>在这里，定义了一个立即执行的匿名函数，并将它的结果赋给数组。</p><p>在立即执行时，传入了变量i，又因为函数参数是按值传递的，因此就会将i的当前值赋给num。</p><p>而这个函数内部，又创建并返回了一个访问num的闭包。</p><p>这样，result数组中每个函数都有一个自己的num变量的副本，就可以返回不同的值了。</p><h3 id=\"关于this对象\"><a href=\"#关于this对象\" class=\"headerlink\" title=\"关于this对象\"></a>关于this对象</h3><p>在闭包中使用this对象也可能导致一些问题。</p><p>this对象是在运行时基于函数的运行环境绑定的：</p><ul><li>在全局函数中，this等于window</li><li>当函数被作为某个对象的方法调用时，this等于那个对象</li></ul><p>匿名函数的执行环境具有全局性，如果通过call()或者apply()改变环境执行环境，this会指向其他环境，但通常this指向window。</p><p>arguments也有同样的问题，</p><p>因此如果想访问作用域中的this和arguments对象，必须将对它们的引用保存到另一个闭包能够访问的变量中，然后就可以让闭包访问该对象了，以this为例：</p><pre><code class=\"js\">var name = &quot;The Window&quot;;\n\nvar object = {\n  name: &quot;My Object&quot;,\n\n  getNameFunc1: function() {\n    return function() {\n      return this.name;\n    }\n  },\n  getNameFunc2: function() {\n    var that = this;\n    return function() {\n      return that.name;\n    }\n  }\n};\n\nobject.getNameFunc1(); // &quot;The Window&quot;\nobject.getNameFunc2(); // &quot;My Object&quot;\n</code></pre><h3 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h3><p>由于IE对JScript对象和COM（组件对象模型）对象<strong>使用不同的垃圾收集例程</strong>，因此闭包在IE中可能会导致问题。</p><p>如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁：</p><pre><code class=\"js\">function assignHansdler() {\n  var element = document.getElementById(&quot;someElement&quot;);\n  element.onclick = function() {\n    alert(element.id);\n  };\n}\n</code></pre><p>以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。</p><p>由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。</p><p>只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远都不会被回收。</p><p>可以用如下方式解决：</p><pre><code class=\"js\">function assignHansdler() {\n  var element = document.getElementById(&quot;someElement&quot;);\n  var id = element.id;\n\n  element.onclick = function() {\n    alert(id);\n  };\n\n  element = null;\n}\n</code></pre><p>这样就消除了循环引用。</p><p>需要注意的是，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。</p><p>因此 ，有必要把element设为null。</p><h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>JavaScript在遇到多次声明一个变量的情况时，会自动忽略后边的声明，但是会执行后边声明中的初始化。</p><p>JavaScript没有块级作用域的概念，</p><p>因此块语句中定义的变量，实际上是在包含函数中而不是语句中创建的。</p><p>可以用匿名函数来模仿块级作用域（私有作用域）来避免这个问题：</p><pre><code class=\"js\">(function() {\n  // 块级作用域\n})();\n</code></pre><p>需要注意的是，JavaScript将function当做一个函数声明的开始，而函数声明后边是不能跟括号的。</p><p>因此上边代码中函数外面包括的括号不能省略。这样可以把函数声明转换成函数表达式。</p><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。</p><p>在匿名函数中的任何变量，都会在执行结束时销毁。</p><p>我们应该通过创造私有作用域来尽量少地向全局作用域添加变量和函数，以免导致命名冲突。</p><h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><p>除了前边提到的稳妥构造函数模式，还可以：</p><p>在构造函数中定义特权方法：</p><pre><code class=\"js\">function MyObject() {\n  // 函数的私有变量\n  var privateVariable = 10;\n  // 函数的私有函数\n  function privateFunction() {\n    return false;\n  }\n  // 特权方法\n  this.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n}\n</code></pre><p>在创建MyObject实例后，除了publicMethod没有任何方法可以直接访问privateVariable和privateFunction()。</p><p>或者利用私有和特权成员，隐藏那些不应该被直接修改的数据：</p><pre><code class=\"js\">function Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\nvar person = new Person(&quot;Nicholas&quot;);\nperson.getName(); // &quot;Nicholas&quot;\nperson.setName(&quot;Greg&quot;);\nperson.getName(); // &quot;Greg&quot;\n</code></pre><p>私有变量name在每一个实例的作用域中都不相同，因为每次调用构造函数都会重新创建这两个方法。</p><p>但是这样使用构造函数会有构造函数模式的缺陷：无法方法复用。每次创建实例都会创建同样一组方法，用静态私有变量来实现特权方法就可以解决这个问题。</p><h3 id=\"静态私有变量\"><a href=\"#静态私有变量\" class=\"headerlink\" title=\"静态私有变量\"></a>静态私有变量</h3><pre><code class=\"js\">(function() {\n  var name = &quot;&quot;;\n  // 没有使用var声明，因此为全局变量\n  Person = function(value) {\n    name = value;\n  }\n  Person.prototype.getName = function() {\n    return name;\n  }\n  Person.prototype.setName = function(value) {\n    name = value;\n  }\n})();\n\nvar person1 = new Person(&quot;Nicholas&quot;);\nperson1.getName(); // &quot;NIcholas&quot;\nperson1.setName(&quot;Greg&quot;);\nperson1.getName(); // &quot;Greg&quot;\n\nvar person2 = new Person(&quot;MIchael&quot;);\nperson1.getName(); // &quot;MIchael&quot;\nperson2.getName(); // &quot;MIchael&quot;\n</code></pre><p>在这种模式下，name就变成了静态的、由所有实例共享的属性。</p><p>因此每次改变name改变的是所有实例的name。</p><p>这样创造静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。</p><p>因此使用哪个方法还要视具体情况而定。</p><blockquote><p>多查找作用域链的一个层次会一定程度上影响查找速度，这正是闭包和私有变量的一个明显的不足之处。</p></blockquote><p>对于私有变量，我认为可以使用两者组合的模式，不知道对不对，这里贴出想法，欢迎指正（zmj原创，转载需注明出处）：</p><pre><code class=\"js\">function Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function(value) {\n    name = value;\n  }\n}\n\n(function() {\n  var teacher = &quot;Nicholas&quot;; // 初始化\n  Person.prototype.getTeacher = function() {\n    return teacher;\n  }\n  Person.prototype.setTeacher = function(value) {\n    teacher = value;\n  }\n})();\n</code></pre><p>这样，就既有实例自己的私有变量，也有静态私有变量了。</p><h3 id=\"模块模式\"><a href=\"#模块模式\" class=\"headerlink\" title=\"模块模式\"></a>模块模式</h3><p>模块模式（module pattern）是为单例（singleton）创建私有变量和私有方法。</p><p>所谓单例就是只有一个实例的对象，一般以对象字面量的方式来创建：</p><pre><code class=\"js\">var singleton = {\n  name: value,\n  method: function() {\n    // 这里是方法的代码\n  }\n};\n</code></pre><p>模块模式通过为单例添加私有变量和特权方法来使其增强：</p><pre><code class=\"js\">var singleton = function() {\n  // 私有变量和私有函数\n  var privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n\n  // 特权/公有方法和属性\n  return {\n    publicProperty: true,\n    publicMethod: function() {\n      privateVariable++;\n      return privateFunction();\n    }\n  };\n}();\n</code></pre><p>这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是十分有用的：</p><pre><code class=\"js\">function BaseComponent() {}\nfunction OtherComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 公共\n  return {\n    getComponentCount: function() {\n      return components.length;\n    },\n    registerComponent: function(component) {\n      if (typeof component == &quot;object&quot;) {\n        components.push(component);\n      }\n    }\n  };\n}();\n\napplication.registerComponent(new OtherComponent());\napplication.getComponentCount(); // 2\n</code></pre><p>在Web应用程序中，经常使用一个单例来管理应用程序级的信息。</p><p>以这种模式创建的单例都是Object的实例。</p><h3 id=\"增强的模块模式\"><a href=\"#增强的模块模式\" class=\"headerlink\" title=\"增强的模块模式\"></a>增强的模块模式</h3><p>如果单例必须是某种类型的实例，还必须添加某些属性和/或方法加以增强，可以使用增强的模块模式：</p><pre><code class=\"js\">function BaseComponent() {}\n\nvar application = function() {\n  // 私有变量和函数\n  var components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 创造application的一个局部副本\n  var app = new BaseComponent();\n  // 公共接口\n  app.getComponentCount: function() {\n    return components.length;\n  }；\n  app.registerComponent: function(component) {\n    if (typeof component == &quot;object&quot;) {\n      components.push(component);\n    }\n  }；\n  // 返回这个副本\n  return app;\n}();\n</code></pre>"},{"title":"JavaScript学习记录四","toc":true,"date":"2018-09-16T12:31:22.000Z","_content":"\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# BOM\n\nBrowser Object Model，浏览器对象模型。\n\nBOM提供了很多用于访问浏览器的功能，这些功能与任何网页内容无关。\n\nBOM缺少事实上的规范，因此浏览器之间共有的对象就成了事实上的标准。\n\n没有所谓的标准BOM实现或者标准BOM接口。\n\n图片来源于网络：\n\n![BOM结构图](http://www.splessons.com/wp-content/uploads/2016/03/javascript-bom-01-splessons-1.png)\n\n## window对象\n\n[window文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)\n\nBOM的核心对象是window，表示浏览器的一个实例。\n\n在浏览器中，window对象有双重角色：\n\n- 通过JavaScript访问浏览器窗口的一个接口\n- ECMAScript规定的Global对象\n\n因此window对象有权访问parseInt()等方法。\n\n### 全局作用域\n\n因为window对象又是ECMAScript中的Global对象，因此在全局作用域中声明的所有变量、函数都会变成window对象的属性和方法。\n\n在全局作用域中，this指向window。\n\n### ！窗口关系及框架\n\n**因为书中使用的frameset和frame已经被HTML5废弃，用iframe取代，因此在看了HTML5后再来补充这一部分。**\n\ntop、parent、一个框架一个window对象\n\n### ！窗口位置\n\nscreenLeft、screenX、moveTo等属性等看完文档再来详细记。\n\n### ！窗口大小\n\ninnerWidth、outerWidth、clientWidth、pageWidth、resizeTo()等属性等看完文档再来详细记。\n\n### 导航和打开窗口\n\nwindow.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口，返回指向新窗口的引用。\n\n`window.open(URL,name,specs,replace)`，具体格式看[这里](http://www.runoob.com/jsref/met-win-open.html)。\n\n新创建的window对象有一个opener属性，保存着打开它的原始窗口对象。\n\n#### 安全限制\n\n弹窗广告问题。\n\n为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。\n\n#### 弹出窗口屏蔽程序\n\n弹出窗口被屏蔽有两种可能：\n\n- 被浏览器内置的屏蔽程序阻止，则window.open()很有可能返回null\n- 被浏览器扩展或其他程序阻止，则window.open()通常会抛出异常\n\n因此要想准确地检测弹出窗口是否被屏蔽：\n\n```js\nvar blocked = false;\ntry {\n  var popup = window.open(\"https://blog.zmj97.top\", \"_blank\");\n  if (popup == null) {\n    blocked = true;\n  }\n} catch(e) {\n  blocked = true;\n}\nif (blocked) {\n  alert(\"The Popup was blocked!\");\n}\n```\n\n检测弹出窗口是否被屏蔽并不会阻止浏览器显示与被屏蔽窗口的相关信息。\n\n### 超时调用\n\nsetTimeout()函数接受两个参数，要执行的代码和执行代码前要等待多少毫秒。\n\n第一个参数可以是一个包含JavaScript代码的字符串（不推荐，就和在eval()函数中使用的字符串一样），\n\n也可以是一个函数：\n\n```js\nsetTimeout(\"alert('Hello World!')\", 1000); // 不推荐\n\n// 推荐的调用方式\nsetTimeout(function() {\n  alert('Hello World!');\n}, 1000);\n```\n\n调用setTImeout()后，该方法会返回一个数值ID，表示超时调用，\n\n可以用它作为参数调用clearTimeout()来取消超时调用。\n\n超时调用ID是计划执行代码的唯一标识符。\n\n```js\n// 设置超时调用\nvar timeoutId = setTimeout(function() {\n  alert('Hello World!');\n}, 1000);\n// 把它取消\nclearTimeout(timeoutId);\n```\n\n超时调用的代码都是在全局作用域中执行的，因此函数中的this的值通常指向window对象。\n\n### 间歇调用\n\nsetInterval()函数接受两个参数，要执行的代码和每次执行代码前要等待多少毫秒。\n\n```js\nsetInterval(\"alert('Hello World!')\", 1000); // 不推荐\n\n// 推荐的调用方式\nsetInterval(function() {\n  alert('Hello World!');\n}, 1000);\n```\n\n取消间歇调用：\n\n```js\nvar num = 0;\nvar max = 10;\nvar intervalId = null;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数到达max，则取消间歇调用\n  if (num == max) {\n    clearInterval(intervalId);\n    alert(\"Done\");\n  }\n}\n\nintervalId = setInterval(incrementNumber, 500);\n```\n\n实际上，使用超时调用来模拟间歇调用被认为是最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前启动。\n\n```js\nvar num = 0;\nvar max = 10;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数未到达max，则设置另一次超时调用\n  if (num < max) {\n    setTimeout(incrementNumber, 500);\n  } else {\n    alert(\"Done\");\n  }\n}\n\nsetTimeout(incrementNumber, 500);\n```\n\n### 系统对话框\n\n`alert()`只有一个确认按钮\n\n`confirm()`有确认和取消两个按钮，返回true表示点了确认，false表示点了取消\n\n`prompt()`，提示框，有一个文本输入域和确认取消按钮，两个参数为要显示给用户的提示内容和文本输入域内的默认内容，如果点击确认则返回文本输入域的值，否则返回null。\n\n三者均不涉及HTML、CSS、JavaScript。\n\n还有含有复选框的对话框选择是否阻止后续的对话框的显示。\n\n还可以在JavaScript中通过`window.print()`和`window.find()`来显示打印和查找对话框。这两者是异步显示的，因此对话框计数器的不会吧它们计算在内。\n\n## location对象\n\n提供了与当前窗口中加载的文档有关的信息和一些导航功能。\n\nlocation对象既是window对象的属性，有事document对象的属性。\n\nlocation将URL解析为独立的片段。\n\n下面是location对象的所有属性（忽略了每个属性前的location前缀）：\n\n| 属性名   | 例子                     | 说明                                                         |\n| -------- | ------------------------ | ------------------------------------------------------------ |\n| hash     | \"#contents\"              | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |\n| host     | \"blog.zmj97.top:80\"      | 返回服务器名称和端口号（如果有）                             |\n| hostname | \"blog.zmj97.top\"         | 返回不带端口号的服务器名称                                   |\n| href     | \"https://blog.zmj97.top\" | 返回当前加载页面的完整URL。location对象的toString()方法也返回这个值 |\n| pathname | \"/tag/\"                  | 返回URL中的目录和/或文件名                                   |\n| port     | \"8080\"                   | 返回URL指定的端口号。如果URL中不包含端口号，则返回空字符串   |\n| protocol | \"https:\"                 | 返回页面使用的协议，通常是http:或https:                      |\n| search   | \"?q=javascript\"          | 返回URL的查询字符串。这个字符串以问号开头                    |\n\n### 查询字符串参数\n\n尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问每个查询字符串参数，因此可以：\n\n```js\nfunction getQueryStringArgs() {\n  // 取得查询字符串并去掉开头的问号\n  var qs = (location.search.length > 0 ? location.search.substring(1) : \"\");\n  // 保存数据的对象\n  var args = {};\n  // 取得每一项\n  var items = qs.split(\"&\");\n  var item = null,\n      name = null,\n      value = null;\n  // 逐个添加到args中\n  for (var i = 0; i < items.length; i++) {\n    item = items[i].split(\"=\");\n    name = decodeURIComponent(item[0]);\n    value = decodeURIComponent(item[1]);\n    args[name] = value;\n  }\n\n  return args;\n}\n```\n\n### 位置操作\n\n`location.assign(\"https://blog.zmj97.top\")`，立即打开新URL并在浏览器的历史记录中生成一条记录。\n\n`window.location = \"https://blog.zmj97.top\"`和`location.href = \"https://blog.zmj97.top\"`与调用assign()的效果一样。\n\n每次修改location对象的属性，页面都会以新URL重新加载（hash除外），并在浏览器的历史记录中生成一条新纪录（包括hash）。\n\n使用`location.replace(\"https://blog.zmj97.top\")`加载新页面后不会生成历史记录，也不能后退。\n\n`location.reload()`重新加载，有可能从缓存中加载\n\n`location.reload(true)`从服务器重新加载\n\n位于reload()调用之后的代码可能会也可能不会执行，取决于网络延迟或系统资源等因素。\n\n因此最好将reload()放在代码的最后一行。\n\n## navigator对象\n\n用于识别客户端浏览器，包含有关浏览器的信息。\n\n### 检测插件\n\nnavigator.plugins数组的每一项包含下列属性：\n\n- name：插件名字\n- description：插件描述\n- filename：插件文件名\n- length：插件所处理的MIME类型数量\n\n```js\n// 检查插件（IE中无效）\nfunction hasPlugin(name) {\n  name = name.toLowerCase();\n  for (var i = 0; i < navigator.plugins.length; i++) {\n    if (navigator.plugins[i].toLowerCase().indexOf(name) > -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n每个插件对象本身也是一个MimeType对象的数组，包括四个属性：\n\n- MIME类型描述description\n- 回指插件对象的enablePlugin\n- MIME类型对应的文件扩展名的字符串suffixes（以逗号分割）\n- 完整MIME类型字符串type\n\n在IE中检查插件只能使用专有的ActiveXObject类型，还要知道插件的COM标识符。\n\nplugins集合有一个refresh()方法用于刷新插件，传入true会加载包含插件的所有页面。否则只更新插件不重新加载页面。\n\n### 注册处理程序\n\nregisterContentHandler()、registerProtocalHandler()\n\n为站点指明处理特定类型的信息\n\n## screen对象\n\n所有浏览器都支持的属性：\n\n- availHeight：可用的屏幕高度（像素高度-系统部件高度），只读\n- availWidth：可用的屏幕宽度（像素宽度-系统部件宽度），只读\n- colorDepth：用于表现颜色的位数，多数系统都是32位，只读\n- height：屏幕的像素高度\n- width：屏幕的像素宽度\n\n## history对象\n\n保存用户上网的历史记录\n\n使用go()方法可以在用户的历史记录中任意跳转\n\n```js\nhistory.go(-1); // 后退一页\nhistory.go(2); // 前进两页\nhistory.back(); // 后退一页\nhistory.forward(); // 前进一页\n```\n\n也可以传入一个字符串：浏览器会跳转到历史记录中最近包含该字符串的页面\n\n```js\nhistory.go(\"wrox.com\"); // 跳转到最近的wrox.com页面\n```\n\n# 客户端检测\n\n不到万不得已，不要使用客户端检测。\n\n先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。\n\n## 能力检测\n\n又称特性检测，是最受人们接受的检测方式。\n\n能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。\n\n不用顾及特定的浏览器如何如何，只要它支持特定的能力，就可以给出解决方案。\n\n基本模式：\n\n```js\nif (object.propertyInQuestion) {\n  // 使用object.propertyInQuestion\n}\n```\n\n- 先测试达成目的的最常用的特性\n- 必须测试实际要用到的特性，而不是通过判断另一个特性是否存在来判断是什么浏览器，然后决定是否用这个特性\n\n如果确定自己的应用程序需要使用哪些特定的浏览器特性，最好一次性检测所有相关特性：\n\n```js\n// 确定浏览器是否支持Netscape风格的插件\nvar hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);\n```\n\n> 在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。\n\n## 怪癖检测\n\n怪癖检测的目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷。\n\n例如IE中有一个bug，如果某个实例属性与标记为[[DontEnum]]的某个原型属性同名，则该实例属性不会出现在for-in循环中：\n\n```js\nvar hasDontEnumQuirk = function() {\n  var o = {\n    toString: function() {}\n  };\n  for (var prop in o) {\n    if (prop == toString) {\n      return false;\n    }\n  }\n  return true;\n}();\n```\n\n怪癖通常为某个浏览器独有的，且被归类为bug。\n\n由于检测怪癖涉及运行代码，因此仅检测有直接影响的怪癖，且最好在脚本一开始就执行此类检测，以便尽早解决问题。\n\n","source":"_posts/JavaScript学习记录四.md","raw":"---\ntitle: JavaScript学习记录四\ntoc: true\ndate: 2018-09-16 20:31:22\ncategories:\n- Web\ntags:\n- JavaScript\n---\n\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# BOM\n\nBrowser Object Model，浏览器对象模型。\n\nBOM提供了很多用于访问浏览器的功能，这些功能与任何网页内容无关。\n\nBOM缺少事实上的规范，因此浏览器之间共有的对象就成了事实上的标准。\n\n没有所谓的标准BOM实现或者标准BOM接口。\n\n图片来源于网络：\n\n![BOM结构图](http://www.splessons.com/wp-content/uploads/2016/03/javascript-bom-01-splessons-1.png)\n\n## window对象\n\n[window文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)\n\nBOM的核心对象是window，表示浏览器的一个实例。\n\n在浏览器中，window对象有双重角色：\n\n- 通过JavaScript访问浏览器窗口的一个接口\n- ECMAScript规定的Global对象\n\n因此window对象有权访问parseInt()等方法。\n\n### 全局作用域\n\n因为window对象又是ECMAScript中的Global对象，因此在全局作用域中声明的所有变量、函数都会变成window对象的属性和方法。\n\n在全局作用域中，this指向window。\n\n### ！窗口关系及框架\n\n**因为书中使用的frameset和frame已经被HTML5废弃，用iframe取代，因此在看了HTML5后再来补充这一部分。**\n\ntop、parent、一个框架一个window对象\n\n### ！窗口位置\n\nscreenLeft、screenX、moveTo等属性等看完文档再来详细记。\n\n### ！窗口大小\n\ninnerWidth、outerWidth、clientWidth、pageWidth、resizeTo()等属性等看完文档再来详细记。\n\n### 导航和打开窗口\n\nwindow.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口，返回指向新窗口的引用。\n\n`window.open(URL,name,specs,replace)`，具体格式看[这里](http://www.runoob.com/jsref/met-win-open.html)。\n\n新创建的window对象有一个opener属性，保存着打开它的原始窗口对象。\n\n#### 安全限制\n\n弹窗广告问题。\n\n为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。\n\n#### 弹出窗口屏蔽程序\n\n弹出窗口被屏蔽有两种可能：\n\n- 被浏览器内置的屏蔽程序阻止，则window.open()很有可能返回null\n- 被浏览器扩展或其他程序阻止，则window.open()通常会抛出异常\n\n因此要想准确地检测弹出窗口是否被屏蔽：\n\n```js\nvar blocked = false;\ntry {\n  var popup = window.open(\"https://blog.zmj97.top\", \"_blank\");\n  if (popup == null) {\n    blocked = true;\n  }\n} catch(e) {\n  blocked = true;\n}\nif (blocked) {\n  alert(\"The Popup was blocked!\");\n}\n```\n\n检测弹出窗口是否被屏蔽并不会阻止浏览器显示与被屏蔽窗口的相关信息。\n\n### 超时调用\n\nsetTimeout()函数接受两个参数，要执行的代码和执行代码前要等待多少毫秒。\n\n第一个参数可以是一个包含JavaScript代码的字符串（不推荐，就和在eval()函数中使用的字符串一样），\n\n也可以是一个函数：\n\n```js\nsetTimeout(\"alert('Hello World!')\", 1000); // 不推荐\n\n// 推荐的调用方式\nsetTimeout(function() {\n  alert('Hello World!');\n}, 1000);\n```\n\n调用setTImeout()后，该方法会返回一个数值ID，表示超时调用，\n\n可以用它作为参数调用clearTimeout()来取消超时调用。\n\n超时调用ID是计划执行代码的唯一标识符。\n\n```js\n// 设置超时调用\nvar timeoutId = setTimeout(function() {\n  alert('Hello World!');\n}, 1000);\n// 把它取消\nclearTimeout(timeoutId);\n```\n\n超时调用的代码都是在全局作用域中执行的，因此函数中的this的值通常指向window对象。\n\n### 间歇调用\n\nsetInterval()函数接受两个参数，要执行的代码和每次执行代码前要等待多少毫秒。\n\n```js\nsetInterval(\"alert('Hello World!')\", 1000); // 不推荐\n\n// 推荐的调用方式\nsetInterval(function() {\n  alert('Hello World!');\n}, 1000);\n```\n\n取消间歇调用：\n\n```js\nvar num = 0;\nvar max = 10;\nvar intervalId = null;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数到达max，则取消间歇调用\n  if (num == max) {\n    clearInterval(intervalId);\n    alert(\"Done\");\n  }\n}\n\nintervalId = setInterval(incrementNumber, 500);\n```\n\n实际上，使用超时调用来模拟间歇调用被认为是最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前启动。\n\n```js\nvar num = 0;\nvar max = 10;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数未到达max，则设置另一次超时调用\n  if (num < max) {\n    setTimeout(incrementNumber, 500);\n  } else {\n    alert(\"Done\");\n  }\n}\n\nsetTimeout(incrementNumber, 500);\n```\n\n### 系统对话框\n\n`alert()`只有一个确认按钮\n\n`confirm()`有确认和取消两个按钮，返回true表示点了确认，false表示点了取消\n\n`prompt()`，提示框，有一个文本输入域和确认取消按钮，两个参数为要显示给用户的提示内容和文本输入域内的默认内容，如果点击确认则返回文本输入域的值，否则返回null。\n\n三者均不涉及HTML、CSS、JavaScript。\n\n还有含有复选框的对话框选择是否阻止后续的对话框的显示。\n\n还可以在JavaScript中通过`window.print()`和`window.find()`来显示打印和查找对话框。这两者是异步显示的，因此对话框计数器的不会吧它们计算在内。\n\n## location对象\n\n提供了与当前窗口中加载的文档有关的信息和一些导航功能。\n\nlocation对象既是window对象的属性，有事document对象的属性。\n\nlocation将URL解析为独立的片段。\n\n下面是location对象的所有属性（忽略了每个属性前的location前缀）：\n\n| 属性名   | 例子                     | 说明                                                         |\n| -------- | ------------------------ | ------------------------------------------------------------ |\n| hash     | \"#contents\"              | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |\n| host     | \"blog.zmj97.top:80\"      | 返回服务器名称和端口号（如果有）                             |\n| hostname | \"blog.zmj97.top\"         | 返回不带端口号的服务器名称                                   |\n| href     | \"https://blog.zmj97.top\" | 返回当前加载页面的完整URL。location对象的toString()方法也返回这个值 |\n| pathname | \"/tag/\"                  | 返回URL中的目录和/或文件名                                   |\n| port     | \"8080\"                   | 返回URL指定的端口号。如果URL中不包含端口号，则返回空字符串   |\n| protocol | \"https:\"                 | 返回页面使用的协议，通常是http:或https:                      |\n| search   | \"?q=javascript\"          | 返回URL的查询字符串。这个字符串以问号开头                    |\n\n### 查询字符串参数\n\n尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问每个查询字符串参数，因此可以：\n\n```js\nfunction getQueryStringArgs() {\n  // 取得查询字符串并去掉开头的问号\n  var qs = (location.search.length > 0 ? location.search.substring(1) : \"\");\n  // 保存数据的对象\n  var args = {};\n  // 取得每一项\n  var items = qs.split(\"&\");\n  var item = null,\n      name = null,\n      value = null;\n  // 逐个添加到args中\n  for (var i = 0; i < items.length; i++) {\n    item = items[i].split(\"=\");\n    name = decodeURIComponent(item[0]);\n    value = decodeURIComponent(item[1]);\n    args[name] = value;\n  }\n\n  return args;\n}\n```\n\n### 位置操作\n\n`location.assign(\"https://blog.zmj97.top\")`，立即打开新URL并在浏览器的历史记录中生成一条记录。\n\n`window.location = \"https://blog.zmj97.top\"`和`location.href = \"https://blog.zmj97.top\"`与调用assign()的效果一样。\n\n每次修改location对象的属性，页面都会以新URL重新加载（hash除外），并在浏览器的历史记录中生成一条新纪录（包括hash）。\n\n使用`location.replace(\"https://blog.zmj97.top\")`加载新页面后不会生成历史记录，也不能后退。\n\n`location.reload()`重新加载，有可能从缓存中加载\n\n`location.reload(true)`从服务器重新加载\n\n位于reload()调用之后的代码可能会也可能不会执行，取决于网络延迟或系统资源等因素。\n\n因此最好将reload()放在代码的最后一行。\n\n## navigator对象\n\n用于识别客户端浏览器，包含有关浏览器的信息。\n\n### 检测插件\n\nnavigator.plugins数组的每一项包含下列属性：\n\n- name：插件名字\n- description：插件描述\n- filename：插件文件名\n- length：插件所处理的MIME类型数量\n\n```js\n// 检查插件（IE中无效）\nfunction hasPlugin(name) {\n  name = name.toLowerCase();\n  for (var i = 0; i < navigator.plugins.length; i++) {\n    if (navigator.plugins[i].toLowerCase().indexOf(name) > -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n每个插件对象本身也是一个MimeType对象的数组，包括四个属性：\n\n- MIME类型描述description\n- 回指插件对象的enablePlugin\n- MIME类型对应的文件扩展名的字符串suffixes（以逗号分割）\n- 完整MIME类型字符串type\n\n在IE中检查插件只能使用专有的ActiveXObject类型，还要知道插件的COM标识符。\n\nplugins集合有一个refresh()方法用于刷新插件，传入true会加载包含插件的所有页面。否则只更新插件不重新加载页面。\n\n### 注册处理程序\n\nregisterContentHandler()、registerProtocalHandler()\n\n为站点指明处理特定类型的信息\n\n## screen对象\n\n所有浏览器都支持的属性：\n\n- availHeight：可用的屏幕高度（像素高度-系统部件高度），只读\n- availWidth：可用的屏幕宽度（像素宽度-系统部件宽度），只读\n- colorDepth：用于表现颜色的位数，多数系统都是32位，只读\n- height：屏幕的像素高度\n- width：屏幕的像素宽度\n\n## history对象\n\n保存用户上网的历史记录\n\n使用go()方法可以在用户的历史记录中任意跳转\n\n```js\nhistory.go(-1); // 后退一页\nhistory.go(2); // 前进两页\nhistory.back(); // 后退一页\nhistory.forward(); // 前进一页\n```\n\n也可以传入一个字符串：浏览器会跳转到历史记录中最近包含该字符串的页面\n\n```js\nhistory.go(\"wrox.com\"); // 跳转到最近的wrox.com页面\n```\n\n# 客户端检测\n\n不到万不得已，不要使用客户端检测。\n\n先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。\n\n## 能力检测\n\n又称特性检测，是最受人们接受的检测方式。\n\n能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。\n\n不用顾及特定的浏览器如何如何，只要它支持特定的能力，就可以给出解决方案。\n\n基本模式：\n\n```js\nif (object.propertyInQuestion) {\n  // 使用object.propertyInQuestion\n}\n```\n\n- 先测试达成目的的最常用的特性\n- 必须测试实际要用到的特性，而不是通过判断另一个特性是否存在来判断是什么浏览器，然后决定是否用这个特性\n\n如果确定自己的应用程序需要使用哪些特定的浏览器特性，最好一次性检测所有相关特性：\n\n```js\n// 确定浏览器是否支持Netscape风格的插件\nvar hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);\n```\n\n> 在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。\n\n## 怪癖检测\n\n怪癖检测的目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷。\n\n例如IE中有一个bug，如果某个实例属性与标记为[[DontEnum]]的某个原型属性同名，则该实例属性不会出现在for-in循环中：\n\n```js\nvar hasDontEnumQuirk = function() {\n  var o = {\n    toString: function() {}\n  };\n  for (var prop in o) {\n    if (prop == toString) {\n      return false;\n    }\n  }\n  return true;\n}();\n```\n\n怪癖通常为某个浏览器独有的，且被归类为bug。\n\n由于检测怪癖涉及运行代码，因此仅检测有直接影响的怪癖，且最好在脚本一开始就执行此类检测，以便尽早解决问题。\n\n","slug":"JavaScript学习记录四","published":1,"updated":"2018-10-10T08:38:15.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vf000hfmagym3jndn0","content":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p><a id=\"more\"></a><hr><h1 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h1><p>Browser Object Model，浏览器对象模型。</p><p>BOM提供了很多用于访问浏览器的功能，这些功能与任何网页内容无关。</p><p>BOM缺少事实上的规范，因此浏览器之间共有的对象就成了事实上的标准。</p><p>没有所谓的标准BOM实现或者标准BOM接口。</p><p>图片来源于网络：</p><p><img src=\"http://www.splessons.com/wp-content/uploads/2016/03/javascript-bom-01-splessons-1.png\" alt=\"BOM结构图\"></p><h2 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">window文档</a></p><p>BOM的核心对象是window，表示浏览器的一个实例。</p><p>在浏览器中，window对象有双重角色：</p><ul><li>通过JavaScript访问浏览器窗口的一个接口</li><li>ECMAScript规定的Global对象</li></ul><p>因此window对象有权访问parseInt()等方法。</p><h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>因为window对象又是ECMAScript中的Global对象，因此在全局作用域中声明的所有变量、函数都会变成window对象的属性和方法。</p><p>在全局作用域中，this指向window。</p><h3 id=\"！窗口关系及框架\"><a href=\"#！窗口关系及框架\" class=\"headerlink\" title=\"！窗口关系及框架\"></a>！窗口关系及框架</h3><p><strong>因为书中使用的frameset和frame已经被HTML5废弃，用iframe取代，因此在看了HTML5后再来补充这一部分。</strong></p><p>top、parent、一个框架一个window对象</p><h3 id=\"！窗口位置\"><a href=\"#！窗口位置\" class=\"headerlink\" title=\"！窗口位置\"></a>！窗口位置</h3><p>screenLeft、screenX、moveTo等属性等看完文档再来详细记。</p><h3 id=\"！窗口大小\"><a href=\"#！窗口大小\" class=\"headerlink\" title=\"！窗口大小\"></a>！窗口大小</h3><p>innerWidth、outerWidth、clientWidth、pageWidth、resizeTo()等属性等看完文档再来详细记。</p><h3 id=\"导航和打开窗口\"><a href=\"#导航和打开窗口\" class=\"headerlink\" title=\"导航和打开窗口\"></a>导航和打开窗口</h3><p>window.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口，返回指向新窗口的引用。</p><p><code>window.open(URL,name,specs,replace)</code>，具体格式看<a href=\"http://www.runoob.com/jsref/met-win-open.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>新创建的window对象有一个opener属性，保存着打开它的原始窗口对象。</p><h4 id=\"安全限制\"><a href=\"#安全限制\" class=\"headerlink\" title=\"安全限制\"></a>安全限制</h4><p>弹窗广告问题。</p><p>为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。</p><h4 id=\"弹出窗口屏蔽程序\"><a href=\"#弹出窗口屏蔽程序\" class=\"headerlink\" title=\"弹出窗口屏蔽程序\"></a>弹出窗口屏蔽程序</h4><p>弹出窗口被屏蔽有两种可能：</p><ul><li>被浏览器内置的屏蔽程序阻止，则window.open()很有可能返回null</li><li>被浏览器扩展或其他程序阻止，则window.open()通常会抛出异常</li></ul><p>因此要想准确地检测弹出窗口是否被屏蔽：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> blocked <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> popup <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://blog.zmj97.top\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"_blank\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>popup <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    blocked <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  blocked <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>blocked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The Popup was blocked!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>检测弹出窗口是否被屏蔽并不会阻止浏览器显示与被屏蔽窗口的相关信息。</p><h3 id=\"超时调用\"><a href=\"#超时调用\" class=\"headerlink\" title=\"超时调用\"></a>超时调用</h3><p>setTimeout()函数接受两个参数，要执行的代码和执行代码前要等待多少毫秒。</p><p>第一个参数可以是一个包含JavaScript代码的字符串（不推荐，就和在eval()函数中使用的字符串一样），</p><p>也可以是一个函数：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"alert('Hello World!')\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不推荐</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 推荐的调用方式</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>调用setTImeout()后，该方法会返回一个数值ID，表示超时调用，</p><p>可以用它作为参数调用clearTimeout()来取消超时调用。</p><p>超时调用ID是计划执行代码的唯一标识符。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 设置超时调用</span>\n<span class=\"token keyword\">var</span> timeoutId <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 把它取消</span>\n<span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timeoutId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>超时调用的代码都是在全局作用域中执行的，因此函数中的this的值通常指向window对象。</p><h3 id=\"间歇调用\"><a href=\"#间歇调用\" class=\"headerlink\" title=\"间歇调用\"></a>间歇调用</h3><p>setInterval()函数接受两个参数，要执行的代码和每次执行代码前要等待多少毫秒。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"alert('Hello World!')\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不推荐</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 推荐的调用方式</span>\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>取消间歇调用：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> max <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> intervalId <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">incrementNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果执行次数到达max，则取消间歇调用</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>intervalId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nintervalId <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>incrementNumber<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>实际上，使用超时调用来模拟间歇调用被认为是最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前启动。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> max <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">incrementNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  num<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果执行次数未到达max，则设置另一次超时调用</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;</span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>incrementNumber<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>incrementNumber<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"系统对话框\"><a href=\"#系统对话框\" class=\"headerlink\" title=\"系统对话框\"></a>系统对话框</h3><p><code>alert()</code>只有一个确认按钮</p><p><code>confirm()</code>有确认和取消两个按钮，返回true表示点了确认，false表示点了取消</p><p><code>prompt()</code>，提示框，有一个文本输入域和确认取消按钮，两个参数为要显示给用户的提示内容和文本输入域内的默认内容，如果点击确认则返回文本输入域的值，否则返回null。</p><p>三者均不涉及HTML、CSS、JavaScript。</p><p>还有含有复选框的对话框选择是否阻止后续的对话框的显示。</p><p>还可以在JavaScript中通过<code>window.print()</code>和<code>window.find()</code>来显示打印和查找对话框。这两者是异步显示的，因此对话框计数器的不会吧它们计算在内。</p><h2 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h2><p>提供了与当前窗口中加载的文档有关的信息和一些导航功能。</p><p>location对象既是window对象的属性，有事document对象的属性。</p><p>location将URL解析为独立的片段。</p><p>下面是location对象的所有属性（忽略了每个属性前的location前缀）：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串</td></tr><tr><td>host</td><td>“blog.zmj97.top:80”</td><td>返回服务器名称和端口号（如果有）</td></tr><tr><td>hostname</td><td>“blog.zmj97.top”</td><td>返回不带端口号的服务器名称</td></tr><tr><td>href</td><td>“<a href=\"https://blog.zmj97.top&quot;\" target=\"_blank\" rel=\"noopener\">https://blog.zmj97.top&quot;</a></td><td>返回当前加载页面的完整URL。location对象的toString()方法也返回这个值</td></tr><tr><td>pathname</td><td>“/tag/“</td><td>返回URL中的目录和/或文件名</td></tr><tr><td>port</td><td>“8080”</td><td>返回URL指定的端口号。如果URL中不包含端口号，则返回空字符串</td></tr><tr><td>protocol</td><td>“https:”</td><td>返回页面使用的协议，通常是http:或https:</td></tr><tr><td>search</td><td>“?q=javascript”</td><td>返回URL的查询字符串。这个字符串以问号开头</td></tr></tbody></table><h3 id=\"查询字符串参数\"><a href=\"#查询字符串参数\" class=\"headerlink\" title=\"查询字符串参数\"></a>查询字符串参数</h3><p>尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问每个查询字符串参数，因此可以：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getQueryStringArgs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 取得查询字符串并去掉开头的问号</span>\n  <span class=\"token keyword\">var</span> qs <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> location<span class=\"token punctuation\">.</span>search<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 保存数据的对象</span>\n  <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 取得每一项</span>\n  <span class=\"token keyword\">var</span> items <span class=\"token operator\">=</span> qs<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> item <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      name <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      value <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 逐个添加到args中</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    item <span class=\"token operator\">=</span> items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    name <span class=\"token operator\">=</span> <span class=\"token function\">decodeURIComponent</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    value <span class=\"token operator\">=</span> <span class=\"token function\">decodeURIComponent</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    args<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> args<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"位置操作\"><a href=\"#位置操作\" class=\"headerlink\" title=\"位置操作\"></a>位置操作</h3><p><code>location.assign(&quot;https://blog.zmj97.top&quot;)</code>，立即打开新URL并在浏览器的历史记录中生成一条记录。</p><p><code>window.location = &quot;https://blog.zmj97.top&quot;</code>和<code>location.href = &quot;https://blog.zmj97.top&quot;</code>与调用assign()的效果一样。</p><p>每次修改location对象的属性，页面都会以新URL重新加载（hash除外），并在浏览器的历史记录中生成一条新纪录（包括hash）。</p><p>使用<code>location.replace(&quot;https://blog.zmj97.top&quot;)</code>加载新页面后不会生成历史记录，也不能后退。</p><p><code>location.reload()</code>重新加载，有可能从缓存中加载</p><p><code>location.reload(true)</code>从服务器重新加载</p><p>位于reload()调用之后的代码可能会也可能不会执行，取决于网络延迟或系统资源等因素。</p><p>因此最好将reload()放在代码的最后一行。</p><h2 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h2><p>用于识别客户端浏览器，包含有关浏览器的信息。</p><h3 id=\"检测插件\"><a href=\"#检测插件\" class=\"headerlink\" title=\"检测插件\"></a>检测插件</h3><p>navigator.plugins数组的每一项包含下列属性：</p><ul><li>name：插件名字</li><li>description：插件描述</li><li>filename：插件文件名</li><li>length：插件所处理的MIME类型数量</li></ul><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 检查插件（IE中无效）</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hasPlugin</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> navigator<span class=\"token punctuation\">.</span>plugins<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>navigator<span class=\"token punctuation\">.</span>plugins<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>每个插件对象本身也是一个MimeType对象的数组，包括四个属性：</p><ul><li>MIME类型描述description</li><li>回指插件对象的enablePlugin</li><li>MIME类型对应的文件扩展名的字符串suffixes（以逗号分割）</li><li>完整MIME类型字符串type</li></ul><p>在IE中检查插件只能使用专有的ActiveXObject类型，还要知道插件的COM标识符。</p><p>plugins集合有一个refresh()方法用于刷新插件，传入true会加载包含插件的所有页面。否则只更新插件不重新加载页面。</p><h3 id=\"注册处理程序\"><a href=\"#注册处理程序\" class=\"headerlink\" title=\"注册处理程序\"></a>注册处理程序</h3><p>registerContentHandler()、registerProtocalHandler()</p><p>为站点指明处理特定类型的信息</p><h2 id=\"screen对象\"><a href=\"#screen对象\" class=\"headerlink\" title=\"screen对象\"></a>screen对象</h2><p>所有浏览器都支持的属性：</p><ul><li>availHeight：可用的屏幕高度（像素高度-系统部件高度），只读</li><li>availWidth：可用的屏幕宽度（像素宽度-系统部件宽度），只读</li><li>colorDepth：用于表现颜色的位数，多数系统都是32位，只读</li><li>height：屏幕的像素高度</li><li>width：屏幕的像素宽度</li></ul><h2 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h2><p>保存用户上网的历史记录</p><p>使用go()方法可以在用户的历史记录中任意跳转</p><pre class=\" language-js\"><code class=\"language-js\">history<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 后退一页</span>\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 前进两页</span>\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 后退一页</span>\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">forward</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 前进一页</span>\n</code></pre><p>也可以传入一个字符串：浏览器会跳转到历史记录中最近包含该字符串的页面</p><pre class=\" language-js\"><code class=\"language-js\">history<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wrox.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 跳转到最近的wrox.com页面</span>\n</code></pre><h1 id=\"客户端检测\"><a href=\"#客户端检测\" class=\"headerlink\" title=\"客户端检测\"></a>客户端检测</h1><p>不到万不得已，不要使用客户端检测。</p><p>先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。</p><h2 id=\"能力检测\"><a href=\"#能力检测\" class=\"headerlink\" title=\"能力检测\"></a>能力检测</h2><p>又称特性检测，是最受人们接受的检测方式。</p><p>能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。</p><p>不用顾及特定的浏览器如何如何，只要它支持特定的能力，就可以给出解决方案。</p><p>基本模式：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">.</span>propertyInQuestion<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 使用object.propertyInQuestion</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><ul><li>先测试达成目的的最常用的特性</li><li>必须测试实际要用到的特性，而不是通过判断另一个特性是否存在来判断是什么浏览器，然后决定是否用这个特性</li></ul><p>如果确定自己的应用程序需要使用哪些特定的浏览器特性，最好一次性检测所有相关特性：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 确定浏览器是否支持Netscape风格的插件</span>\n<span class=\"token keyword\">var</span> hasNSPlugins <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>navigator<span class=\"token punctuation\">.</span>plugins <span class=\"token operator\">&amp;&amp;</span> navigator<span class=\"token punctuation\">.</span>plugins<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><blockquote><p>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。</p></blockquote><h2 id=\"怪癖检测\"><a href=\"#怪癖检测\" class=\"headerlink\" title=\"怪癖检测\"></a>怪癖检测</h2><p>怪癖检测的目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷。</p><p>例如IE中有一个bug，如果某个实例属性与标记为[[DontEnum]]的某个原型属性同名，则该实例属性不会出现在for-in循环中：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> hasDontEnumQuirk <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    toString<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> prop <span class=\"token keyword\">in</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prop <span class=\"token operator\">==</span> toString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>怪癖通常为某个浏览器独有的，且被归类为bug。</p><p>由于检测怪癖涉及运行代码，因此仅检测有直接影响的怪癖，且最好在脚本一开始就执行此类检测，以便尽早解决问题。</p>","site":{"data":{}},"excerpt":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p>","more":"<hr><h1 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h1><p>Browser Object Model，浏览器对象模型。</p><p>BOM提供了很多用于访问浏览器的功能，这些功能与任何网页内容无关。</p><p>BOM缺少事实上的规范，因此浏览器之间共有的对象就成了事实上的标准。</p><p>没有所谓的标准BOM实现或者标准BOM接口。</p><p>图片来源于网络：</p><p><img src=\"http://www.splessons.com/wp-content/uploads/2016/03/javascript-bom-01-splessons-1.png\" alt=\"BOM结构图\"></p><h2 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">window文档</a></p><p>BOM的核心对象是window，表示浏览器的一个实例。</p><p>在浏览器中，window对象有双重角色：</p><ul><li>通过JavaScript访问浏览器窗口的一个接口</li><li>ECMAScript规定的Global对象</li></ul><p>因此window对象有权访问parseInt()等方法。</p><h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p>因为window对象又是ECMAScript中的Global对象，因此在全局作用域中声明的所有变量、函数都会变成window对象的属性和方法。</p><p>在全局作用域中，this指向window。</p><h3 id=\"！窗口关系及框架\"><a href=\"#！窗口关系及框架\" class=\"headerlink\" title=\"！窗口关系及框架\"></a>！窗口关系及框架</h3><p><strong>因为书中使用的frameset和frame已经被HTML5废弃，用iframe取代，因此在看了HTML5后再来补充这一部分。</strong></p><p>top、parent、一个框架一个window对象</p><h3 id=\"！窗口位置\"><a href=\"#！窗口位置\" class=\"headerlink\" title=\"！窗口位置\"></a>！窗口位置</h3><p>screenLeft、screenX、moveTo等属性等看完文档再来详细记。</p><h3 id=\"！窗口大小\"><a href=\"#！窗口大小\" class=\"headerlink\" title=\"！窗口大小\"></a>！窗口大小</h3><p>innerWidth、outerWidth、clientWidth、pageWidth、resizeTo()等属性等看完文档再来详细记。</p><h3 id=\"导航和打开窗口\"><a href=\"#导航和打开窗口\" class=\"headerlink\" title=\"导航和打开窗口\"></a>导航和打开窗口</h3><p>window.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口，返回指向新窗口的引用。</p><p><code>window.open(URL,name,specs,replace)</code>，具体格式看<a href=\"http://www.runoob.com/jsref/met-win-open.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>新创建的window对象有一个opener属性，保存着打开它的原始窗口对象。</p><h4 id=\"安全限制\"><a href=\"#安全限制\" class=\"headerlink\" title=\"安全限制\"></a>安全限制</h4><p>弹窗广告问题。</p><p>为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。</p><h4 id=\"弹出窗口屏蔽程序\"><a href=\"#弹出窗口屏蔽程序\" class=\"headerlink\" title=\"弹出窗口屏蔽程序\"></a>弹出窗口屏蔽程序</h4><p>弹出窗口被屏蔽有两种可能：</p><ul><li>被浏览器内置的屏蔽程序阻止，则window.open()很有可能返回null</li><li>被浏览器扩展或其他程序阻止，则window.open()通常会抛出异常</li></ul><p>因此要想准确地检测弹出窗口是否被屏蔽：</p><pre><code class=\"js\">var blocked = false;\ntry {\n  var popup = window.open(&quot;https://blog.zmj97.top&quot;, &quot;_blank&quot;);\n  if (popup == null) {\n    blocked = true;\n  }\n} catch(e) {\n  blocked = true;\n}\nif (blocked) {\n  alert(&quot;The Popup was blocked!&quot;);\n}\n</code></pre><p>检测弹出窗口是否被屏蔽并不会阻止浏览器显示与被屏蔽窗口的相关信息。</p><h3 id=\"超时调用\"><a href=\"#超时调用\" class=\"headerlink\" title=\"超时调用\"></a>超时调用</h3><p>setTimeout()函数接受两个参数，要执行的代码和执行代码前要等待多少毫秒。</p><p>第一个参数可以是一个包含JavaScript代码的字符串（不推荐，就和在eval()函数中使用的字符串一样），</p><p>也可以是一个函数：</p><pre><code class=\"js\">setTimeout(&quot;alert(&#39;Hello World!&#39;)&quot;, 1000); // 不推荐\n\n// 推荐的调用方式\nsetTimeout(function() {\n  alert(&#39;Hello World!&#39;);\n}, 1000);\n</code></pre><p>调用setTImeout()后，该方法会返回一个数值ID，表示超时调用，</p><p>可以用它作为参数调用clearTimeout()来取消超时调用。</p><p>超时调用ID是计划执行代码的唯一标识符。</p><pre><code class=\"js\">// 设置超时调用\nvar timeoutId = setTimeout(function() {\n  alert(&#39;Hello World!&#39;);\n}, 1000);\n// 把它取消\nclearTimeout(timeoutId);\n</code></pre><p>超时调用的代码都是在全局作用域中执行的，因此函数中的this的值通常指向window对象。</p><h3 id=\"间歇调用\"><a href=\"#间歇调用\" class=\"headerlink\" title=\"间歇调用\"></a>间歇调用</h3><p>setInterval()函数接受两个参数，要执行的代码和每次执行代码前要等待多少毫秒。</p><pre><code class=\"js\">setInterval(&quot;alert(&#39;Hello World!&#39;)&quot;, 1000); // 不推荐\n\n// 推荐的调用方式\nsetInterval(function() {\n  alert(&#39;Hello World!&#39;);\n}, 1000);\n</code></pre><p>取消间歇调用：</p><pre><code class=\"js\">var num = 0;\nvar max = 10;\nvar intervalId = null;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数到达max，则取消间歇调用\n  if (num == max) {\n    clearInterval(intervalId);\n    alert(&quot;Done&quot;);\n  }\n}\n\nintervalId = setInterval(incrementNumber, 500);\n</code></pre><p>实际上，使用超时调用来模拟间歇调用被认为是最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前启动。</p><pre><code class=\"js\">var num = 0;\nvar max = 10;\n\nfunction incrementNumber() {\n  num++;\n  // 如果执行次数未到达max，则设置另一次超时调用\n  if (num &lt; max) {\n    setTimeout(incrementNumber, 500);\n  } else {\n    alert(&quot;Done&quot;);\n  }\n}\n\nsetTimeout(incrementNumber, 500);\n</code></pre><h3 id=\"系统对话框\"><a href=\"#系统对话框\" class=\"headerlink\" title=\"系统对话框\"></a>系统对话框</h3><p><code>alert()</code>只有一个确认按钮</p><p><code>confirm()</code>有确认和取消两个按钮，返回true表示点了确认，false表示点了取消</p><p><code>prompt()</code>，提示框，有一个文本输入域和确认取消按钮，两个参数为要显示给用户的提示内容和文本输入域内的默认内容，如果点击确认则返回文本输入域的值，否则返回null。</p><p>三者均不涉及HTML、CSS、JavaScript。</p><p>还有含有复选框的对话框选择是否阻止后续的对话框的显示。</p><p>还可以在JavaScript中通过<code>window.print()</code>和<code>window.find()</code>来显示打印和查找对话框。这两者是异步显示的，因此对话框计数器的不会吧它们计算在内。</p><h2 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h2><p>提供了与当前窗口中加载的文档有关的信息和一些导航功能。</p><p>location对象既是window对象的属性，有事document对象的属性。</p><p>location将URL解析为独立的片段。</p><p>下面是location对象的所有属性（忽略了每个属性前的location前缀）：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串</td></tr><tr><td>host</td><td>“blog.zmj97.top:80”</td><td>返回服务器名称和端口号（如果有）</td></tr><tr><td>hostname</td><td>“blog.zmj97.top”</td><td>返回不带端口号的服务器名称</td></tr><tr><td>href</td><td>“<a href=\"https://blog.zmj97.top&quot;\" target=\"_blank\" rel=\"noopener\">https://blog.zmj97.top&quot;</a></td><td>返回当前加载页面的完整URL。location对象的toString()方法也返回这个值</td></tr><tr><td>pathname</td><td>“/tag/“</td><td>返回URL中的目录和/或文件名</td></tr><tr><td>port</td><td>“8080”</td><td>返回URL指定的端口号。如果URL中不包含端口号，则返回空字符串</td></tr><tr><td>protocol</td><td>“https:”</td><td>返回页面使用的协议，通常是http:或https:</td></tr><tr><td>search</td><td>“?q=javascript”</td><td>返回URL的查询字符串。这个字符串以问号开头</td></tr></tbody></table><h3 id=\"查询字符串参数\"><a href=\"#查询字符串参数\" class=\"headerlink\" title=\"查询字符串参数\"></a>查询字符串参数</h3><p>尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问每个查询字符串参数，因此可以：</p><pre><code class=\"js\">function getQueryStringArgs() {\n  // 取得查询字符串并去掉开头的问号\n  var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;);\n  // 保存数据的对象\n  var args = {};\n  // 取得每一项\n  var items = qs.split(&quot;&amp;&quot;);\n  var item = null,\n      name = null,\n      value = null;\n  // 逐个添加到args中\n  for (var i = 0; i &lt; items.length; i++) {\n    item = items[i].split(&quot;=&quot;);\n    name = decodeURIComponent(item[0]);\n    value = decodeURIComponent(item[1]);\n    args[name] = value;\n  }\n\n  return args;\n}\n</code></pre><h3 id=\"位置操作\"><a href=\"#位置操作\" class=\"headerlink\" title=\"位置操作\"></a>位置操作</h3><p><code>location.assign(&quot;https://blog.zmj97.top&quot;)</code>，立即打开新URL并在浏览器的历史记录中生成一条记录。</p><p><code>window.location = &quot;https://blog.zmj97.top&quot;</code>和<code>location.href = &quot;https://blog.zmj97.top&quot;</code>与调用assign()的效果一样。</p><p>每次修改location对象的属性，页面都会以新URL重新加载（hash除外），并在浏览器的历史记录中生成一条新纪录（包括hash）。</p><p>使用<code>location.replace(&quot;https://blog.zmj97.top&quot;)</code>加载新页面后不会生成历史记录，也不能后退。</p><p><code>location.reload()</code>重新加载，有可能从缓存中加载</p><p><code>location.reload(true)</code>从服务器重新加载</p><p>位于reload()调用之后的代码可能会也可能不会执行，取决于网络延迟或系统资源等因素。</p><p>因此最好将reload()放在代码的最后一行。</p><h2 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h2><p>用于识别客户端浏览器，包含有关浏览器的信息。</p><h3 id=\"检测插件\"><a href=\"#检测插件\" class=\"headerlink\" title=\"检测插件\"></a>检测插件</h3><p>navigator.plugins数组的每一项包含下列属性：</p><ul><li>name：插件名字</li><li>description：插件描述</li><li>filename：插件文件名</li><li>length：插件所处理的MIME类型数量</li></ul><pre><code class=\"js\">// 检查插件（IE中无效）\nfunction hasPlugin(name) {\n  name = name.toLowerCase();\n  for (var i = 0; i &lt; navigator.plugins.length; i++) {\n    if (navigator.plugins[i].toLowerCase().indexOf(name) &gt; -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n</code></pre><p>每个插件对象本身也是一个MimeType对象的数组，包括四个属性：</p><ul><li>MIME类型描述description</li><li>回指插件对象的enablePlugin</li><li>MIME类型对应的文件扩展名的字符串suffixes（以逗号分割）</li><li>完整MIME类型字符串type</li></ul><p>在IE中检查插件只能使用专有的ActiveXObject类型，还要知道插件的COM标识符。</p><p>plugins集合有一个refresh()方法用于刷新插件，传入true会加载包含插件的所有页面。否则只更新插件不重新加载页面。</p><h3 id=\"注册处理程序\"><a href=\"#注册处理程序\" class=\"headerlink\" title=\"注册处理程序\"></a>注册处理程序</h3><p>registerContentHandler()、registerProtocalHandler()</p><p>为站点指明处理特定类型的信息</p><h2 id=\"screen对象\"><a href=\"#screen对象\" class=\"headerlink\" title=\"screen对象\"></a>screen对象</h2><p>所有浏览器都支持的属性：</p><ul><li>availHeight：可用的屏幕高度（像素高度-系统部件高度），只读</li><li>availWidth：可用的屏幕宽度（像素宽度-系统部件宽度），只读</li><li>colorDepth：用于表现颜色的位数，多数系统都是32位，只读</li><li>height：屏幕的像素高度</li><li>width：屏幕的像素宽度</li></ul><h2 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h2><p>保存用户上网的历史记录</p><p>使用go()方法可以在用户的历史记录中任意跳转</p><pre><code class=\"js\">history.go(-1); // 后退一页\nhistory.go(2); // 前进两页\nhistory.back(); // 后退一页\nhistory.forward(); // 前进一页\n</code></pre><p>也可以传入一个字符串：浏览器会跳转到历史记录中最近包含该字符串的页面</p><pre><code class=\"js\">history.go(&quot;wrox.com&quot;); // 跳转到最近的wrox.com页面\n</code></pre><h1 id=\"客户端检测\"><a href=\"#客户端检测\" class=\"headerlink\" title=\"客户端检测\"></a>客户端检测</h1><p>不到万不得已，不要使用客户端检测。</p><p>先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。</p><h2 id=\"能力检测\"><a href=\"#能力检测\" class=\"headerlink\" title=\"能力检测\"></a>能力检测</h2><p>又称特性检测，是最受人们接受的检测方式。</p><p>能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。</p><p>不用顾及特定的浏览器如何如何，只要它支持特定的能力，就可以给出解决方案。</p><p>基本模式：</p><pre><code class=\"js\">if (object.propertyInQuestion) {\n  // 使用object.propertyInQuestion\n}\n</code></pre><ul><li>先测试达成目的的最常用的特性</li><li>必须测试实际要用到的特性，而不是通过判断另一个特性是否存在来判断是什么浏览器，然后决定是否用这个特性</li></ul><p>如果确定自己的应用程序需要使用哪些特定的浏览器特性，最好一次性检测所有相关特性：</p><pre><code class=\"js\">// 确定浏览器是否支持Netscape风格的插件\nvar hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);\n</code></pre><blockquote><p>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。</p></blockquote><h2 id=\"怪癖检测\"><a href=\"#怪癖检测\" class=\"headerlink\" title=\"怪癖检测\"></a>怪癖检测</h2><p>怪癖检测的目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷。</p><p>例如IE中有一个bug，如果某个实例属性与标记为[[DontEnum]]的某个原型属性同名，则该实例属性不会出现在for-in循环中：</p><pre><code class=\"js\">var hasDontEnumQuirk = function() {\n  var o = {\n    toString: function() {}\n  };\n  for (var prop in o) {\n    if (prop == toString) {\n      return false;\n    }\n  }\n  return true;\n}();\n</code></pre><p>怪癖通常为某个浏览器独有的，且被归类为bug。</p><p>由于检测怪癖涉及运行代码，因此仅检测有直接影响的怪癖，且最好在脚本一开始就执行此类检测，以便尽早解决问题。</p>"},{"title":"JavaScript学习记录二","toc":true,"date":"2018-09-13T02:14:53.000Z","_content":"\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# 变量、作用域和内存问题\n\n## 基本类型和引用类型的值\n\nECMAScript变量可能包含两种不同数据类型的值：\n\n- **基本类型值**：保存在**栈内存**中的简单数据段，这种值完全保存在内存中的一个位置\n- **引用类型值**：保存在**堆内存**中的对象，保存的实际上是一个指针，指针指向内存中真正对象保存的位置\n\n五种基本数据类型：Undefined、Null、Boolean、Number、String在内存中占有固定大小的空间，因此可以保存在栈内存中。因为我们操作的是它们实际保存的值，所以它们是**按值**访问的。\n\n对于对象，先从栈中读取内存地址，然后再按照地址找到保存在堆中的值。因为我们操作的不是实际的值，而是那个值所引用的对象，因此我们称之为**按引用**访问的。（图片来源于网络，cr 水印）\n\n![栈内存与堆内存](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536816598256&di=246ab4e73e12049d497d375df4fd273b&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D2929764421%2C2277861536%26fm%3D214%26gp%3D0.jpg)\n\n### 动态属性\n\n对于对象，我们可以改变和删除其属性和方法，但是不能给基本类型的值添加属性。\n\n即只能给引用类型值动态地添加属性。\n\n### 复制变量值\n\n当复制基本类型值的时候，会在栈中为其开辟一块新的内存保存其值。\n\n但是当复制引用类型的值时，实际上复制保存的是这个对象在堆内存中的地址，也就是两者指向的是同一个对象。\n\n### 传递参数\n\nECMAScript中所有的函数的参数都是**按值传递**的。\n\n传递基本类型值就如基本类型变量的复制一样，传递引用类型变量时也如同引用变量的复制。\n\n因此传递引用类型的变量时，传递的相当于是拷贝的指针。\n\n可以看下边这个例子（我觉得可以把对象看做是一个指向对象的指针，然后函数传递的是一个拷贝的指针）：\n\n```javascript\nfunction setName(obj) {\n  obj.name = \"Nicholas\";\n  obj = new Object();\n  obj.name = \"Greg\";\n}\n\nvar person = new Obejct();\nsetName(person);\nalert(person.name); // \"Nicholas\"\n```\n\n### 检测类型\n\ntypeof检测null返回\"object\"\n\n当我们想知道一个对象是什么类型的对象时，可以使用`instanceof`，它的语法是：\n\n`result = variable instanceof constructor`\n\n如果变量是给定引用类型（由构造函数表示）的实例，则instanceof返回true：\n\n```javascript\nalert(person instanceof Object); // 变量person是Object么？\nalert(colors instanceof Array); // 变量colors是Array么？\n```\n\n当使用instanceof检测基本类型的值时始终返回false，因为基本类型不是对象。\n\n注： 在Safiri和Chrome中使用typeof检测正则表达式会错误的返回\"function\"。\n\n## 执行环境和作用域\n\n[执行环境](https://blog.csdn.net/wmaoshu/article/details/60466990)定义了变量或函数有权访问的其他数据，决定了它们各自的行为。\n\n每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。\n\n在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。\n\n一个执行环境中的所有代码执行完毕后，该环境和保存在其中的所有变量和函数定义都被销毁，\n\n全局执行环境直到关闭页面或者浏览器时才会被销毁。\n\n关于作用域链可以看[这里](https://blog.csdn.net/charlene0824/article/details/52252824)。\n\n### 延长作用域链\n\n- with语句： 其变量对象包含为指定的对象的所有属性和方法所做的变量声明。\n- catch语句： 包含被抛出的错误对象的声明\n\n在IE的JavaScript实现中，catch语句捕获的错误对象会被添加到执行环境的变量对象中。\n\n### 没有块级作用域\n\n- 使用if 、for语句创建的变量会保存在语句外部的执行环境中。\n\n- 函数内部是一个局部环境\n- 访问局部变量比全局变量快，因为不用向上搜索作用域链\n\n## 垃圾收集\n\nJavaScript具有自动垃圾收集机制，按照固定的时间间隔或代码执行中预定的收集时间，周期性地找出不再使用的变量释放其内存。\n\n关于垃圾收集方式的详细解释可以看[这里](https://www.cnblogs.com/scottjeremy/p/6870729.html)。\n\n关于性能问题和管理内存可以看[这里](https://www.cnblogs.com/yxField/p/4226591.html)。\n\n# 引用类型\n\n## Object类型\n\n创建Object实例的方式：\n\n- `var xxx = new Object()`\n- `var xxx = {age: 29}`, `{}`是对象字面量边界\n\n可以用`xxx.age`或者`xxx['age']`来访问属性，更建议用点表示法。\n\n## Array类型\n\nECMAScript数组的每一项可以保存任何类型的数据。\n\n数组的索引从0开始。\n\n数组的项数保存在其length属性中，它并不是只读的，可以通过设置它来在数组的末尾移除或添加项，添加项的初始值为undefined。\n\n因为JavaScript使用一个32位整数保存数组元素个数，因此数组最多可以包含4294967295项（2的32次方减1）。\n\n以下是创建数组的例子：\n\n```javascript\n// new 可以省略\nvar a = new Array(); // 创建一个空数组\nvar b = new Array(20); // 创造一个包含20项的数组，每一项的初始值都是undefined\nvar c = new Array(\"red\", \"blue\", \"green\"); // 创造一个包含三项：\"red\",\"blue\",\"green\"的数组\nvar d = [\"red\", \"blue\", \"green\"]; // 创造一个包含三项：\"red\",\"blue\",\"green\"的数组\nvar e = []; // 创建一个空数组\nvar f = [1,2,]; // 不要这样！这样会创建一个包含2或3项的数组\nvar g = [,,,,,]; // 不要这样！这样会创建一个包含5或6项的数组\n```\n\n### 转换方法\n\nvalueOf()返回当前对象的原始值；\n\ntoString()方法先调用每一项的toString()方法，然后用逗号将它们拼接起来并返回；\n\ntoLocalString()方法先调用每一项的toLocalString()方法，然后用逗号将它们拼接起来并返回；\n\n如果使用join()方法可以使用不同的分隔符来构建这个字符串：\n\n```javascript\nvar a = ['a','b','c'];\nalert(a.join(',')); // 'a,b,c'\nalert(a.join('||')); // 'a||b||c'\n```\n\n如果某一项是undefined或null，那么在toString()、toLocalString()、join()方法返回的结果中以空字符串表示。\n\n### 栈方法\n\nECMAScript为数组提供了push()和pop()方法，以便实现类似栈的行为（LIFO，后进先出）。\n\n- push()方法可以接受任意数量的参数，然后把它们逐个添加到数组末尾，并返回修改后的数组长度\n- pop()方法则从数组末尾移除最后一项，并将length减一，返回移除的项。\n\n### 队列方法\n\n可以使用push()和shift()方法，实现类似于队列的行为（FIFO，先进先出）。\n\n- shift()方法从数组开头移除第一项，并将length减一，返回移除的项。\n- ECMAScript还提供了unshift()方法，可以接受任意数量的参数，然后把它们逐个添加到数组头部，并返回修改后的数组长度（IE返回undefined）。\n\n关于unshift()的添加多个变量的顺序：\n\n```javascript\na = [\"a\", \"b\", \"c\", null]；\na.unshift('1','2'); // [\"1\", \"2\", \"a\", \"b\", \"c\", null]\n```\n\n### 重排序方法\n\nreverse()会反转数组项的顺序：\n\n```javascript\nvar a = [1,2,6,5,3,0];\na.reverse();\nalert(a); // 0,3,5,6,2,1\n```\n\nsort()为排序函数，默认从小到大排序，也可以传入一个比较函数：\n\n```javascript\nvar a = [1,2,6,5,3,0];\na.sort();\nalert(a); // 0,1,2,3,5,6\n\nfunction compare(v1, v2) {\n  if (v1 < v2) {\n    return 1;\n  } else if (v1 > v2) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\na.sort(compare);\nalert(a); // 6,5,3,2,1,0\n```\n\n对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以简化一下比较函数：\n\n```javascript\n// 升序排序\nfunction compare1(v1, v2) {\n  return v1 - v2;\n}\n\n// 降序排序\nfunction compare1(v1, v2) {\n  return v2 - v1;\n}\n```\n\n### 操作方法\n\n#### concat()\n\n——先创建一个当前数组的副本，然后将接收到的参数添加到这个副本的末尾，返回新构建的这个数组：\n\n```javascript\nvar a = ['1','2','3'];\nvar b = a.concat('4',['5','6']);\nalert(a); // 1,2,3\nalert(b); // 1,2,3,4,5,6\n```\n\n#### slice()\n\n——局部拷贝数组，接受一个参数或两个参数；\n\n一个参数时拷贝从这个参数指定的位置到结尾；\n\n两个参数时，拷贝两个参数之间的项，不包含结束为止的项。\n\n当参数为负数时，则用该数加数组长度：\n\n- 若加完之后大于等于零则用加完后的数计算\n- 若加完之后还小于0则把该数看做0\n\n若起始位置大于结束位置，则返回空数组。\n\n下边为一个简单的例子：\n\n```javascript\nvar a = [0,1,2,3,4];\nvar b = a.slice(1);\nvar c = a.slice(1,4);\nalert(a); // 1,2,3,4\nalert(b); // 1,2,3\n```\n\n#### splice()\n\n主要用途是向数组的中部插入项，对原数组进行操作\n\n使用方式主要有三种：\n\n- 删除： 指定两个参数——要删除的第一项的位置和要删除的项数，返回被删除的项\n- 插入： 指定三个参数——起始位置、0（要删除的项数）、要插入的项（任意数量），返回被删除的项（空）\n- 替换： 指定三个参数——起始位置、要删除的项数、要插入的项（任意数量），返回被删除的项（空）\n\n代码例子可以看[这里](https://blog.csdn.net/qq_33733970/article/details/78787726)。\n\n## Date类型\n\n是在早期Java中的java.util.Date类基础上构建的。\n\n因此Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。\n\nDate类型保存的日期能够精确到1970年1月1日前后285616年。\n\n关于创建日期和设置日期可以看[这里](http://www.runoob.com/js/js-obj-date.html)。\n\nDate对象属性及方法可以看[这里](http://www.runoob.com/jsref/jsref-obj-date.html)。\n\n将表示日期的字符串传递给Date构造函数，后台会自动调用Date.parse()，然后将得到的值传给构造函数。\n\nDate对象可以直接进行大小比较。\n\n可以进行日期加减，下边的例子表示五天后的日期：\n\n```javascript\nvar myDate=new Date();\nmyDate.setDate(myDate.getDate()+5);\n```\n\n## [RegExp类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\n正则表达式： `var expression = / pattern / flags`\n\n正则表达式语法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_in_regular_expressions)。\n\nflags为一个或多个标志，正则表达式的匹配模式支持下面三个标志：\n\n- g——全局(global)模式，应用于所有字符串\n- i——不区分带小写(case-insensitive)模式\n- m——多行(multiiline)模式，到达一行文本末尾时还会继续查找喜爱航是否存在与模式匹配的项\n\n元字符：`()[]{}\\^$|?*+.`，元字符必须转义。\n\n以下是一些例子：\n\n```javascript\nvar pattern1 = /at/g;\t\t// 匹配字符串中所有\"at\"实例\nvar pattern2 = /.at/gi;\t\t// 匹配字符串中所有以\"at\"结尾的三个字符的实例，不区分大小写\nvar pattern3 = /\\.at/gi;\t// 匹配字符串中所有\".at\"实例，不区分大小写\nvar pattern4 = /[bc]at/i;\t// 匹配字符串中第一个\"bat\"或\"cat\"实例，不区分大小写\nvar pattern5 = /\\[bc\\]at/i;\t// 匹配字符串中第一个\"[bc]at\"实例，不区分大小写\n```\n\n也可以使用构造函数来定义，例如下边两个式子得到的值是等价==相同的：\n\n```javascript\nvar pattern1 = /[bc]at/i;\nvar pattern2 = new RegExp(\"[bc]at\", \"i\");\n```\n\n需要注意的是，构造函数的字符串中，元字符必须双重转义，比如`/\\./`双重转义为\"\\\\\\\\.\"\n\n### 实例属性\n\n- global——布尔值，表示是否设置了g标志\n- ignoreCase——布尔值，表示是否设置了i标志\n- multiline——布尔值，表示是否设置了m标志\n- lastIndex——整数，表示开始搜索下一个匹配项的字符位置，从0算起\n- source——正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回\n\n### RegExp实例方法\n\n关于exec()方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)。\n\n关于test()方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)。\n\n### RegExp构造函数属性\n\n| 长属性名     | 短属性名 | 说明                                     |\n| ------------ | -------- | ---------------------------------------- |\n| input        | $_       | 最近一次要匹配的字符串                   |\n| lastMatch    | $&       | 最近一次的匹配项                         |\n| lastParen    | $+       | 最近一次匹配的捕获组                     |\n| leftContext  | $`       | input字符串中lastMatch之前的文本         |\n| rightContext | $'       | input字符串中lastMatch之后的文本         |\n| multiline    | $*       | 布尔值，表示是否所有表达式都使用多行模式 |\n\n注：书中说Opera不支持input、lastMatch、lastParent、multiline，但查阅MDN文档显示的是支持的，因此待验证。\n\n关于如何使用，以lastMatch为例：\n\n```javascript\nvar re = /hi/g;\nre.test('hi there!');\nRegExp.lastMatch; // \"hi\"\nRegExp['$&'];     // \"hi\"\n```\n\n\n\n另外对于书中提到的ECMAScript正则表达式不支持的特性，因为版本不断更新，比如现在已经支持Unicode，因此就不在这里列出来了。\n\n## Function类型\n\n所有函数实际上都是Function类型的实例，且与其他引用数据类型一样具有属性和方法。\n\n**“函数是对象，函数名是指针”。**\n\n定义函数的方式：\n\n```javascript\nfunction sum1(num1, num2) {\n  return num1 + num2;\n}\n\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n\nvar sum3 = new Function('num1', 'num2', 'return num1 + num2'); // 不推荐\n```\n\n### 深入理解没有重载\n\n将函数名想象为指针，当用同一个函数名重新声明一个函数实际上相当于改变了指针的指向。\n\n指针只能指向一个对象。\n\n### 函数声明与函数表达式\n\n```javascript\n// 函数声明\nfunction sum1(num1, num2) {\n  return num1 + num2;\n}\n// 函数表达式\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n解析器会率先读取函数声明，并使其在执行任何代码之前可用，\n\n但是对于函数表达式，必须等到解析器执行到它所在的代码行才会真正被解释执行。\n\n可以同时使用函数声明和函数表达式`var sum1 = function sum2() {}`，但会在Safari中导致错误。\n\n### 作为值的函数\n\n函数名本身就是变量，因此可以把函数当做参数传递，[这里](https://blog.csdn.net/lingfeng2008w/article/details/50598431)有人总结了当做参数传递的用法。\n\n### 函数内部属性\n\n在函数内部有两个特殊的对象：arguments和this。\n\n**arguments**还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，有什么用呢？可以看阶乘函数这个例子：\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * factorial(num-1);\n  }\n}\n```\n\n像这样递归，我们在修改函数名、拷贝函数后修改原函数内容后都会遇到麻烦，因此就要用到callee属性了：\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 使用callee属性\n  }\n}\n\nvar trueFactorial = factorial;  // 拷贝函数\nfactorial = function() {  // 修改原函数定义\n  return 0;\n};\n\nalert(factorial(5));  // 0\nalert(trueFactorial(5));// 120\n```\n\n**this**是函数在执行时所处的作用域（挡在网页的全局作用域调用函数时，this对象引用的就是window），可以看下边这个例子：\n\n```javascript\nfunction sayColor() {\n  alert(this.color);\n}\n\nwindow.color = 'red';\nvar b = {color: 'blue'};\nb.sayColor = sayColor;\n\nsayColor();   //'red'\nb.sayColor(); //'blue'\n```\n\n### 函数属性和方法\n\n每个函数都包含两个属性：length和prototype。\n\n- length：函数希望接收的命名参数的个数\n- prototype：可以看我[这篇文章](https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html)。\n\n每个函数都包含两个非继承而来的方法：apply()和call()。\n\n这两个的用途都是给函数**指定函数体内this的值**。\n\n> `apply` 与 [`call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 非常相似，不同之处在于提供参数的方式。\n>\n> `apply` 使用参数数组而不是一组参数列表。`apply` 可以使用数组字面量（array literal），如 `fun.apply(this, ['eat', 'bananas'])`，或数组对象， 如  `fun.apply(this, new Array('eat', 'bananas'))`。\n>\n> 而 `call`的语法为`fun.call(thisArg, arg1, arg2, ...)`。\n>\n> 需要注意的是，指定的`this`值并不一定是该函数执行时真正的`this`值，如果这个函数处于[非严格模式下](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode)，则指定为`null`和`undefined`的`this`值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的`this`会指向该原始值的自动[包装对象](https://www.cnblogs.com/moqing/p/5593986.html)。\n\n每个函数都一个非标准的caller属性，指向调用该函数的函数，\n\n因此一般在一个函数的内部，通过`arguments.callee.caller`来实现对调用栈的追溯，\n\n但只建议将该属性用于调试目的。\n\n## 基本包装类型\n\n先看[这篇文章](https://www.cnblogs.com/moqing/p/5593986.html)\n\n### Boolean类型\n\n- 基本类型的布尔值： `var a = false`\n- 引用类型的布尔值： `var b = new Boolean(false)`\n\n除了包装对象的问题，两个还有两个区别：\n\n- typeof 的结果一个是\"boolean\"一个是\"object\"\n- instanceof测试是否为Boolean对象一个是false，一个是true\n\n**建议永远不要使用Boolean对象。**\n\n### Number类型\n\n重写了valueOf()、toLocaleString()和toString()方法。\n\n- valueOf()返回对象表示的基本类型的数值。\n\n- 可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。\n\n- toFixed()方法会按照指定的小数位返回数值的字符串表示（四舍五入）：`var num = 10;num.toFixed(2)`结果为“10.00”\n- toExponential()按照指定的小数位数返回数值的指数表示的字符串：`var num = 10;num.toExponential(2)`结果为“1.00e+1”\n- toPrecision()接受一个参数作为表示数值所有数字的位数（不包括指数部分），然后返回最合适的表示格式的字符串。\n\n### String类型\n\n#### 字符方法\n\n访问字符串中特定字符：`charAt()`、`charCodeAt()`\n\n```javascript\nvar s = 'hello world!';\ns.charAt(1);\t// \"e\", 返回字符\ns.charCodeAt(1);// \"101\"， 返回字符编码\ns[1];\t\t\t// \"e\"\n```\n\n#### 字符串操作方法\n\n- concat() ： *string*.concat(*string1*, *string2*, ..., *stringX*)， 连接字符串，不改变原字符串，返回连接后的字符串\n- slice()：*string*.slice(*start*,*end*)，提取字符串片断，start为要截取的片段的起始下标；end为要截取的片段的结尾下标加一，若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串，如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。\n- substring()：类似于slice()\n- substr()：*string*.substr(*start*,*length*)， 提取字符片段，start为要截取的片段的起始下标；length为要截取的长度，那么返回从 sstart到结尾的字串。\n\n```javascript\nvar str1 = \"Hello \";\nvar str2 = \"world!\";\nstr1.concat(str2); // \"Hello world!\"\nstr.slice(1,5); // \"ello\"\nstr.substring(1,5); // \"ello\"\nstr.substr(2,3); // \"llo\"\n```\n\n假设p为一个正确的坐标值，m为一个负值，则\n\n- string.concat(p,m)x相当于string.concat(p)\n- string.substring(p,m)相当于string.substring(p,0)相当于string.substring(0,p)\n- string.substr(p,m)相当于string.substr(p,0)，返回空字符串\n\n#### 字符串位置方法\n\n`indexOf()`和`lastIndexOf()`，传入一个字符串，返回这个字符串在源字符串中第一次和最后一次出现的位置，若没有找到则返回-1。\n\n还可以传入第二个参数表示开始查找的位置，`indexOf()`往后查找，`lastIndexOf()`往前查找。\n\n#### 字符串大小写转换方法\n\n- toLowerCase()、toUpperCase()\n- toLocaleLowerCase()、toLocaleUpperCase()，针对地区应用不同的规则\n\n#### 字符串的模式匹配方法\n\n1. `match()`，等价于调用RegExp对象的exec()方法。\n\n   `match()`接受一个正则表达式或者一个RegExp对象作为参数，返回一个数组，数组第一项是与整个模式匹配的字符串，之后的每一项都是和捕获组匹配的字符串。\n\n2. `search()`与`match()`唯一不同的是返回的是第一个匹配项的索引。\n\n3. `replace()`添加了一个传入的参数，表示匹配到的字符串要替换成的字符串。如果要全部替换，要记得在正则表达式中指定全局标志(g)。第二个参数也可以是函数，该函数的返回值将替换掉第一个参数匹配到的结果。\n\n   替换字符串可以插入下面的特殊变量名：\n\n| 变量名 | 代表的值                                                     |\n| ------ | ------------------------------------------------------------ |\n| `$$`   | 插入一个 \"$\"。                                               |\n| `$&`   | 插入匹配的子串。                                             |\n| $`     | 插入当前匹配的子串左边的内容。                               |\n| `$'`   | 插入当前匹配的子串右边的内容。                               |\n| `$*n*` | 假如第一个参数是 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp)对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 |\n\n4. `splite()`，基于指定的分隔符`separator`将一个字符串分割成多个子字符串，还可以指定第二个参数，一个整数，限定返回的分割片段数量。\n\n```javascript\n\"Webkit Moz O ms Khtml\".split( \" \" )   // [\"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"]\nvar myString = \"Hello World. How are you doing?\";\nmyString.split(\" \", 3); // [\"Hello\", \"World.\", \"How\"]\n```\n\n如果 `separator` 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。\n\n```js\nvar myString = \"Hello 1 word. Sentence number 2.\";\nvar splits = myString.split(/(\\d)/);\t// \\d匹配数字\n\nconsole.log(splits); // [ \"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\" ]\n```\n\n#### localeCompare()方法\n\n`referenceStr.localeCompare(compareString[, locales[, options]])`\n\n判断字符串参数compareString是否在字母表中排在字符串referenceStr之前，是的话返回正数，不是返回负数，相等返回0。\n\nlocales和options都是可选参数，还没有被所有浏览器支持，具体的含义可以查阅[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)。\n\n下边是一个简单的例子：\n\n```js\n// \"c\" 在 \"a\" 之后， 返回负数\n'a'.localeCompare('c'); \n// -2 或者 -1 (或者其他负数)\n\n// \"against\" 在 \"check\" 之前\n'check'.localeCompare('against'); \n// 2 或者 1 (或者其他正数)\n\n// 相同\n'a'.localeCompare('a'); \n// 0\n```\n\n#### fromCharCode()方法\n\nString构造函数的的静态方法，接收一个或者多个字符编码，然后把它们转换成一个字符串。\n\n```js\nString.fromCharCode(104, 101, 108, 108, 111); // \"hello\"\n```\n\n#### HTML方法\n\n该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用这些特性。因此不再列出。\n\n## 内置对象\n\n### 全局(Global)对象\n\n在大多是ECMAScript实现中都不能直接访问Global对象，不过Web浏览器实现了承担该角色的window对象，因此在全局作用域中生命的所有变量核函数，就都成为了window对象的属性。\n\n#### 全局函数\n\n所有在全局作用域定义的属性和方法都是Global对象的属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n- [`eval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)：将传入的字符串当做 JavaScript 代码进行执行。\n- [`uneval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/uneval) ：返回代表传入对象的源代码的字符串，该特性是非标准的，请尽量不要在生产环境中使用它！\n- [`isFinite()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite)：判定一个数字是否是有限数字。`isFinite` 方法检测它参数的数值。如果参数是 `NaN`，正无穷大或者负无穷大，会返回`false`，其他返回 `true`。\n- [`isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)：确定一个值是否为[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 。如果`isNaN`函数的参数不是`Number`类型， `isNaN`函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)进行判断。ECMAScript (ES2015)包含[`Number.isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)函数。通过`Number.isNaN(x)`来检测`变量x`是否是一个`NaN`将会是一种可靠的做法。然而，在缺少`Number.isNaN`函数的情况下, 通过表达式`(x != x)` 来检测`变量x`是否是`NaN`会更加可靠。\n- [`parseFloat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat)：解析一个字符串参数并返回一个浮点数。\n- [`parseInt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。\n- [`decodeURI()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI)：解码一个由[`encodeURI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) 先前创建的统一资源标识符（URI）或类似的例程。\n- [`decodeURIComponent()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) : 解码由 [`encodeURIComponent`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) 方法或者其它类似方法编码的部分统一资源标识符（URI）。\n- [`encodeURI()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI)：对统一资源标识符（URI）进行编码，将有效的URI不能包含的字符替换为特殊的UTF-8编码。\n- [`encodeURIComponent()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) ：对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。\n- [`escape()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape) ，已废弃。生成新的由十六进制转义序列替换的字符串. 使用 [`encodeURI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) 或 [`encodeURIComponent`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) 代替。\n- [`unescape()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape) ，已废弃。\n\n`encodeURI` 会替换所有的字符，但不包括以下字符，即使它们具有适当的UTF-8转义序列：\n\n| 类型         | 包含                                          |\n| ------------ | --------------------------------------------- |\n| 保留字符     | `;` `,` `/` `?` `:` `@` `&` `=` `+` `$`       |\n| 非转义的字符 | 字母 数字 `-` `_` `.` `!` `~` `*` `'` `(` `)` |\n| 数字符号     | `#`                                           |\n\n请注意，`encodeURI` 自身*无法*产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 \"&\", \"+\", 和 \"=\" 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。\n\n然而`encodeURIComponent` 转义除了字母、数字、`(`、`)`、`.`、`!`、`~`、`*`、`'`、`-`和`_`之外的所有字符。\n\n例子：\n\n```js\n// 解码一个西里尔字母（Cyrillic）URL\ndecodeURI(\"https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\");\n// \"https://developer.mozilla.org/ru/docs/JavaScript_шеллы\"\n\n// 解码一个西里尔字母的URL\ndecodeURIComponent(\"JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\");\n// \"JavaScript_шеллы\"\n\n// *****************************************************************\n\nvar fileName = 'my file(2).txt';\nvar header = \"Content-Disposition: attachment; filename*=UTF-8''\" \n       + encodeRFC5987ValueChars(fileName);\n\nconsole.log(header); \n// 输出 \"Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt\"\n\nfunction encodeRFC5987ValueChars (str) {\n  return encodeURIComponent(str).\n    // 注意，仅管 RFC3986 保留 \"!\"，但 RFC5987 并没有\n    // 所以我们并不需要过滤它\n    replace(/['()]/g, escape). // i.e., %27 %28 %29\n    replace(/\\*/g, '%2A').\n      // 下面的并不是 RFC5987 中 URI 编码必须的\n      // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性\n      replace(/%(?:7C|60|5E)/g, unescape);\n}\n```\n\n 注： [RFC 3986](http://tools.ietf.org/html/rfc3986)，保留 !, ', (, ), 和 *\n\n#### Global对象的属性\n\n特殊值如undefined等、所有原生引用类型的构造函数都是Global对象的属性。\n\n除了这些还有：\n\n- [`Error`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)\n- [`EvalError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError)\n- [`InternalError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/InternalError)\n- [`RangeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError)\n- [`ReferenceError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)\n- [`SyntaxError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError)\n- [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)\n- [`URIError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/URIError)\n\n### Math对象\n\n[**Math**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math) 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。\n\n`Math` 的所有属性和方法都是静态的：例如常数pi可以用 `Math.PI` 表示，用 `x` 作参数 Math.sin(x)调用sin函数。\n\n#### Math对象的属性\n\n[`Math.E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/E)\n\n欧拉常数，也是自然对数的底数, 约等于 2.718.\n\n[`Math.LN2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2)\n\n2的自然对数, 约等于0.693.\n\n[`Math.LN10`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10)\n\n10的自然对数, 约等于 2.303.\n\n[`Math.LOG2E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E)\n\n以2为底E的对数, 约等于 1.443.\n\n[`Math.LOG10E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E)\n\n以10为底E的对数, 约等于 0.434.\n\n[`Math.PI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/PI)\n\n圆周率，一个圆的周长和直径之比，约等于 3.14159.\n\n[`Math.SQRT1_2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2)\n\n1/2的平方根, 约等于 0.707.\n\n[`Math.SQRT2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT2)\n\n2的平方根,约等于 1.414.\n\n#### 常用方法\n\n[`Math.max()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max)\n\n返回0个到多个数值中最大值.\n\n[`Math.min()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min)\n\n返回0个到多个数值中最小值.\n\n[`Math.ceil(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)\n\n返回x向上取整后的值.\n\n[`Math.floor(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)\n\n返回小于x的最大整数。\n\n[`Math.round(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round)\n\n返回四舍五入后的整数.\n\n[`Math.random()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random)\n\n返回0到1之间的伪随机数.\n\n所有方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math#Methods)。","source":"_posts/JavaScript学习记录二.md","raw":"---\ntitle: JavaScript学习记录二\ntoc: true\ndate: 2018-09-13 10:14:53\ncategories:\n- Web\ntags:\n- JavaScript\n---\n\n——《JavaScript高级程序设计（第2版）》学习笔记\n\n要多查阅[MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web)\n\n<!-- more -->\n\n---\n\n# 变量、作用域和内存问题\n\n## 基本类型和引用类型的值\n\nECMAScript变量可能包含两种不同数据类型的值：\n\n- **基本类型值**：保存在**栈内存**中的简单数据段，这种值完全保存在内存中的一个位置\n- **引用类型值**：保存在**堆内存**中的对象，保存的实际上是一个指针，指针指向内存中真正对象保存的位置\n\n五种基本数据类型：Undefined、Null、Boolean、Number、String在内存中占有固定大小的空间，因此可以保存在栈内存中。因为我们操作的是它们实际保存的值，所以它们是**按值**访问的。\n\n对于对象，先从栈中读取内存地址，然后再按照地址找到保存在堆中的值。因为我们操作的不是实际的值，而是那个值所引用的对象，因此我们称之为**按引用**访问的。（图片来源于网络，cr 水印）\n\n![栈内存与堆内存](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536816598256&di=246ab4e73e12049d497d375df4fd273b&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D2929764421%2C2277861536%26fm%3D214%26gp%3D0.jpg)\n\n### 动态属性\n\n对于对象，我们可以改变和删除其属性和方法，但是不能给基本类型的值添加属性。\n\n即只能给引用类型值动态地添加属性。\n\n### 复制变量值\n\n当复制基本类型值的时候，会在栈中为其开辟一块新的内存保存其值。\n\n但是当复制引用类型的值时，实际上复制保存的是这个对象在堆内存中的地址，也就是两者指向的是同一个对象。\n\n### 传递参数\n\nECMAScript中所有的函数的参数都是**按值传递**的。\n\n传递基本类型值就如基本类型变量的复制一样，传递引用类型变量时也如同引用变量的复制。\n\n因此传递引用类型的变量时，传递的相当于是拷贝的指针。\n\n可以看下边这个例子（我觉得可以把对象看做是一个指向对象的指针，然后函数传递的是一个拷贝的指针）：\n\n```javascript\nfunction setName(obj) {\n  obj.name = \"Nicholas\";\n  obj = new Object();\n  obj.name = \"Greg\";\n}\n\nvar person = new Obejct();\nsetName(person);\nalert(person.name); // \"Nicholas\"\n```\n\n### 检测类型\n\ntypeof检测null返回\"object\"\n\n当我们想知道一个对象是什么类型的对象时，可以使用`instanceof`，它的语法是：\n\n`result = variable instanceof constructor`\n\n如果变量是给定引用类型（由构造函数表示）的实例，则instanceof返回true：\n\n```javascript\nalert(person instanceof Object); // 变量person是Object么？\nalert(colors instanceof Array); // 变量colors是Array么？\n```\n\n当使用instanceof检测基本类型的值时始终返回false，因为基本类型不是对象。\n\n注： 在Safiri和Chrome中使用typeof检测正则表达式会错误的返回\"function\"。\n\n## 执行环境和作用域\n\n[执行环境](https://blog.csdn.net/wmaoshu/article/details/60466990)定义了变量或函数有权访问的其他数据，决定了它们各自的行为。\n\n每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。\n\n在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。\n\n一个执行环境中的所有代码执行完毕后，该环境和保存在其中的所有变量和函数定义都被销毁，\n\n全局执行环境直到关闭页面或者浏览器时才会被销毁。\n\n关于作用域链可以看[这里](https://blog.csdn.net/charlene0824/article/details/52252824)。\n\n### 延长作用域链\n\n- with语句： 其变量对象包含为指定的对象的所有属性和方法所做的变量声明。\n- catch语句： 包含被抛出的错误对象的声明\n\n在IE的JavaScript实现中，catch语句捕获的错误对象会被添加到执行环境的变量对象中。\n\n### 没有块级作用域\n\n- 使用if 、for语句创建的变量会保存在语句外部的执行环境中。\n\n- 函数内部是一个局部环境\n- 访问局部变量比全局变量快，因为不用向上搜索作用域链\n\n## 垃圾收集\n\nJavaScript具有自动垃圾收集机制，按照固定的时间间隔或代码执行中预定的收集时间，周期性地找出不再使用的变量释放其内存。\n\n关于垃圾收集方式的详细解释可以看[这里](https://www.cnblogs.com/scottjeremy/p/6870729.html)。\n\n关于性能问题和管理内存可以看[这里](https://www.cnblogs.com/yxField/p/4226591.html)。\n\n# 引用类型\n\n## Object类型\n\n创建Object实例的方式：\n\n- `var xxx = new Object()`\n- `var xxx = {age: 29}`, `{}`是对象字面量边界\n\n可以用`xxx.age`或者`xxx['age']`来访问属性，更建议用点表示法。\n\n## Array类型\n\nECMAScript数组的每一项可以保存任何类型的数据。\n\n数组的索引从0开始。\n\n数组的项数保存在其length属性中，它并不是只读的，可以通过设置它来在数组的末尾移除或添加项，添加项的初始值为undefined。\n\n因为JavaScript使用一个32位整数保存数组元素个数，因此数组最多可以包含4294967295项（2的32次方减1）。\n\n以下是创建数组的例子：\n\n```javascript\n// new 可以省略\nvar a = new Array(); // 创建一个空数组\nvar b = new Array(20); // 创造一个包含20项的数组，每一项的初始值都是undefined\nvar c = new Array(\"red\", \"blue\", \"green\"); // 创造一个包含三项：\"red\",\"blue\",\"green\"的数组\nvar d = [\"red\", \"blue\", \"green\"]; // 创造一个包含三项：\"red\",\"blue\",\"green\"的数组\nvar e = []; // 创建一个空数组\nvar f = [1,2,]; // 不要这样！这样会创建一个包含2或3项的数组\nvar g = [,,,,,]; // 不要这样！这样会创建一个包含5或6项的数组\n```\n\n### 转换方法\n\nvalueOf()返回当前对象的原始值；\n\ntoString()方法先调用每一项的toString()方法，然后用逗号将它们拼接起来并返回；\n\ntoLocalString()方法先调用每一项的toLocalString()方法，然后用逗号将它们拼接起来并返回；\n\n如果使用join()方法可以使用不同的分隔符来构建这个字符串：\n\n```javascript\nvar a = ['a','b','c'];\nalert(a.join(',')); // 'a,b,c'\nalert(a.join('||')); // 'a||b||c'\n```\n\n如果某一项是undefined或null，那么在toString()、toLocalString()、join()方法返回的结果中以空字符串表示。\n\n### 栈方法\n\nECMAScript为数组提供了push()和pop()方法，以便实现类似栈的行为（LIFO，后进先出）。\n\n- push()方法可以接受任意数量的参数，然后把它们逐个添加到数组末尾，并返回修改后的数组长度\n- pop()方法则从数组末尾移除最后一项，并将length减一，返回移除的项。\n\n### 队列方法\n\n可以使用push()和shift()方法，实现类似于队列的行为（FIFO，先进先出）。\n\n- shift()方法从数组开头移除第一项，并将length减一，返回移除的项。\n- ECMAScript还提供了unshift()方法，可以接受任意数量的参数，然后把它们逐个添加到数组头部，并返回修改后的数组长度（IE返回undefined）。\n\n关于unshift()的添加多个变量的顺序：\n\n```javascript\na = [\"a\", \"b\", \"c\", null]；\na.unshift('1','2'); // [\"1\", \"2\", \"a\", \"b\", \"c\", null]\n```\n\n### 重排序方法\n\nreverse()会反转数组项的顺序：\n\n```javascript\nvar a = [1,2,6,5,3,0];\na.reverse();\nalert(a); // 0,3,5,6,2,1\n```\n\nsort()为排序函数，默认从小到大排序，也可以传入一个比较函数：\n\n```javascript\nvar a = [1,2,6,5,3,0];\na.sort();\nalert(a); // 0,1,2,3,5,6\n\nfunction compare(v1, v2) {\n  if (v1 < v2) {\n    return 1;\n  } else if (v1 > v2) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\na.sort(compare);\nalert(a); // 6,5,3,2,1,0\n```\n\n对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以简化一下比较函数：\n\n```javascript\n// 升序排序\nfunction compare1(v1, v2) {\n  return v1 - v2;\n}\n\n// 降序排序\nfunction compare1(v1, v2) {\n  return v2 - v1;\n}\n```\n\n### 操作方法\n\n#### concat()\n\n——先创建一个当前数组的副本，然后将接收到的参数添加到这个副本的末尾，返回新构建的这个数组：\n\n```javascript\nvar a = ['1','2','3'];\nvar b = a.concat('4',['5','6']);\nalert(a); // 1,2,3\nalert(b); // 1,2,3,4,5,6\n```\n\n#### slice()\n\n——局部拷贝数组，接受一个参数或两个参数；\n\n一个参数时拷贝从这个参数指定的位置到结尾；\n\n两个参数时，拷贝两个参数之间的项，不包含结束为止的项。\n\n当参数为负数时，则用该数加数组长度：\n\n- 若加完之后大于等于零则用加完后的数计算\n- 若加完之后还小于0则把该数看做0\n\n若起始位置大于结束位置，则返回空数组。\n\n下边为一个简单的例子：\n\n```javascript\nvar a = [0,1,2,3,4];\nvar b = a.slice(1);\nvar c = a.slice(1,4);\nalert(a); // 1,2,3,4\nalert(b); // 1,2,3\n```\n\n#### splice()\n\n主要用途是向数组的中部插入项，对原数组进行操作\n\n使用方式主要有三种：\n\n- 删除： 指定两个参数——要删除的第一项的位置和要删除的项数，返回被删除的项\n- 插入： 指定三个参数——起始位置、0（要删除的项数）、要插入的项（任意数量），返回被删除的项（空）\n- 替换： 指定三个参数——起始位置、要删除的项数、要插入的项（任意数量），返回被删除的项（空）\n\n代码例子可以看[这里](https://blog.csdn.net/qq_33733970/article/details/78787726)。\n\n## Date类型\n\n是在早期Java中的java.util.Date类基础上构建的。\n\n因此Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。\n\nDate类型保存的日期能够精确到1970年1月1日前后285616年。\n\n关于创建日期和设置日期可以看[这里](http://www.runoob.com/js/js-obj-date.html)。\n\nDate对象属性及方法可以看[这里](http://www.runoob.com/jsref/jsref-obj-date.html)。\n\n将表示日期的字符串传递给Date构造函数，后台会自动调用Date.parse()，然后将得到的值传给构造函数。\n\nDate对象可以直接进行大小比较。\n\n可以进行日期加减，下边的例子表示五天后的日期：\n\n```javascript\nvar myDate=new Date();\nmyDate.setDate(myDate.getDate()+5);\n```\n\n## [RegExp类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\n正则表达式： `var expression = / pattern / flags`\n\n正则表达式语法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_in_regular_expressions)。\n\nflags为一个或多个标志，正则表达式的匹配模式支持下面三个标志：\n\n- g——全局(global)模式，应用于所有字符串\n- i——不区分带小写(case-insensitive)模式\n- m——多行(multiiline)模式，到达一行文本末尾时还会继续查找喜爱航是否存在与模式匹配的项\n\n元字符：`()[]{}\\^$|?*+.`，元字符必须转义。\n\n以下是一些例子：\n\n```javascript\nvar pattern1 = /at/g;\t\t// 匹配字符串中所有\"at\"实例\nvar pattern2 = /.at/gi;\t\t// 匹配字符串中所有以\"at\"结尾的三个字符的实例，不区分大小写\nvar pattern3 = /\\.at/gi;\t// 匹配字符串中所有\".at\"实例，不区分大小写\nvar pattern4 = /[bc]at/i;\t// 匹配字符串中第一个\"bat\"或\"cat\"实例，不区分大小写\nvar pattern5 = /\\[bc\\]at/i;\t// 匹配字符串中第一个\"[bc]at\"实例，不区分大小写\n```\n\n也可以使用构造函数来定义，例如下边两个式子得到的值是等价==相同的：\n\n```javascript\nvar pattern1 = /[bc]at/i;\nvar pattern2 = new RegExp(\"[bc]at\", \"i\");\n```\n\n需要注意的是，构造函数的字符串中，元字符必须双重转义，比如`/\\./`双重转义为\"\\\\\\\\.\"\n\n### 实例属性\n\n- global——布尔值，表示是否设置了g标志\n- ignoreCase——布尔值，表示是否设置了i标志\n- multiline——布尔值，表示是否设置了m标志\n- lastIndex——整数，表示开始搜索下一个匹配项的字符位置，从0算起\n- source——正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回\n\n### RegExp实例方法\n\n关于exec()方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)。\n\n关于test()方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)。\n\n### RegExp构造函数属性\n\n| 长属性名     | 短属性名 | 说明                                     |\n| ------------ | -------- | ---------------------------------------- |\n| input        | $_       | 最近一次要匹配的字符串                   |\n| lastMatch    | $&       | 最近一次的匹配项                         |\n| lastParen    | $+       | 最近一次匹配的捕获组                     |\n| leftContext  | $`       | input字符串中lastMatch之前的文本         |\n| rightContext | $'       | input字符串中lastMatch之后的文本         |\n| multiline    | $*       | 布尔值，表示是否所有表达式都使用多行模式 |\n\n注：书中说Opera不支持input、lastMatch、lastParent、multiline，但查阅MDN文档显示的是支持的，因此待验证。\n\n关于如何使用，以lastMatch为例：\n\n```javascript\nvar re = /hi/g;\nre.test('hi there!');\nRegExp.lastMatch; // \"hi\"\nRegExp['$&'];     // \"hi\"\n```\n\n\n\n另外对于书中提到的ECMAScript正则表达式不支持的特性，因为版本不断更新，比如现在已经支持Unicode，因此就不在这里列出来了。\n\n## Function类型\n\n所有函数实际上都是Function类型的实例，且与其他引用数据类型一样具有属性和方法。\n\n**“函数是对象，函数名是指针”。**\n\n定义函数的方式：\n\n```javascript\nfunction sum1(num1, num2) {\n  return num1 + num2;\n}\n\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n\nvar sum3 = new Function('num1', 'num2', 'return num1 + num2'); // 不推荐\n```\n\n### 深入理解没有重载\n\n将函数名想象为指针，当用同一个函数名重新声明一个函数实际上相当于改变了指针的指向。\n\n指针只能指向一个对象。\n\n### 函数声明与函数表达式\n\n```javascript\n// 函数声明\nfunction sum1(num1, num2) {\n  return num1 + num2;\n}\n// 函数表达式\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n解析器会率先读取函数声明，并使其在执行任何代码之前可用，\n\n但是对于函数表达式，必须等到解析器执行到它所在的代码行才会真正被解释执行。\n\n可以同时使用函数声明和函数表达式`var sum1 = function sum2() {}`，但会在Safari中导致错误。\n\n### 作为值的函数\n\n函数名本身就是变量，因此可以把函数当做参数传递，[这里](https://blog.csdn.net/lingfeng2008w/article/details/50598431)有人总结了当做参数传递的用法。\n\n### 函数内部属性\n\n在函数内部有两个特殊的对象：arguments和this。\n\n**arguments**还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，有什么用呢？可以看阶乘函数这个例子：\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * factorial(num-1);\n  }\n}\n```\n\n像这样递归，我们在修改函数名、拷贝函数后修改原函数内容后都会遇到麻烦，因此就要用到callee属性了：\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 使用callee属性\n  }\n}\n\nvar trueFactorial = factorial;  // 拷贝函数\nfactorial = function() {  // 修改原函数定义\n  return 0;\n};\n\nalert(factorial(5));  // 0\nalert(trueFactorial(5));// 120\n```\n\n**this**是函数在执行时所处的作用域（挡在网页的全局作用域调用函数时，this对象引用的就是window），可以看下边这个例子：\n\n```javascript\nfunction sayColor() {\n  alert(this.color);\n}\n\nwindow.color = 'red';\nvar b = {color: 'blue'};\nb.sayColor = sayColor;\n\nsayColor();   //'red'\nb.sayColor(); //'blue'\n```\n\n### 函数属性和方法\n\n每个函数都包含两个属性：length和prototype。\n\n- length：函数希望接收的命名参数的个数\n- prototype：可以看我[这篇文章](https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html)。\n\n每个函数都包含两个非继承而来的方法：apply()和call()。\n\n这两个的用途都是给函数**指定函数体内this的值**。\n\n> `apply` 与 [`call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 非常相似，不同之处在于提供参数的方式。\n>\n> `apply` 使用参数数组而不是一组参数列表。`apply` 可以使用数组字面量（array literal），如 `fun.apply(this, ['eat', 'bananas'])`，或数组对象， 如  `fun.apply(this, new Array('eat', 'bananas'))`。\n>\n> 而 `call`的语法为`fun.call(thisArg, arg1, arg2, ...)`。\n>\n> 需要注意的是，指定的`this`值并不一定是该函数执行时真正的`this`值，如果这个函数处于[非严格模式下](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode)，则指定为`null`和`undefined`的`this`值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的`this`会指向该原始值的自动[包装对象](https://www.cnblogs.com/moqing/p/5593986.html)。\n\n每个函数都一个非标准的caller属性，指向调用该函数的函数，\n\n因此一般在一个函数的内部，通过`arguments.callee.caller`来实现对调用栈的追溯，\n\n但只建议将该属性用于调试目的。\n\n## 基本包装类型\n\n先看[这篇文章](https://www.cnblogs.com/moqing/p/5593986.html)\n\n### Boolean类型\n\n- 基本类型的布尔值： `var a = false`\n- 引用类型的布尔值： `var b = new Boolean(false)`\n\n除了包装对象的问题，两个还有两个区别：\n\n- typeof 的结果一个是\"boolean\"一个是\"object\"\n- instanceof测试是否为Boolean对象一个是false，一个是true\n\n**建议永远不要使用Boolean对象。**\n\n### Number类型\n\n重写了valueOf()、toLocaleString()和toString()方法。\n\n- valueOf()返回对象表示的基本类型的数值。\n\n- 可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。\n\n- toFixed()方法会按照指定的小数位返回数值的字符串表示（四舍五入）：`var num = 10;num.toFixed(2)`结果为“10.00”\n- toExponential()按照指定的小数位数返回数值的指数表示的字符串：`var num = 10;num.toExponential(2)`结果为“1.00e+1”\n- toPrecision()接受一个参数作为表示数值所有数字的位数（不包括指数部分），然后返回最合适的表示格式的字符串。\n\n### String类型\n\n#### 字符方法\n\n访问字符串中特定字符：`charAt()`、`charCodeAt()`\n\n```javascript\nvar s = 'hello world!';\ns.charAt(1);\t// \"e\", 返回字符\ns.charCodeAt(1);// \"101\"， 返回字符编码\ns[1];\t\t\t// \"e\"\n```\n\n#### 字符串操作方法\n\n- concat() ： *string*.concat(*string1*, *string2*, ..., *stringX*)， 连接字符串，不改变原字符串，返回连接后的字符串\n- slice()：*string*.slice(*start*,*end*)，提取字符串片断，start为要截取的片段的起始下标；end为要截取的片段的结尾下标加一，若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串，如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。\n- substring()：类似于slice()\n- substr()：*string*.substr(*start*,*length*)， 提取字符片段，start为要截取的片段的起始下标；length为要截取的长度，那么返回从 sstart到结尾的字串。\n\n```javascript\nvar str1 = \"Hello \";\nvar str2 = \"world!\";\nstr1.concat(str2); // \"Hello world!\"\nstr.slice(1,5); // \"ello\"\nstr.substring(1,5); // \"ello\"\nstr.substr(2,3); // \"llo\"\n```\n\n假设p为一个正确的坐标值，m为一个负值，则\n\n- string.concat(p,m)x相当于string.concat(p)\n- string.substring(p,m)相当于string.substring(p,0)相当于string.substring(0,p)\n- string.substr(p,m)相当于string.substr(p,0)，返回空字符串\n\n#### 字符串位置方法\n\n`indexOf()`和`lastIndexOf()`，传入一个字符串，返回这个字符串在源字符串中第一次和最后一次出现的位置，若没有找到则返回-1。\n\n还可以传入第二个参数表示开始查找的位置，`indexOf()`往后查找，`lastIndexOf()`往前查找。\n\n#### 字符串大小写转换方法\n\n- toLowerCase()、toUpperCase()\n- toLocaleLowerCase()、toLocaleUpperCase()，针对地区应用不同的规则\n\n#### 字符串的模式匹配方法\n\n1. `match()`，等价于调用RegExp对象的exec()方法。\n\n   `match()`接受一个正则表达式或者一个RegExp对象作为参数，返回一个数组，数组第一项是与整个模式匹配的字符串，之后的每一项都是和捕获组匹配的字符串。\n\n2. `search()`与`match()`唯一不同的是返回的是第一个匹配项的索引。\n\n3. `replace()`添加了一个传入的参数，表示匹配到的字符串要替换成的字符串。如果要全部替换，要记得在正则表达式中指定全局标志(g)。第二个参数也可以是函数，该函数的返回值将替换掉第一个参数匹配到的结果。\n\n   替换字符串可以插入下面的特殊变量名：\n\n| 变量名 | 代表的值                                                     |\n| ------ | ------------------------------------------------------------ |\n| `$$`   | 插入一个 \"$\"。                                               |\n| `$&`   | 插入匹配的子串。                                             |\n| $`     | 插入当前匹配的子串左边的内容。                               |\n| `$'`   | 插入当前匹配的子串右边的内容。                               |\n| `$*n*` | 假如第一个参数是 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp)对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 |\n\n4. `splite()`，基于指定的分隔符`separator`将一个字符串分割成多个子字符串，还可以指定第二个参数，一个整数，限定返回的分割片段数量。\n\n```javascript\n\"Webkit Moz O ms Khtml\".split( \" \" )   // [\"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"]\nvar myString = \"Hello World. How are you doing?\";\nmyString.split(\" \", 3); // [\"Hello\", \"World.\", \"How\"]\n```\n\n如果 `separator` 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。\n\n```js\nvar myString = \"Hello 1 word. Sentence number 2.\";\nvar splits = myString.split(/(\\d)/);\t// \\d匹配数字\n\nconsole.log(splits); // [ \"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\" ]\n```\n\n#### localeCompare()方法\n\n`referenceStr.localeCompare(compareString[, locales[, options]])`\n\n判断字符串参数compareString是否在字母表中排在字符串referenceStr之前，是的话返回正数，不是返回负数，相等返回0。\n\nlocales和options都是可选参数，还没有被所有浏览器支持，具体的含义可以查阅[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)。\n\n下边是一个简单的例子：\n\n```js\n// \"c\" 在 \"a\" 之后， 返回负数\n'a'.localeCompare('c'); \n// -2 或者 -1 (或者其他负数)\n\n// \"against\" 在 \"check\" 之前\n'check'.localeCompare('against'); \n// 2 或者 1 (或者其他正数)\n\n// 相同\n'a'.localeCompare('a'); \n// 0\n```\n\n#### fromCharCode()方法\n\nString构造函数的的静态方法，接收一个或者多个字符编码，然后把它们转换成一个字符串。\n\n```js\nString.fromCharCode(104, 101, 108, 108, 111); // \"hello\"\n```\n\n#### HTML方法\n\n该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用这些特性。因此不再列出。\n\n## 内置对象\n\n### 全局(Global)对象\n\n在大多是ECMAScript实现中都不能直接访问Global对象，不过Web浏览器实现了承担该角色的window对象，因此在全局作用域中生命的所有变量核函数，就都成为了window对象的属性。\n\n#### 全局函数\n\n所有在全局作用域定义的属性和方法都是Global对象的属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n- [`eval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval)：将传入的字符串当做 JavaScript 代码进行执行。\n- [`uneval()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/uneval) ：返回代表传入对象的源代码的字符串，该特性是非标准的，请尽量不要在生产环境中使用它！\n- [`isFinite()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite)：判定一个数字是否是有限数字。`isFinite` 方法检测它参数的数值。如果参数是 `NaN`，正无穷大或者负无穷大，会返回`false`，其他返回 `true`。\n- [`isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)：确定一个值是否为[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 。如果`isNaN`函数的参数不是`Number`类型， `isNaN`函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)进行判断。ECMAScript (ES2015)包含[`Number.isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)函数。通过`Number.isNaN(x)`来检测`变量x`是否是一个`NaN`将会是一种可靠的做法。然而，在缺少`Number.isNaN`函数的情况下, 通过表达式`(x != x)` 来检测`变量x`是否是`NaN`会更加可靠。\n- [`parseFloat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat)：解析一个字符串参数并返回一个浮点数。\n- [`parseInt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。\n- [`decodeURI()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI)：解码一个由[`encodeURI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) 先前创建的统一资源标识符（URI）或类似的例程。\n- [`decodeURIComponent()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) : 解码由 [`encodeURIComponent`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) 方法或者其它类似方法编码的部分统一资源标识符（URI）。\n- [`encodeURI()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI)：对统一资源标识符（URI）进行编码，将有效的URI不能包含的字符替换为特殊的UTF-8编码。\n- [`encodeURIComponent()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) ：对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。\n- [`escape()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape) ，已废弃。生成新的由十六进制转义序列替换的字符串. 使用 [`encodeURI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) 或 [`encodeURIComponent`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) 代替。\n- [`unescape()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape) ，已废弃。\n\n`encodeURI` 会替换所有的字符，但不包括以下字符，即使它们具有适当的UTF-8转义序列：\n\n| 类型         | 包含                                          |\n| ------------ | --------------------------------------------- |\n| 保留字符     | `;` `,` `/` `?` `:` `@` `&` `=` `+` `$`       |\n| 非转义的字符 | 字母 数字 `-` `_` `.` `!` `~` `*` `'` `(` `)` |\n| 数字符号     | `#`                                           |\n\n请注意，`encodeURI` 自身*无法*产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 \"&\", \"+\", 和 \"=\" 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。\n\n然而`encodeURIComponent` 转义除了字母、数字、`(`、`)`、`.`、`!`、`~`、`*`、`'`、`-`和`_`之外的所有字符。\n\n例子：\n\n```js\n// 解码一个西里尔字母（Cyrillic）URL\ndecodeURI(\"https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\");\n// \"https://developer.mozilla.org/ru/docs/JavaScript_шеллы\"\n\n// 解码一个西里尔字母的URL\ndecodeURIComponent(\"JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\");\n// \"JavaScript_шеллы\"\n\n// *****************************************************************\n\nvar fileName = 'my file(2).txt';\nvar header = \"Content-Disposition: attachment; filename*=UTF-8''\" \n       + encodeRFC5987ValueChars(fileName);\n\nconsole.log(header); \n// 输出 \"Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt\"\n\nfunction encodeRFC5987ValueChars (str) {\n  return encodeURIComponent(str).\n    // 注意，仅管 RFC3986 保留 \"!\"，但 RFC5987 并没有\n    // 所以我们并不需要过滤它\n    replace(/['()]/g, escape). // i.e., %27 %28 %29\n    replace(/\\*/g, '%2A').\n      // 下面的并不是 RFC5987 中 URI 编码必须的\n      // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性\n      replace(/%(?:7C|60|5E)/g, unescape);\n}\n```\n\n 注： [RFC 3986](http://tools.ietf.org/html/rfc3986)，保留 !, ', (, ), 和 *\n\n#### Global对象的属性\n\n特殊值如undefined等、所有原生引用类型的构造函数都是Global对象的属性。\n\n除了这些还有：\n\n- [`Error`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)\n- [`EvalError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError)\n- [`InternalError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/InternalError)\n- [`RangeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError)\n- [`ReferenceError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)\n- [`SyntaxError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError)\n- [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)\n- [`URIError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/URIError)\n\n### Math对象\n\n[**Math**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math) 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。\n\n`Math` 的所有属性和方法都是静态的：例如常数pi可以用 `Math.PI` 表示，用 `x` 作参数 Math.sin(x)调用sin函数。\n\n#### Math对象的属性\n\n[`Math.E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/E)\n\n欧拉常数，也是自然对数的底数, 约等于 2.718.\n\n[`Math.LN2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2)\n\n2的自然对数, 约等于0.693.\n\n[`Math.LN10`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10)\n\n10的自然对数, 约等于 2.303.\n\n[`Math.LOG2E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E)\n\n以2为底E的对数, 约等于 1.443.\n\n[`Math.LOG10E`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E)\n\n以10为底E的对数, 约等于 0.434.\n\n[`Math.PI`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/PI)\n\n圆周率，一个圆的周长和直径之比，约等于 3.14159.\n\n[`Math.SQRT1_2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2)\n\n1/2的平方根, 约等于 0.707.\n\n[`Math.SQRT2`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT2)\n\n2的平方根,约等于 1.414.\n\n#### 常用方法\n\n[`Math.max()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max)\n\n返回0个到多个数值中最大值.\n\n[`Math.min()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min)\n\n返回0个到多个数值中最小值.\n\n[`Math.ceil(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)\n\n返回x向上取整后的值.\n\n[`Math.floor(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)\n\n返回小于x的最大整数。\n\n[`Math.round(x)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round)\n\n返回四舍五入后的整数.\n\n[`Math.random()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random)\n\n返回0到1之间的伪随机数.\n\n所有方法看[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math#Methods)。","slug":"JavaScript学习记录二","published":1,"updated":"2018-10-10T08:53:58.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vg000jfmagt0rapvda","content":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p><a id=\"more\"></a><hr><h1 id=\"变量、作用域和内存问题\"><a href=\"#变量、作用域和内存问题\" class=\"headerlink\" title=\"变量、作用域和内存问题\"></a>变量、作用域和内存问题</h1><h2 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h2><p>ECMAScript变量可能包含两种不同数据类型的值：</p><ul><li><strong>基本类型值</strong>：保存在<strong>栈内存</strong>中的简单数据段，这种值完全保存在内存中的一个位置</li><li><strong>引用类型值</strong>：保存在<strong>堆内存</strong>中的对象，保存的实际上是一个指针，指针指向内存中真正对象保存的位置</li></ul><p>五种基本数据类型：Undefined、Null、Boolean、Number、String在内存中占有固定大小的空间，因此可以保存在栈内存中。因为我们操作的是它们实际保存的值，所以它们是<strong>按值</strong>访问的。</p><p>对于对象，先从栈中读取内存地址，然后再按照地址找到保存在堆中的值。因为我们操作的不是实际的值，而是那个值所引用的对象，因此我们称之为<strong>按引用</strong>访问的。（图片来源于网络，cr 水印）</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536816598256&amp;di=246ab4e73e12049d497d375df4fd273b&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D2929764421%2C2277861536%26fm%3D214%26gp%3D0.jpg\" alt=\"栈内存与堆内存\"></p><h3 id=\"动态属性\"><a href=\"#动态属性\" class=\"headerlink\" title=\"动态属性\"></a>动态属性</h3><p>对于对象，我们可以改变和删除其属性和方法，但是不能给基本类型的值添加属性。</p><p>即只能给引用类型值动态地添加属性。</p><h3 id=\"复制变量值\"><a href=\"#复制变量值\" class=\"headerlink\" title=\"复制变量值\"></a>复制变量值</h3><p>当复制基本类型值的时候，会在栈中为其开辟一块新的内存保存其值。</p><p>但是当复制引用类型的值时，实际上复制保存的是这个对象在堆内存中的地址，也就是两者指向的是同一个对象。</p><h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>ECMAScript中所有的函数的参数都是<strong>按值传递</strong>的。</p><p>传递基本类型值就如基本类型变量的复制一样，传递引用类型变量时也如同引用变量的复制。</p><p>因此传递引用类型的变量时，传递的相当于是拷贝的指针。</p><p>可以看下边这个例子（我觉得可以把对象看做是一个指向对象的指针，然后函数传递的是一个拷贝的指针）：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  obj<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">;</span>\n  obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  obj<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Obejct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Nicholas\"</span>\n</code></pre><h3 id=\"检测类型\"><a href=\"#检测类型\" class=\"headerlink\" title=\"检测类型\"></a>检测类型</h3><p>typeof检测null返回”object”</p><p>当我们想知道一个对象是什么类型的对象时，可以使用<code>instanceof</code>，它的语法是：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型（由构造函数表示）的实例，则instanceof返回true：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变量person是Object么？</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>colors <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变量colors是Array么？</span>\n</code></pre><p>当使用instanceof检测基本类型的值时始终返回false，因为基本类型不是对象。</p><p>注： 在Safiri和Chrome中使用typeof检测正则表达式会错误的返回”function”。</p><h2 id=\"执行环境和作用域\"><a href=\"#执行环境和作用域\" class=\"headerlink\" title=\"执行环境和作用域\"></a>执行环境和作用域</h2><p><a href=\"https://blog.csdn.net/wmaoshu/article/details/60466990\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">执行环境</a>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p><p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</p><p>在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。</p><p>一个执行环境中的所有代码执行完毕后，该环境和保存在其中的所有变量和函数定义都被销毁，</p><p>全局执行环境直到关闭页面或者浏览器时才会被销毁。</p><p>关于作用域链可以看<a href=\"https://blog.csdn.net/charlene0824/article/details/52252824\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h3 id=\"延长作用域链\"><a href=\"#延长作用域链\" class=\"headerlink\" title=\"延长作用域链\"></a>延长作用域链</h3><ul><li>with语句： 其变量对象包含为指定的对象的所有属性和方法所做的变量声明。</li><li>catch语句： 包含被抛出的错误对象的声明</li></ul><p>在IE的JavaScript实现中，catch语句捕获的错误对象会被添加到执行环境的变量对象中。</p><h3 id=\"没有块级作用域\"><a href=\"#没有块级作用域\" class=\"headerlink\" title=\"没有块级作用域\"></a>没有块级作用域</h3><ul><li><p>使用if 、for语句创建的变量会保存在语句外部的执行环境中。</p></li><li><p>函数内部是一个局部环境</p></li><li>访问局部变量比全局变量快，因为不用向上搜索作用域链</li></ul><h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，按照固定的时间间隔或代码执行中预定的收集时间，周期性地找出不再使用的变量释放其内存。</p><p>关于垃圾收集方式的详细解释可以看<a href=\"https://www.cnblogs.com/scottjeremy/p/6870729.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>关于性能问题和管理内存可以看<a href=\"https://www.cnblogs.com/yxField/p/4226591.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h1 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h1><h2 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h2><p>创建Object实例的方式：</p><ul><li><code>var xxx = new Object()</code></li><li><code>var xxx = {age: 29}</code>, <code>{}</code>是对象字面量边界</li></ul><p>可以用<code>xxx.age</code>或者<code>xxx[&#39;age&#39;]</code>来访问属性，更建议用点表示法。</p><h2 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h2><p>ECMAScript数组的每一项可以保存任何类型的数据。</p><p>数组的索引从0开始。</p><p>数组的项数保存在其length属性中，它并不是只读的，可以通过设置它来在数组的末尾移除或添加项，添加项的初始值为undefined。</p><p>因为JavaScript使用一个32位整数保存数组元素个数，因此数组最多可以包含4294967295项（2的32次方减1）。</p><p>以下是创建数组的例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// new 可以省略</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创建一个空数组</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创造一个包含20项的数组，每一项的初始值都是undefined</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创造一个包含三项：\"red\",\"blue\",\"green\"的数组</span>\n<span class=\"token keyword\">var</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创造一个包含三项：\"red\",\"blue\",\"green\"的数组</span>\n<span class=\"token keyword\">var</span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创建一个空数组</span>\n<span class=\"token keyword\">var</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不要这样！这样会创建一个包含2或3项的数组</span>\n<span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不要这样！这样会创建一个包含5或6项的数组</span>\n</code></pre><h3 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h3><p>valueOf()返回当前对象的原始值；</p><p>toString()方法先调用每一项的toString()方法，然后用逗号将它们拼接起来并返回；</p><p>toLocalString()方法先调用每一项的toLocalString()方法，然后用逗号将它们拼接起来并返回；</p><p>如果使用join()方法可以使用不同的分隔符来构建这个字符串：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'a,b,c'</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'||'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'a||b||c'</span>\n</code></pre><p>如果某一项是undefined或null，那么在toString()、toLocalString()、join()方法返回的结果中以空字符串表示。</p><h3 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h3><p>ECMAScript为数组提供了push()和pop()方法，以便实现类似栈的行为（LIFO，后进先出）。</p><ul><li>push()方法可以接受任意数量的参数，然后把它们逐个添加到数组末尾，并返回修改后的数组长度</li><li>pop()方法则从数组末尾移除最后一项，并将length减一，返回移除的项。</li></ul><h3 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h3><p>可以使用push()和shift()方法，实现类似于队列的行为（FIFO，先进先出）。</p><ul><li>shift()方法从数组开头移除第一项，并将length减一，返回移除的项。</li><li>ECMAScript还提供了unshift()方法，可以接受任意数量的参数，然后把它们逐个添加到数组头部，并返回修改后的数组长度（IE返回undefined）。</li></ul><p>关于unshift()的添加多个变量的顺序：</p><pre class=\" language-javascript\"><code class=\"language-javascript\">a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span>；\na<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"1\", \"2\", \"a\", \"b\", \"c\", null]</span>\n</code></pre><h3 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h3><p>reverse()会反转数组项的顺序：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 0,3,5,6,2,1</span>\n</code></pre><p>sort()为排序函数，默认从小到大排序，也可以传入一个比较函数：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 0,1,2,3,5,6</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v1 <span class=\"token operator\">&lt;</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v1 <span class=\"token operator\">></span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>compare<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 6,5,3,2,1,0</span>\n</code></pre><p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以简化一下比较函数：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 升序排序</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">compare1</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> v1 <span class=\"token operator\">-</span> v2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 降序排序</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">compare1</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> v2 <span class=\"token operator\">-</span> v1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h4><p>——先创建一个当前数组的副本，然后将接收到的参数添加到这个副本的末尾，返回新构建的这个数组：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'3'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token string\">'4'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'6'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1,2,3</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1,2,3,4,5,6</span>\n</code></pre><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h4><p>——局部拷贝数组，接受一个参数或两个参数；</p><p>一个参数时拷贝从这个参数指定的位置到结尾；</p><p>两个参数时，拷贝两个参数之间的项，不包含结束为止的项。</p><p>当参数为负数时，则用该数加数组长度：</p><ul><li>若加完之后大于等于零则用加完后的数计算</li><li>若加完之后还小于0则把该数看做0</li></ul><p>若起始位置大于结束位置，则返回空数组。</p><p>下边为一个简单的例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1,2,3,4</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1,2,3</span>\n</code></pre><h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h4><p>主要用途是向数组的中部插入项，对原数组进行操作</p><p>使用方式主要有三种：</p><ul><li>删除： 指定两个参数——要删除的第一项的位置和要删除的项数，返回被删除的项</li><li>插入： 指定三个参数——起始位置、0（要删除的项数）、要插入的项（任意数量），返回被删除的项（空）</li><li>替换： 指定三个参数——起始位置、要删除的项数、要插入的项（任意数量），返回被删除的项（空）</li></ul><p>代码例子可以看<a href=\"https://blog.csdn.net/qq_33733970/article/details/78787726\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h2 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h2><p>是在早期Java中的java.util.Date类基础上构建的。</p><p>因此Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。</p><p>Date类型保存的日期能够精确到1970年1月1日前后285616年。</p><p>关于创建日期和设置日期可以看<a href=\"http://www.runoob.com/js/js-obj-date.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>Date对象属性及方法可以看<a href=\"http://www.runoob.com/jsref/jsref-obj-date.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>将表示日期的字符串传递给Date构造函数，后台会自动调用Date.parse()，然后将得到的值传给构造函数。</p><p>Date对象可以直接进行大小比较。</p><p>可以进行日期加减，下边的例子表示五天后的日期：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myDate<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyDate<span class=\"token punctuation\">.</span><span class=\"token function\">setDate</span><span class=\"token punctuation\">(</span>myDate<span class=\"token punctuation\">.</span><span class=\"token function\">getDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><h2 id=\"RegExp类型\"><a href=\"#RegExp类型\" class=\"headerlink\" title=\"RegExp类型\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RegExp类型</a></h2><p>正则表达式： <code>var expression = / pattern / flags</code></p><p>正则表达式语法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_in_regular_expressions\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>flags为一个或多个标志，正则表达式的匹配模式支持下面三个标志：</p><ul><li>g——全局(global)模式，应用于所有字符串</li><li>i——不区分带小写(case-insensitive)模式</li><li>m——多行(multiiline)模式，到达一行文本末尾时还会继续查找喜爱航是否存在与模式匹配的项</li></ul><p>元字符：<code>()[]{}\\^$|?*+.</code>，元字符必须转义。</p><p>以下是一些例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> pattern1 <span class=\"token operator\">=</span> <span class=\"token regex\">/at/g</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// 匹配字符串中所有\"at\"实例</span>\n<span class=\"token keyword\">var</span> pattern2 <span class=\"token operator\">=</span> <span class=\"token regex\">/.at/gi</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// 匹配字符串中所有以\"at\"结尾的三个字符的实例，不区分大小写</span>\n<span class=\"token keyword\">var</span> pattern3 <span class=\"token operator\">=</span> <span class=\"token regex\">/\\.at/gi</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 匹配字符串中所有\".at\"实例，不区分大小写</span>\n<span class=\"token keyword\">var</span> pattern4 <span class=\"token operator\">=</span> <span class=\"token regex\">/[bc]at/i</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 匹配字符串中第一个\"bat\"或\"cat\"实例，不区分大小写</span>\n<span class=\"token keyword\">var</span> pattern5 <span class=\"token operator\">=</span> <span class=\"token regex\">/\\[bc\\]at/i</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 匹配字符串中第一个\"[bc]at\"实例，不区分大小写</span>\n</code></pre><p>也可以使用构造函数来定义，例如下边两个式子得到的值是等价==相同的：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> pattern1 <span class=\"token operator\">=</span> <span class=\"token regex\">/[bc]at/i</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> pattern2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[bc]at\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>需要注意的是，构造函数的字符串中，元字符必须双重转义，比如<code>/\\./</code>双重转义为”\\\\.”</p><h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><ul><li>global——布尔值，表示是否设置了g标志</li><li>ignoreCase——布尔值，表示是否设置了i标志</li><li>multiline——布尔值，表示是否设置了m标志</li><li>lastIndex——整数，表示开始搜索下一个匹配项的字符位置，从0算起</li><li>source——正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li></ul><h3 id=\"RegExp实例方法\"><a href=\"#RegExp实例方法\" class=\"headerlink\" title=\"RegExp实例方法\"></a>RegExp实例方法</h3><p>关于exec()方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>关于test()方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h3 id=\"RegExp构造函数属性\"><a href=\"#RegExp构造函数属性\" class=\"headerlink\" title=\"RegExp构造函数属性\"></a>RegExp构造函数属性</h3><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input字符串中lastMatch之前的文本</td></tr><tr><td>rightContext</td><td>$’</td><td>input字符串中lastMatch之后的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，表示是否所有表达式都使用多行模式</td></tr></tbody></table><p>注：书中说Opera不支持input、lastMatch、lastParent、multiline，但查阅MDN文档显示的是支持的，因此待验证。</p><p>关于如何使用，以lastMatch为例：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> re <span class=\"token operator\">=</span> <span class=\"token regex\">/hi/g</span><span class=\"token punctuation\">;</span>\nre<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hi there!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nRegExp<span class=\"token punctuation\">.</span>lastMatch<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"hi\"</span>\nRegExp<span class=\"token punctuation\">[</span><span class=\"token string\">'$&amp;'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// \"hi\"</span>\n</code></pre><p>另外对于书中提到的ECMAScript正则表达式不支持的特性，因为版本不断更新，比如现在已经支持Unicode，因此就不在这里列出来了。</p><h2 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h2><p>所有函数实际上都是Function类型的实例，且与其他引用数据类型一样具有属性和方法。</p><p><strong>“函数是对象，函数名是指针”。</strong></p><p>定义函数的方式：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum1</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> sum2 <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> sum3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'num1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'num2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'return num1 + num2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不推荐</span>\n</code></pre><h3 id=\"深入理解没有重载\"><a href=\"#深入理解没有重载\" class=\"headerlink\" title=\"深入理解没有重载\"></a>深入理解没有重载</h3><p>将函数名想象为指针，当用同一个函数名重新声明一个函数实际上相当于改变了指针的指向。</p><p>指针只能指向一个对象。</p><h3 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h3><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 函数声明</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum1</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 函数表达式</span>\n<span class=\"token keyword\">var</span> sum2 <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用，</p><p>但是对于函数表达式，必须等到解析器执行到它所在的代码行才会真正被解释执行。</p><p>可以同时使用函数声明和函数表达式<code>var sum1 = function sum2() {}</code>，但会在Safari中导致错误。</p><h3 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h3><p>函数名本身就是变量，因此可以把函数当做参数传递，<a href=\"https://blog.csdn.net/lingfeng2008w/article/details/50598431\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>有人总结了当做参数传递的用法。</p><h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><p>在函数内部有两个特殊的对象：arguments和this。</p><p><strong>arguments</strong>还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，有什么用呢？可以看阶乘函数这个例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>像这样递归，我们在修改函数名、拷贝函数后修改原函数内容后都会遇到麻烦，因此就要用到callee属性了：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 使用callee属性</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> trueFactorial <span class=\"token operator\">=</span> factorial<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 拷贝函数</span>\nfactorial <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 修改原函数定义</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 0</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token function\">trueFactorial</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 120</span>\n</code></pre><p><strong>this</strong>是函数在执行时所处的作用域（挡在网页的全局作用域调用函数时，this对象引用的就是window），可以看下边这个例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nwindow<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>color<span class=\"token punctuation\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nb<span class=\"token punctuation\">.</span>sayColor <span class=\"token operator\">=</span> sayColor<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//'red'</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'blue'</span>\n</code></pre><h3 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h3><p>每个函数都包含两个属性：length和prototype。</p><ul><li>length：函数希望接收的命名参数的个数</li><li>prototype：可以看我<a href=\"https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</li></ul><p>每个函数都包含两个非继承而来的方法：apply()和call()。</p><p>这两个的用途都是给函数<strong>指定函数体内this的值</strong>。</p><blockquote><p><code>apply</code> 与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>call()</code></a> 非常相似，不同之处在于提供参数的方式。</p><p><code>apply</code> 使用参数数组而不是一组参数列表。<code>apply</code> 可以使用数组字面量（array literal），如 <code>fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])</code>，或数组对象， 如 <code>fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))</code>。</p><p>而 <code>call</code>的语法为<code>fun.call(thisArg, arg1, arg2, ...)</code>。</p><p>需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<a href=\"https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">非严格模式下</a>，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动<a href=\"https://www.cnblogs.com/moqing/p/5593986.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">包装对象</a>。</p></blockquote><p>每个函数都一个非标准的caller属性，指向调用该函数的函数，</p><p>因此一般在一个函数的内部，通过<code>arguments.callee.caller</code>来实现对调用栈的追溯，</p><p>但只建议将该属性用于调试目的。</p><h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>先看<a href=\"https://www.cnblogs.com/moqing/p/5593986.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇文章</a></p><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3><ul><li>基本类型的布尔值： <code>var a = false</code></li><li>引用类型的布尔值： <code>var b = new Boolean(false)</code></li></ul><p>除了包装对象的问题，两个还有两个区别：</p><ul><li>typeof 的结果一个是”boolean”一个是”object”</li><li>instanceof测试是否为Boolean对象一个是false，一个是true</li></ul><p><strong>建议永远不要使用Boolean对象。</strong></p><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3><p>重写了valueOf()、toLocaleString()和toString()方法。</p><ul><li><p>valueOf()返回对象表示的基本类型的数值。</p></li><li><p>可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p></li><li><p>toFixed()方法会按照指定的小数位返回数值的字符串表示（四舍五入）：<code>var num = 10;num.toFixed(2)</code>结果为“10.00”</p></li><li>toExponential()按照指定的小数位数返回数值的指数表示的字符串：<code>var num = 10;num.toExponential(2)</code>结果为“1.00e+1”</li><li>toPrecision()接受一个参数作为表示数值所有数字的位数（不包括指数部分），然后返回最合适的表示格式的字符串。</li></ul><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><h4 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h4><p>访问字符串中特定字符：<code>charAt()</code>、<code>charCodeAt()</code></p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token string\">'hello world!'</span><span class=\"token punctuation\">;</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// \"e\", 返回字符</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// \"101\"， 返回字符编码</span>\ns<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">// \"e\"</span>\n</code></pre><h4 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h4><ul><li>concat() ： <em>string</em>.concat(<em>string1</em>, <em>string2</em>, …, <em>stringX</em>)， 连接字符串，不改变原字符串，返回连接后的字符串</li><li>slice()：<em>string</em>.slice(<em>start</em>,<em>end</em>)，提取字符串片断，start为要截取的片段的起始下标；end为要截取的片段的结尾下标加一，若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串，如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li><li>substring()：类似于slice()</li><li>substr()：<em>string</em>.substr(<em>start</em>,<em>length</em>)， 提取字符片段，start为要截取的片段的起始下标；length为要截取的长度，那么返回从 sstart到结尾的字串。</li></ul><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"world!\"</span><span class=\"token punctuation\">;</span>\nstr1<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"Hello world!\"</span>\nstr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"ello\"</span>\nstr<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"ello\"</span>\nstr<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"llo\"</span>\n</code></pre><p>假设p为一个正确的坐标值，m为一个负值，则</p><ul><li>string.concat(p,m)x相当于string.concat(p)</li><li>string.substring(p,m)相当于string.substring(p,0)相当于string.substring(0,p)</li><li>string.substr(p,m)相当于string.substr(p,0)，返回空字符串</li></ul><h4 id=\"字符串位置方法\"><a href=\"#字符串位置方法\" class=\"headerlink\" title=\"字符串位置方法\"></a>字符串位置方法</h4><p><code>indexOf()</code>和<code>lastIndexOf()</code>，传入一个字符串，返回这个字符串在源字符串中第一次和最后一次出现的位置，若没有找到则返回-1。</p><p>还可以传入第二个参数表示开始查找的位置，<code>indexOf()</code>往后查找，<code>lastIndexOf()</code>往前查找。</p><h4 id=\"字符串大小写转换方法\"><a href=\"#字符串大小写转换方法\" class=\"headerlink\" title=\"字符串大小写转换方法\"></a>字符串大小写转换方法</h4><ul><li>toLowerCase()、toUpperCase()</li><li>toLocaleLowerCase()、toLocaleUpperCase()，针对地区应用不同的规则</li></ul><h4 id=\"字符串的模式匹配方法\"><a href=\"#字符串的模式匹配方法\" class=\"headerlink\" title=\"字符串的模式匹配方法\"></a>字符串的模式匹配方法</h4><ol><li><p><code>match()</code>，等价于调用RegExp对象的exec()方法。</p><p><code>match()</code>接受一个正则表达式或者一个RegExp对象作为参数，返回一个数组，数组第一项是与整个模式匹配的字符串，之后的每一项都是和捕获组匹配的字符串。</p></li><li><p><code>search()</code>与<code>match()</code>唯一不同的是返回的是第一个匹配项的索引。</p></li><li><p><code>replace()</code>添加了一个传入的参数，表示匹配到的字符串要替换成的字符串。如果要全部替换，要记得在正则表达式中指定全局标志(g)。第二个参数也可以是函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><p>替换字符串可以插入下面的特殊变量名：</p></li></ol><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td><code>$$</code></td><td>插入一个 “$”。</td></tr><tr><td><code>$&amp;</code></td><td>插入匹配的子串。</td></tr><tr><td>$`</td><td>插入当前匹配的子串左边的内容。</td></tr><tr><td><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容。</td></tr><tr><td><code>$*n*</code></td><td>假如第一个参数是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RegExp</code></a>对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。</td></tr></tbody></table><ol start=\"4\"><li><code>splite()</code>，基于指定的分隔符<code>separator</code>将一个字符串分割成多个子字符串，还可以指定第二个参数，一个整数，限定返回的分割片段数量。</li></ol><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"Webkit Moz O ms Khtml\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\" \"</span> <span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">// [\"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"]</span>\n<span class=\"token keyword\">var</span> myString <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World. How are you doing?\"</span><span class=\"token punctuation\">;</span>\nmyString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"Hello\", \"World.\", \"How\"]</span>\n</code></pre><p>如果 <code>separator</code> 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myString <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello 1 word. Sentence number 2.\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> splits <span class=\"token operator\">=</span> myString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/(\\d)/</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// \\d匹配数字</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>splits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [ \"Hello \", \"1\", \" word. Sentence number \", \"2\", \".\" ]</span>\n</code></pre><h4 id=\"localeCompare-方法\"><a href=\"#localeCompare-方法\" class=\"headerlink\" title=\"localeCompare()方法\"></a>localeCompare()方法</h4><p><code>referenceStr.localeCompare(compareString[, locales[, options]])</code></p><p>判断字符串参数compareString是否在字母表中排在字符串referenceStr之前，是的话返回正数，不是返回负数，相等返回0。</p><p>locales和options都是可选参数，还没有被所有浏览器支持，具体的含义可以查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">文档</a>。</p><p>下边是一个简单的例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// \"c\" 在 \"a\" 之后， 返回负数</span>\n<span class=\"token string\">'a'</span><span class=\"token punctuation\">.</span><span class=\"token function\">localeCompare</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// -2 或者 -1 (或者其他负数)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// \"against\" 在 \"check\" 之前</span>\n<span class=\"token string\">'check'</span><span class=\"token punctuation\">.</span><span class=\"token function\">localeCompare</span><span class=\"token punctuation\">(</span><span class=\"token string\">'against'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// 2 或者 1 (或者其他正数)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 相同</span>\n<span class=\"token string\">'a'</span><span class=\"token punctuation\">.</span><span class=\"token function\">localeCompare</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// 0</span>\n</code></pre><h4 id=\"fromCharCode-方法\"><a href=\"#fromCharCode-方法\" class=\"headerlink\" title=\"fromCharCode()方法\"></a>fromCharCode()方法</h4><p>String构造函数的的静态方法，接收一个或者多个字符编码，然后把它们转换成一个字符串。</p><pre class=\" language-js\"><code class=\"language-js\">String<span class=\"token punctuation\">.</span><span class=\"token function\">fromCharCode</span><span class=\"token punctuation\">(</span><span class=\"token number\">104</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">108</span><span class=\"token punctuation\">,</span> <span class=\"token number\">108</span><span class=\"token punctuation\">,</span> <span class=\"token number\">111</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"hello\"</span>\n</code></pre><h4 id=\"HTML方法\"><a href=\"#HTML方法\" class=\"headerlink\" title=\"HTML方法\"></a>HTML方法</h4><p>该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用这些特性。因此不再列出。</p><h2 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h2><h3 id=\"全局-Global-对象\"><a href=\"#全局-Global-对象\" class=\"headerlink\" title=\"全局(Global)对象\"></a>全局(Global)对象</h3><p>在大多是ECMAScript实现中都不能直接访问Global对象，不过Web浏览器实现了承担该角色的window对象，因此在全局作用域中生命的所有变量核函数，就都成为了window对象的属性。</p><h4 id=\"全局函数\"><a href=\"#全局函数\" class=\"headerlink\" title=\"全局函数\"></a>全局函数</h4><p>所有在全局作用域定义的属性和方法都是Global对象的属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><ul><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>eval()</code></a>：将传入的字符串当做 JavaScript 代码进行执行。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/uneval\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>uneval()</code></a> ：返回代表传入对象的源代码的字符串，该特性是非标准的，请尽量不要在生产环境中使用它！</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>isFinite()</code></a>：判定一个数字是否是有限数字。<code>isFinite</code> 方法检测它参数的数值。如果参数是 <code>NaN</code>，正无穷大或者负无穷大，会返回<code>false</code>，其他返回 <code>true</code>。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>isNaN()</code></a>：确定一个值是否为<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a> 。如果<code>isNaN</code>函数的参数不是<code>Number</code>类型， <code>isNaN</code>函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a>进行判断。ECMAScript (ES2015)包含<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Number.isNaN()</code></a>函数。通过<code>Number.isNaN(x)</code>来检测<code>变量x</code>是否是一个<code>NaN</code>将会是一种可靠的做法。然而，在缺少<code>Number.isNaN</code>函数的情况下, 通过表达式<code>(x != x)</code> 来检测<code>变量x</code>是否是<code>NaN</code>会更加可靠。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>parseFloat()</code></a>：解析一个字符串参数并返回一个浮点数。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>parseInt()</code></a>：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a>。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>decodeURI()</code></a>：解码一个由<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI</code></a> 先前创建的统一资源标识符（URI）或类似的例程。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>decodeURIComponent()</code></a> : 解码由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent</code></a> 方法或者其它类似方法编码的部分统一资源标识符（URI）。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI()</code></a>：对统一资源标识符（URI）进行编码，将有效的URI不能包含的字符替换为特殊的UTF-8编码。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent()</code></a> ：对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>escape()</code></a> ，已废弃。生成新的由十六进制转义序列替换的字符串. 使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent</code></a> 代替。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>unescape()</code></a> ，已废弃。</li></ul><p><code>encodeURI</code> 会替换所有的字符，但不包括以下字符，即使它们具有适当的UTF-8转义序列：</p><table><thead><tr><th>类型</th><th>包含</th></tr></thead><tbody><tr><td>保留字符</td><td><code>;</code> <code>,</code> <code>/</code> <code>?</code> <code>:</code> <code>@</code> <code>&amp;</code> <code>=</code> <code>+</code> <code>$</code></td></tr><tr><td>非转义的字符</td><td>字母 数字 <code>-</code> <code>_</code> <code>.</code> <code>!</code> <code>~</code> <code>*</code> <code>&#39;</code> <code>(</code> <code>)</code></td></tr><tr><td>数字符号</td><td><code>#</code></td></tr></tbody></table><p>请注意，<code>encodeURI</code> 自身<em>无法</em>产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 “&amp;”, “+”, 和 “=” 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。</p><p>然而<code>encodeURIComponent</code> 转义除了字母、数字、<code>(</code>、<code>)</code>、<code>.</code>、<code>!</code>、<code>~</code>、<code>*</code>、<code>&#39;</code>、<code>-</code>和<code>_</code>之外的所有字符。</p><p>例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 解码一个西里尔字母（Cyrillic）URL</span>\n<span class=\"token function\">decodeURI</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// \"https://developer.mozilla.org/ru/docs/JavaScript_шеллы\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 解码一个西里尔字母的URL</span>\n<span class=\"token function\">decodeURIComponent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// \"JavaScript_шеллы\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// *****************************************************************</span>\n\n<span class=\"token keyword\">var</span> fileName <span class=\"token operator\">=</span> <span class=\"token string\">'my file(2).txt'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> header <span class=\"token operator\">=</span> <span class=\"token string\">\"Content-Disposition: attachment; filename*=UTF-8''\"</span> \n       <span class=\"token operator\">+</span> <span class=\"token function\">encodeRFC5987ValueChars</span><span class=\"token punctuation\">(</span>fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// 输出 \"Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt\"</span>\n\n<span class=\"token keyword\">function</span> encodeRFC5987ValueChars <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">encodeURIComponent</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 注意，仅管 RFC3986 保留 \"!\"，但 RFC5987 并没有</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 所以我们并不需要过滤它</span>\n    <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/['()]/g</span><span class=\"token punctuation\">,</span> escape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span> <span class=\"token comment\" spellcheck=\"true\">// i.e., %27 %28 %29</span>\n    <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\*/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'%2A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 下面的并不是 RFC5987 中 URI 编码必须的</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性</span>\n      <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/%(?:7C|60|5E)/g</span><span class=\"token punctuation\">,</span> unescape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>注： <a href=\"http://tools.ietf.org/html/rfc3986\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RFC 3986</a>，保留 !, ‘, (, ), 和 *</p><h4 id=\"Global对象的属性\"><a href=\"#Global对象的属性\" class=\"headerlink\" title=\"Global对象的属性\"></a>Global对象的属性</h4><p>特殊值如undefined等、所有原生引用类型的构造函数都是Global对象的属性。</p><p>除了这些还有：</p><ul><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Error</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>EvalError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/InternalError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>InternalError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RangeError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>ReferenceError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>SyntaxError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>TypeError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/URIError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>URIError</code></a></li></ul><h3 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Math</strong></a> 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。</p><p><code>Math</code> 的所有属性和方法都是静态的：例如常数pi可以用 <code>Math.PI</code> 表示，用 <code>x</code> 作参数 Math.sin(x)调用sin函数。</p><h4 id=\"Math对象的属性\"><a href=\"#Math对象的属性\" class=\"headerlink\" title=\"Math对象的属性\"></a>Math对象的属性</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.E</code></a></p><p>欧拉常数，也是自然对数的底数, 约等于 2.718.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LN2</code></a></p><p>2的自然对数, 约等于0.693.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LN10</code></a></p><p>10的自然对数, 约等于 2.303.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LOG2E</code></a></p><p>以2为底E的对数, 约等于 1.443.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LOG10E</code></a></p><p>以10为底E的对数, 约等于 0.434.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/PI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.PI</code></a></p><p>圆周率，一个圆的周长和直径之比，约等于 3.14159.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.SQRT1_2</code></a></p><p>1/2的平方根, 约等于 0.707.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.SQRT2</code></a></p><p>2的平方根,约等于 1.414.</p><h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.max()</code></a></p><p>返回0个到多个数值中最大值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.min()</code></a></p><p>返回0个到多个数值中最小值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.ceil(x)</code></a></p><p>返回x向上取整后的值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.floor(x)</code></a></p><p>返回小于x的最大整数。</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.round(x)</code></a></p><p>返回四舍五入后的整数.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.random()</code></a></p><p>返回0到1之间的伪随机数.</p><p>所有方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math#Methods\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p>","site":{"data":{}},"excerpt":"<p>——《JavaScript高级程序设计（第2版）》学习笔记</p><p>要多查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MDN Web 文档</a></p>","more":"<hr><h1 id=\"变量、作用域和内存问题\"><a href=\"#变量、作用域和内存问题\" class=\"headerlink\" title=\"变量、作用域和内存问题\"></a>变量、作用域和内存问题</h1><h2 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h2><p>ECMAScript变量可能包含两种不同数据类型的值：</p><ul><li><strong>基本类型值</strong>：保存在<strong>栈内存</strong>中的简单数据段，这种值完全保存在内存中的一个位置</li><li><strong>引用类型值</strong>：保存在<strong>堆内存</strong>中的对象，保存的实际上是一个指针，指针指向内存中真正对象保存的位置</li></ul><p>五种基本数据类型：Undefined、Null、Boolean、Number、String在内存中占有固定大小的空间，因此可以保存在栈内存中。因为我们操作的是它们实际保存的值，所以它们是<strong>按值</strong>访问的。</p><p>对于对象，先从栈中读取内存地址，然后再按照地址找到保存在堆中的值。因为我们操作的不是实际的值，而是那个值所引用的对象，因此我们称之为<strong>按引用</strong>访问的。（图片来源于网络，cr 水印）</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536816598256&amp;di=246ab4e73e12049d497d375df4fd273b&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D2929764421%2C2277861536%26fm%3D214%26gp%3D0.jpg\" alt=\"栈内存与堆内存\"></p><h3 id=\"动态属性\"><a href=\"#动态属性\" class=\"headerlink\" title=\"动态属性\"></a>动态属性</h3><p>对于对象，我们可以改变和删除其属性和方法，但是不能给基本类型的值添加属性。</p><p>即只能给引用类型值动态地添加属性。</p><h3 id=\"复制变量值\"><a href=\"#复制变量值\" class=\"headerlink\" title=\"复制变量值\"></a>复制变量值</h3><p>当复制基本类型值的时候，会在栈中为其开辟一块新的内存保存其值。</p><p>但是当复制引用类型的值时，实际上复制保存的是这个对象在堆内存中的地址，也就是两者指向的是同一个对象。</p><h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>ECMAScript中所有的函数的参数都是<strong>按值传递</strong>的。</p><p>传递基本类型值就如基本类型变量的复制一样，传递引用类型变量时也如同引用变量的复制。</p><p>因此传递引用类型的变量时，传递的相当于是拷贝的指针。</p><p>可以看下边这个例子（我觉得可以把对象看做是一个指向对象的指针，然后函数传递的是一个拷贝的指针）：</p><pre><code class=\"javascript\">function setName(obj) {\n  obj.name = &quot;Nicholas&quot;;\n  obj = new Object();\n  obj.name = &quot;Greg&quot;;\n}\n\nvar person = new Obejct();\nsetName(person);\nalert(person.name); // &quot;Nicholas&quot;\n</code></pre><h3 id=\"检测类型\"><a href=\"#检测类型\" class=\"headerlink\" title=\"检测类型\"></a>检测类型</h3><p>typeof检测null返回”object”</p><p>当我们想知道一个对象是什么类型的对象时，可以使用<code>instanceof</code>，它的语法是：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型（由构造函数表示）的实例，则instanceof返回true：</p><pre><code class=\"javascript\">alert(person instanceof Object); // 变量person是Object么？\nalert(colors instanceof Array); // 变量colors是Array么？\n</code></pre><p>当使用instanceof检测基本类型的值时始终返回false，因为基本类型不是对象。</p><p>注： 在Safiri和Chrome中使用typeof检测正则表达式会错误的返回”function”。</p><h2 id=\"执行环境和作用域\"><a href=\"#执行环境和作用域\" class=\"headerlink\" title=\"执行环境和作用域\"></a>执行环境和作用域</h2><p><a href=\"https://blog.csdn.net/wmaoshu/article/details/60466990\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">执行环境</a>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p><p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</p><p>在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。</p><p>一个执行环境中的所有代码执行完毕后，该环境和保存在其中的所有变量和函数定义都被销毁，</p><p>全局执行环境直到关闭页面或者浏览器时才会被销毁。</p><p>关于作用域链可以看<a href=\"https://blog.csdn.net/charlene0824/article/details/52252824\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h3 id=\"延长作用域链\"><a href=\"#延长作用域链\" class=\"headerlink\" title=\"延长作用域链\"></a>延长作用域链</h3><ul><li>with语句： 其变量对象包含为指定的对象的所有属性和方法所做的变量声明。</li><li>catch语句： 包含被抛出的错误对象的声明</li></ul><p>在IE的JavaScript实现中，catch语句捕获的错误对象会被添加到执行环境的变量对象中。</p><h3 id=\"没有块级作用域\"><a href=\"#没有块级作用域\" class=\"headerlink\" title=\"没有块级作用域\"></a>没有块级作用域</h3><ul><li><p>使用if 、for语句创建的变量会保存在语句外部的执行环境中。</p></li><li><p>函数内部是一个局部环境</p></li><li>访问局部变量比全局变量快，因为不用向上搜索作用域链</li></ul><h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，按照固定的时间间隔或代码执行中预定的收集时间，周期性地找出不再使用的变量释放其内存。</p><p>关于垃圾收集方式的详细解释可以看<a href=\"https://www.cnblogs.com/scottjeremy/p/6870729.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>关于性能问题和管理内存可以看<a href=\"https://www.cnblogs.com/yxField/p/4226591.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h1 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h1><h2 id=\"Object类型\"><a href=\"#Object类型\" class=\"headerlink\" title=\"Object类型\"></a>Object类型</h2><p>创建Object实例的方式：</p><ul><li><code>var xxx = new Object()</code></li><li><code>var xxx = {age: 29}</code>, <code>{}</code>是对象字面量边界</li></ul><p>可以用<code>xxx.age</code>或者<code>xxx[&#39;age&#39;]</code>来访问属性，更建议用点表示法。</p><h2 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h2><p>ECMAScript数组的每一项可以保存任何类型的数据。</p><p>数组的索引从0开始。</p><p>数组的项数保存在其length属性中，它并不是只读的，可以通过设置它来在数组的末尾移除或添加项，添加项的初始值为undefined。</p><p>因为JavaScript使用一个32位整数保存数组元素个数，因此数组最多可以包含4294967295项（2的32次方减1）。</p><p>以下是创建数组的例子：</p><pre><code class=\"javascript\">// new 可以省略\nvar a = new Array(); // 创建一个空数组\nvar b = new Array(20); // 创造一个包含20项的数组，每一项的初始值都是undefined\nvar c = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); // 创造一个包含三项：&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;的数组\nvar d = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创造一个包含三项：&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;的数组\nvar e = []; // 创建一个空数组\nvar f = [1,2,]; // 不要这样！这样会创建一个包含2或3项的数组\nvar g = [,,,,,]; // 不要这样！这样会创建一个包含5或6项的数组\n</code></pre><h3 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h3><p>valueOf()返回当前对象的原始值；</p><p>toString()方法先调用每一项的toString()方法，然后用逗号将它们拼接起来并返回；</p><p>toLocalString()方法先调用每一项的toLocalString()方法，然后用逗号将它们拼接起来并返回；</p><p>如果使用join()方法可以使用不同的分隔符来构建这个字符串：</p><pre><code class=\"javascript\">var a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\nalert(a.join(&#39;,&#39;)); // &#39;a,b,c&#39;\nalert(a.join(&#39;||&#39;)); // &#39;a||b||c&#39;\n</code></pre><p>如果某一项是undefined或null，那么在toString()、toLocalString()、join()方法返回的结果中以空字符串表示。</p><h3 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h3><p>ECMAScript为数组提供了push()和pop()方法，以便实现类似栈的行为（LIFO，后进先出）。</p><ul><li>push()方法可以接受任意数量的参数，然后把它们逐个添加到数组末尾，并返回修改后的数组长度</li><li>pop()方法则从数组末尾移除最后一项，并将length减一，返回移除的项。</li></ul><h3 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h3><p>可以使用push()和shift()方法，实现类似于队列的行为（FIFO，先进先出）。</p><ul><li>shift()方法从数组开头移除第一项，并将length减一，返回移除的项。</li><li>ECMAScript还提供了unshift()方法，可以接受任意数量的参数，然后把它们逐个添加到数组头部，并返回修改后的数组长度（IE返回undefined）。</li></ul><p>关于unshift()的添加多个变量的顺序：</p><pre><code class=\"javascript\">a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null]；\na.unshift(&#39;1&#39;,&#39;2&#39;); // [&quot;1&quot;, &quot;2&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null]\n</code></pre><h3 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h3><p>reverse()会反转数组项的顺序：</p><pre><code class=\"javascript\">var a = [1,2,6,5,3,0];\na.reverse();\nalert(a); // 0,3,5,6,2,1\n</code></pre><p>sort()为排序函数，默认从小到大排序，也可以传入一个比较函数：</p><pre><code class=\"javascript\">var a = [1,2,6,5,3,0];\na.sort();\nalert(a); // 0,1,2,3,5,6\n\nfunction compare(v1, v2) {\n  if (v1 &lt; v2) {\n    return 1;\n  } else if (v1 &gt; v2) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\na.sort(compare);\nalert(a); // 6,5,3,2,1,0\n</code></pre><p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以简化一下比较函数：</p><pre><code class=\"javascript\">// 升序排序\nfunction compare1(v1, v2) {\n  return v1 - v2;\n}\n\n// 降序排序\nfunction compare1(v1, v2) {\n  return v2 - v1;\n}\n</code></pre><h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h4><p>——先创建一个当前数组的副本，然后将接收到的参数添加到这个副本的末尾，返回新构建的这个数组：</p><pre><code class=\"javascript\">var a = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;];\nvar b = a.concat(&#39;4&#39;,[&#39;5&#39;,&#39;6&#39;]);\nalert(a); // 1,2,3\nalert(b); // 1,2,3,4,5,6\n</code></pre><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h4><p>——局部拷贝数组，接受一个参数或两个参数；</p><p>一个参数时拷贝从这个参数指定的位置到结尾；</p><p>两个参数时，拷贝两个参数之间的项，不包含结束为止的项。</p><p>当参数为负数时，则用该数加数组长度：</p><ul><li>若加完之后大于等于零则用加完后的数计算</li><li>若加完之后还小于0则把该数看做0</li></ul><p>若起始位置大于结束位置，则返回空数组。</p><p>下边为一个简单的例子：</p><pre><code class=\"javascript\">var a = [0,1,2,3,4];\nvar b = a.slice(1);\nvar c = a.slice(1,4);\nalert(a); // 1,2,3,4\nalert(b); // 1,2,3\n</code></pre><h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h4><p>主要用途是向数组的中部插入项，对原数组进行操作</p><p>使用方式主要有三种：</p><ul><li>删除： 指定两个参数——要删除的第一项的位置和要删除的项数，返回被删除的项</li><li>插入： 指定三个参数——起始位置、0（要删除的项数）、要插入的项（任意数量），返回被删除的项（空）</li><li>替换： 指定三个参数——起始位置、要删除的项数、要插入的项（任意数量），返回被删除的项（空）</li></ul><p>代码例子可以看<a href=\"https://blog.csdn.net/qq_33733970/article/details/78787726\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h2 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h2><p>是在早期Java中的java.util.Date类基础上构建的。</p><p>因此Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。</p><p>Date类型保存的日期能够精确到1970年1月1日前后285616年。</p><p>关于创建日期和设置日期可以看<a href=\"http://www.runoob.com/js/js-obj-date.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>Date对象属性及方法可以看<a href=\"http://www.runoob.com/jsref/jsref-obj-date.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>将表示日期的字符串传递给Date构造函数，后台会自动调用Date.parse()，然后将得到的值传给构造函数。</p><p>Date对象可以直接进行大小比较。</p><p>可以进行日期加减，下边的例子表示五天后的日期：</p><pre><code class=\"javascript\">var myDate=new Date();\nmyDate.setDate(myDate.getDate()+5);\n</code></pre><h2 id=\"RegExp类型\"><a href=\"#RegExp类型\" class=\"headerlink\" title=\"RegExp类型\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RegExp类型</a></h2><p>正则表达式： <code>var expression = / pattern / flags</code></p><p>正则表达式语法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_in_regular_expressions\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>flags为一个或多个标志，正则表达式的匹配模式支持下面三个标志：</p><ul><li>g——全局(global)模式，应用于所有字符串</li><li>i——不区分带小写(case-insensitive)模式</li><li>m——多行(multiiline)模式，到达一行文本末尾时还会继续查找喜爱航是否存在与模式匹配的项</li></ul><p>元字符：<code>()[]{}\\^$|?*+.</code>，元字符必须转义。</p><p>以下是一些例子：</p><pre><code class=\"javascript\">var pattern1 = /at/g;        // 匹配字符串中所有&quot;at&quot;实例\nvar pattern2 = /.at/gi;        // 匹配字符串中所有以&quot;at&quot;结尾的三个字符的实例，不区分大小写\nvar pattern3 = /\\.at/gi;    // 匹配字符串中所有&quot;.at&quot;实例，不区分大小写\nvar pattern4 = /[bc]at/i;    // 匹配字符串中第一个&quot;bat&quot;或&quot;cat&quot;实例，不区分大小写\nvar pattern5 = /\\[bc\\]at/i;    // 匹配字符串中第一个&quot;[bc]at&quot;实例，不区分大小写\n</code></pre><p>也可以使用构造函数来定义，例如下边两个式子得到的值是等价==相同的：</p><pre><code class=\"javascript\">var pattern1 = /[bc]at/i;\nvar pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);\n</code></pre><p>需要注意的是，构造函数的字符串中，元字符必须双重转义，比如<code>/\\./</code>双重转义为”\\\\.”</p><h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><ul><li>global——布尔值，表示是否设置了g标志</li><li>ignoreCase——布尔值，表示是否设置了i标志</li><li>multiline——布尔值，表示是否设置了m标志</li><li>lastIndex——整数，表示开始搜索下一个匹配项的字符位置，从0算起</li><li>source——正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li></ul><h3 id=\"RegExp实例方法\"><a href=\"#RegExp实例方法\" class=\"headerlink\" title=\"RegExp实例方法\"></a>RegExp实例方法</h3><p>关于exec()方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><p>关于test()方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p><h3 id=\"RegExp构造函数属性\"><a href=\"#RegExp构造函数属性\" class=\"headerlink\" title=\"RegExp构造函数属性\"></a>RegExp构造函数属性</h3><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input字符串中lastMatch之前的文本</td></tr><tr><td>rightContext</td><td>$’</td><td>input字符串中lastMatch之后的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，表示是否所有表达式都使用多行模式</td></tr></tbody></table><p>注：书中说Opera不支持input、lastMatch、lastParent、multiline，但查阅MDN文档显示的是支持的，因此待验证。</p><p>关于如何使用，以lastMatch为例：</p><pre><code class=\"javascript\">var re = /hi/g;\nre.test(&#39;hi there!&#39;);\nRegExp.lastMatch; // &quot;hi&quot;\nRegExp[&#39;$&amp;&#39;];     // &quot;hi&quot;\n</code></pre><p>另外对于书中提到的ECMAScript正则表达式不支持的特性，因为版本不断更新，比如现在已经支持Unicode，因此就不在这里列出来了。</p><h2 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h2><p>所有函数实际上都是Function类型的实例，且与其他引用数据类型一样具有属性和方法。</p><p><strong>“函数是对象，函数名是指针”。</strong></p><p>定义函数的方式：</p><pre><code class=\"javascript\">function sum1(num1, num2) {\n  return num1 + num2;\n}\n\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n\nvar sum3 = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;); // 不推荐\n</code></pre><h3 id=\"深入理解没有重载\"><a href=\"#深入理解没有重载\" class=\"headerlink\" title=\"深入理解没有重载\"></a>深入理解没有重载</h3><p>将函数名想象为指针，当用同一个函数名重新声明一个函数实际上相当于改变了指针的指向。</p><p>指针只能指向一个对象。</p><h3 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h3><pre><code class=\"javascript\">// 函数声明\nfunction sum1(num1, num2) {\n  return num1 + num2;\n}\n// 函数表达式\nvar sum2 = function(num1, num2) {\n  return num1 + num2;\n};\n</code></pre><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用，</p><p>但是对于函数表达式，必须等到解析器执行到它所在的代码行才会真正被解释执行。</p><p>可以同时使用函数声明和函数表达式<code>var sum1 = function sum2() {}</code>，但会在Safari中导致错误。</p><h3 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h3><p>函数名本身就是变量，因此可以把函数当做参数传递，<a href=\"https://blog.csdn.net/lingfeng2008w/article/details/50598431\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>有人总结了当做参数传递的用法。</p><h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><p>在函数内部有两个特殊的对象：arguments和this。</p><p><strong>arguments</strong>还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，有什么用呢？可以看阶乘函数这个例子：</p><pre><code class=\"javascript\">function factorial(num) {\n  if (num &lt;= 1) {\n    return 1;\n  } else {\n    return num * factorial(num-1);\n  }\n}\n</code></pre><p>像这样递归，我们在修改函数名、拷贝函数后修改原函数内容后都会遇到麻烦，因此就要用到callee属性了：</p><pre><code class=\"javascript\">function factorial(num) {\n  if (num &lt;= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num-1); // 使用callee属性\n  }\n}\n\nvar trueFactorial = factorial;  // 拷贝函数\nfactorial = function() {  // 修改原函数定义\n  return 0;\n};\n\nalert(factorial(5));  // 0\nalert(trueFactorial(5));// 120\n</code></pre><p><strong>this</strong>是函数在执行时所处的作用域（挡在网页的全局作用域调用函数时，this对象引用的就是window），可以看下边这个例子：</p><pre><code class=\"javascript\">function sayColor() {\n  alert(this.color);\n}\n\nwindow.color = &#39;red&#39;;\nvar b = {color: &#39;blue&#39;};\nb.sayColor = sayColor;\n\nsayColor();   //&#39;red&#39;\nb.sayColor(); //&#39;blue&#39;\n</code></pre><h3 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h3><p>每个函数都包含两个属性：length和prototype。</p><ul><li>length：函数希望接收的命名参数的个数</li><li>prototype：可以看我<a href=\"https://blog.zmj97.top/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</li></ul><p>每个函数都包含两个非继承而来的方法：apply()和call()。</p><p>这两个的用途都是给函数<strong>指定函数体内this的值</strong>。</p><blockquote><p><code>apply</code> 与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>call()</code></a> 非常相似，不同之处在于提供参数的方式。</p><p><code>apply</code> 使用参数数组而不是一组参数列表。<code>apply</code> 可以使用数组字面量（array literal），如 <code>fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])</code>，或数组对象， 如 <code>fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))</code>。</p><p>而 <code>call</code>的语法为<code>fun.call(thisArg, arg1, arg2, ...)</code>。</p><p>需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<a href=\"https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">非严格模式下</a>，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动<a href=\"https://www.cnblogs.com/moqing/p/5593986.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">包装对象</a>。</p></blockquote><p>每个函数都一个非标准的caller属性，指向调用该函数的函数，</p><p>因此一般在一个函数的内部，通过<code>arguments.callee.caller</code>来实现对调用栈的追溯，</p><p>但只建议将该属性用于调试目的。</p><h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>先看<a href=\"https://www.cnblogs.com/moqing/p/5593986.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这篇文章</a></p><h3 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h3><ul><li>基本类型的布尔值： <code>var a = false</code></li><li>引用类型的布尔值： <code>var b = new Boolean(false)</code></li></ul><p>除了包装对象的问题，两个还有两个区别：</p><ul><li>typeof 的结果一个是”boolean”一个是”object”</li><li>instanceof测试是否为Boolean对象一个是false，一个是true</li></ul><p><strong>建议永远不要使用Boolean对象。</strong></p><h3 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h3><p>重写了valueOf()、toLocaleString()和toString()方法。</p><ul><li><p>valueOf()返回对象表示的基本类型的数值。</p></li><li><p>可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p></li><li><p>toFixed()方法会按照指定的小数位返回数值的字符串表示（四舍五入）：<code>var num = 10;num.toFixed(2)</code>结果为“10.00”</p></li><li>toExponential()按照指定的小数位数返回数值的指数表示的字符串：<code>var num = 10;num.toExponential(2)</code>结果为“1.00e+1”</li><li>toPrecision()接受一个参数作为表示数值所有数字的位数（不包括指数部分），然后返回最合适的表示格式的字符串。</li></ul><h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><h4 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h4><p>访问字符串中特定字符：<code>charAt()</code>、<code>charCodeAt()</code></p><pre><code class=\"javascript\">var s = &#39;hello world!&#39;;\ns.charAt(1);    // &quot;e&quot;, 返回字符\ns.charCodeAt(1);// &quot;101&quot;， 返回字符编码\ns[1];            // &quot;e&quot;\n</code></pre><h4 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h4><ul><li>concat() ： <em>string</em>.concat(<em>string1</em>, <em>string2</em>, …, <em>stringX</em>)， 连接字符串，不改变原字符串，返回连接后的字符串</li><li>slice()：<em>string</em>.slice(<em>start</em>,<em>end</em>)，提取字符串片断，start为要截取的片段的起始下标；end为要截取的片段的结尾下标加一，若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串，如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</li><li>substring()：类似于slice()</li><li>substr()：<em>string</em>.substr(<em>start</em>,<em>length</em>)， 提取字符片段，start为要截取的片段的起始下标；length为要截取的长度，那么返回从 sstart到结尾的字串。</li></ul><pre><code class=\"javascript\">var str1 = &quot;Hello &quot;;\nvar str2 = &quot;world!&quot;;\nstr1.concat(str2); // &quot;Hello world!&quot;\nstr.slice(1,5); // &quot;ello&quot;\nstr.substring(1,5); // &quot;ello&quot;\nstr.substr(2,3); // &quot;llo&quot;\n</code></pre><p>假设p为一个正确的坐标值，m为一个负值，则</p><ul><li>string.concat(p,m)x相当于string.concat(p)</li><li>string.substring(p,m)相当于string.substring(p,0)相当于string.substring(0,p)</li><li>string.substr(p,m)相当于string.substr(p,0)，返回空字符串</li></ul><h4 id=\"字符串位置方法\"><a href=\"#字符串位置方法\" class=\"headerlink\" title=\"字符串位置方法\"></a>字符串位置方法</h4><p><code>indexOf()</code>和<code>lastIndexOf()</code>，传入一个字符串，返回这个字符串在源字符串中第一次和最后一次出现的位置，若没有找到则返回-1。</p><p>还可以传入第二个参数表示开始查找的位置，<code>indexOf()</code>往后查找，<code>lastIndexOf()</code>往前查找。</p><h4 id=\"字符串大小写转换方法\"><a href=\"#字符串大小写转换方法\" class=\"headerlink\" title=\"字符串大小写转换方法\"></a>字符串大小写转换方法</h4><ul><li>toLowerCase()、toUpperCase()</li><li>toLocaleLowerCase()、toLocaleUpperCase()，针对地区应用不同的规则</li></ul><h4 id=\"字符串的模式匹配方法\"><a href=\"#字符串的模式匹配方法\" class=\"headerlink\" title=\"字符串的模式匹配方法\"></a>字符串的模式匹配方法</h4><ol><li><p><code>match()</code>，等价于调用RegExp对象的exec()方法。</p><p><code>match()</code>接受一个正则表达式或者一个RegExp对象作为参数，返回一个数组，数组第一项是与整个模式匹配的字符串，之后的每一项都是和捕获组匹配的字符串。</p></li><li><p><code>search()</code>与<code>match()</code>唯一不同的是返回的是第一个匹配项的索引。</p></li><li><p><code>replace()</code>添加了一个传入的参数，表示匹配到的字符串要替换成的字符串。如果要全部替换，要记得在正则表达式中指定全局标志(g)。第二个参数也可以是函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><p>替换字符串可以插入下面的特殊变量名：</p></li></ol><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td><code>$$</code></td><td>插入一个 “$”。</td></tr><tr><td><code>$&amp;</code></td><td>插入匹配的子串。</td></tr><tr><td>$`</td><td>插入当前匹配的子串左边的内容。</td></tr><tr><td><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容。</td></tr><tr><td><code>$*n*</code></td><td>假如第一个参数是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RegExp</code></a>对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。</td></tr></tbody></table><ol start=\"4\"><li><code>splite()</code>，基于指定的分隔符<code>separator</code>将一个字符串分割成多个子字符串，还可以指定第二个参数，一个整数，限定返回的分割片段数量。</li></ol><pre><code class=\"javascript\">&quot;Webkit Moz O ms Khtml&quot;.split( &quot; &quot; )   // [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;, &quot;ms&quot;, &quot;Khtml&quot;]\nvar myString = &quot;Hello World. How are you doing?&quot;;\nmyString.split(&quot; &quot;, 3); // [&quot;Hello&quot;, &quot;World.&quot;, &quot;How&quot;]\n</code></pre><p>如果 <code>separator</code> 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。</p><pre><code class=\"js\">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;\nvar splits = myString.split(/(\\d)/);    // \\d匹配数字\n\nconsole.log(splits); // [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]\n</code></pre><h4 id=\"localeCompare-方法\"><a href=\"#localeCompare-方法\" class=\"headerlink\" title=\"localeCompare()方法\"></a>localeCompare()方法</h4><p><code>referenceStr.localeCompare(compareString[, locales[, options]])</code></p><p>判断字符串参数compareString是否在字母表中排在字符串referenceStr之前，是的话返回正数，不是返回负数，相等返回0。</p><p>locales和options都是可选参数，还没有被所有浏览器支持，具体的含义可以查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">文档</a>。</p><p>下边是一个简单的例子：</p><pre><code class=\"js\">// &quot;c&quot; 在 &quot;a&quot; 之后， 返回负数\n&#39;a&#39;.localeCompare(&#39;c&#39;); \n// -2 或者 -1 (或者其他负数)\n\n// &quot;against&quot; 在 &quot;check&quot; 之前\n&#39;check&#39;.localeCompare(&#39;against&#39;); \n// 2 或者 1 (或者其他正数)\n\n// 相同\n&#39;a&#39;.localeCompare(&#39;a&#39;); \n// 0\n</code></pre><h4 id=\"fromCharCode-方法\"><a href=\"#fromCharCode-方法\" class=\"headerlink\" title=\"fromCharCode()方法\"></a>fromCharCode()方法</h4><p>String构造函数的的静态方法，接收一个或者多个字符编码，然后把它们转换成一个字符串。</p><pre><code class=\"js\">String.fromCharCode(104, 101, 108, 108, 111); // &quot;hello&quot;\n</code></pre><h4 id=\"HTML方法\"><a href=\"#HTML方法\" class=\"headerlink\" title=\"HTML方法\"></a>HTML方法</h4><p>该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用这些特性。因此不再列出。</p><h2 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h2><h3 id=\"全局-Global-对象\"><a href=\"#全局-Global-对象\" class=\"headerlink\" title=\"全局(Global)对象\"></a>全局(Global)对象</h3><p>在大多是ECMAScript实现中都不能直接访问Global对象，不过Web浏览器实现了承担该角色的window对象，因此在全局作用域中生命的所有变量核函数，就都成为了window对象的属性。</p><h4 id=\"全局函数\"><a href=\"#全局函数\" class=\"headerlink\" title=\"全局函数\"></a>全局函数</h4><p>所有在全局作用域定义的属性和方法都是Global对象的属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p><ul><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>eval()</code></a>：将传入的字符串当做 JavaScript 代码进行执行。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/uneval\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>uneval()</code></a> ：返回代表传入对象的源代码的字符串，该特性是非标准的，请尽量不要在生产环境中使用它！</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>isFinite()</code></a>：判定一个数字是否是有限数字。<code>isFinite</code> 方法检测它参数的数值。如果参数是 <code>NaN</code>，正无穷大或者负无穷大，会返回<code>false</code>，其他返回 <code>true</code>。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>isNaN()</code></a>：确定一个值是否为<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a> 。如果<code>isNaN</code>函数的参数不是<code>Number</code>类型， <code>isNaN</code>函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a>进行判断。ECMAScript (ES2015)包含<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Number.isNaN()</code></a>函数。通过<code>Number.isNaN(x)</code>来检测<code>变量x</code>是否是一个<code>NaN</code>将会是一种可靠的做法。然而，在缺少<code>Number.isNaN</code>函数的情况下, 通过表达式<code>(x != x)</code> 来检测<code>变量x</code>是否是<code>NaN</code>会更加可靠。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>parseFloat()</code></a>：解析一个字符串参数并返回一个浮点数。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>parseInt()</code></a>：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>NaN</code></a>。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>decodeURI()</code></a>：解码一个由<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI</code></a> 先前创建的统一资源标识符（URI）或类似的例程。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>decodeURIComponent()</code></a> : 解码由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent</code></a> 方法或者其它类似方法编码的部分统一资源标识符（URI）。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI()</code></a>：对统一资源标识符（URI）进行编码，将有效的URI不能包含的字符替换为特殊的UTF-8编码。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent()</code></a> ：对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>escape()</code></a> ，已废弃。生成新的由十六进制转义序列替换的字符串. 使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURI</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>encodeURIComponent</code></a> 代替。</li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>unescape()</code></a> ，已废弃。</li></ul><p><code>encodeURI</code> 会替换所有的字符，但不包括以下字符，即使它们具有适当的UTF-8转义序列：</p><table><thead><tr><th>类型</th><th>包含</th></tr></thead><tbody><tr><td>保留字符</td><td><code>;</code> <code>,</code> <code>/</code> <code>?</code> <code>:</code> <code>@</code> <code>&amp;</code> <code>=</code> <code>+</code> <code>$</code></td></tr><tr><td>非转义的字符</td><td>字母 数字 <code>-</code> <code>_</code> <code>.</code> <code>!</code> <code>~</code> <code>*</code> <code>&#39;</code> <code>(</code> <code>)</code></td></tr><tr><td>数字符号</td><td><code>#</code></td></tr></tbody></table><p>请注意，<code>encodeURI</code> 自身<em>无法</em>产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 “&amp;”, “+”, 和 “=” 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。</p><p>然而<code>encodeURIComponent</code> 转义除了字母、数字、<code>(</code>、<code>)</code>、<code>.</code>、<code>!</code>、<code>~</code>、<code>*</code>、<code>&#39;</code>、<code>-</code>和<code>_</code>之外的所有字符。</p><p>例子：</p><pre><code class=\"js\">// 解码一个西里尔字母（Cyrillic）URL\ndecodeURI(&quot;https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B&quot;);\n// &quot;https://developer.mozilla.org/ru/docs/JavaScript_шеллы&quot;\n\n// 解码一个西里尔字母的URL\ndecodeURIComponent(&quot;JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B&quot;);\n// &quot;JavaScript_шеллы&quot;\n\n// *****************************************************************\n\nvar fileName = &#39;my file(2).txt&#39;;\nvar header = &quot;Content-Disposition: attachment; filename*=UTF-8&#39;&#39;&quot; \n       + encodeRFC5987ValueChars(fileName);\n\nconsole.log(header); \n// 输出 &quot;Content-Disposition: attachment; filename*=UTF-8&#39;&#39;my%20file%282%29.txt&quot;\n\nfunction encodeRFC5987ValueChars (str) {\n  return encodeURIComponent(str).\n    // 注意，仅管 RFC3986 保留 &quot;!&quot;，但 RFC5987 并没有\n    // 所以我们并不需要过滤它\n    replace(/[&#39;()]/g, escape). // i.e., %27 %28 %29\n    replace(/\\*/g, &#39;%2A&#39;).\n      // 下面的并不是 RFC5987 中 URI 编码必须的\n      // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性\n      replace(/%(?:7C|60|5E)/g, unescape);\n}\n</code></pre><p>注： <a href=\"http://tools.ietf.org/html/rfc3986\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RFC 3986</a>，保留 !, ‘, (, ), 和 *</p><h4 id=\"Global对象的属性\"><a href=\"#Global对象的属性\" class=\"headerlink\" title=\"Global对象的属性\"></a>Global对象的属性</h4><p>特殊值如undefined等、所有原生引用类型的构造函数都是Global对象的属性。</p><p>除了这些还有：</p><ul><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Error</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>EvalError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/InternalError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>InternalError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RangeError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>ReferenceError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>SyntaxError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>TypeError</code></a></li><li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/URIError\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>URIError</code></a></li></ul><h3 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><strong>Math</strong></a> 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。</p><p><code>Math</code> 的所有属性和方法都是静态的：例如常数pi可以用 <code>Math.PI</code> 表示，用 <code>x</code> 作参数 Math.sin(x)调用sin函数。</p><h4 id=\"Math对象的属性\"><a href=\"#Math对象的属性\" class=\"headerlink\" title=\"Math对象的属性\"></a>Math对象的属性</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.E</code></a></p><p>欧拉常数，也是自然对数的底数, 约等于 2.718.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LN2</code></a></p><p>2的自然对数, 约等于0.693.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN10\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LN10</code></a></p><p>10的自然对数, 约等于 2.303.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG2E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LOG2E</code></a></p><p>以2为底E的对数, 约等于 1.443.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LOG10E\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.LOG10E</code></a></p><p>以10为底E的对数, 约等于 0.434.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/PI\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.PI</code></a></p><p>圆周率，一个圆的周长和直径之比，约等于 3.14159.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT1_2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.SQRT1_2</code></a></p><p>1/2的平方根, 约等于 0.707.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.SQRT2</code></a></p><p>2的平方根,约等于 1.414.</p><h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.max()</code></a></p><p>返回0个到多个数值中最大值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.min()</code></a></p><p>返回0个到多个数值中最小值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.ceil(x)</code></a></p><p>返回x向上取整后的值.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/floor\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.floor(x)</code></a></p><p>返回小于x的最大整数。</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.round(x)</code></a></p><p>返回四舍五入后的整数.</p><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/random\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>Math.random()</code></a></p><p>返回0到1之间的伪随机数.</p><p>所有方法看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math#Methods\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">这里</a>。</p>"},{"title":"JavaScript实现双向链表","toc":false,"date":"2018-10-07T02:11:36.000Z","_content":"\n\n\n![img](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3254661749,1008892734&fm=26&gp=0.jpg)\n\n\n\n- append(element): 添加元素到链表尾部\n- insert(position,element): 向双向链表中某个位置插入元素\n- removeAt(position): 移除双向链表中某个位置的元素\n\n<!-- more -->\n\n- getHead(): 获取双向链表的头部\n- getTail(): 获取双向链表的尾部\n- isEmpty(): 检查双向链表是否为空，为空则返回true\n- size(): 返回双向链表长度\n\n```js\n   function DoublyLinkedList() {\n    var Node = function (element) {\n        this.element = element;\n        this.next = null;\n        this.prev = null;\n    }\n\n    var length = 0;\n    var head = null;\n    var tail = null;\n    \n    this.append = function (element) {\n        var node = new Node(element);\n\n        if (head === null) {\n            head = node\n            tail = node\n        } else {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        }\n        length++;\n        return true;\n    }\n\n\n    /**\n     * 向双向链表中某个位置插入元素\n     * \n     * @param {any} position 要插入的位置\n     * @param {any} element 要插入的元素\n     * @returns 插入成功或失败\n     */\n    this.insert = function (position, element) {\n        var node = new Node(element),\n            current = head,\n            previous,\n            index = 0;\n\n        if (position < 0 && position > length) {\n            return false;\n        }\n\n        if (position === 0) {\n            node.next = head\n            head.prev = node\n            head = node\n        } else if (position === length) {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        } else {\n            while (index++ < position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = node;\n            node.prev = previous;\n            node.next = current;\n            current.prev = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 移除双向链表中某个位置的元素\n     * \n     * @param {any} position 要移除元素的位置\n     * @returns 移除成功，返回移除的元素\n     */\n    this.removeAt = function (position) {\n        var previous,\n            current = head,\n            index = 0;\n        if (position < 0 && position >= length) {\n            return false;\n        }\n\n        if (position === 0) {\n            head = current.next;\n            head.prev = null;\n        } else if(position === length - 1) {\n             current = tail;\n             tail = current.prev;\n             tail.next = null;\n        } else {\n            while (index++ < position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = current.next;\n            current.next.prev = previous;\n        }\n        length--;\n        return current.element;\n    }\n\n    this.getHead = function () {\n        return head.element;\n    }\n\n    this.isEmpty = function () {\n        return length === 0\n    }\n\n    this.getTail = function () {\n        return tail.element;\n    }\n\n    this.size = function () {\n        return length\n    }\n}\n```\n\n","source":"_posts/JavaScript实现双向链表.md","raw":"---\ntitle: JavaScript实现双向链表\ntoc: false\ndate: 2018-10-07 10:11:36\ncategories:\n- Web\ntags:\n- JavaScript\n- 双向链表\n---\n\n\n\n![img](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3254661749,1008892734&fm=26&gp=0.jpg)\n\n\n\n- append(element): 添加元素到链表尾部\n- insert(position,element): 向双向链表中某个位置插入元素\n- removeAt(position): 移除双向链表中某个位置的元素\n\n<!-- more -->\n\n- getHead(): 获取双向链表的头部\n- getTail(): 获取双向链表的尾部\n- isEmpty(): 检查双向链表是否为空，为空则返回true\n- size(): 返回双向链表长度\n\n```js\n   function DoublyLinkedList() {\n    var Node = function (element) {\n        this.element = element;\n        this.next = null;\n        this.prev = null;\n    }\n\n    var length = 0;\n    var head = null;\n    var tail = null;\n    \n    this.append = function (element) {\n        var node = new Node(element);\n\n        if (head === null) {\n            head = node\n            tail = node\n        } else {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        }\n        length++;\n        return true;\n    }\n\n\n    /**\n     * 向双向链表中某个位置插入元素\n     * \n     * @param {any} position 要插入的位置\n     * @param {any} element 要插入的元素\n     * @returns 插入成功或失败\n     */\n    this.insert = function (position, element) {\n        var node = new Node(element),\n            current = head,\n            previous,\n            index = 0;\n\n        if (position < 0 && position > length) {\n            return false;\n        }\n\n        if (position === 0) {\n            node.next = head\n            head.prev = node\n            head = node\n        } else if (position === length) {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        } else {\n            while (index++ < position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = node;\n            node.prev = previous;\n            node.next = current;\n            current.prev = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 移除双向链表中某个位置的元素\n     * \n     * @param {any} position 要移除元素的位置\n     * @returns 移除成功，返回移除的元素\n     */\n    this.removeAt = function (position) {\n        var previous,\n            current = head,\n            index = 0;\n        if (position < 0 && position >= length) {\n            return false;\n        }\n\n        if (position === 0) {\n            head = current.next;\n            head.prev = null;\n        } else if(position === length - 1) {\n             current = tail;\n             tail = current.prev;\n             tail.next = null;\n        } else {\n            while (index++ < position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = current.next;\n            current.next.prev = previous;\n        }\n        length--;\n        return current.element;\n    }\n\n    this.getHead = function () {\n        return head.element;\n    }\n\n    this.isEmpty = function () {\n        return length === 0\n    }\n\n    this.getTail = function () {\n        return tail.element;\n    }\n\n    this.size = function () {\n        return length\n    }\n}\n```\n\n","slug":"JavaScript实现双向链表","published":1,"updated":"2018-10-10T08:38:56.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vi000nfmaguq3im2ie","content":"<p><img src=\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3254661749,1008892734&amp;fm=26&amp;gp=0.jpg\" alt=\"img\"></p><ul><li>append(element): 添加元素到链表尾部</li><li>insert(position,element): 向双向链表中某个位置插入元素</li><li>removeAt(position): 移除双向链表中某个位置的元素</li></ul><a id=\"more\"></a><ul><li>getHead(): 获取双向链表的头部</li><li>getTail(): 获取双向链表的尾部</li><li>isEmpty(): 检查双向链表是否为空，为空则返回true</li><li>size(): 返回双向链表长度</li></ul><pre class=\" language-js\"><code class=\"language-js\">   <span class=\"token keyword\">function</span> <span class=\"token function\">DoublyLinkedList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> Node <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>element <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">var</span> length <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> tail <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>append <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            head <span class=\"token operator\">=</span> node\n            tail <span class=\"token operator\">=</span> node\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n            tail <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        length<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 向双向链表中某个位置插入元素\n     * \n     * @param {any} position 要插入的位置\n     * @param {any} element 要插入的元素\n     * @returns 插入成功或失败\n     */</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>insert <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            current <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span>\n            previous<span class=\"token punctuation\">,</span>\n            index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>position <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> position <span class=\"token operator\">></span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>position <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head\n            head<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> node\n            head <span class=\"token operator\">=</span> node\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>position <span class=\"token operator\">===</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n            tail <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index<span class=\"token operator\">++</span> <span class=\"token operator\">&lt;</span> position<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                previous <span class=\"token operator\">=</span> current\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            previous<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> previous<span class=\"token punctuation\">;</span>\n            node<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n            current<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        length<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 移除双向链表中某个位置的元素\n     * \n     * @param {any} position 要移除元素的位置\n     * @returns 移除成功，返回移除的元素\n     */</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>removeAt <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> previous<span class=\"token punctuation\">,</span>\n            current <span class=\"token operator\">=</span> head<span class=\"token punctuation\">,</span>\n            index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>position <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> position <span class=\"token operator\">>=</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>position <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            head <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            head<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>position <span class=\"token operator\">===</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             current <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n             tail <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n             tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index<span class=\"token operator\">++</span> <span class=\"token operator\">&lt;</span> position<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                previous <span class=\"token operator\">=</span> current\n                current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            previous<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            current<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> previous<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        length<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> current<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getHead <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>isEmpty <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> length <span class=\"token operator\">===</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getTail <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> tail<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> length\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>","site":{"data":{}},"excerpt":"<p><img src=\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3254661749,1008892734&amp;fm=26&amp;gp=0.jpg\" alt=\"img\"></p><ul><li>append(element): 添加元素到链表尾部</li><li>insert(position,element): 向双向链表中某个位置插入元素</li><li>removeAt(position): 移除双向链表中某个位置的元素</li></ul>","more":"<ul><li>getHead(): 获取双向链表的头部</li><li>getTail(): 获取双向链表的尾部</li><li>isEmpty(): 检查双向链表是否为空，为空则返回true</li><li>size(): 返回双向链表长度</li></ul><pre><code class=\"js\">   function DoublyLinkedList() {\n    var Node = function (element) {\n        this.element = element;\n        this.next = null;\n        this.prev = null;\n    }\n\n    var length = 0;\n    var head = null;\n    var tail = null;\n\n    this.append = function (element) {\n        var node = new Node(element);\n\n        if (head === null) {\n            head = node\n            tail = node\n        } else {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        }\n        length++;\n        return true;\n    }\n\n\n    /**\n     * 向双向链表中某个位置插入元素\n     * \n     * @param {any} position 要插入的位置\n     * @param {any} element 要插入的元素\n     * @returns 插入成功或失败\n     */\n    this.insert = function (position, element) {\n        var node = new Node(element),\n            current = head,\n            previous,\n            index = 0;\n\n        if (position &lt; 0 &amp;&amp; position &gt; length) {\n            return false;\n        }\n\n        if (position === 0) {\n            node.next = head\n            head.prev = node\n            head = node\n        } else if (position === length) {\n            tail.next = node;\n            node.prev = tail;\n            tail = node;\n        } else {\n            while (index++ &lt; position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = node;\n            node.prev = previous;\n            node.next = current;\n            current.prev = node;\n        }\n        length++;\n        return true;\n    }\n\n    /**\n     * 移除双向链表中某个位置的元素\n     * \n     * @param {any} position 要移除元素的位置\n     * @returns 移除成功，返回移除的元素\n     */\n    this.removeAt = function (position) {\n        var previous,\n            current = head,\n            index = 0;\n        if (position &lt; 0 &amp;&amp; position &gt;= length) {\n            return false;\n        }\n\n        if (position === 0) {\n            head = current.next;\n            head.prev = null;\n        } else if(position === length - 1) {\n             current = tail;\n             tail = current.prev;\n             tail.next = null;\n        } else {\n            while (index++ &lt; position) {\n                previous = current\n                current = current.next;\n            }\n            previous.next = current.next;\n            current.next.prev = previous;\n        }\n        length--;\n        return current.element;\n    }\n\n    this.getHead = function () {\n        return head.element;\n    }\n\n    this.isEmpty = function () {\n        return length === 0\n    }\n\n    this.getTail = function () {\n        return tail.element;\n    }\n\n    this.size = function () {\n        return length\n    }\n}\n</code></pre>"},{"title":"TensorFlow基础知识","date":"2018-03-31T06:13:12.000Z","_content":"\n\n\n**TensorFlow**是一个采用**数据流图（data flow graphs）**，用于数值计算的开源软件库。\n\n<!-- more -->\n\n下图就是一个**数据流图**。数据流图是一个用来描述数学计算的由**“结点”（nodes）和“线”(edges)**组成的**有向图**。\n\n**“节点”** 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点或者是输出（push out）的终点，以及读取/写入持久变量（persistent variable）的终点。\n\n**“线”**表示“节点”之间的输入/输出关系。这些数据“线”可以输运**“张量”（tensor）**，即大小可动态调整的多维数据数组。\n\n一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。\n\n![Tensors Flowing](http://www.tensorfly.cn/images/tensors_flowing.gif)\n\n# 开始学习\n\n[官方基础知识链接](http://www.tensorfly.cn/tfdoc/get_started/basic_usage.html)\n\n- 使用图 (graph) 来表示计算任务.\n- 在被称之为 `会话 (Session)` 的上下文 (context) 中执行图.\n- 使用 tensor 表示数据.\n- 通过 `变量 (Variable)` 维护状态.\n- 使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据.\n- 图中的节点被称之为 *op* (operation 的缩写). 一个 op 获得 0 个或多个 `Tensor`, 执行计算,\n  产生 0 个或多个 `Tensor`. 每个 Tensor 是一个类型化的多维数组.\n\n## 构建图（创造节点）\n\n```python\nimport tensorflow as tf\n\n# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点\n# 加到默认图中.\n#\n# 构造器的返回值代表该常量 op 的返回值.\nmatrix1 = tf.constant([[3., 3.]])\n\n# 创建另外一个常量 op, 产生一个 2x1 矩阵.\nmatrix2 = tf.constant([[2.],[2.]])\n\n# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.\n# 返回值 'product' 代表矩阵乘法的结果.\nproduct = tf.matmul(matrix1, matrix2)\n```\n\n## 启动图\n\n```python\n# 启动默认图.\nsess = tf.Session()\n\n# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数. \n# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回\n# 矩阵乘法 op 的输出.\n#\n# 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.\n# \n# 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.\n#\n# 返回值 'result' 是一个 numpy `ndarray` 对象.\nresult = sess.run(product)\nprint result\n# ==> [[ 12.]]\n\n# 任务完成, 关闭会话.\nsess.close()\n```\n\n也可以：\n\n```python\nwith tf.Session() as sess:\n  result = sess.run([product])\n  print result\n```\n\n## Tensor\n\nTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor.\n可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和\n一个 shape. \n\n## 变量\n\n变量维护图执行过程中的状态信息。\n\n启动图后, 变量必须先经过`初始化` (init) op 初始化,\n\n必须增加一个`初始化` op 到图中：`init_op = tf.initialize_all_variables()`\n\n启动图后首先运行 'init' op：`sess.run(init_op)`\n\n## Fetch\n\n为了取回操作的输出内容, 可以在使用 `Session` 对象的 `run()` 调用 执行图时, 传入一些 tensor来取回结果。\n\n## Feed\n\nTensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor,可以对图中任何操作提交补丁, 直接插入一个 tensor。\n\n最常见的用例是将某些特殊的操作指定为 \"feed\" 操作,标记的方法是使用 tf.placeholder() 为这些操作创建占位符. \n\n```python\ninput1 = tf.placeholder(tf.types.float32)\ninput2 = tf.placeholder(tf.types.float32)\noutput = tf.mul(input1, input2)\n\nwith tf.Session() as sess:\n  print sess.run([output], feed_dict={input1:[7.], input2:[2.]})\n```\n\n","source":"_posts/TensorFlow基础知识.md","raw":"---\ntitle: TensorFlow基础知识\ndate: 2018-03-31 14:13:12\ncategories: \n- deep learning\ntags:\n- TensorFlow\n---\n\n\n\n**TensorFlow**是一个采用**数据流图（data flow graphs）**，用于数值计算的开源软件库。\n\n<!-- more -->\n\n下图就是一个**数据流图**。数据流图是一个用来描述数学计算的由**“结点”（nodes）和“线”(edges)**组成的**有向图**。\n\n**“节点”** 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点或者是输出（push out）的终点，以及读取/写入持久变量（persistent variable）的终点。\n\n**“线”**表示“节点”之间的输入/输出关系。这些数据“线”可以输运**“张量”（tensor）**，即大小可动态调整的多维数据数组。\n\n一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。\n\n![Tensors Flowing](http://www.tensorfly.cn/images/tensors_flowing.gif)\n\n# 开始学习\n\n[官方基础知识链接](http://www.tensorfly.cn/tfdoc/get_started/basic_usage.html)\n\n- 使用图 (graph) 来表示计算任务.\n- 在被称之为 `会话 (Session)` 的上下文 (context) 中执行图.\n- 使用 tensor 表示数据.\n- 通过 `变量 (Variable)` 维护状态.\n- 使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据.\n- 图中的节点被称之为 *op* (operation 的缩写). 一个 op 获得 0 个或多个 `Tensor`, 执行计算,\n  产生 0 个或多个 `Tensor`. 每个 Tensor 是一个类型化的多维数组.\n\n## 构建图（创造节点）\n\n```python\nimport tensorflow as tf\n\n# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点\n# 加到默认图中.\n#\n# 构造器的返回值代表该常量 op 的返回值.\nmatrix1 = tf.constant([[3., 3.]])\n\n# 创建另外一个常量 op, 产生一个 2x1 矩阵.\nmatrix2 = tf.constant([[2.],[2.]])\n\n# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.\n# 返回值 'product' 代表矩阵乘法的结果.\nproduct = tf.matmul(matrix1, matrix2)\n```\n\n## 启动图\n\n```python\n# 启动默认图.\nsess = tf.Session()\n\n# 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数. \n# 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回\n# 矩阵乘法 op 的输出.\n#\n# 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.\n# \n# 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.\n#\n# 返回值 'result' 是一个 numpy `ndarray` 对象.\nresult = sess.run(product)\nprint result\n# ==> [[ 12.]]\n\n# 任务完成, 关闭会话.\nsess.close()\n```\n\n也可以：\n\n```python\nwith tf.Session() as sess:\n  result = sess.run([product])\n  print result\n```\n\n## Tensor\n\nTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor.\n可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和\n一个 shape. \n\n## 变量\n\n变量维护图执行过程中的状态信息。\n\n启动图后, 变量必须先经过`初始化` (init) op 初始化,\n\n必须增加一个`初始化` op 到图中：`init_op = tf.initialize_all_variables()`\n\n启动图后首先运行 'init' op：`sess.run(init_op)`\n\n## Fetch\n\n为了取回操作的输出内容, 可以在使用 `Session` 对象的 `run()` 调用 执行图时, 传入一些 tensor来取回结果。\n\n## Feed\n\nTensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor,可以对图中任何操作提交补丁, 直接插入一个 tensor。\n\n最常见的用例是将某些特殊的操作指定为 \"feed\" 操作,标记的方法是使用 tf.placeholder() 为这些操作创建占位符. \n\n```python\ninput1 = tf.placeholder(tf.types.float32)\ninput2 = tf.placeholder(tf.types.float32)\noutput = tf.mul(input1, input2)\n\nwith tf.Session() as sess:\n  print sess.run([output], feed_dict={input1:[7.], input2:[2.]})\n```\n\n","slug":"TensorFlow基础知识","published":1,"updated":"2018-10-10T08:39:28.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vk000pfmagjayrsdy0","content":"<p><strong>TensorFlow</strong>是一个采用<strong>数据流图（data flow graphs）</strong>，用于数值计算的开源软件库。</p><a id=\"more\"></a><p>下图就是一个<strong>数据流图</strong>。数据流图是一个用来描述数学计算的由<strong>“结点”（nodes）和“线”(edges)</strong>组成的<strong>有向图</strong>。</p><p><strong>“节点”</strong> 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点或者是输出（push out）的终点，以及读取/写入持久变量（persistent variable）的终点。</p><p><strong>“线”</strong>表示“节点”之间的输入/输出关系。这些数据“线”可以输运<strong>“张量”（tensor）</strong>，即大小可动态调整的多维数据数组。</p><p>一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p><p><img src=\"http://www.tensorfly.cn/images/tensors_flowing.gif\" alt=\"Tensors Flowing\"></p><h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><p><a href=\"http://www.tensorfly.cn/tfdoc/get_started/basic_usage.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方基础知识链接</a></p><ul><li>使用图 (graph) 来表示计算任务.</li><li>在被称之为 <code>会话 (Session)</code> 的上下文 (context) 中执行图.</li><li>使用 tensor 表示数据.</li><li>通过 <code>变量 (Variable)</code> 维护状态.</li><li>使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据.</li><li>图中的节点被称之为 <em>op</em> (operation 的缩写). 一个 op 获得 0 个或多个 <code>Tensor</code>, 执行计算,<br>产生 0 个或多个 <code>Tensor</code>. 每个 Tensor 是一个类型化的多维数组.</li></ul><h2 id=\"构建图（创造节点）\"><a href=\"#构建图（创造节点）\" class=\"headerlink\" title=\"构建图（创造节点）\"></a>构建图（创造节点）</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> tensorflow <span class=\"token keyword\">as</span> tf\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点</span>\n<span class=\"token comment\" spellcheck=\"true\"># 加到默认图中.</span>\n<span class=\"token comment\" spellcheck=\"true\">#</span>\n<span class=\"token comment\" spellcheck=\"true\"># 构造器的返回值代表该常量 op 的返回值.</span>\nmatrix1 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>constant<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建另外一个常量 op, 产生一个 2x1 矩阵.</span>\nmatrix2 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>constant<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.</span>\n<span class=\"token comment\" spellcheck=\"true\"># 返回值 'product' 代表矩阵乘法的结果.</span>\nproduct <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>matmul<span class=\"token punctuation\">(</span>matrix1<span class=\"token punctuation\">,</span> matrix2<span class=\"token punctuation\">)</span>\n</code></pre><h2 id=\"启动图\"><a href=\"#启动图\" class=\"headerlink\" title=\"启动图\"></a>启动图</h2><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 启动默认图.</span>\nsess <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>Session<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数. </span>\n<span class=\"token comment\" spellcheck=\"true\"># 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回</span>\n<span class=\"token comment\" spellcheck=\"true\"># 矩阵乘法 op 的输出.</span>\n<span class=\"token comment\" spellcheck=\"true\">#</span>\n<span class=\"token comment\" spellcheck=\"true\"># 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.</span>\n<span class=\"token comment\" spellcheck=\"true\"># </span>\n<span class=\"token comment\" spellcheck=\"true\"># 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.</span>\n<span class=\"token comment\" spellcheck=\"true\">#</span>\n<span class=\"token comment\" spellcheck=\"true\"># 返回值 'result' 是一个 numpy `ndarray` 对象.</span>\nresult <span class=\"token operator\">=</span> sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span> result\n<span class=\"token comment\" spellcheck=\"true\"># ==> [[ 12.]]</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 任务完成, 关闭会话.</span>\nsess<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre><p>也可以：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>Session<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> sess<span class=\"token punctuation\">:</span>\n  result <span class=\"token operator\">=</span> sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>product<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">print</span> result\n</code></pre><h2 id=\"Tensor\"><a href=\"#Tensor\" class=\"headerlink\" title=\"Tensor\"></a>Tensor</h2><p>TensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor.<br>可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和<br>一个 shape.</p><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量维护图执行过程中的状态信息。</p><p>启动图后, 变量必须先经过<code>初始化</code> (init) op 初始化,</p><p>必须增加一个<code>初始化</code> op 到图中：<code>init_op = tf.initialize_all_variables()</code></p><p>启动图后首先运行 ‘init’ op：<code>sess.run(init_op)</code></p><h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>为了取回操作的输出内容, 可以在使用 <code>Session</code> 对象的 <code>run()</code> 调用 执行图时, 传入一些 tensor来取回结果。</p><h2 id=\"Feed\"><a href=\"#Feed\" class=\"headerlink\" title=\"Feed\"></a>Feed</h2><p>TensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor,可以对图中任何操作提交补丁, 直接插入一个 tensor。</p><p>最常见的用例是将某些特殊的操作指定为 “feed” 操作,标记的方法是使用 tf.placeholder() 为这些操作创建占位符.</p><pre class=\" language-python\"><code class=\"language-python\">input1 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>placeholder<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>types<span class=\"token punctuation\">.</span>float32<span class=\"token punctuation\">)</span>\ninput2 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>placeholder<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>types<span class=\"token punctuation\">.</span>float32<span class=\"token punctuation\">)</span>\noutput <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>mul<span class=\"token punctuation\">(</span>input1<span class=\"token punctuation\">,</span> input2<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>Session<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> sess<span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">print</span> sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>output<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>input1<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> input2<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>","site":{"data":{}},"excerpt":"<p><strong>TensorFlow</strong>是一个采用<strong>数据流图（data flow graphs）</strong>，用于数值计算的开源软件库。</p>","more":"<p>下图就是一个<strong>数据流图</strong>。数据流图是一个用来描述数学计算的由<strong>“结点”（nodes）和“线”(edges)</strong>组成的<strong>有向图</strong>。</p><p><strong>“节点”</strong> 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点或者是输出（push out）的终点，以及读取/写入持久变量（persistent variable）的终点。</p><p><strong>“线”</strong>表示“节点”之间的输入/输出关系。这些数据“线”可以输运<strong>“张量”（tensor）</strong>，即大小可动态调整的多维数据数组。</p><p>一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p><p><img src=\"http://www.tensorfly.cn/images/tensors_flowing.gif\" alt=\"Tensors Flowing\"></p><h1 id=\"开始学习\"><a href=\"#开始学习\" class=\"headerlink\" title=\"开始学习\"></a>开始学习</h1><p><a href=\"http://www.tensorfly.cn/tfdoc/get_started/basic_usage.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方基础知识链接</a></p><ul><li>使用图 (graph) 来表示计算任务.</li><li>在被称之为 <code>会话 (Session)</code> 的上下文 (context) 中执行图.</li><li>使用 tensor 表示数据.</li><li>通过 <code>变量 (Variable)</code> 维护状态.</li><li>使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据.</li><li>图中的节点被称之为 <em>op</em> (operation 的缩写). 一个 op 获得 0 个或多个 <code>Tensor</code>, 执行计算,<br>产生 0 个或多个 <code>Tensor</code>. 每个 Tensor 是一个类型化的多维数组.</li></ul><h2 id=\"构建图（创造节点）\"><a href=\"#构建图（创造节点）\" class=\"headerlink\" title=\"构建图（创造节点）\"></a>构建图（创造节点）</h2><pre><code class=\"python\">import tensorflow as tf\n\n# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点\n# 加到默认图中.\n#\n# 构造器的返回值代表该常量 op 的返回值.\nmatrix1 = tf.constant([[3., 3.]])\n\n# 创建另外一个常量 op, 产生一个 2x1 矩阵.\nmatrix2 = tf.constant([[2.],[2.]])\n\n# 创建一个矩阵乘法 matmul op , 把 &#39;matrix1&#39; 和 &#39;matrix2&#39; 作为输入.\n# 返回值 &#39;product&#39; 代表矩阵乘法的结果.\nproduct = tf.matmul(matrix1, matrix2)\n</code></pre><h2 id=\"启动图\"><a href=\"#启动图\" class=\"headerlink\" title=\"启动图\"></a>启动图</h2><pre><code class=\"python\"># 启动默认图.\nsess = tf.Session()\n\n# 调用 sess 的 &#39;run()&#39; 方法来执行矩阵乘法 op, 传入 &#39;product&#39; 作为该方法的参数. \n# 上面提到, &#39;product&#39; 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回\n# 矩阵乘法 op 的输出.\n#\n# 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.\n# \n# 函数调用 &#39;run(product)&#39; 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.\n#\n# 返回值 &#39;result&#39; 是一个 numpy `ndarray` 对象.\nresult = sess.run(product)\nprint result\n# ==&gt; [[ 12.]]\n\n# 任务完成, 关闭会话.\nsess.close()\n</code></pre><p>也可以：</p><pre><code class=\"python\">with tf.Session() as sess:\n  result = sess.run([product])\n  print result\n</code></pre><h2 id=\"Tensor\"><a href=\"#Tensor\" class=\"headerlink\" title=\"Tensor\"></a>Tensor</h2><p>TensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor.<br>可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和<br>一个 shape.</p><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量维护图执行过程中的状态信息。</p><p>启动图后, 变量必须先经过<code>初始化</code> (init) op 初始化,</p><p>必须增加一个<code>初始化</code> op 到图中：<code>init_op = tf.initialize_all_variables()</code></p><p>启动图后首先运行 ‘init’ op：<code>sess.run(init_op)</code></p><h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>为了取回操作的输出内容, 可以在使用 <code>Session</code> 对象的 <code>run()</code> 调用 执行图时, 传入一些 tensor来取回结果。</p><h2 id=\"Feed\"><a href=\"#Feed\" class=\"headerlink\" title=\"Feed\"></a>Feed</h2><p>TensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor,可以对图中任何操作提交补丁, 直接插入一个 tensor。</p><p>最常见的用例是将某些特殊的操作指定为 “feed” 操作,标记的方法是使用 tf.placeholder() 为这些操作创建占位符.</p><pre><code class=\"python\">input1 = tf.placeholder(tf.types.float32)\ninput2 = tf.placeholder(tf.types.float32)\noutput = tf.mul(input1, input2)\n\nwith tf.Session() as sess:\n  print sess.run([output], feed_dict={input1:[7.], input2:[2.]})\n</code></pre>"},{"title":"Promise与async/await","toc":true,"date":"2018-10-04T02:52:06.000Z","_content":"\n## Promise\n\n`Promise`对象代表一个异步操作，有三个状态：\n\n- `pending`进行中\n- `fulfilled`已成功\n- `rejected`已失败\n\n<!-- more -->\n\n`Promise`对象有两个特点：\n\n- <u>对象的状态不受外界影响</u>。只有异步操作的结果可以决定当前是哪一种状态。\n- <u>一旦状态改变，就不会再变</u>。只要状态发生改变（`pending`到`fulfilled`或`pending`到`rejected`），状态就凝固了，一直保持这个结果，这时就称为 `resolved`（已定型）。\n\n`Promise`的缺点：\n\n- 无法取消。一旦新建它就会立即执行，无法中途取消。\n- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。\n\n- 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n例子：\n\n```javascript\nconst getJSON = function(url) {\n  // Promise 新建后就会立即执行。\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        // resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\n/*\n * then方法可以接受两个回调函数作为参数。 \n * 第一个回调函数在Promise对象的状态变为resolved时调用。\n * 第二个回调函数在Promise对象的状态变为rejected时调用。\n * then方法是定义在原型对象Promise.prototype上的。\n */\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n## async/await\n\nasync放置在函数前，确保这个函数返回一个promise（返回的不是promise也会被包装成promise）。\n\nawait只能在async函数中工作。\n\npromise前面的await关键字能够使JavaScript等待，直到promise处理结束。\n\n```js\nasync function showAvatar() {\n    // read our JSON\n    let response = await fetch('/article/promise-chaining/user.json')\n    let user = await response.json()\n    \n    // read github user\n    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`)\n    let githubUser = await githubResponse.json()\n    \n    // 展示头像\n    let img = document.createElement('img')\n    img.src = githubUser.avatar_url\n    img.className = 'promise-avatar-example'\n    documenmt.body.append(img)\n    \n    // 等待3s\n    await new Promise((resolve, reject) => {\n        setTimeout(resolve, 3000)\n    })\n    \n    img.remove()\n    \n    return githubUser\n}\nshowAvatar()\n```\n\n","source":"_posts/Promise与async-await.md","raw":"---\ntitle: Promise与async/await\ntoc: true\ndate: 2018-10-04 10:52:06\ncategories:\n- Web\ntags:\n- JavaScript\n- ES6\n---\n\n## Promise\n\n`Promise`对象代表一个异步操作，有三个状态：\n\n- `pending`进行中\n- `fulfilled`已成功\n- `rejected`已失败\n\n<!-- more -->\n\n`Promise`对象有两个特点：\n\n- <u>对象的状态不受外界影响</u>。只有异步操作的结果可以决定当前是哪一种状态。\n- <u>一旦状态改变，就不会再变</u>。只要状态发生改变（`pending`到`fulfilled`或`pending`到`rejected`），状态就凝固了，一直保持这个结果，这时就称为 `resolved`（已定型）。\n\n`Promise`的缺点：\n\n- 无法取消。一旦新建它就会立即执行，无法中途取消。\n- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。\n\n- 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n例子：\n\n```javascript\nconst getJSON = function(url) {\n  // Promise 新建后就会立即执行。\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        // resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\n/*\n * then方法可以接受两个回调函数作为参数。 \n * 第一个回调函数在Promise对象的状态变为resolved时调用。\n * 第二个回调函数在Promise对象的状态变为rejected时调用。\n * then方法是定义在原型对象Promise.prototype上的。\n */\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n## async/await\n\nasync放置在函数前，确保这个函数返回一个promise（返回的不是promise也会被包装成promise）。\n\nawait只能在async函数中工作。\n\npromise前面的await关键字能够使JavaScript等待，直到promise处理结束。\n\n```js\nasync function showAvatar() {\n    // read our JSON\n    let response = await fetch('/article/promise-chaining/user.json')\n    let user = await response.json()\n    \n    // read github user\n    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`)\n    let githubUser = await githubResponse.json()\n    \n    // 展示头像\n    let img = document.createElement('img')\n    img.src = githubUser.avatar_url\n    img.className = 'promise-avatar-example'\n    documenmt.body.append(img)\n    \n    // 等待3s\n    await new Promise((resolve, reject) => {\n        setTimeout(resolve, 3000)\n    })\n    \n    img.remove()\n    \n    return githubUser\n}\nshowAvatar()\n```\n\n","slug":"Promise与async-await","published":1,"updated":"2018-10-10T08:39:20.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vm000tfmag9vl96f1b","content":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p><code>Promise</code>对象代表一个异步操作，有三个状态：</p><ul><li><code>pending</code>进行中</li><li><code>fulfilled</code>已成功</li><li><code>rejected</code>已失败</li></ul><a id=\"more\"></a><p><code>Promise</code>对象有两个特点：</p><ul><li><u>对象的状态不受外界影响</u>。只有异步操作的结果可以决定当前是哪一种状态。</li><li><u>一旦状态改变，就不会再变</u>。只要状态发生改变（<code>pending</code>到<code>fulfilled</code>或<code>pending</code>到<code>rejected</code>），状态就凝固了，一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。</li></ul><p><code>Promise</code>的缺点：</p><ul><li>无法取消。一旦新建它就会立即执行，无法中途取消。</li><li><p>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</p></li><li><p>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li></ul><p>例子：</p><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> getJSON <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// Promise 新建后就会立即执行。</span>\n  <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> handler <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">!==</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statusText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> client <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">.</span>onreadystatechange <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">\"json\"</span><span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">.</span><span class=\"token function\">setRequestHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Accept\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"application/json\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    client<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> promise<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n * then方法可以接受两个回调函数作为参数。 \n * 第一个回调函数在Promise对象的状态变为resolved时调用。\n * 第二个回调函数在Promise对象的状态变为rejected时调用。\n * then方法是定义在原型对象Promise.prototype上的。\n */</span>\n<span class=\"token function\">getJSON</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/posts.json\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Contents: '</span> <span class=\"token operator\">+</span> json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'出错了'</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>async放置在函数前，确保这个函数返回一个promise（返回的不是promise也会被包装成promise）。</p><p>await只能在async函数中工作。</p><p>promise前面的await关键字能够使JavaScript等待，直到promise处理结束。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">showAvatar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// read our JSON</span>\n    <span class=\"token keyword\">let</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/article/promise-chaining/user.json'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">let</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// read github user</span>\n    <span class=\"token keyword\">let</span> githubResponse <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`https://api.github.com/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">let</span> githubUser <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> githubResponse<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 展示头像</span>\n    <span class=\"token keyword\">let</span> img <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'img'</span><span class=\"token punctuation\">)</span>\n    img<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> githubUser<span class=\"token punctuation\">.</span>avatar_url\n    img<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'promise-avatar-example'</span>\n    documenmt<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 等待3s</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    img<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> githubUser\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">showAvatar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p><code>Promise</code>对象代表一个异步操作，有三个状态：</p><ul><li><code>pending</code>进行中</li><li><code>fulfilled</code>已成功</li><li><code>rejected</code>已失败</li></ul>","more":"<p><code>Promise</code>对象有两个特点：</p><ul><li><u>对象的状态不受外界影响</u>。只有异步操作的结果可以决定当前是哪一种状态。</li><li><u>一旦状态改变，就不会再变</u>。只要状态发生改变（<code>pending</code>到<code>fulfilled</code>或<code>pending</code>到<code>rejected</code>），状态就凝固了，一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。</li></ul><p><code>Promise</code>的缺点：</p><ul><li>无法取消。一旦新建它就会立即执行，无法中途取消。</li><li><p>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</p></li><li><p>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li></ul><p>例子：</p><pre><code class=\"javascript\">const getJSON = function(url) {\n  // Promise 新建后就会立即执行。\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        // resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(&quot;GET&quot;, url);\n    client.onreadystatechange = handler;\n    client.responseType = &quot;json&quot;;\n    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);\n    client.send();\n\n  });\n\n  return promise;\n};\n\n/*\n * then方法可以接受两个回调函数作为参数。 \n * 第一个回调函数在Promise对象的状态变为resolved时调用。\n * 第二个回调函数在Promise对象的状态变为rejected时调用。\n * then方法是定义在原型对象Promise.prototype上的。\n */\ngetJSON(&quot;/posts.json&quot;).then(function(json) {\n  console.log(&#39;Contents: &#39; + json);\n}, function(error) {\n  console.error(&#39;出错了&#39;, error);\n});\n</code></pre><h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>async放置在函数前，确保这个函数返回一个promise（返回的不是promise也会被包装成promise）。</p><p>await只能在async函数中工作。</p><p>promise前面的await关键字能够使JavaScript等待，直到promise处理结束。</p><pre><code class=\"js\">async function showAvatar() {\n    // read our JSON\n    let response = await fetch(&#39;/article/promise-chaining/user.json&#39;)\n    let user = await response.json()\n\n    // read github user\n    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`)\n    let githubUser = await githubResponse.json()\n\n    // 展示头像\n    let img = document.createElement(&#39;img&#39;)\n    img.src = githubUser.avatar_url\n    img.className = &#39;promise-avatar-example&#39;\n    documenmt.body.append(img)\n\n    // 等待3s\n    await new Promise((resolve, reject) =&gt; {\n        setTimeout(resolve, 3000)\n    })\n\n    img.remove()\n\n    return githubUser\n}\nshowAvatar()\n</code></pre>"},{"title":"TensorFlow训练MNIST报错ResourceExhaustedError","date":"2018-04-01T04:35:44.000Z","_content":"\n\n\n在最后测试的一步报错：\n\n```shell\nResourceExhaustedError (see above for traceback): OOM when allocating tensor\n```\n\n搜索了一下才知道是GPU显存不足（emmmm....）造成的，可以把最后测试的那行代码改为将测试集分成几个小部分分别测试最后再求精度的平均值：\n\n<!-- more -->\n\n```python\naccuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\ngood = 0\ntotal = 0\nfor i in range(10):\n    testSet = mnist.test.next_batch(50)\n    good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n    total += testSet[0].shape[0]\nprint (\"test accuracy %g\"%(good/total))\n```\n\n","source":"_posts/TensorFlow训练MNIST报错ResourceExhaustedError.md","raw":"---\ntitle: TensorFlow训练MNIST报错ResourceExhaustedError\ndate: 2018-04-01 12:35:44\ncategories: \n- deep learning\ntags:\n- MNIST\n- TensorFlow\n---\n\n\n\n在最后测试的一步报错：\n\n```shell\nResourceExhaustedError (see above for traceback): OOM when allocating tensor\n```\n\n搜索了一下才知道是GPU显存不足（emmmm....）造成的，可以把最后测试的那行代码改为将测试集分成几个小部分分别测试最后再求精度的平均值：\n\n<!-- more -->\n\n```python\naccuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\ngood = 0\ntotal = 0\nfor i in range(10):\n    testSet = mnist.test.next_batch(50)\n    good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n    total += testSet[0].shape[0]\nprint (\"test accuracy %g\"%(good/total))\n```\n\n","slug":"TensorFlow训练MNIST报错ResourceExhaustedError","published":1,"updated":"2018-10-10T08:39:38.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vn000wfmagdgfgwkto","content":"<p>在最后测试的一步报错：</p><pre class=\" language-shell\"><code class=\"language-shell\">ResourceExhaustedError (see above for traceback): OOM when allocating tensor\n</code></pre><p>搜索了一下才知道是GPU显存不足（emmmm….）造成的，可以把最后测试的那行代码改为将测试集分成几个小部分分别测试最后再求精度的平均值：</p><a id=\"more\"></a><pre class=\" language-python\"><code class=\"language-python\">accuracy_sum <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>reduce_sum<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>cast<span class=\"token punctuation\">(</span>correct_prediction<span class=\"token punctuation\">,</span> tf<span class=\"token punctuation\">.</span>float32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ngood <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\ntotal <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    testSet <span class=\"token operator\">=</span> mnist<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">.</span>next_batch<span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n    good <span class=\"token operator\">+=</span> accuracy_sum<span class=\"token punctuation\">.</span>eval<span class=\"token punctuation\">(</span>feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y_<span class=\"token punctuation\">:</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">:</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    total <span class=\"token operator\">+=</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"test accuracy %g\"</span><span class=\"token operator\">%</span><span class=\"token punctuation\">(</span>good<span class=\"token operator\">/</span>total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>","site":{"data":{}},"excerpt":"<p>在最后测试的一步报错：</p><pre><code class=\"shell\">ResourceExhaustedError (see above for traceback): OOM when allocating tensor\n</code></pre><p>搜索了一下才知道是GPU显存不足（emmmm….）造成的，可以把最后测试的那行代码改为将测试集分成几个小部分分别测试最后再求精度的平均值：</p>","more":"<pre><code class=\"python\">accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\ngood = 0\ntotal = 0\nfor i in range(10):\n    testSet = mnist.test.next_batch(50)\n    good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n    total += testSet[0].shape[0]\nprint (&quot;test accuracy %g&quot;%(good/total))\n</code></pre>"},{"title":"PAT刷题记录","toc":true,"date":"2018-07-19T14:54:17.000Z","_content":"\n\n\nOJ：[牛客网](https://www.nowcoder.com/pat)\n\n<!-- more -->\n\n---\n\n\n\n## 1001 A+B Format (20)\n\n**题目描述**\n\n> Calculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000.  The numbers are separated by a space.\n\n**输出描述**\n\n> For each test case, you should output the sum of a and b in one line.  The sum must be written in the standard format.\n\n**输入例子**\n\n> -1000000 9\n\n**输出例子**\n\n> -999,991\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int digit[10];\n    for (int i = 0; i < 10; i++) digit[i] = -1;\n    int a,b,re;\n    cin >> a >> b;\n    re = a + b;\n    if (re < 0) {\n        cout<<'-';\n        re = -re;\n    }\n    int i = 0;\n    while(re) {\n        digit[i] = (re%10);\n        re/=10;\n        i++;\n    }\n    for (int k = i-1; k >=0; k--) {\n        cout<<digit[k];\n        if (k%3 == 0 && k>0) cout<<',';\n    }\n    return 0;\n}\n```\n\n\n\n## 1002 A+B for Polynomials (25)\n\n**题目描述**\n\n> This time, you are supposed to find A+B where A and B are two polynomials.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n> K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively.  It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\n**输出描述**\n\n> For each test case you should output the sum of A and B in one line, with the same format as the input.  Notice that there must be NO extra space at the end of each line.  **Please be accurate to 1 decimal place.**\n\n**输入例子**\n\n> 2 1 2.4 0 3.2\n> 2 2 1.5 1 0.5\n\n**输出例子**\n\n> 3 2 1.5 1 2.9 0 3.2\n\n**实现代码**\n\n注意保留小数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n\tint n;\n\tfloat value;\n\titem(int a, float b) {n=a,value=b;}\n};\n\nint main() {\n\tvector<item> polynomials;\n\tint k;\n\n\tcin>>k;\n\tint tmp_n;\n\tfloat tmp_value;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tpolynomials.push_back(item(tmp_n,tmp_value));\n\t}\n\n\tcin>>k;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tbool hasItem = false;\n\t\tfor (int i = 0; i < polynomials.size(); i++) {\n\t\t\tif (polynomials[i].n == tmp_n) {\n\t\t\t\thasItem = true;\n\t\t\t\tpolynomials[i].value+=tmp_value;\n\t\t\t\tif (polynomials[i].value == 0)\n\t\t\t\t\tpolynomials.erase(polynomials.begin()+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tif (!hasItem) polynomials.push_back(item(tmp_n,tmp_value));\t\n\t}\n\n\tfor (int k = 0; k < polynomials.size(); k++) {\n\t\tfor (int i = 0; i < polynomials.size()-1; i++) {\n\t\t\tif (polynomials[i].n < polynomials[i+1].n) {\n\t\t\t\titem tmp_item = polynomials[i];\n\t\t\t\tpolynomials[i] = polynomials[i+1];\n\t\t\t\tpolynomials[i+1] = tmp_item;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<polynomials.size();\n\tfor (int i = 0; i < polynomials.size(); i++)\n\t\tprintf(\" %d %.1f\", polynomials[i].n, polynomials[i].value);\n\n\treturn 0;\n}\n```\n\n\n\n## 1003 Emergency (25)\n\n**题目描述**\n\n> As an emergency rescue team leader of a city, you are given a special map of your country.  The map shows several scattered cities connected by some roads.  Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map.  When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.\n\n**输入描述**\n\n> Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (<= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively.  The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city.  Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively.  \n> It is guaranteed that there exists at least one path from C1 to C2.\n\n**输出描述**\n\n> For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.\n>\n> All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.\n\n**输入例子**\n\n> 5 6 0 2\n> 1 2 1 5 3\n> 0 1 1\n> 0 2 2\n> 0 3 1\n> 1 2 1\n> 2 4 1\n> 3 4 1\n\n**输出例子**\n\n> 2 4\n\n**实现代码**\n\ndijkstra最短路\n\n```c++\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nstruct road\n{\n\tint endCity;\n\tint length;\n\troad(int e, int l) {endCity = e, length = l;}\n};\n\n\nint main() {\n\tint n,m,c1,c2;\n\tcin>>n>>m>>c1>>c2;\n\tvector<int> teamsCount;\n\n\tint tmp1,tmp2,tmp3;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>tmp1;\n\t\tteamsCount.push_back(tmp1);\n\t}\n\n\tvector<vector<road> > roads(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin>>tmp1>>tmp2>>tmp3;\n\t\troads[tmp1].push_back(road(tmp2,tmp3));\n\t\troads[tmp2].push_back(road(tmp1,tmp3));\n\t}\n\n\tvector<int> maxTeams(n);\n\tfor (int i = 0; i < n; i++) maxTeams[i] = 0;\n\tmaxTeams[c1] = teamsCount[c1];\n\n\tvector<int> minLen(n);\n\tfor (int i = 0; i < n; i++) minLen[i] = INT_MAX;\n\tminLen[c1] = 0;\n\n\tint currentCity = c1;\n\tvector<int> minLenRoadCount(n);\n\tfor (int i = 0; i < n; i++) minLenRoadCount[i] = 1;\n\n\tvector<bool> visited(n);\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tvisited[c1] = true;\n\twhile (currentCity != c2) {\n\t\tint len = roads[currentCity].size();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (visited[roads[currentCity][i].endCity]) continue;\n\t\t\tint endCity = roads[currentCity][i].endCity;\n\t\t\tint length = roads[currentCity][i].length;\n\t\t\tif (minLen[endCity] > minLen[currentCity] + length) {\n\t\t\t\tminLen[endCity] = minLen[currentCity] + length;\n\t\t\t\tminLenRoadCount[endCity] = 1;\n\t\t\t\tmaxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n\t\t\t} else if (minLen[endCity] == minLen[currentCity] + length) {\n\t\t\t\tminLenRoadCount[endCity]++;\n\t\t\t\tif (maxTeams[endCity] < maxTeams[currentCity] + teamsCount[endCity])\n\t\t\t\t\tmaxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n\t\t\t}\n\t\t}\n\n\t\tint min = INT_MAX;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tif (minLen[i] < min) {\n\t\t\t\tmin = minLen[i];\n\t\t\t\tcurrentCity = i;\n\t\t\t}\n\t\t}\n\t\tvisited[currentCity] = true;\n\t}\n\n\tcout<<minLenRoadCount[c2]<<' '<<maxTeams[c2];\n\n\treturn 0;\n}\n```\n\n\n\n## 1004 Counting Leaves (30)\n\n**题目描述**\n\n> A family hierarchy is usually presented by a pedigree tree.  Your job is to count those family members who have no child.\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a line containing 0 < N < 100, the number of nodes in a tree, and M (< N), the number of non-leaf nodes.  Then M lines follow, each in the format:\n>\n> ID K ID[1] ID[2] ... ID[K]\n>\n> where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID's of its children.  For the sake of simplicity, let us fix the root ID to be 01.\n\n**输出描述**\n\n> For each test case, you are supposed to count those family members who have no child **for every seniority level** starting from the root.  The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.\n> The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child.  Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node.  Then we should output \"0 1\" in a line.\n\n**输入例子**\n\n> 2 1\n> 01 1 02\n\n**输出例子**\n\n> 0 1\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n#define MAX_NODES 100\n\nstruct node\n{\n\tint id = -1;\n\tint childs_count = 0;\n\tvector<int> childs;\n};\n\nint main() {\n\tint n,m;\n\tcin>>n>>m;\n\tnode nodes[MAX_NODES];\n\n\tint id,k,tmp;\n\twhile (m--) {\n\t\tcin>>id>>k;\n\t\tnodes[id].id = id;\n\t\tnodes[id].childs_count = k;\n\t\twhile (k--) {\n\t\t\tcin>>tmp;\n\t\t\t(nodes[id].childs).push_back(tmp);\n\t\t}\n\t}\n\n\tvector<int> this_level, next_level;\n\tthis_level.push_back(1);\n\twhile (1) {\n\t\tint count_output = 0;\n\t\tfor (int i = 0; i < this_level.size(); i++) {\n\t\t\tif (nodes[this_level[i]].childs_count == 0) count_output++;\n\t\t\telse next_level.insert(next_level.begin(),nodes[this_level[i]].childs.begin(),nodes[this_level[i]].childs.end());\n\t\t}\n\t\tcout<<count_output;\n\t\tif (next_level.empty()) break;\n\t\tcout<<' ';\n\t\tthis_level = next_level;\n\t\tnext_level.clear();\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1005 Spell It Right (20)\n\n**题目描述**\n\n> Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies one line which contains an N (<= 10^100).\n\n**输出描述**\n\n> For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\n**输入例子**\n\n> 12345\n\n**输出例子**\n\n> one five\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string n;\n    cin>>n;\n    int len = n.size();\n    int re = 0;\n    for (int i = 0; i < len; i++) re+=(n[i]-'0');\n    string english[10] = {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\n    int digit[100], re_len = 0;\n    while (re) {\n        digit[re_len] = (re%10);\n        re/=10;\n        re_len++;\n    }\n    for (int i = re_len-1; i >= 0; i--) {\n        cout<<english[digit[i]];\n        if (i != 0) cout<<' ';\n    }\n    return 0;\n}\n```\n\n\n\n## 1006 Sign In and Sign Out (25)\n\n**题目描述**\n\n> At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door.  Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n\n**输入描述**\n\n> Each input file contains one test case. Each case contains the records for one day.  The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n>\n> ID_number Sign_in_time Sign_out_time\n>\n> where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\n**输出描述**\n\n> For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day.  The two ID numbers must be separated by one space.\n> Note:  It is guaranteed that the records are consistent.  That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\n**输入例子**\n\n> 3\n> CS301111 15:30:28 17:00:10\n> SC3021234 08:00:00 11:25:25\n> CS301133 21:45:00 21:58:40\n\n**输出例子**\n\n> SC3021234 CS301133\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool a_larger_than_b(string a, string b) {\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] < b[i]) return false;\n        if (a[i] > b[i]) return true;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    string id,in,out;\n    string result_in_id, result_in_time, result_out_id, result_out_time;\n    cin>>id>>in>>out;\n    result_in_id = result_out_id = id;\n    result_in_time = in;\n    result_out_time = out;\n    n--;\n    while (n--) {\n        cin>>id>>in>>out;\n        if (a_larger_than_b(result_in_time,in)) {\n            result_in_id = id;\n            result_in_time = in;\n        }\n        if (a_larger_than_b(out,result_out_time)) {\n            result_out_id = id;\n            result_out_time = out;\n        }\n    }\n    cout<<result_in_id<<' '<<result_out_id;\n    return 0;\n}\n```\n\n\n\n## 1007 Maximum Subsequence Sum (25)\n\n**题目描述**\n\n> Given a sequence of K integers { N1\n> , N2\n> , ..., NK\n>  }.  A continuous subsequence is defined to be { Ni\n> , Ni+1\n> , ..., Nj\n>  } where 1 <= i <= j <= K.  The *Maximum Subsequence*\n>  is the continuous subsequence which has the largest sum of its\n> elements.  For example, given sequence { -2, 11, -4, 13, -5, -2 }, its\n> maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n>\n> Now you are supposed to find the largest sum, together with the first\n> and the last numbers of the maximum subsequence.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies two lines.  The first line contains a positive integer K (<= 10000).  The second line contains K numbers, separated by a space.\n\n**输出描述**\n\n> For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line.  In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case).  If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\n**输入例子**\n\n> 10\n> -10 1 2 3 4 -5 -23 3 7 -21\n\n**输出例子**\n\n> 10 1 4\n\n**实现代码**\n\n<u>和为负的子序列一定不会是最大和子序列的开头。</u>\n\n当当前和小于0时，使用临时\"first number\"记录下一个数，\n\n更新最大和时，当前数为“last number”， 临时“first number”中存储的值为“first number”的值。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint* nums = new int[n];\n\tbool allNegative = true;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>nums[i];\n\t\tif (nums[i] >= 0) allNegative = false;\n\t}\n\n\tif (allNegative) {\n\t\tcout<<0<<' '<<nums[0]<<' '<<nums[n-1];\n\t} else {\n\t\tint maxSum = 0, currentSum = 0;\n\t\tint firstNum = nums[0], lastNum = nums[0];\n\t\tint firstNumCurrent = firstNum;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcurrentSum+=nums[i];\n\t\t\tif (currentSum < 0) {\n\t\t\t\tcurrentSum = 0;\n\t\t\t\tfirstNumCurrent = nums[i+1];\n\t\t\t} else if (currentSum > maxSum) {\n\t\t\t\tmaxSum = currentSum;\n\t\t\t\tfirstNum = firstNumCurrent;\n\t\t\t\tlastNum = nums[i];\n\t\t\t}\n\t\t}\n\t\tcout<<maxSum<<' '<<firstNum<<' '<<lastNum;\n\t}\n\n\tdelete nums;\n\n\treturn 0;\n}\n```\n\n\n\n## 1008 Elevator (20)\n\n**题目描述**\n\n> The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n> For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\n**输入描述**\n\n> Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\n**输出描述**\n\n> For each test case, print the total time on a single line.\n\n**输入例子**\n\n> 3 2 3 1\n\n**输出例子**\n\n> 41\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 0, b, n, re = 0;\n    cin >> n;\n    while (n--) {\n        cin >> b;\n        if (b > a) {\n            re+=((b-a)*6);\n        } else {\n            re+=((a-b)*4);\n        }\n        re+=5;\n        a = b;\n    }\n    cout<<re;\n    return 0;\n}\n```\n\n\n\n## 1009 Product of Polynomials (25)\n\n**题目描述**\n\n> This time, you are supposed to find A*B where A and B are two polynomials.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n> K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively.  It is given that 1 <= K <= 10, 0 <= NK < ... < N2 < N1 <=1000.\n\n**输出描述**\n\n> For each test case you should output the product of A and B in one line, with the same format as the input.  Notice that there must be NO extra space at the end of each line.  Please be accurate up to 1 decimal place.\n\n**输入例子**\n\n> 2 1 2.4 0 3.2\n> 2 2 1.5 1 0.5\n\n**输出例子**\n\n> 3 3 3.6 2 6.0 1 1.6\n\n**实现代码**\n\n把[1002 A+B for Polynomials (25)](#1002-A-B-for-Polynomials-25)稍微改一下就好。\n\n使用`float`虽然算出来明明是对的但是过不了牛客的测试，全部换成`double`就好了，不知道是什么问题。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n\tint n;\n\tdouble value;\n\titem(int a, double b) {n=a,value=b;}\n};\n\nint main() {\n\tvector<item> polynomials, result;\n\tint k;\n\n\tcin>>k;\n\tint tmp_n;\n\tdouble tmp_value;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tpolynomials.push_back(item(tmp_n,tmp_value));\n\t}\n\n\tcin>>k;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tfor (int k = 0; k < polynomials.size(); k++) {\n\t\t\tbool hasItem = false;\n\t\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\t\tif (result[i].n == tmp_n+polynomials[k].n) {\n\t\t\t\t\thasItem = true;\n\t\t\t\t\tresult[i].value+=(tmp_value*polynomials[k].value);\n\t\t\t\t\tif (result[i].value == 0)\n\t\t\t\t\t\tresult.erase(result.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\tif (!hasItem) result.push_back(item(tmp_n+polynomials[k].n,tmp_value*polynomials[k].value));\n\t\t}\n\t}\n\n\tfor (int k = 0; k < result.size(); k++) {\n\t\tfor (int i = 0; i < result.size()-1; i++) {\n\t\t\tif (result[i].n < result[i+1].n) {\n\t\t\t\titem tmp_item = result[i];\n\t\t\t\tresult[i] = result[i+1];\n\t\t\t\tresult[i+1] = tmp_item;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<result.size();\n\tfor (int i = 0; i < result.size(); i++)\n\t\tprintf(\" %d %.1f\", result[i].n, result[i].value);\n\n\treturn 0;\n}\n```\n\n\n\n## 1015 Reversible Primes (20)\n\n**题目描述**\n\n> A *reversible prime*\n>  in any number system is a prime whose \"reverse\" in that\n> number system is also a prime. For example in the decimal system 73 is a\n> reversible prime because its reverse 37 is also a prime.\n>\n> \n>\n> Now given any two positive integers N (< 105\n> ) and D (1 < D <= 10), you are supposed to tell if N is a\n> reversible prime with radix D.\n\n**输入描述**\n\n> The input file consists of several test cases.  Each case occupies a line which contains two integers N and D.  The input is finished by a negative N.\n\n**输出描述**\n\n> For each test case, print in one line \"Yes\" if N is a reversible prime with radix D, or \"No\" if not.\n\n**输入例子**\n\n> 73 10\n> 23 2\n> 23 10\n> -2\n\n**输出例子**\n\n> Yes\n> Yes\n> No\n\n**实现代码**\n\n求N以及N在D进制下反转后是否均为质数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint reverseWithRadix(int n, int d) {\n\tvector<int> remainers;\n\twhile (n > 0) {\n\t\tremainers.push_back(n%d);\n\t\tn/=d;\n\t}\n\tint re = 0;\n\tint bit_count = remainers.size();\n\tfor (int i = 0; i < bit_count; i++)\n\t\tre+=(pow(d,bit_count-i-1)*remainers[i]);\n\treturn re;\n}\n\nbool isPrime(int n) {\n\tif (n == 1) return false;\n\tif (n < 4) return true;\n\tif (n % 2 == 0) return false;\n\tint sqrt_n = sqrt(n) + 1;\n\tfor (int i = 3; i <= sqrt_n; i+=2) {\n\t\tif (n % i == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n,d;\n\twhile (1) {\n\t\tcin>>n;\n\t\tif (n < 0) break;\n\t\tcin>>d;\n\t\tif (isPrime(n) && isPrime(reverseWithRadix(n,d))) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n## 1020 Tree Traversals (25)\n\n**题目描述**\n\n> Suppose that all the keys in a binary tree are distinct positive integers.  Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line gives a positive integer N (<=30), the total number of nodes in the binary tree.  The second line gives the **postorder** sequence and the third line gives the **inorder** sequence.  All the numbers in a line are separated by a space.\n\n**输出描述**\n\n> For each test case, print in one line the level order traversal sequence of the corresponding binary tree.  All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> 7\n> 2 3 1 5 7 6 4\n> 1 2 3 4 5 6 7\n\n**输出例子**\n\n> 4 1 6 3 5 7 2\n\npostorder: 后序遍历\n\ninorder: 中序遍历\n\nlevel order: 层序遍历（从根开始,依次向下,对于每一层从左向右遍历）\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nstruct node\n{\n\tnode* left;\n\tnode* right;\n\tint value;\n};\n\n\nnode* binaryTreeRoot(int* postorder, int* inorder, int len) {\n\tif (len <= 0) return NULL;\n\n\tnode* root = new node;\n\troot->value = *(postorder+len-1);\n\n\tint pos = 0;\n\tfor (; pos < len; pos++)\n\t\tif (*(inorder+pos) == root->value) break;\n\n\troot->left = binaryTreeRoot(postorder, inorder, pos);\n\tint rightLen = len - pos - 1;\n\troot->right = binaryTreeRoot(postorder+pos, inorder+pos+1, rightLen);\n\n\treturn root;\n}\n\nvoid deleteNodes(node* root) {\n\tif (root == NULL) return;\n\tdeleteNodes(root->left);\n\tdeleteNodes(root->right);\n\tdelete root;\n}\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint* postorderNodes = new int[n];\n\tint* inorderNodes = new int[n];\n\tfor (int i = 0; i < n; i++) cin>>postorderNodes[i];\n\tfor (int i = 0; i < n; i++) cin>>inorderNodes[i];\n\n\tnode* root = binaryTreeRoot(postorderNodes, inorderNodes, n);\n\tif (!root) return 0;\n\n\tqueue<node*> levelNodes;\n\tlevelNodes.push(root);\n\twhile (1) {\n\t\tnode* tmp = levelNodes.front();\n\t\tif (tmp->left) levelNodes.push(tmp->left);\n\t\tif (tmp->right) levelNodes.push(tmp->right);\n\t\tcout<<tmp->value;\n\t\tlevelNodes.pop();\n\t\tif (!levelNodes.empty()) cout<<' ';\n\t\telse break;\n\t}\n\n\tdeleteNodes(root);\n\tdelete postorderNodes;\n\tdelete inorderNodes;\n\n\treturn 0;\n}\n```\n\n\n\n## 1023 Have Fun with Numbers (20)\n\n**题目描述**\n\n> Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication.  Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation.  Check to see the result if we double it again!\n>\n> Now you are suppose to check if there are more numbers with this property.  That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains one positive integer with no more than 20 digits.\n\n**输出描述**\n\n> For each test case, first print in a line \"Yes\" if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or \"No\" if not.  Then in the next line, print the doubled number.\n\n**输入例子**\n\n> 1234567899\n\n**输出例子**\n\n> Yes\n> 2469135798\n\n**实现代码**\n\n若双倍后多一位则为No;\n\n使用`digit_count[i]`保存数字`i`（0-9）的个数，\n\n再减去双倍后各个数字的个数，若每一个`digit_count[i]`均为0则为Yes,否则为No。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\n\n\nint main() {\n\tint digit_count[10];\n\tfor (int i = 0; i < 10; i++) digit_count[i] = 0;\n\tstring s;\n\tcin>>s;\n\tint k = s.size();\n\tvector<int> digits;\n\tfor (int i = 0; i < k; i++) {\n\t\tint digit = s[i]-'0';\n\t\tdigits.push_back(digit);\n\t\tdigit_count[digit]++;\n\t}\n\tint carry = 0;\n\tfor (int i = k-1; i >= 0; i--) {\n\t\tdigits[i] = 2*digits[i] + carry;\n\t\tcarry = digits[i] / 10;\n\t\tdigits[i] %= 10;\n\t\tdigit_count[digits[i]]--;\n\t}\n\tif (carry) {\n\t\tcout<<\"No\\n\"<<carry;\n\t\tfor (int i = 0; i < k; i++) cout<<digits[i];\n\t\treturn 0;\n\t}\n\tbool result = true;\n\tfor (int i = 0; i < 10; i++)\n\t\tif (digit_count[i] != 0) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\tif (result) cout<<\"Yes\\n\";\n\telse cout<<\"No\\n\";\n\tfor (int i = 0; i < k; i++) cout<<digits[i];\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n## 1027 Colors in Mars (20)\n\n**题目描述**\n\n> People in Mars represent the colors in their computers in a similar way as the Earth people.  That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits  for Blue.  The only difference is that they use radix 13 (0-9 and A-C) instead of 16.  Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.\n\n**输入描述**\n\n> Each input file contains one test case which occupies a line containing the three decimal color values.\n\n**输出描述**\n\n> For each test case you should output the Mars RGB value in the following format: first output \"#\", then followed by a 6-digit number where all the English characters must be upper-cased.  If a single color is only 1-digit long, you must print a \"0\" to the left.\n\n**输入例子**\n\n> 15 43 71\n\n**输出例子**\n\n> \\#123456\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    cout<<'#';\n    int n;\n    for (int i = 0; i < 3; i++) {\n        cin>>n;\n        int tmp = n/13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n        tmp = n%13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n    }\n    return 0;\n}\n```\n\n\n\n## 1028 List Sorting (25)\n\n**题目描述**\n\n> Excel can sort records according to any column.  Now you are supposed to imitate this function.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains two integers N (<=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with.  Then N lines follow, each contains a record of a student.  A student's record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).\n\n**输出描述**\n\n> For each test case, output the sorting result in N lines.  That is, if C = 1 then the records must be sorted in increasing order according to ID's; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades.  **If there are several students who have the same name or grade, they must be sorted according to their ID's in increasing order.**\n\n**输入例子**\n\n> 3 1\n> 000007 James 85\n> 000010 Amy 90\n> 000001 Zoe 60\n\n**输出例子**\n\n> 000001 Zoe 60\n> 000007 James 85\n> 000010 Amy 90\n\n**实现代码**\n\n利用结构体，使用sort函数排序。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct student\n{\n\tstring id;\n\tstring name;\n\tint grade;\n\tstudent(string i, string n, int g) {id = i, name = n, grade = g;}\n};\n\nbool cmp1(student a, student b) {\n\treturn a.id < b.id;\n}\n\nbool cmp2(student a, student b) {\n\treturn (a.name == b.name)?(a.id < b.id):(a.name < b.name);\n}\n\nbool cmp3(student a, student b) {\n\treturn (a.grade == b.grade)?(a.id < b.id):(a.grade < b.grade);\n}\n\nint main() {\n\tint n,c;\n\tcin>>n>>c;\n\tvector<student> students;\n\n\tstring id,name;\n\tint grade;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>id>>name>>grade;\n\t\tstudents.push_back(student(id,name,grade));\n\t}\n\n\tif (c == 1) sort(students.begin(),students.end(),cmp1);\n\telse if (c == 2) sort(students.begin(),students.end(),cmp2);\n\telse sort(students.begin(),students.end(),cmp3);\n\n\tif (n > 0) cout<<students[0].id<<' '<<students[0].name<<' '<<students[0].grade;\n\tfor (int i = 1; i < n; i++) {\n\t\tcout<<\"\\n\"<<students[i].id<<' '<<students[i].name<<' '<<students[i].grade;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1029 Median (25)\n\n**题目描述**\n\n> Given an increasing sequence S of N integers, the *median* is the number at the middle position.  For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15.  The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences.  For example, the median of S1 and S2 is 13.\n> Given two increasing sequences of integers, you are asked to find their median.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case occupies 2 lines, each gives the information of a sequence.  For each sequence, the first positive integer N (<=1000000) is the size of that sequence.  Then N integers follow, separated by a space.  It is guaranteed that all the integers are in the range of **long int**.\n\n**输出描述**\n\n> For each test case you should output the median of the two given sequences in a line.\n\n**输入例子**\n\n> 4 11 12 13 14\n> 5 9 10 15 16 17\n\n**输出例子**\n\n> 13\n\n**实现代码**\n\n用两个数组存储两组数据，每组数据一个pos，比较两个pos出的数值大小，较小值的pos向后移，直到找到中位数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n\tint m,n;\n\tcin>>m;\n\tint* firstSequence = new int[m];\n\tfor (int i = 0; i < m; i++) cin>>firstSequence[i];\n\tcin>>n;\n\tint* secondSequence = new int[n];\n\tfor (int i = 0; i < n; i++) cin>>secondSequence[i];\n\n\tint firstPos = 0, secondPos = 0;\n\tfor (int i = int((m+n+1)/2); i > 0; i--) {\n\t\tif (i == 1) {\n\t\t\tif (firstPos == m) cout<<secondSequence[secondPos];\n\t\t\telse if (secondPos == n) cout<<firstSequence[firstPos];\n\t\t\telse if (firstSequence[firstPos] < secondSequence[secondPos]) cout<<firstSequence[firstPos];\n\t\t\telse cout<<secondSequence[secondPos];\n\t\t} else {\n\t\t\tif (firstPos == m) secondPos++;\n\t\t\telse if (secondPos == n) firstPos++;\n\t\t\telse if (firstSequence[firstPos] < secondSequence[secondPos]) firstPos++;\n\t\t\telse secondPos++;\n\t\t}\n\t}\n\n\tdelete firstSequence;\n\tdelete secondSequence;\n\n\treturn 0;\n}\n```\n\n\n\n## 1030 Travel Plan (30)\n\n**题目描述**\n\n> A traveler's map gives the distances between cities along the highways, together with the cost of each highway. \n>  Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination.\n>  If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.\n>\n>  DECLARE: The test data in PAT is wrong,we strengthened the test data.If the same code got passed in pat,it may not be able to get passed in NOWCODER,please check your code.(This means that our test data is no problem,I guarantee.)\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (<=500) is the number of cities (and hence the cities are numbered from 0 to N-1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:\n>  City1 City2 Distance Cost\n>\n>  where the numbers are all integers no more than 500, and are separated by a space.\n\n**输出描述**\n\n> For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.\n\n**输入例子**\n\n> 4 5 0 3\n>\n> 0 1 1 20\n>\n> 1 3 2 30\n>\n> 0 3 4 10\n>\n> 0 2 2 20\n>\n> 2 3 1 20\n\n**输出例子**\n\n> 0 2 3 3 40\n\n**实现代码**\n\n最短路问题，用Dijkstra（迪杰斯特拉）算法解即可。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\nstruct highway\n{\n\tint endCity;\n\tint distance;\n\tint cost;\n\thighway(int e, int d, int c) {endCity=e,distance=d,cost=c;}\n};\n\n\nint main() {\n\t// N为城市数，M为公路数，S为开始城市，D为结束城市\n\tint N,M,S,D;\n\tcin>>N>>M>>S>>D;\n\n\t// highways(i) 为与城市i相连的所有公路\n\tvector<vector<highway> > highways(N);\n\tbool* visited = new bool[N];\n\tint* distance = new int[N];\n\tint* cost = new int[N];\n\tint* lastCity = new int[N];\n\tfor (int i = 0; i < N; i++) \n\t\tvisited[i] = false, distance[i] = cost[i] = INT_MAX;\n\n\t// 读入数据，更新highways\n\tint tmp_city_1, tmp_city_2, tmp_distance, tmp_cost;\n\twhile (M--) {\n\t\tcin>>tmp_city_1>>tmp_city_2>>tmp_distance>>tmp_cost;\n\t\thighways[tmp_city_1].push_back(highway(tmp_city_2,tmp_distance,tmp_cost));\n\t\thighways[tmp_city_2].push_back(highway(tmp_city_1,tmp_distance,tmp_cost));\n\t}\n\n\t// dijkstra\n\tint currentCity = S;\n\tvisited[S] = true, distance[S] = cost[S] = 0, lastCity[S] = S;\n\twhile (currentCity != D) {\n\t\tfor (int i = 0; i < highways[currentCity].size(); i++) {\n\t\t\tint tmp_endCity = highways[currentCity][i].endCity, \n\t\t\t\ttmp_distance = highways[currentCity][i].distance,\n\t\t\t\ttmp_cost = highways[currentCity][i].cost;\t\t\t\t\n\t\t\tif (visited[tmp_endCity]) continue;\n\t\t\tif (distance[currentCity] + tmp_distance < distance[tmp_endCity] ||\n\t\t\t\t(distance[currentCity] + tmp_distance == distance[tmp_endCity] && \n\t\t\t\t cost[currentCity] + tmp_cost < cost[tmp_endCity])) {\n\t\t\t\tdistance[tmp_endCity] = distance[currentCity] + tmp_distance;\n\t\t\t\tcost[tmp_endCity] = cost[currentCity] + tmp_cost;\n\t\t\t\tlastCity[tmp_endCity] = currentCity;\n\t\t\t}\n\t\t}\n\t\tint minDistance = INT_MAX;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tif (distance[i] < minDistance) minDistance=distance[i],currentCity = i;\n\t\t}\n\t\t// 添加离起始点最短的点到已访问集\n\t\tvisited[currentCity] = true;\n\t}\n\n\t// 逆序列逆向输出即为最短路径\n\tstack<int> pathStack;\n\tpathStack.push(D);\n\tcurrentCity = D;\n\twhile (currentCity != S) {\n\t\tcurrentCity = lastCity[currentCity];\n\t\tpathStack.push(currentCity);\n\t}\n\n\twhile (!pathStack.empty()) {\n\t\tcout<<pathStack.top()<<' ';\n\t\tpathStack.pop();\n\t}\n\tcout<<distance[D]<<' '<<cost[D];\n\n\tdelete visited,distance,cost,lastCity;\n\treturn 0;\n}\n\n```\n\n\n\n## 1035 Password (20)\n\n**题目描述**\n\n> To prepare for PAT, the judge sometimes has to generate random passwords for the users.  The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase).  One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o.  Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a positive integer N (<= 1000), followed by N lines of accounts.  Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.\n\n**输出描述**\n\n> For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords.  The accounts must be printed in the same order as they are read in.  If no account is modified, print in one line \"There are N accounts and no account is modified\" where N is the total number of accounts.  However, if N is one, you must print \"There is 1 account and no account is modified\" instead.\n\n**输入例子**\n\n> 3\n> Team000002 Rlsp0dfa\n> Team000003 perfectpwd\n> Team000001 R1spOdfa\n\n**输出例子**\n\n> 2\n> Team000002 RLsp%dfa\n> Team000001 R@spodfa\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct account\n{\n\tstring id;\n\tstring password;\n\taccount(string i, string p) {id = i, password = p;}\n};\n\nint main() {\n\tint n;\n\tcin>>n;\n\tvector<account> result;\n\n\tstring id,password;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>id>>password;\n\t\tif (password.find_first_of('0') == string::npos &&\n\t\t\tpassword.find_first_of('O') == string::npos &&\n\t\t\tpassword.find_first_of('1') == string::npos &&\n\t\t\tpassword.find_first_of('l') == string::npos)\n\t\t\tcontinue;\n\t\tfor (int s = 0; s < password.size(); s++) {\n\t\t\tif (password[s] == '0') password[s] = '%';\n\t\t\tif (password[s] == 'O') password[s] = 'o';\n\t\t\tif (password[s] == '1') password[s] = '@';\n\t\t\tif (password[s] == 'l') password[s] = 'L';\n\t\t}\n\t\tresult.push_back(account(id,password));\n\t}\n\n\tint result_len = result.size();\n\tif (n == 1 && result_len == 0) {\n\t\tcout<<\"There is 1 account and no account is modified\";\n\t} else if (result_len == 0) {\n\t\tcout<<\"There are \"<<n<<\" accounts and no account is modified\";\n\t} else {\n\t\tcout<<result_len;\n\t\tfor (int i = 0; i < result_len; i++) {\n\t\t\tcout<<\"\\n\"<<result[i].id<<' '<<result[i].password;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n\n\n## 1036 Boys vs Girls (25)\n\n**题目描述**\n\n> This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a positive integer N, followed by N lines of student information.  Each line contains a student's name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100.  It is guaranteed that all the grades are distinct.\n\n**输出描述**\n\n> For each test case, output in 3 lines.  The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade.  The third line gives the difference gradeF-gradeM.  If one such kind of student is missing, output \"Absent\" in the corresponding line, and output \"NA\" in the third line instead.\n\n**输入例子**\n\n> 3\n> Joe M Math990112 89\n> Mike M CS991301 100\n> Mary F EE990830 95\n\n**输出例子**\n\n> Mary EE990830\n> Joe Math990112\n> 6\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin>>n;\n\tstring re_male_name, re_male_id;\n\tstring re_female_name, re_female_id;\n\tint re_male_grade = 101, re_female_grade = -1;\n\n\tstring name, gender, id;\n\tint grade;\n\twhile(n--) {\n\t\tcin>>name>>gender>>id>>grade;\n\t\tif (gender==\"M\") {\n\t\t\tif (grade < re_male_grade) {\n\t\t\t\tre_male_name = name;\n\t\t\t\tre_male_id = id;\n\t\t\t\tre_male_grade = grade;\n\t\t\t}\n\t\t} else {\n\t\t\tif (grade > re_female_grade) {\n\t\t\t\tre_female_name = name;\n\t\t\t\tre_female_id = id;\n\t\t\t\tre_female_grade = grade;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re_female_name==\"\") cout<<\"Absent\"<<endl;\n\telse cout<<re_female_name<<' '<<re_female_id<<endl;\n\tif (re_male_name==\"\") cout<<\"Absent\"<<endl;\n\telse cout<<re_male_name<<' '<<re_male_id<<endl;\n\tif (re_female_name==\"\" || re_male_name==\"\") cout<<\"NA\";\n\telse cout<<re_female_grade - re_male_grade;\n\t\n\treturn 0;\n\n}\n```\n\n\n\n## 1037 Magic Coupon (25)\n\n**题目描述**\n\n> The magic shop in Mars is offering some magic coupons.  Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back!  What is more, the shop also offers some bonus product for free.  However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product... but hey, magically, they have some coupons with negative N's! \n> For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M\\$) where a negative value corresponds to a bonus product.  You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back.  On the other hand, if you apply coupon 3 to product 4, you will have to pay M\\$12 to the shop.\n> Each coupon and each product may be selected at most once.  Your task is to get as much money back as possible.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers.  Then the next line contains the number of products NP, followed by a line with NP product values.  Here 1<= NC, NP <= 105, and it is guaranteed that all the numbers will not exceed 230.\n\n**输出描述**\n\n> For each test case, simply print in a line the maximum amount of money you can get back.\n\n**输入例子**\n\n> 4\n> 1 2 4 -1\n> 4\n> 7 6 -2 -3\n\n**输出例子**\n\n> 43\n\n**实现代码**\n\n\n\n\n\n## 1054 The Dominant Color (20)\n\n**题目描述**\n\n> Behind the scenes in the computer's memory, color is always talked about as a series of 24 bits of information for each pixel.  In an image, the color with the largest proportional area is called the dominant color.  **A *strictly* dominant color takes more than half of the total area.**  Now given an image of resolution M by N (for example, 800x600), you are supposed to point out the strictly dominant color.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains 2 positive numbers: M (<=800) and N (<=600) which are the resolutions of the image.  Then N lines follow, each contains M digital colors in the range [0, 224).  It is guaranteed that the strictly dominant color exists for each input image.  All the numbers in a line are separated by a space.\n\n**输出描述**\n\n> For each test case, simply print the dominant color in a line.\n\n**输入例子**\n\n> 5 3\n> 0 0 255 16777215 24\n> 24 24 0 0 24\n> 24 0 24 24 24\n\n**输出例子**\n\n>  24\n\n首先要注意到dominant color是超过半数的，刚开始只想到了排序后最中间的数一定为结果，但是要存储的数据太多，后来看了[参考链接](https://blog.csdn.net/zhu_liangwei/article/details/9734671)，学会了下边这个方法。\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n, all_count, tmp, re = -1, count = 0;\n    cin>>m>>n;\n    all_count = m*n;\n    while (all_count--) {\n        cin>>tmp;\n        if (count == 0) re = tmp;\n        if (re == tmp) count++;\n        else count--;\n    }\n    cout<<re;\n    return 0;\n}\n```\n\n## 1081 Rational Sum (20)\n\n**题目描述**\n\n> Given N rational numbers in the form \"numerator/denominator\", you are supposed to calculate their sum.\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a positive integer N (<=100), followed in the next line N rational numbers \"a1/b1 a2/b2 ...\" where all the numerators and denominators are in the range of \"long int\".  If there is a negative number, then the sign must appear in front of the numerator.\n\n**输出描述**\n\n> For each test case, output the sum in the simplest form \"integer numerator/denominator\" where \"integer\" is the integer part of the sum, \"numerator\" < \"denominator\", and the numerator and the denominator have no common factor.  You must output only the fractional part if the integer part is 0.\n\n**输入例子**\n\n> 5\n> 2/5 4/15 1/30 -2/60 8/3\n\n**输出例子**\n\n> 3 1/3\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    return ((b==0)?abs(a):gcd(b,a%b));\n}\n\nint main() {\n    long long n, tmp_gcd;\n    cin>>n;\n    char c;\n    long long re_integer = 0, re_numerator, re_denominator;\n    cin>>re_numerator>>c>>re_denominator;\n    tmp_gcd = gcd(re_numerator,re_denominator);\n    re_numerator/=tmp_gcd,re_denominator/=tmp_gcd;\n    re_integer += int(re_numerator/re_denominator);\n    re_numerator%=re_denominator;\n    while(--n) {\n        long long tmp_nu, tmp_de, tmp_nu_re, tmp_de_re;\n        cin>>tmp_nu>>c>>tmp_de;\n        tmp_de_re = tmp_de * re_denominator;\n        tmp_nu_re = tmp_nu * re_denominator + tmp_de * re_numerator;\n        tmp_gcd = gcd(tmp_de_re,tmp_nu_re);\n        tmp_de_re/=tmp_gcd,tmp_nu_re/=tmp_gcd;\n        re_integer += int(tmp_nu_re/tmp_de_re);\n        re_numerator = tmp_nu_re % tmp_de_re;\n        re_denominator = tmp_de_re;\n    }\n    if (re_integer == 0 && re_numerator == 0) cout<<0;\n    else if (re_integer == 0) {\n    \tcout<<re_numerator<<'/'<<re_denominator;\n\t} else if (re_numerator == 0) {\n\t\tcout<<re_integer;\n\t} else {\n\t\tcout<<re_integer<<' '<<re_numerator<<'/'<<re_denominator;\n\t}\n    return 0;\n}\n```\n\n\n\n## 1082 Read Number in Chinese (25)\n\n**题目描述**\n\n> Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way.  Output \"Fu\" first if it is negative.  For example, -123456789 is read as \"Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\".  Note: zero (\"ling\") must be handled correctly according to the Chinese tradition.  For example, 100800 is \"yi Shi Wan ling ba Bai\".\n\n**输入描述**\n\n> Each input file contains one test case, which gives an integer with no more than 9 digits.\n\n**输出描述**\n\n> For each test case, print in a line the Chinese way of reading the number.  The characters are separated by a space and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> -123456789\n\n**输出例子**\n\n> Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\n\n**实现代码**\n\n首先按照数字单位的顺序添加到结果容器中，然后遍历结果容器，如果有连续重复的\"ling\"只留一个，如果\"Wan\"前有“ling”去掉0，如果\"Wan\"直接跟在“Yi”后边将“Wan”换成“ling”。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring units[] = {\"\",\"Shi\",\"Bai\",\"Qian\",\"Wan\",\"Shi\",\"Bai\",\"Qian\",\"Yi\"};\n\tstring digits[] = {\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"};\n\tvector<string> re;\n\tint n;\n\tcin>>n;\n\tif (n < 0) {\n\t\tre.push_back(\"Fu\");\n\t\tn = -n;\n\t}\n\tif (n == 0) {\n\t\tcout<<\"ling\";\n\t\treturn 0;\n\t}\n\tvector<int> n_digits;\n\twhile (n > 0) {\n\t\tn_digits.push_back(n%10);\n\t\tn/=10;\n\t}\n\tint len = n_digits.size();\n\tfor (int i = len-1; i >= 0; i--) {\n\t\tre.push_back(digits[n_digits[i]]);\n\t\tif (i==4 || n_digits[i] != 0 && i>0) re.push_back(units[i]);\n\t}\n\tvector<string>::iterator iter = re.begin()+1;\n\twhile (iter < re.end()) {\n\t\tif (*(iter)==\"ling\" && *(iter-1)==\"ling\")\n\t\t\tre.erase(iter);\n\t\telse if (*(iter)==\"Wan\" && *(iter-1)==\"ling\")\n\t\t\tre.erase((iter--)-1);\n\t\telse if (*(iter)==\"Wan\" && *(iter-1)==\"Yi\")\n\t\t\t*(iter++) = \"ling\";\n\t\telse\n\t\t\titer++;\n\t}\n\tif (re.size()>1 && re[re.size()-1]==\"ling\") re.erase(re.end()-1);\n\tcout<<re[0];\n\tfor (int i = 1; i < re.size(); i++) cout<<' '<<re[i];\n\t\t\n\treturn 0;\n}\n\n```\n\n\n\n## 1083 List Grades (25)\n\n**题目描述**\n\n> Given a list of N student records with name, ID and grade.  You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case is given in the following format:\n> N\n> name[1] ID[1] grade[1]\n> name[2] ID[2] grade[2]\n> ... ...\n> name[N] ID[N] grade[N]\n> grade1 grade2\n>\n> where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade's interval.  It is guaranteed that all the grades are *distinct*.\n\n**输出描述**\n\n> For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order.  Each student record occupies a line with the student's name and ID, separated by one space.  If there is no student's grade in that interval, output \"NONE\" instead.\n\n**输入例子**\n\n> 4\n> Tom CS000001 59\n> Joe Math990112 89\n> Mike CS991301 100\n> Mary EE990830 95\n> 60 100\n\n**输出例子**\n\n> Mike CS991301\n> Mary EE990830\n> Joe Math990112\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n\nstruct student\n{\n\tstring name;\n\tstring id;\n\tint grade;\n\tstudent(string n,string i, int g) {\n\t\tname = n;\n\t\tid = i;\n\t\tgrade = g;\n\t}\n};\n\nint main() {\n\tint n;\n\tcin>>n;\n\tvector<student> re;\n\n\tstring name,id;\n\tint grade;\n\twhile(n--) {\n\t\tcin>>name>>id>>grade;\n\t\tstudent tmp(name,id,grade);\n\t\tre.push_back(tmp);\n\t}\n\tint min_grade,max_grade;\n\tcin>>min_grade>>max_grade;\n\n\tvector<student>::iterator iter = re.begin();\n\twhile (iter != re.end()) {\n\t\tif ((*iter).grade < min_grade || (*iter).grade > max_grade)\n\t\t\tre.erase(iter);\n\t\telse\n\t\t\titer++;\n\t}\n\n\tfor (int k = 0 ; k < re.size(); k++) {\n\t\tfor (int i = 0 ; i < re.size()-1; i++) {\n\t\t\tif (re[i].grade < re[i+1].grade) {\n\t\t\t\tstudent tmp(re[i].name,re[i].id,re[i].grade);\n\t\t\t\tre[i] = re[i+1];\n\t\t\t\tre[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re.empty()) cout<<\"NONE\";\n\telse {\n\t\tcout<<re[0].name<<' '<<re[0].id;\n\t\tfor (int i = 1; i < re.size(); i++)\n\t\t\tcout<<\"\\n\"<<re[i].name<<' '<<re[i].id;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1086 Tree Traversals Again (25)\n\n**题目描述**\n\n> An inorder binary tree traversal can be implemented in a non-recursive way with a stack.  For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop().  Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations.  Your task is to give the postorder traversal sequence of this tree.\n>\n> ![](/images/pat_1086.jpg)\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains a positive integer N (<=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N).  Then 2N lines follow, each describes a stack operation in the format: \"Push X\" where X is the index of the node being pushed onto the stack; or \"Pop\" meaning to pop one node from the stack.\n\n**输出描述**\n\n> For each test case, print the postorder traversal sequence of the corresponding tree in one line.  A solution is guaranteed to exist.  All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> 6\n> Push 1\n> Push 2\n> Push 3\n> Pop\n> Pop\n> Push 4\n> Pop\n> Pop\n> Push 5\n> Push 6\n> Pop\n> Pop\n\n**输出例子**\n\n> 3 4 2 6 5 1\n\n**实现代码**\n\n以上述例子为例，按顺序排下来123456为前序，使用栈的pop顺序为中序，利用前序和中序可以得到后序。\n\n注意1-N为标号，每次push的为值，值有可能重复，但是push顺序为标号1-N。\n\n可以用下边这个测试用例测试：\n\n> //输入\n>\n> 19\n> Push 4\n> Push 11\n> Push 7\n> Push 12\n> Pop\n> Pop\n> Pop\n> Push 14\n> Push 17\n> Pop\n> Pop\n> Push 6\n> Push 18\n> Pop\n> Push 8\n> Pop\n> Pop\n> Push 4\n> Pop\n> Pop\n> Push 11\n> Push 16\n> Push 11\n> Push 12\n> Pop\n> Push 2\n> Pop\n> Pop\n> Pop\n> Push 7\n> Push 4\n> Pop\n> Pop\n> Push 12\n> Pop\n> Pop\n> Push 11\n> Pop\n>\n> // 输出\n>\n> 12 7 17 8 18 4 6 14 11 2 12 11 4 12 7 16 11 11 4 \n\n我的代码如下：\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<int> post;\nvoid generatePostOrder(vector<int> pre, vector<int> in, int len) {\n\tif (len <= 0) return;\n\tif (len == 1) {\n\t\tpost.push_back(pre[0]);\n\t\treturn;\n\t}\n\tint root_num = pre[0], root_pos_of_in = 0;\n\tfor (; root_pos_of_in < len; root_pos_of_in++) {\n\t\tif (in[root_pos_of_in] == root_num) break;\n\t}\n\tint left_len = root_pos_of_in;\n\tint right_len = len - left_len - 1;\n\tvector<int> pre_left,pre_right,in_left,in_right;\n\tpre_left.assign(pre.begin()+1, pre.begin()+1+left_len);\n\tpre_right.assign(pre.begin()+1+left_len, pre.end());\n\tin_left.assign(in.begin(),in.begin()+left_len);\n\tin_right.assign(in.begin()+left_len+1, in.end());\n\tgeneratePostOrder(pre_left,in_left,left_len);\n\tgeneratePostOrder(pre_right,in_right,right_len);\n\tpost.push_back(root_num);\n}\n\nint main() {\n\tint n, tmp;\n\tcin>>n;\n\tstring op;\n\tvector<int> pre,in,value;\n\tstack<int> tmp_stack;\n\tint index = 0;\n\tfor (int i = 0; i < 2*n; i++) {\n\t\tcin>>op;\n\t\tif (op == \"Push\") {\n\t\t\tcin>>tmp;\n\t\t\tvalue.push_back(tmp);\n\t\t\ttmp_stack.push(index);\n\t\t\tpre.push_back(index++);\n\t\t} else {\n\t\t\tin.push_back(tmp_stack.top());\n\t\t\ttmp_stack.pop();\n\t\t}\n\t}\n\tgeneratePostOrder(pre,in,n);\n\tif (n > 0) cout<<value[post[0]];\n\tfor (int i = 1; i < n; i++) {\n\t\tcout<<\" \"<<value[post[i]];\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n## 10xx\n\n**题目描述**\n\n> \n\n**输入描述**\n\n> \n\n**输出描述**\n\n> \n\n**输入例子**\n\n> \n\n**输出例子**\n\n> \n\n**实现代码**\n\n","source":"_posts/PAT刷题记录.md","raw":"---\ntitle: PAT刷题记录\ntoc: true\ndate: 2018-07-19 22:54:17\ncategories: OJ\ntags:\n- PAT\n- 刷题\n---\n\n\n\nOJ：[牛客网](https://www.nowcoder.com/pat)\n\n<!-- more -->\n\n---\n\n\n\n## 1001 A+B Format (20)\n\n**题目描述**\n\n> Calculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000.  The numbers are separated by a space.\n\n**输出描述**\n\n> For each test case, you should output the sum of a and b in one line.  The sum must be written in the standard format.\n\n**输入例子**\n\n> -1000000 9\n\n**输出例子**\n\n> -999,991\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int digit[10];\n    for (int i = 0; i < 10; i++) digit[i] = -1;\n    int a,b,re;\n    cin >> a >> b;\n    re = a + b;\n    if (re < 0) {\n        cout<<'-';\n        re = -re;\n    }\n    int i = 0;\n    while(re) {\n        digit[i] = (re%10);\n        re/=10;\n        i++;\n    }\n    for (int k = i-1; k >=0; k--) {\n        cout<<digit[k];\n        if (k%3 == 0 && k>0) cout<<',';\n    }\n    return 0;\n}\n```\n\n\n\n## 1002 A+B for Polynomials (25)\n\n**题目描述**\n\n> This time, you are supposed to find A+B where A and B are two polynomials.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n> K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively.  It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\n**输出描述**\n\n> For each test case you should output the sum of A and B in one line, with the same format as the input.  Notice that there must be NO extra space at the end of each line.  **Please be accurate to 1 decimal place.**\n\n**输入例子**\n\n> 2 1 2.4 0 3.2\n> 2 2 1.5 1 0.5\n\n**输出例子**\n\n> 3 2 1.5 1 2.9 0 3.2\n\n**实现代码**\n\n注意保留小数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n\tint n;\n\tfloat value;\n\titem(int a, float b) {n=a,value=b;}\n};\n\nint main() {\n\tvector<item> polynomials;\n\tint k;\n\n\tcin>>k;\n\tint tmp_n;\n\tfloat tmp_value;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tpolynomials.push_back(item(tmp_n,tmp_value));\n\t}\n\n\tcin>>k;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tbool hasItem = false;\n\t\tfor (int i = 0; i < polynomials.size(); i++) {\n\t\t\tif (polynomials[i].n == tmp_n) {\n\t\t\t\thasItem = true;\n\t\t\t\tpolynomials[i].value+=tmp_value;\n\t\t\t\tif (polynomials[i].value == 0)\n\t\t\t\t\tpolynomials.erase(polynomials.begin()+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\t\n\t\tif (!hasItem) polynomials.push_back(item(tmp_n,tmp_value));\t\n\t}\n\n\tfor (int k = 0; k < polynomials.size(); k++) {\n\t\tfor (int i = 0; i < polynomials.size()-1; i++) {\n\t\t\tif (polynomials[i].n < polynomials[i+1].n) {\n\t\t\t\titem tmp_item = polynomials[i];\n\t\t\t\tpolynomials[i] = polynomials[i+1];\n\t\t\t\tpolynomials[i+1] = tmp_item;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<polynomials.size();\n\tfor (int i = 0; i < polynomials.size(); i++)\n\t\tprintf(\" %d %.1f\", polynomials[i].n, polynomials[i].value);\n\n\treturn 0;\n}\n```\n\n\n\n## 1003 Emergency (25)\n\n**题目描述**\n\n> As an emergency rescue team leader of a city, you are given a special map of your country.  The map shows several scattered cities connected by some roads.  Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map.  When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.\n\n**输入描述**\n\n> Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (<= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively.  The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city.  Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively.  \n> It is guaranteed that there exists at least one path from C1 to C2.\n\n**输出描述**\n\n> For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.\n>\n> All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.\n\n**输入例子**\n\n> 5 6 0 2\n> 1 2 1 5 3\n> 0 1 1\n> 0 2 2\n> 0 3 1\n> 1 2 1\n> 2 4 1\n> 3 4 1\n\n**输出例子**\n\n> 2 4\n\n**实现代码**\n\ndijkstra最短路\n\n```c++\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nstruct road\n{\n\tint endCity;\n\tint length;\n\troad(int e, int l) {endCity = e, length = l;}\n};\n\n\nint main() {\n\tint n,m,c1,c2;\n\tcin>>n>>m>>c1>>c2;\n\tvector<int> teamsCount;\n\n\tint tmp1,tmp2,tmp3;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>tmp1;\n\t\tteamsCount.push_back(tmp1);\n\t}\n\n\tvector<vector<road> > roads(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin>>tmp1>>tmp2>>tmp3;\n\t\troads[tmp1].push_back(road(tmp2,tmp3));\n\t\troads[tmp2].push_back(road(tmp1,tmp3));\n\t}\n\n\tvector<int> maxTeams(n);\n\tfor (int i = 0; i < n; i++) maxTeams[i] = 0;\n\tmaxTeams[c1] = teamsCount[c1];\n\n\tvector<int> minLen(n);\n\tfor (int i = 0; i < n; i++) minLen[i] = INT_MAX;\n\tminLen[c1] = 0;\n\n\tint currentCity = c1;\n\tvector<int> minLenRoadCount(n);\n\tfor (int i = 0; i < n; i++) minLenRoadCount[i] = 1;\n\n\tvector<bool> visited(n);\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tvisited[c1] = true;\n\twhile (currentCity != c2) {\n\t\tint len = roads[currentCity].size();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (visited[roads[currentCity][i].endCity]) continue;\n\t\t\tint endCity = roads[currentCity][i].endCity;\n\t\t\tint length = roads[currentCity][i].length;\n\t\t\tif (minLen[endCity] > minLen[currentCity] + length) {\n\t\t\t\tminLen[endCity] = minLen[currentCity] + length;\n\t\t\t\tminLenRoadCount[endCity] = 1;\n\t\t\t\tmaxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n\t\t\t} else if (minLen[endCity] == minLen[currentCity] + length) {\n\t\t\t\tminLenRoadCount[endCity]++;\n\t\t\t\tif (maxTeams[endCity] < maxTeams[currentCity] + teamsCount[endCity])\n\t\t\t\t\tmaxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n\t\t\t}\n\t\t}\n\n\t\tint min = INT_MAX;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tif (minLen[i] < min) {\n\t\t\t\tmin = minLen[i];\n\t\t\t\tcurrentCity = i;\n\t\t\t}\n\t\t}\n\t\tvisited[currentCity] = true;\n\t}\n\n\tcout<<minLenRoadCount[c2]<<' '<<maxTeams[c2];\n\n\treturn 0;\n}\n```\n\n\n\n## 1004 Counting Leaves (30)\n\n**题目描述**\n\n> A family hierarchy is usually presented by a pedigree tree.  Your job is to count those family members who have no child.\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a line containing 0 < N < 100, the number of nodes in a tree, and M (< N), the number of non-leaf nodes.  Then M lines follow, each in the format:\n>\n> ID K ID[1] ID[2] ... ID[K]\n>\n> where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID's of its children.  For the sake of simplicity, let us fix the root ID to be 01.\n\n**输出描述**\n\n> For each test case, you are supposed to count those family members who have no child **for every seniority level** starting from the root.  The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.\n> The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child.  Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node.  Then we should output \"0 1\" in a line.\n\n**输入例子**\n\n> 2 1\n> 01 1 02\n\n**输出例子**\n\n> 0 1\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n#define MAX_NODES 100\n\nstruct node\n{\n\tint id = -1;\n\tint childs_count = 0;\n\tvector<int> childs;\n};\n\nint main() {\n\tint n,m;\n\tcin>>n>>m;\n\tnode nodes[MAX_NODES];\n\n\tint id,k,tmp;\n\twhile (m--) {\n\t\tcin>>id>>k;\n\t\tnodes[id].id = id;\n\t\tnodes[id].childs_count = k;\n\t\twhile (k--) {\n\t\t\tcin>>tmp;\n\t\t\t(nodes[id].childs).push_back(tmp);\n\t\t}\n\t}\n\n\tvector<int> this_level, next_level;\n\tthis_level.push_back(1);\n\twhile (1) {\n\t\tint count_output = 0;\n\t\tfor (int i = 0; i < this_level.size(); i++) {\n\t\t\tif (nodes[this_level[i]].childs_count == 0) count_output++;\n\t\t\telse next_level.insert(next_level.begin(),nodes[this_level[i]].childs.begin(),nodes[this_level[i]].childs.end());\n\t\t}\n\t\tcout<<count_output;\n\t\tif (next_level.empty()) break;\n\t\tcout<<' ';\n\t\tthis_level = next_level;\n\t\tnext_level.clear();\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1005 Spell It Right (20)\n\n**题目描述**\n\n> Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies one line which contains an N (<= 10^100).\n\n**输出描述**\n\n> For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\n**输入例子**\n\n> 12345\n\n**输出例子**\n\n> one five\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string n;\n    cin>>n;\n    int len = n.size();\n    int re = 0;\n    for (int i = 0; i < len; i++) re+=(n[i]-'0');\n    string english[10] = {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\n    int digit[100], re_len = 0;\n    while (re) {\n        digit[re_len] = (re%10);\n        re/=10;\n        re_len++;\n    }\n    for (int i = re_len-1; i >= 0; i--) {\n        cout<<english[digit[i]];\n        if (i != 0) cout<<' ';\n    }\n    return 0;\n}\n```\n\n\n\n## 1006 Sign In and Sign Out (25)\n\n**题目描述**\n\n> At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door.  Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n\n**输入描述**\n\n> Each input file contains one test case. Each case contains the records for one day.  The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n>\n> ID_number Sign_in_time Sign_out_time\n>\n> where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\n**输出描述**\n\n> For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day.  The two ID numbers must be separated by one space.\n> Note:  It is guaranteed that the records are consistent.  That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\n**输入例子**\n\n> 3\n> CS301111 15:30:28 17:00:10\n> SC3021234 08:00:00 11:25:25\n> CS301133 21:45:00 21:58:40\n\n**输出例子**\n\n> SC3021234 CS301133\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool a_larger_than_b(string a, string b) {\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] < b[i]) return false;\n        if (a[i] > b[i]) return true;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    string id,in,out;\n    string result_in_id, result_in_time, result_out_id, result_out_time;\n    cin>>id>>in>>out;\n    result_in_id = result_out_id = id;\n    result_in_time = in;\n    result_out_time = out;\n    n--;\n    while (n--) {\n        cin>>id>>in>>out;\n        if (a_larger_than_b(result_in_time,in)) {\n            result_in_id = id;\n            result_in_time = in;\n        }\n        if (a_larger_than_b(out,result_out_time)) {\n            result_out_id = id;\n            result_out_time = out;\n        }\n    }\n    cout<<result_in_id<<' '<<result_out_id;\n    return 0;\n}\n```\n\n\n\n## 1007 Maximum Subsequence Sum (25)\n\n**题目描述**\n\n> Given a sequence of K integers { N1\n> , N2\n> , ..., NK\n>  }.  A continuous subsequence is defined to be { Ni\n> , Ni+1\n> , ..., Nj\n>  } where 1 <= i <= j <= K.  The *Maximum Subsequence*\n>  is the continuous subsequence which has the largest sum of its\n> elements.  For example, given sequence { -2, 11, -4, 13, -5, -2 }, its\n> maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n>\n> Now you are supposed to find the largest sum, together with the first\n> and the last numbers of the maximum subsequence.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies two lines.  The first line contains a positive integer K (<= 10000).  The second line contains K numbers, separated by a space.\n\n**输出描述**\n\n> For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line.  In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case).  If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\n**输入例子**\n\n> 10\n> -10 1 2 3 4 -5 -23 3 7 -21\n\n**输出例子**\n\n> 10 1 4\n\n**实现代码**\n\n<u>和为负的子序列一定不会是最大和子序列的开头。</u>\n\n当当前和小于0时，使用临时\"first number\"记录下一个数，\n\n更新最大和时，当前数为“last number”， 临时“first number”中存储的值为“first number”的值。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint* nums = new int[n];\n\tbool allNegative = true;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>nums[i];\n\t\tif (nums[i] >= 0) allNegative = false;\n\t}\n\n\tif (allNegative) {\n\t\tcout<<0<<' '<<nums[0]<<' '<<nums[n-1];\n\t} else {\n\t\tint maxSum = 0, currentSum = 0;\n\t\tint firstNum = nums[0], lastNum = nums[0];\n\t\tint firstNumCurrent = firstNum;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcurrentSum+=nums[i];\n\t\t\tif (currentSum < 0) {\n\t\t\t\tcurrentSum = 0;\n\t\t\t\tfirstNumCurrent = nums[i+1];\n\t\t\t} else if (currentSum > maxSum) {\n\t\t\t\tmaxSum = currentSum;\n\t\t\t\tfirstNum = firstNumCurrent;\n\t\t\t\tlastNum = nums[i];\n\t\t\t}\n\t\t}\n\t\tcout<<maxSum<<' '<<firstNum<<' '<<lastNum;\n\t}\n\n\tdelete nums;\n\n\treturn 0;\n}\n```\n\n\n\n## 1008 Elevator (20)\n\n**题目描述**\n\n> The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n> For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\n**输入描述**\n\n> Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\n**输出描述**\n\n> For each test case, print the total time on a single line.\n\n**输入例子**\n\n> 3 2 3 1\n\n**输出例子**\n\n> 41\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 0, b, n, re = 0;\n    cin >> n;\n    while (n--) {\n        cin >> b;\n        if (b > a) {\n            re+=((b-a)*6);\n        } else {\n            re+=((a-b)*4);\n        }\n        re+=5;\n        a = b;\n    }\n    cout<<re;\n    return 0;\n}\n```\n\n\n\n## 1009 Product of Polynomials (25)\n\n**题目描述**\n\n> This time, you are supposed to find A*B where A and B are two polynomials.\n\n**输入描述**\n\n> Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\n> K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively.  It is given that 1 <= K <= 10, 0 <= NK < ... < N2 < N1 <=1000.\n\n**输出描述**\n\n> For each test case you should output the product of A and B in one line, with the same format as the input.  Notice that there must be NO extra space at the end of each line.  Please be accurate up to 1 decimal place.\n\n**输入例子**\n\n> 2 1 2.4 0 3.2\n> 2 2 1.5 1 0.5\n\n**输出例子**\n\n> 3 3 3.6 2 6.0 1 1.6\n\n**实现代码**\n\n把[1002 A+B for Polynomials (25)](#1002-A-B-for-Polynomials-25)稍微改一下就好。\n\n使用`float`虽然算出来明明是对的但是过不了牛客的测试，全部换成`double`就好了，不知道是什么问题。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n\tint n;\n\tdouble value;\n\titem(int a, double b) {n=a,value=b;}\n};\n\nint main() {\n\tvector<item> polynomials, result;\n\tint k;\n\n\tcin>>k;\n\tint tmp_n;\n\tdouble tmp_value;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tpolynomials.push_back(item(tmp_n,tmp_value));\n\t}\n\n\tcin>>k;\n\twhile (k--) {\n\t\tcin>>tmp_n>>tmp_value;\n\t\tfor (int k = 0; k < polynomials.size(); k++) {\n\t\t\tbool hasItem = false;\n\t\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\t\tif (result[i].n == tmp_n+polynomials[k].n) {\n\t\t\t\t\thasItem = true;\n\t\t\t\t\tresult[i].value+=(tmp_value*polynomials[k].value);\n\t\t\t\t\tif (result[i].value == 0)\n\t\t\t\t\t\tresult.erase(result.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\tif (!hasItem) result.push_back(item(tmp_n+polynomials[k].n,tmp_value*polynomials[k].value));\n\t\t}\n\t}\n\n\tfor (int k = 0; k < result.size(); k++) {\n\t\tfor (int i = 0; i < result.size()-1; i++) {\n\t\t\tif (result[i].n < result[i+1].n) {\n\t\t\t\titem tmp_item = result[i];\n\t\t\t\tresult[i] = result[i+1];\n\t\t\t\tresult[i+1] = tmp_item;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<result.size();\n\tfor (int i = 0; i < result.size(); i++)\n\t\tprintf(\" %d %.1f\", result[i].n, result[i].value);\n\n\treturn 0;\n}\n```\n\n\n\n## 1015 Reversible Primes (20)\n\n**题目描述**\n\n> A *reversible prime*\n>  in any number system is a prime whose \"reverse\" in that\n> number system is also a prime. For example in the decimal system 73 is a\n> reversible prime because its reverse 37 is also a prime.\n>\n> \n>\n> Now given any two positive integers N (< 105\n> ) and D (1 < D <= 10), you are supposed to tell if N is a\n> reversible prime with radix D.\n\n**输入描述**\n\n> The input file consists of several test cases.  Each case occupies a line which contains two integers N and D.  The input is finished by a negative N.\n\n**输出描述**\n\n> For each test case, print in one line \"Yes\" if N is a reversible prime with radix D, or \"No\" if not.\n\n**输入例子**\n\n> 73 10\n> 23 2\n> 23 10\n> -2\n\n**输出例子**\n\n> Yes\n> Yes\n> No\n\n**实现代码**\n\n求N以及N在D进制下反转后是否均为质数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint reverseWithRadix(int n, int d) {\n\tvector<int> remainers;\n\twhile (n > 0) {\n\t\tremainers.push_back(n%d);\n\t\tn/=d;\n\t}\n\tint re = 0;\n\tint bit_count = remainers.size();\n\tfor (int i = 0; i < bit_count; i++)\n\t\tre+=(pow(d,bit_count-i-1)*remainers[i]);\n\treturn re;\n}\n\nbool isPrime(int n) {\n\tif (n == 1) return false;\n\tif (n < 4) return true;\n\tif (n % 2 == 0) return false;\n\tint sqrt_n = sqrt(n) + 1;\n\tfor (int i = 3; i <= sqrt_n; i+=2) {\n\t\tif (n % i == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n,d;\n\twhile (1) {\n\t\tcin>>n;\n\t\tif (n < 0) break;\n\t\tcin>>d;\n\t\tif (isPrime(n) && isPrime(reverseWithRadix(n,d))) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n## 1020 Tree Traversals (25)\n\n**题目描述**\n\n> Suppose that all the keys in a binary tree are distinct positive integers.  Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line gives a positive integer N (<=30), the total number of nodes in the binary tree.  The second line gives the **postorder** sequence and the third line gives the **inorder** sequence.  All the numbers in a line are separated by a space.\n\n**输出描述**\n\n> For each test case, print in one line the level order traversal sequence of the corresponding binary tree.  All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> 7\n> 2 3 1 5 7 6 4\n> 1 2 3 4 5 6 7\n\n**输出例子**\n\n> 4 1 6 3 5 7 2\n\npostorder: 后序遍历\n\ninorder: 中序遍历\n\nlevel order: 层序遍历（从根开始,依次向下,对于每一层从左向右遍历）\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nstruct node\n{\n\tnode* left;\n\tnode* right;\n\tint value;\n};\n\n\nnode* binaryTreeRoot(int* postorder, int* inorder, int len) {\n\tif (len <= 0) return NULL;\n\n\tnode* root = new node;\n\troot->value = *(postorder+len-1);\n\n\tint pos = 0;\n\tfor (; pos < len; pos++)\n\t\tif (*(inorder+pos) == root->value) break;\n\n\troot->left = binaryTreeRoot(postorder, inorder, pos);\n\tint rightLen = len - pos - 1;\n\troot->right = binaryTreeRoot(postorder+pos, inorder+pos+1, rightLen);\n\n\treturn root;\n}\n\nvoid deleteNodes(node* root) {\n\tif (root == NULL) return;\n\tdeleteNodes(root->left);\n\tdeleteNodes(root->right);\n\tdelete root;\n}\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint* postorderNodes = new int[n];\n\tint* inorderNodes = new int[n];\n\tfor (int i = 0; i < n; i++) cin>>postorderNodes[i];\n\tfor (int i = 0; i < n; i++) cin>>inorderNodes[i];\n\n\tnode* root = binaryTreeRoot(postorderNodes, inorderNodes, n);\n\tif (!root) return 0;\n\n\tqueue<node*> levelNodes;\n\tlevelNodes.push(root);\n\twhile (1) {\n\t\tnode* tmp = levelNodes.front();\n\t\tif (tmp->left) levelNodes.push(tmp->left);\n\t\tif (tmp->right) levelNodes.push(tmp->right);\n\t\tcout<<tmp->value;\n\t\tlevelNodes.pop();\n\t\tif (!levelNodes.empty()) cout<<' ';\n\t\telse break;\n\t}\n\n\tdeleteNodes(root);\n\tdelete postorderNodes;\n\tdelete inorderNodes;\n\n\treturn 0;\n}\n```\n\n\n\n## 1023 Have Fun with Numbers (20)\n\n**题目描述**\n\n> Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication.  Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation.  Check to see the result if we double it again!\n>\n> Now you are suppose to check if there are more numbers with this property.  That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains one positive integer with no more than 20 digits.\n\n**输出描述**\n\n> For each test case, first print in a line \"Yes\" if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or \"No\" if not.  Then in the next line, print the doubled number.\n\n**输入例子**\n\n> 1234567899\n\n**输出例子**\n\n> Yes\n> 2469135798\n\n**实现代码**\n\n若双倍后多一位则为No;\n\n使用`digit_count[i]`保存数字`i`（0-9）的个数，\n\n再减去双倍后各个数字的个数，若每一个`digit_count[i]`均为0则为Yes,否则为No。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\n\n\nint main() {\n\tint digit_count[10];\n\tfor (int i = 0; i < 10; i++) digit_count[i] = 0;\n\tstring s;\n\tcin>>s;\n\tint k = s.size();\n\tvector<int> digits;\n\tfor (int i = 0; i < k; i++) {\n\t\tint digit = s[i]-'0';\n\t\tdigits.push_back(digit);\n\t\tdigit_count[digit]++;\n\t}\n\tint carry = 0;\n\tfor (int i = k-1; i >= 0; i--) {\n\t\tdigits[i] = 2*digits[i] + carry;\n\t\tcarry = digits[i] / 10;\n\t\tdigits[i] %= 10;\n\t\tdigit_count[digits[i]]--;\n\t}\n\tif (carry) {\n\t\tcout<<\"No\\n\"<<carry;\n\t\tfor (int i = 0; i < k; i++) cout<<digits[i];\n\t\treturn 0;\n\t}\n\tbool result = true;\n\tfor (int i = 0; i < 10; i++)\n\t\tif (digit_count[i] != 0) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\tif (result) cout<<\"Yes\\n\";\n\telse cout<<\"No\\n\";\n\tfor (int i = 0; i < k; i++) cout<<digits[i];\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n## 1027 Colors in Mars (20)\n\n**题目描述**\n\n> People in Mars represent the colors in their computers in a similar way as the Earth people.  That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits  for Blue.  The only difference is that they use radix 13 (0-9 and A-C) instead of 16.  Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.\n\n**输入描述**\n\n> Each input file contains one test case which occupies a line containing the three decimal color values.\n\n**输出描述**\n\n> For each test case you should output the Mars RGB value in the following format: first output \"#\", then followed by a 6-digit number where all the English characters must be upper-cased.  If a single color is only 1-digit long, you must print a \"0\" to the left.\n\n**输入例子**\n\n> 15 43 71\n\n**输出例子**\n\n> \\#123456\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    cout<<'#';\n    int n;\n    for (int i = 0; i < 3; i++) {\n        cin>>n;\n        int tmp = n/13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n        tmp = n%13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n    }\n    return 0;\n}\n```\n\n\n\n## 1028 List Sorting (25)\n\n**题目描述**\n\n> Excel can sort records according to any column.  Now you are supposed to imitate this function.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains two integers N (<=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with.  Then N lines follow, each contains a record of a student.  A student's record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).\n\n**输出描述**\n\n> For each test case, output the sorting result in N lines.  That is, if C = 1 then the records must be sorted in increasing order according to ID's; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades.  **If there are several students who have the same name or grade, they must be sorted according to their ID's in increasing order.**\n\n**输入例子**\n\n> 3 1\n> 000007 James 85\n> 000010 Amy 90\n> 000001 Zoe 60\n\n**输出例子**\n\n> 000001 Zoe 60\n> 000007 James 85\n> 000010 Amy 90\n\n**实现代码**\n\n利用结构体，使用sort函数排序。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct student\n{\n\tstring id;\n\tstring name;\n\tint grade;\n\tstudent(string i, string n, int g) {id = i, name = n, grade = g;}\n};\n\nbool cmp1(student a, student b) {\n\treturn a.id < b.id;\n}\n\nbool cmp2(student a, student b) {\n\treturn (a.name == b.name)?(a.id < b.id):(a.name < b.name);\n}\n\nbool cmp3(student a, student b) {\n\treturn (a.grade == b.grade)?(a.id < b.id):(a.grade < b.grade);\n}\n\nint main() {\n\tint n,c;\n\tcin>>n>>c;\n\tvector<student> students;\n\n\tstring id,name;\n\tint grade;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>id>>name>>grade;\n\t\tstudents.push_back(student(id,name,grade));\n\t}\n\n\tif (c == 1) sort(students.begin(),students.end(),cmp1);\n\telse if (c == 2) sort(students.begin(),students.end(),cmp2);\n\telse sort(students.begin(),students.end(),cmp3);\n\n\tif (n > 0) cout<<students[0].id<<' '<<students[0].name<<' '<<students[0].grade;\n\tfor (int i = 1; i < n; i++) {\n\t\tcout<<\"\\n\"<<students[i].id<<' '<<students[i].name<<' '<<students[i].grade;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1029 Median (25)\n\n**题目描述**\n\n> Given an increasing sequence S of N integers, the *median* is the number at the middle position.  For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15.  The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences.  For example, the median of S1 and S2 is 13.\n> Given two increasing sequences of integers, you are asked to find their median.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case occupies 2 lines, each gives the information of a sequence.  For each sequence, the first positive integer N (<=1000000) is the size of that sequence.  Then N integers follow, separated by a space.  It is guaranteed that all the integers are in the range of **long int**.\n\n**输出描述**\n\n> For each test case you should output the median of the two given sequences in a line.\n\n**输入例子**\n\n> 4 11 12 13 14\n> 5 9 10 15 16 17\n\n**输出例子**\n\n> 13\n\n**实现代码**\n\n用两个数组存储两组数据，每组数据一个pos，比较两个pos出的数值大小，较小值的pos向后移，直到找到中位数。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n\tint m,n;\n\tcin>>m;\n\tint* firstSequence = new int[m];\n\tfor (int i = 0; i < m; i++) cin>>firstSequence[i];\n\tcin>>n;\n\tint* secondSequence = new int[n];\n\tfor (int i = 0; i < n; i++) cin>>secondSequence[i];\n\n\tint firstPos = 0, secondPos = 0;\n\tfor (int i = int((m+n+1)/2); i > 0; i--) {\n\t\tif (i == 1) {\n\t\t\tif (firstPos == m) cout<<secondSequence[secondPos];\n\t\t\telse if (secondPos == n) cout<<firstSequence[firstPos];\n\t\t\telse if (firstSequence[firstPos] < secondSequence[secondPos]) cout<<firstSequence[firstPos];\n\t\t\telse cout<<secondSequence[secondPos];\n\t\t} else {\n\t\t\tif (firstPos == m) secondPos++;\n\t\t\telse if (secondPos == n) firstPos++;\n\t\t\telse if (firstSequence[firstPos] < secondSequence[secondPos]) firstPos++;\n\t\t\telse secondPos++;\n\t\t}\n\t}\n\n\tdelete firstSequence;\n\tdelete secondSequence;\n\n\treturn 0;\n}\n```\n\n\n\n## 1030 Travel Plan (30)\n\n**题目描述**\n\n> A traveler's map gives the distances between cities along the highways, together with the cost of each highway. \n>  Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination.\n>  If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.\n>\n>  DECLARE: The test data in PAT is wrong,we strengthened the test data.If the same code got passed in pat,it may not be able to get passed in NOWCODER,please check your code.(This means that our test data is no problem,I guarantee.)\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (<=500) is the number of cities (and hence the cities are numbered from 0 to N-1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:\n>  City1 City2 Distance Cost\n>\n>  where the numbers are all integers no more than 500, and are separated by a space.\n\n**输出描述**\n\n> For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.\n\n**输入例子**\n\n> 4 5 0 3\n>\n> 0 1 1 20\n>\n> 1 3 2 30\n>\n> 0 3 4 10\n>\n> 0 2 2 20\n>\n> 2 3 1 20\n\n**输出例子**\n\n> 0 2 3 3 40\n\n**实现代码**\n\n最短路问题，用Dijkstra（迪杰斯特拉）算法解即可。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\nstruct highway\n{\n\tint endCity;\n\tint distance;\n\tint cost;\n\thighway(int e, int d, int c) {endCity=e,distance=d,cost=c;}\n};\n\n\nint main() {\n\t// N为城市数，M为公路数，S为开始城市，D为结束城市\n\tint N,M,S,D;\n\tcin>>N>>M>>S>>D;\n\n\t// highways(i) 为与城市i相连的所有公路\n\tvector<vector<highway> > highways(N);\n\tbool* visited = new bool[N];\n\tint* distance = new int[N];\n\tint* cost = new int[N];\n\tint* lastCity = new int[N];\n\tfor (int i = 0; i < N; i++) \n\t\tvisited[i] = false, distance[i] = cost[i] = INT_MAX;\n\n\t// 读入数据，更新highways\n\tint tmp_city_1, tmp_city_2, tmp_distance, tmp_cost;\n\twhile (M--) {\n\t\tcin>>tmp_city_1>>tmp_city_2>>tmp_distance>>tmp_cost;\n\t\thighways[tmp_city_1].push_back(highway(tmp_city_2,tmp_distance,tmp_cost));\n\t\thighways[tmp_city_2].push_back(highway(tmp_city_1,tmp_distance,tmp_cost));\n\t}\n\n\t// dijkstra\n\tint currentCity = S;\n\tvisited[S] = true, distance[S] = cost[S] = 0, lastCity[S] = S;\n\twhile (currentCity != D) {\n\t\tfor (int i = 0; i < highways[currentCity].size(); i++) {\n\t\t\tint tmp_endCity = highways[currentCity][i].endCity, \n\t\t\t\ttmp_distance = highways[currentCity][i].distance,\n\t\t\t\ttmp_cost = highways[currentCity][i].cost;\t\t\t\t\n\t\t\tif (visited[tmp_endCity]) continue;\n\t\t\tif (distance[currentCity] + tmp_distance < distance[tmp_endCity] ||\n\t\t\t\t(distance[currentCity] + tmp_distance == distance[tmp_endCity] && \n\t\t\t\t cost[currentCity] + tmp_cost < cost[tmp_endCity])) {\n\t\t\t\tdistance[tmp_endCity] = distance[currentCity] + tmp_distance;\n\t\t\t\tcost[tmp_endCity] = cost[currentCity] + tmp_cost;\n\t\t\t\tlastCity[tmp_endCity] = currentCity;\n\t\t\t}\n\t\t}\n\t\tint minDistance = INT_MAX;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tif (distance[i] < minDistance) minDistance=distance[i],currentCity = i;\n\t\t}\n\t\t// 添加离起始点最短的点到已访问集\n\t\tvisited[currentCity] = true;\n\t}\n\n\t// 逆序列逆向输出即为最短路径\n\tstack<int> pathStack;\n\tpathStack.push(D);\n\tcurrentCity = D;\n\twhile (currentCity != S) {\n\t\tcurrentCity = lastCity[currentCity];\n\t\tpathStack.push(currentCity);\n\t}\n\n\twhile (!pathStack.empty()) {\n\t\tcout<<pathStack.top()<<' ';\n\t\tpathStack.pop();\n\t}\n\tcout<<distance[D]<<' '<<cost[D];\n\n\tdelete visited,distance,cost,lastCity;\n\treturn 0;\n}\n\n```\n\n\n\n## 1035 Password (20)\n\n**题目描述**\n\n> To prepare for PAT, the judge sometimes has to generate random passwords for the users.  The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase).  One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o.  Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a positive integer N (<= 1000), followed by N lines of accounts.  Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.\n\n**输出描述**\n\n> For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords.  The accounts must be printed in the same order as they are read in.  If no account is modified, print in one line \"There are N accounts and no account is modified\" where N is the total number of accounts.  However, if N is one, you must print \"There is 1 account and no account is modified\" instead.\n\n**输入例子**\n\n> 3\n> Team000002 Rlsp0dfa\n> Team000003 perfectpwd\n> Team000001 R1spOdfa\n\n**输出例子**\n\n> 2\n> Team000002 RLsp%dfa\n> Team000001 R@spodfa\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct account\n{\n\tstring id;\n\tstring password;\n\taccount(string i, string p) {id = i, password = p;}\n};\n\nint main() {\n\tint n;\n\tcin>>n;\n\tvector<account> result;\n\n\tstring id,password;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>id>>password;\n\t\tif (password.find_first_of('0') == string::npos &&\n\t\t\tpassword.find_first_of('O') == string::npos &&\n\t\t\tpassword.find_first_of('1') == string::npos &&\n\t\t\tpassword.find_first_of('l') == string::npos)\n\t\t\tcontinue;\n\t\tfor (int s = 0; s < password.size(); s++) {\n\t\t\tif (password[s] == '0') password[s] = '%';\n\t\t\tif (password[s] == 'O') password[s] = 'o';\n\t\t\tif (password[s] == '1') password[s] = '@';\n\t\t\tif (password[s] == 'l') password[s] = 'L';\n\t\t}\n\t\tresult.push_back(account(id,password));\n\t}\n\n\tint result_len = result.size();\n\tif (n == 1 && result_len == 0) {\n\t\tcout<<\"There is 1 account and no account is modified\";\n\t} else if (result_len == 0) {\n\t\tcout<<\"There are \"<<n<<\" accounts and no account is modified\";\n\t} else {\n\t\tcout<<result_len;\n\t\tfor (int i = 0; i < result_len; i++) {\n\t\t\tcout<<\"\\n\"<<result[i].id<<' '<<result[i].password;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n\n\n## 1036 Boys vs Girls (25)\n\n**题目描述**\n\n> This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case contains a positive integer N, followed by N lines of student information.  Each line contains a student's name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100.  It is guaranteed that all the grades are distinct.\n\n**输出描述**\n\n> For each test case, output in 3 lines.  The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade.  The third line gives the difference gradeF-gradeM.  If one such kind of student is missing, output \"Absent\" in the corresponding line, and output \"NA\" in the third line instead.\n\n**输入例子**\n\n> 3\n> Joe M Math990112 89\n> Mike M CS991301 100\n> Mary F EE990830 95\n\n**输出例子**\n\n> Mary EE990830\n> Joe Math990112\n> 6\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin>>n;\n\tstring re_male_name, re_male_id;\n\tstring re_female_name, re_female_id;\n\tint re_male_grade = 101, re_female_grade = -1;\n\n\tstring name, gender, id;\n\tint grade;\n\twhile(n--) {\n\t\tcin>>name>>gender>>id>>grade;\n\t\tif (gender==\"M\") {\n\t\t\tif (grade < re_male_grade) {\n\t\t\t\tre_male_name = name;\n\t\t\t\tre_male_id = id;\n\t\t\t\tre_male_grade = grade;\n\t\t\t}\n\t\t} else {\n\t\t\tif (grade > re_female_grade) {\n\t\t\t\tre_female_name = name;\n\t\t\t\tre_female_id = id;\n\t\t\t\tre_female_grade = grade;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re_female_name==\"\") cout<<\"Absent\"<<endl;\n\telse cout<<re_female_name<<' '<<re_female_id<<endl;\n\tif (re_male_name==\"\") cout<<\"Absent\"<<endl;\n\telse cout<<re_male_name<<' '<<re_male_id<<endl;\n\tif (re_female_name==\"\" || re_male_name==\"\") cout<<\"NA\";\n\telse cout<<re_female_grade - re_male_grade;\n\t\n\treturn 0;\n\n}\n```\n\n\n\n## 1037 Magic Coupon (25)\n\n**题目描述**\n\n> The magic shop in Mars is offering some magic coupons.  Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back!  What is more, the shop also offers some bonus product for free.  However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product... but hey, magically, they have some coupons with negative N's! \n> For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M\\$) where a negative value corresponds to a bonus product.  You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back.  On the other hand, if you apply coupon 3 to product 4, you will have to pay M\\$12 to the shop.\n> Each coupon and each product may be selected at most once.  Your task is to get as much money back as possible.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers.  Then the next line contains the number of products NP, followed by a line with NP product values.  Here 1<= NC, NP <= 105, and it is guaranteed that all the numbers will not exceed 230.\n\n**输出描述**\n\n> For each test case, simply print in a line the maximum amount of money you can get back.\n\n**输入例子**\n\n> 4\n> 1 2 4 -1\n> 4\n> 7 6 -2 -3\n\n**输出例子**\n\n> 43\n\n**实现代码**\n\n\n\n\n\n## 1054 The Dominant Color (20)\n\n**题目描述**\n\n> Behind the scenes in the computer's memory, color is always talked about as a series of 24 bits of information for each pixel.  In an image, the color with the largest proportional area is called the dominant color.  **A *strictly* dominant color takes more than half of the total area.**  Now given an image of resolution M by N (for example, 800x600), you are supposed to point out the strictly dominant color.\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains 2 positive numbers: M (<=800) and N (<=600) which are the resolutions of the image.  Then N lines follow, each contains M digital colors in the range [0, 224).  It is guaranteed that the strictly dominant color exists for each input image.  All the numbers in a line are separated by a space.\n\n**输出描述**\n\n> For each test case, simply print the dominant color in a line.\n\n**输入例子**\n\n> 5 3\n> 0 0 255 16777215 24\n> 24 24 0 0 24\n> 24 0 24 24 24\n\n**输出例子**\n\n>  24\n\n首先要注意到dominant color是超过半数的，刚开始只想到了排序后最中间的数一定为结果，但是要存储的数据太多，后来看了[参考链接](https://blog.csdn.net/zhu_liangwei/article/details/9734671)，学会了下边这个方法。\n\n**实现代码**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n, all_count, tmp, re = -1, count = 0;\n    cin>>m>>n;\n    all_count = m*n;\n    while (all_count--) {\n        cin>>tmp;\n        if (count == 0) re = tmp;\n        if (re == tmp) count++;\n        else count--;\n    }\n    cout<<re;\n    return 0;\n}\n```\n\n## 1081 Rational Sum (20)\n\n**题目描述**\n\n> Given N rational numbers in the form \"numerator/denominator\", you are supposed to calculate their sum.\n\n**输入描述**\n\n> Each input file contains one test case. Each case starts with a positive integer N (<=100), followed in the next line N rational numbers \"a1/b1 a2/b2 ...\" where all the numerators and denominators are in the range of \"long int\".  If there is a negative number, then the sign must appear in front of the numerator.\n\n**输出描述**\n\n> For each test case, output the sum in the simplest form \"integer numerator/denominator\" where \"integer\" is the integer part of the sum, \"numerator\" < \"denominator\", and the numerator and the denominator have no common factor.  You must output only the fractional part if the integer part is 0.\n\n**输入例子**\n\n> 5\n> 2/5 4/15 1/30 -2/60 8/3\n\n**输出例子**\n\n> 3 1/3\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    return ((b==0)?abs(a):gcd(b,a%b));\n}\n\nint main() {\n    long long n, tmp_gcd;\n    cin>>n;\n    char c;\n    long long re_integer = 0, re_numerator, re_denominator;\n    cin>>re_numerator>>c>>re_denominator;\n    tmp_gcd = gcd(re_numerator,re_denominator);\n    re_numerator/=tmp_gcd,re_denominator/=tmp_gcd;\n    re_integer += int(re_numerator/re_denominator);\n    re_numerator%=re_denominator;\n    while(--n) {\n        long long tmp_nu, tmp_de, tmp_nu_re, tmp_de_re;\n        cin>>tmp_nu>>c>>tmp_de;\n        tmp_de_re = tmp_de * re_denominator;\n        tmp_nu_re = tmp_nu * re_denominator + tmp_de * re_numerator;\n        tmp_gcd = gcd(tmp_de_re,tmp_nu_re);\n        tmp_de_re/=tmp_gcd,tmp_nu_re/=tmp_gcd;\n        re_integer += int(tmp_nu_re/tmp_de_re);\n        re_numerator = tmp_nu_re % tmp_de_re;\n        re_denominator = tmp_de_re;\n    }\n    if (re_integer == 0 && re_numerator == 0) cout<<0;\n    else if (re_integer == 0) {\n    \tcout<<re_numerator<<'/'<<re_denominator;\n\t} else if (re_numerator == 0) {\n\t\tcout<<re_integer;\n\t} else {\n\t\tcout<<re_integer<<' '<<re_numerator<<'/'<<re_denominator;\n\t}\n    return 0;\n}\n```\n\n\n\n## 1082 Read Number in Chinese (25)\n\n**题目描述**\n\n> Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way.  Output \"Fu\" first if it is negative.  For example, -123456789 is read as \"Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\".  Note: zero (\"ling\") must be handled correctly according to the Chinese tradition.  For example, 100800 is \"yi Shi Wan ling ba Bai\".\n\n**输入描述**\n\n> Each input file contains one test case, which gives an integer with no more than 9 digits.\n\n**输出描述**\n\n> For each test case, print in a line the Chinese way of reading the number.  The characters are separated by a space and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> -123456789\n\n**输出例子**\n\n> Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\n\n**实现代码**\n\n首先按照数字单位的顺序添加到结果容器中，然后遍历结果容器，如果有连续重复的\"ling\"只留一个，如果\"Wan\"前有“ling”去掉0，如果\"Wan\"直接跟在“Yi”后边将“Wan”换成“ling”。\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring units[] = {\"\",\"Shi\",\"Bai\",\"Qian\",\"Wan\",\"Shi\",\"Bai\",\"Qian\",\"Yi\"};\n\tstring digits[] = {\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"};\n\tvector<string> re;\n\tint n;\n\tcin>>n;\n\tif (n < 0) {\n\t\tre.push_back(\"Fu\");\n\t\tn = -n;\n\t}\n\tif (n == 0) {\n\t\tcout<<\"ling\";\n\t\treturn 0;\n\t}\n\tvector<int> n_digits;\n\twhile (n > 0) {\n\t\tn_digits.push_back(n%10);\n\t\tn/=10;\n\t}\n\tint len = n_digits.size();\n\tfor (int i = len-1; i >= 0; i--) {\n\t\tre.push_back(digits[n_digits[i]]);\n\t\tif (i==4 || n_digits[i] != 0 && i>0) re.push_back(units[i]);\n\t}\n\tvector<string>::iterator iter = re.begin()+1;\n\twhile (iter < re.end()) {\n\t\tif (*(iter)==\"ling\" && *(iter-1)==\"ling\")\n\t\t\tre.erase(iter);\n\t\telse if (*(iter)==\"Wan\" && *(iter-1)==\"ling\")\n\t\t\tre.erase((iter--)-1);\n\t\telse if (*(iter)==\"Wan\" && *(iter-1)==\"Yi\")\n\t\t\t*(iter++) = \"ling\";\n\t\telse\n\t\t\titer++;\n\t}\n\tif (re.size()>1 && re[re.size()-1]==\"ling\") re.erase(re.end()-1);\n\tcout<<re[0];\n\tfor (int i = 1; i < re.size(); i++) cout<<' '<<re[i];\n\t\t\n\treturn 0;\n}\n\n```\n\n\n\n## 1083 List Grades (25)\n\n**题目描述**\n\n> Given a list of N student records with name, ID and grade.  You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.\n\n**输入描述**\n\n> Each input file contains one test case.  Each case is given in the following format:\n> N\n> name[1] ID[1] grade[1]\n> name[2] ID[2] grade[2]\n> ... ...\n> name[N] ID[N] grade[N]\n> grade1 grade2\n>\n> where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade's interval.  It is guaranteed that all the grades are *distinct*.\n\n**输出描述**\n\n> For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order.  Each student record occupies a line with the student's name and ID, separated by one space.  If there is no student's grade in that interval, output \"NONE\" instead.\n\n**输入例子**\n\n> 4\n> Tom CS000001 59\n> Joe Math990112 89\n> Mike CS991301 100\n> Mary EE990830 95\n> 60 100\n\n**输出例子**\n\n> Mike CS991301\n> Mary EE990830\n> Joe Math990112\n\n**实现代码**\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n\nstruct student\n{\n\tstring name;\n\tstring id;\n\tint grade;\n\tstudent(string n,string i, int g) {\n\t\tname = n;\n\t\tid = i;\n\t\tgrade = g;\n\t}\n};\n\nint main() {\n\tint n;\n\tcin>>n;\n\tvector<student> re;\n\n\tstring name,id;\n\tint grade;\n\twhile(n--) {\n\t\tcin>>name>>id>>grade;\n\t\tstudent tmp(name,id,grade);\n\t\tre.push_back(tmp);\n\t}\n\tint min_grade,max_grade;\n\tcin>>min_grade>>max_grade;\n\n\tvector<student>::iterator iter = re.begin();\n\twhile (iter != re.end()) {\n\t\tif ((*iter).grade < min_grade || (*iter).grade > max_grade)\n\t\t\tre.erase(iter);\n\t\telse\n\t\t\titer++;\n\t}\n\n\tfor (int k = 0 ; k < re.size(); k++) {\n\t\tfor (int i = 0 ; i < re.size()-1; i++) {\n\t\t\tif (re[i].grade < re[i+1].grade) {\n\t\t\t\tstudent tmp(re[i].name,re[i].id,re[i].grade);\n\t\t\t\tre[i] = re[i+1];\n\t\t\t\tre[i+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (re.empty()) cout<<\"NONE\";\n\telse {\n\t\tcout<<re[0].name<<' '<<re[0].id;\n\t\tfor (int i = 1; i < re.size(); i++)\n\t\t\tcout<<\"\\n\"<<re[i].name<<' '<<re[i].id;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## 1086 Tree Traversals Again (25)\n\n**题目描述**\n\n> An inorder binary tree traversal can be implemented in a non-recursive way with a stack.  For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop().  Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations.  Your task is to give the postorder traversal sequence of this tree.\n>\n> ![](/images/pat_1086.jpg)\n\n**输入描述**\n\n> Each input file contains one test case.  For each case, the first line contains a positive integer N (<=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N).  Then 2N lines follow, each describes a stack operation in the format: \"Push X\" where X is the index of the node being pushed onto the stack; or \"Pop\" meaning to pop one node from the stack.\n\n**输出描述**\n\n> For each test case, print the postorder traversal sequence of the corresponding tree in one line.  A solution is guaranteed to exist.  All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\n\n**输入例子**\n\n> 6\n> Push 1\n> Push 2\n> Push 3\n> Pop\n> Pop\n> Push 4\n> Pop\n> Pop\n> Push 5\n> Push 6\n> Pop\n> Pop\n\n**输出例子**\n\n> 3 4 2 6 5 1\n\n**实现代码**\n\n以上述例子为例，按顺序排下来123456为前序，使用栈的pop顺序为中序，利用前序和中序可以得到后序。\n\n注意1-N为标号，每次push的为值，值有可能重复，但是push顺序为标号1-N。\n\n可以用下边这个测试用例测试：\n\n> //输入\n>\n> 19\n> Push 4\n> Push 11\n> Push 7\n> Push 12\n> Pop\n> Pop\n> Pop\n> Push 14\n> Push 17\n> Pop\n> Pop\n> Push 6\n> Push 18\n> Pop\n> Push 8\n> Pop\n> Pop\n> Push 4\n> Pop\n> Pop\n> Push 11\n> Push 16\n> Push 11\n> Push 12\n> Pop\n> Push 2\n> Pop\n> Pop\n> Pop\n> Push 7\n> Push 4\n> Pop\n> Pop\n> Push 12\n> Pop\n> Pop\n> Push 11\n> Pop\n>\n> // 输出\n>\n> 12 7 17 8 18 4 6 14 11 2 12 11 4 12 7 16 11 11 4 \n\n我的代码如下：\n\n```c++\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<int> post;\nvoid generatePostOrder(vector<int> pre, vector<int> in, int len) {\n\tif (len <= 0) return;\n\tif (len == 1) {\n\t\tpost.push_back(pre[0]);\n\t\treturn;\n\t}\n\tint root_num = pre[0], root_pos_of_in = 0;\n\tfor (; root_pos_of_in < len; root_pos_of_in++) {\n\t\tif (in[root_pos_of_in] == root_num) break;\n\t}\n\tint left_len = root_pos_of_in;\n\tint right_len = len - left_len - 1;\n\tvector<int> pre_left,pre_right,in_left,in_right;\n\tpre_left.assign(pre.begin()+1, pre.begin()+1+left_len);\n\tpre_right.assign(pre.begin()+1+left_len, pre.end());\n\tin_left.assign(in.begin(),in.begin()+left_len);\n\tin_right.assign(in.begin()+left_len+1, in.end());\n\tgeneratePostOrder(pre_left,in_left,left_len);\n\tgeneratePostOrder(pre_right,in_right,right_len);\n\tpost.push_back(root_num);\n}\n\nint main() {\n\tint n, tmp;\n\tcin>>n;\n\tstring op;\n\tvector<int> pre,in,value;\n\tstack<int> tmp_stack;\n\tint index = 0;\n\tfor (int i = 0; i < 2*n; i++) {\n\t\tcin>>op;\n\t\tif (op == \"Push\") {\n\t\t\tcin>>tmp;\n\t\t\tvalue.push_back(tmp);\n\t\t\ttmp_stack.push(index);\n\t\t\tpre.push_back(index++);\n\t\t} else {\n\t\t\tin.push_back(tmp_stack.top());\n\t\t\ttmp_stack.pop();\n\t\t}\n\t}\n\tgeneratePostOrder(pre,in,n);\n\tif (n > 0) cout<<value[post[0]];\n\tfor (int i = 1; i < n; i++) {\n\t\tcout<<\" \"<<value[post[i]];\n\t}\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n## 10xx\n\n**题目描述**\n\n> \n\n**输入描述**\n\n> \n\n**输出描述**\n\n> \n\n**输入例子**\n\n> \n\n**输出例子**\n\n> \n\n**实现代码**\n\n","slug":"PAT刷题记录","published":1,"updated":"2018-10-10T08:39:12.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vp0011fmag0bqqu2l1","content":"<p>OJ：<a href=\"https://www.nowcoder.com/pat\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网</a></p><a id=\"more\"></a><hr><h2 id=\"1001-A-B-Format-20\"><a href=\"#1001-A-B-Format-20\" class=\"headerlink\" title=\"1001 A+B Format (20)\"></a>1001 A+B Format (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>-1000000 9</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>-999,991</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nint main() {\n    int digit[10];\n    for (int i = 0; i < 10; i++) digit[i] = -1;\n    int a,b,re;\n    cin >> a >> b;\n    re = a + b;\n    if (re < 0) {\n        cout<<'-';\n        re = -re;\n    }\n    int i = 0;\n    while(re) {\n        digit[i] = (re%10);\n        re/=10;\n        i++;\n    }\n    for (int k = i-1; k >=0; k--) {\n        cout<<digit[k];\n        if (k%3 == 0 && k>0) cout<<',';\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1002-A-B-for-Polynomials-25\"><a href=\"#1002-A-B-for-Polynomials-25\" class=\"headerlink\" title=\"1002 A+B for Polynomials (25)\"></a>1002 A+B for Polynomials (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time, you are supposed to find A+B where A and B are two polynomials.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br>K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. <strong>Please be accurate to 1 decimal place.</strong></p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 2 1.5 1 2.9 0 3.2</p></blockquote><p><strong>实现代码</strong></p><p>注意保留小数。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n    int n;\n    float value;\n    item(int a, float b) {n=a,value=b;}\n};\n\nint main() {\n    vector<item> polynomials;\n    int k;\n\n    cin>>k;\n    int tmp_n;\n    float tmp_value;\n    while (k--) {\n        cin>>tmp_n>>tmp_value;\n        polynomials.push_back(item(tmp_n,tmp_value));\n    }\n\n    cin>>k;\n    while (k--) {\n        cin>>tmp_n>>tmp_value;\n        bool hasItem = false;\n        for (int i = 0; i < polynomials.size(); i++) {\n            if (polynomials[i].n == tmp_n) {\n                hasItem = true;\n                polynomials[i].value+=tmp_value;\n                if (polynomials[i].value == 0)\n                    polynomials.erase(polynomials.begin()+i);\n                break;\n            }\n        }        \n        if (!hasItem) polynomials.push_back(item(tmp_n,tmp_value));    \n    }\n\n    for (int k = 0; k < polynomials.size(); k++) {\n        for (int i = 0; i < polynomials.size()-1; i++) {\n            if (polynomials[i].n < polynomials[i+1].n) {\n                item tmp_item = polynomials[i];\n                polynomials[i] = polynomials[i+1];\n                polynomials[i+1] = tmp_item;\n            }\n        }\n    }\n\n    cout<<polynomials.size();\n    for (int i = 0; i < polynomials.size(); i++)\n        printf(\" %d %.1f\", polynomials[i].n, polynomials[i].value);\n\n    return 0;\n}\n</code></pre><h2 id=\"1003-Emergency-25\"><a href=\"#1003-Emergency-25\" class=\"headerlink\" title=\"1003 Emergency (25)\"></a>1003 Emergency (25)</h2><p><strong>题目描述</strong></p><blockquote><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively.<br>It is guaranteed that there exists at least one path from C1 to C2.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.</p><p>All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>2 4</p></blockquote><p><strong>实现代码</strong></p><p>dijkstra最短路</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nstruct road\n{\n    int endCity;\n    int length;\n    road(int e, int l) {endCity = e, length = l;}\n};\n\n\nint main() {\n    int n,m,c1,c2;\n    cin>>n>>m>>c1>>c2;\n    vector<int> teamsCount;\n\n    int tmp1,tmp2,tmp3;\n    for (int i = 0; i < n; i++) {\n        cin>>tmp1;\n        teamsCount.push_back(tmp1);\n    }\n\n    vector<vector<road> > roads(n);\n    for (int i = 0; i < m; i++) {\n        cin>>tmp1>>tmp2>>tmp3;\n        roads[tmp1].push_back(road(tmp2,tmp3));\n        roads[tmp2].push_back(road(tmp1,tmp3));\n    }\n\n    vector<int> maxTeams(n);\n    for (int i = 0; i < n; i++) maxTeams[i] = 0;\n    maxTeams[c1] = teamsCount[c1];\n\n    vector<int> minLen(n);\n    for (int i = 0; i < n; i++) minLen[i] = INT_MAX;\n    minLen[c1] = 0;\n\n    int currentCity = c1;\n    vector<int> minLenRoadCount(n);\n    for (int i = 0; i < n; i++) minLenRoadCount[i] = 1;\n\n    vector<bool> visited(n);\n    for (int i = 0; i < n; i++) visited[i] = false;\n    visited[c1] = true;\n    while (currentCity != c2) {\n        int len = roads[currentCity].size();\n        for (int i = 0; i < len; i++) {\n            if (visited[roads[currentCity][i].endCity]) continue;\n            int endCity = roads[currentCity][i].endCity;\n            int length = roads[currentCity][i].length;\n            if (minLen[endCity] > minLen[currentCity] + length) {\n                minLen[endCity] = minLen[currentCity] + length;\n                minLenRoadCount[endCity] = 1;\n                maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n            } else if (minLen[endCity] == minLen[currentCity] + length) {\n                minLenRoadCount[endCity]++;\n                if (maxTeams[endCity] < maxTeams[currentCity] + teamsCount[endCity])\n                    maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n            }\n        }\n\n        int min = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) continue;\n            if (minLen[i] < min) {\n                min = minLen[i];\n                currentCity = i;\n            }\n        }\n        visited[currentCity] = true;\n    }\n\n    cout<<minLenRoadCount[c2]<<' '<<maxTeams[c2];\n\n    return 0;\n}\n</code></pre><h2 id=\"1004-Counting-Leaves-30\"><a href=\"#1004-Counting-Leaves-30\" class=\"headerlink\" title=\"1004 Counting Leaves (30)\"></a>1004 Counting Leaves (30)</h2><p><strong>题目描述</strong></p><blockquote><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:</p><p>ID K ID[1] ID[2] … ID[K]</p><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, you are supposed to count those family members who have no child <strong>for every seniority level</strong> starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.<br>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1<br>01 1 02</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>0 1</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n#define MAX_NODES 100\n\nstruct node\n{\n    int id = -1;\n    int childs_count = 0;\n    vector<int> childs;\n};\n\nint main() {\n    int n,m;\n    cin>>n>>m;\n    node nodes[MAX_NODES];\n\n    int id,k,tmp;\n    while (m--) {\n        cin>>id>>k;\n        nodes[id].id = id;\n        nodes[id].childs_count = k;\n        while (k--) {\n            cin>>tmp;\n            (nodes[id].childs).push_back(tmp);\n        }\n    }\n\n    vector<int> this_level, next_level;\n    this_level.push_back(1);\n    while (1) {\n        int count_output = 0;\n        for (int i = 0; i < this_level.size(); i++) {\n            if (nodes[this_level[i]].childs_count == 0) count_output++;\n            else next_level.insert(next_level.begin(),nodes[this_level[i]].childs.begin(),nodes[this_level[i]].childs.end());\n        }\n        cout<<count_output;\n        if (next_level.empty()) break;\n        cout<<' ';\n        this_level = next_level;\n        next_level.clear();\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1005-Spell-It-Right-20\"><a href=\"#1005-Spell-It-Right-20\" class=\"headerlink\" title=\"1005 Spell It Right (20)\"></a>1005 Spell It Right (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10^100).</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>12345</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>one five</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string n;\n    cin>>n;\n    int len = n.size();\n    int re = 0;\n    for (int i = 0; i < len; i++) re+=(n[i]-'0');\n    string english[10] = {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\n    int digit[100], re_len = 0;\n    while (re) {\n        digit[re_len] = (re%10);\n        re/=10;\n        re_len++;\n    }\n    for (int i = re_len-1; i >= 0; i--) {\n        cout<<english[digit[i]];\n        if (i != 0) cout<<' ';\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1006-Sign-In-and-Sign-Out-25\"><a href=\"#1006-Sign-In-and-Sign-Out-25\" class=\"headerlink\" title=\"1006 Sign In and Sign Out (25)\"></a>1006 Sign In and Sign Out (25)</h2><p><strong>题目描述</strong></p><blockquote><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p><p>ID_number Sign_in_time Sign_out_time</p><p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.<br>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>SC3021234 CS301133</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <string>\nusing namespace std;\n\nbool a_larger_than_b(string a, string b) {\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] < b[i]) return false;\n        if (a[i] > b[i]) return true;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    string id,in,out;\n    string result_in_id, result_in_time, result_out_id, result_out_time;\n    cin>>id>>in>>out;\n    result_in_id = result_out_id = id;\n    result_in_time = in;\n    result_out_time = out;\n    n--;\n    while (n--) {\n        cin>>id>>in>>out;\n        if (a_larger_than_b(result_in_time,in)) {\n            result_in_id = id;\n            result_in_time = in;\n        }\n        if (a_larger_than_b(out,result_out_time)) {\n            result_out_id = id;\n            result_out_time = out;\n        }\n    }\n    cout<<result_in_id<<' '<<result_out_id;\n    return 0;\n}\n</code></pre><h2 id=\"1007-Maximum-Subsequence-Sum-25\"><a href=\"#1007-Maximum-Subsequence-Sum-25\" class=\"headerlink\" title=\"1007 Maximum Subsequence Sum (25)\"></a>1007 Maximum Subsequence Sum (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a sequence of K integers { N1<br>, N2<br>, …, NK<br>}. A continuous subsequence is defined to be { Ni<br>, Ni+1<br>, …, Nj<br>} where 1 &lt;= i &lt;= j &lt;= K. The <em>Maximum Subsequence</em><br>is the continuous subsequence which has the largest sum of its<br>elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its<br>maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first<br>and the last numbers of the maximum subsequence.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>10<br>-10 1 2 3 4 -5 -23 3 7 -21</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>10 1 4</p></blockquote><p><strong>实现代码</strong></p><p><u>和为负的子序列一定不会是最大和子序列的开头。</u></p><p>当当前和小于0时，使用临时”first number”记录下一个数，</p><p>更新最大和时，当前数为“last number”， 临时“first number”中存储的值为“first number”的值。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n    int n;\n    cin>>n;\n    int* nums = new int[n];\n    bool allNegative = true;\n\n    for (int i = 0; i < n; i++) {\n        cin>>nums[i];\n        if (nums[i] >= 0) allNegative = false;\n    }\n\n    if (allNegative) {\n        cout<<0<<' '<<nums[0]<<' '<<nums[n-1];\n    } else {\n        int maxSum = 0, currentSum = 0;\n        int firstNum = nums[0], lastNum = nums[0];\n        int firstNumCurrent = firstNum;\n        for (int i = 0; i < n; i++) {\n            currentSum+=nums[i];\n            if (currentSum < 0) {\n                currentSum = 0;\n                firstNumCurrent = nums[i+1];\n            } else if (currentSum > maxSum) {\n                maxSum = currentSum;\n                firstNum = firstNumCurrent;\n                lastNum = nums[i];\n            }\n        }\n        cout<<maxSum<<' '<<firstNum<<' '<<lastNum;\n    }\n\n    delete nums;\n\n    return 0;\n}\n</code></pre><h2 id=\"1008-Elevator-20\"><a href=\"#1008-Elevator-20\" class=\"headerlink\" title=\"1008 Elevator (20)\"></a>1008 Elevator (20)</h2><p><strong>题目描述</strong></p><blockquote><p>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.<br>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print the total time on a single line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3 2 3 1</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>41</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 0, b, n, re = 0;\n    cin >> n;\n    while (n--) {\n        cin >> b;\n        if (b > a) {\n            re+=((b-a)*6);\n        } else {\n            re+=((a-b)*4);\n        }\n        re+=5;\n        a = b;\n    }\n    cout<<re;\n    return 0;\n}\n</code></pre><h2 id=\"1009-Product-of-Polynomials-25\"><a href=\"#1009-Product-of-Polynomials-25\" class=\"headerlink\" title=\"1009 Product of Polynomials (25)\"></a>1009 Product of Polynomials (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time, you are supposed to find A*B where A and B are two polynomials.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br>K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 3 3.6 2 6.0 1 1.6</p></blockquote><p><strong>实现代码</strong></p><p>把<a href=\"#1002-A-B-for-Polynomials-25\">1002 A+B for Polynomials (25)</a>稍微改一下就好。</p><p>使用<code>float</code>虽然算出来明明是对的但是过不了牛客的测试，全部换成<code>double</code>就好了，不知道是什么问题。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\nstruct item\n{\n    int n;\n    double value;\n    item(int a, double b) {n=a,value=b;}\n};\n\nint main() {\n    vector<item> polynomials, result;\n    int k;\n\n    cin>>k;\n    int tmp_n;\n    double tmp_value;\n    while (k--) {\n        cin>>tmp_n>>tmp_value;\n        polynomials.push_back(item(tmp_n,tmp_value));\n    }\n\n    cin>>k;\n    while (k--) {\n        cin>>tmp_n>>tmp_value;\n        for (int k = 0; k < polynomials.size(); k++) {\n            bool hasItem = false;\n            for (int i = 0; i < result.size(); i++) {\n                if (result[i].n == tmp_n+polynomials[k].n) {\n                    hasItem = true;\n                    result[i].value+=(tmp_value*polynomials[k].value);\n                    if (result[i].value == 0)\n                        result.erase(result.begin()+i);\n                    break;\n                }\n            }        \n            if (!hasItem) result.push_back(item(tmp_n+polynomials[k].n,tmp_value*polynomials[k].value));\n        }\n    }\n\n    for (int k = 0; k < result.size(); k++) {\n        for (int i = 0; i < result.size()-1; i++) {\n            if (result[i].n < result[i+1].n) {\n                item tmp_item = result[i];\n                result[i] = result[i+1];\n                result[i+1] = tmp_item;\n            }\n        }\n    }\n\n    cout<<result.size();\n    for (int i = 0; i < result.size(); i++)\n        printf(\" %d %.1f\", result[i].n, result[i].value);\n\n    return 0;\n}\n</code></pre><h2 id=\"1015-Reversible-Primes-20\"><a href=\"#1015-Reversible-Primes-20\" class=\"headerlink\" title=\"1015 Reversible Primes (20)\"></a>1015 Reversible Primes (20)</h2><p><strong>题目描述</strong></p><blockquote><p>A <em>reversible prime</em><br>in any number system is a prime whose “reverse” in that<br>number system is also a prime. For example in the decimal system 73 is a<br>reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers N (&lt; 105<br>) and D (1 &lt; D &lt;= 10), you are supposed to tell if N is a<br>reversible prime with radix D.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line “Yes” if N is a reversible prime with radix D, or “No” if not.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>73 10<br>23 2<br>23 10<br>-2</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Yes<br>Yes<br>No</p></blockquote><p><strong>实现代码</strong></p><p>求N以及N在D进制下反转后是否均为质数。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint reverseWithRadix(int n, int d) {\n    vector<int> remainers;\n    while (n > 0) {\n        remainers.push_back(n%d);\n        n/=d;\n    }\n    int re = 0;\n    int bit_count = remainers.size();\n    for (int i = 0; i < bit_count; i++)\n        re+=(pow(d,bit_count-i-1)*remainers[i]);\n    return re;\n}\n\nbool isPrime(int n) {\n    if (n == 1) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0) return false;\n    int sqrt_n = sqrt(n) + 1;\n    for (int i = 3; i <= sqrt_n; i+=2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n,d;\n    while (1) {\n        cin>>n;\n        if (n < 0) break;\n        cin>>d;\n        if (isPrime(n) && isPrime(reverseWithRadix(n,d))) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n    return 0;\n}\n\n</code></pre><h2 id=\"1020-Tree-Traversals-25\"><a href=\"#1020-Tree-Traversals-25\" class=\"headerlink\" title=\"1020 Tree Traversals (25)\"></a>1020 Tree Traversals (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the <strong>postorder</strong> sequence and the third line gives the <strong>inorder</strong> sequence. All the numbers in a line are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>7<br>2 3 1 5 7 6 4<br>1 2 3 4 5 6 7</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>4 1 6 3 5 7 2</p></blockquote><p>postorder: 后序遍历</p><p>inorder: 中序遍历</p><p>level order: 层序遍历（从根开始,依次向下,对于每一层从左向右遍历）</p><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nstruct node\n{\n    node* left;\n    node* right;\n    int value;\n};\n\n\nnode* binaryTreeRoot(int* postorder, int* inorder, int len) {\n    if (len <= 0) return NULL;\n\n    node* root = new node;\n    root->value = *(postorder+len-1);\n\n    int pos = 0;\n    for (; pos < len; pos++)\n        if (*(inorder+pos) == root->value) break;\n\n    root->left = binaryTreeRoot(postorder, inorder, pos);\n    int rightLen = len - pos - 1;\n    root->right = binaryTreeRoot(postorder+pos, inorder+pos+1, rightLen);\n\n    return root;\n}\n\nvoid deleteNodes(node* root) {\n    if (root == NULL) return;\n    deleteNodes(root->left);\n    deleteNodes(root->right);\n    delete root;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    int* postorderNodes = new int[n];\n    int* inorderNodes = new int[n];\n    for (int i = 0; i < n; i++) cin>>postorderNodes[i];\n    for (int i = 0; i < n; i++) cin>>inorderNodes[i];\n\n    node* root = binaryTreeRoot(postorderNodes, inorderNodes, n);\n    if (!root) return 0;\n\n    queue<node*> levelNodes;\n    levelNodes.push(root);\n    while (1) {\n        node* tmp = levelNodes.front();\n        if (tmp->left) levelNodes.push(tmp->left);\n        if (tmp->right) levelNodes.push(tmp->right);\n        cout<<tmp->value;\n        levelNodes.pop();\n        if (!levelNodes.empty()) cout<<' ';\n        else break;\n    }\n\n    deleteNodes(root);\n    delete postorderNodes;\n    delete inorderNodes;\n\n    return 0;\n}\n</code></pre><h2 id=\"1023-Have-Fun-with-Numbers-20\"><a href=\"#1023-Have-Fun-with-Numbers-20\" class=\"headerlink\" title=\"1023 Have Fun with Numbers (20)\"></a>1023 Have Fun with Numbers (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains one positive integer with no more than 20 digits.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>1234567899</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Yes<br>2469135798</p></blockquote><p><strong>实现代码</strong></p><p>若双倍后多一位则为No;</p><p>使用<code>digit_count[i]</code>保存数字<code>i</code>（0-9）的个数，</p><p>再减去双倍后各个数字的个数，若每一个<code>digit_count[i]</code>均为0则为Yes,否则为No。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\n\n\nint main() {\n    int digit_count[10];\n    for (int i = 0; i < 10; i++) digit_count[i] = 0;\n    string s;\n    cin>>s;\n    int k = s.size();\n    vector<int> digits;\n    for (int i = 0; i < k; i++) {\n        int digit = s[i]-'0';\n        digits.push_back(digit);\n        digit_count[digit]++;\n    }\n    int carry = 0;\n    for (int i = k-1; i >= 0; i--) {\n        digits[i] = 2*digits[i] + carry;\n        carry = digits[i] / 10;\n        digits[i] %= 10;\n        digit_count[digits[i]]--;\n    }\n    if (carry) {\n        cout<<\"No\\n\"<<carry;\n        for (int i = 0; i < k; i++) cout<<digits[i];\n        return 0;\n    }\n    bool result = true;\n    for (int i = 0; i < 10; i++)\n        if (digit_count[i] != 0) {\n            result = false;\n            break;\n        }\n    if (result) cout<<\"Yes\\n\";\n    else cout<<\"No\\n\";\n    for (int i = 0; i < k; i++) cout<<digits[i];\n\n    return 0;\n}\n\n</code></pre><h2 id=\"1027-Colors-in-Mars-20\"><a href=\"#1027-Colors-in-Mars-20\" class=\"headerlink\" title=\"1027 Colors in Mars (20)\"></a>1027 Colors in Mars (20)</h2><p><strong>题目描述</strong></p><blockquote><p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case which occupies a line containing the three decimal color values.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the Mars RGB value in the following format: first output “#”, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a “0” to the left.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>15 43 71</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>#123456</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nint main() {\n    cout<<'#';\n    int n;\n    for (int i = 0; i < 3; i++) {\n        cin>>n;\n        int tmp = n/13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n        tmp = n%13;\n        if (tmp > 9) cout<<char((tmp-10)+'A');\n        else cout<<tmp;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1028-List-Sorting-25\"><a href=\"#1028-List-Sorting-25\" class=\"headerlink\" title=\"1028 List Sorting (25)\"></a>1028 List Sorting (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Excel can sort records according to any column. Now you are supposed to imitate this function.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains two integers N (&lt;=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to ID’s; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. <strong>If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.</strong></p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3 1<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>000001 Zoe 60<br>000007 James 85<br>000010 Amy 90</p></blockquote><p><strong>实现代码</strong></p><p>利用结构体，使用sort函数排序。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct student\n{\n    string id;\n    string name;\n    int grade;\n    student(string i, string n, int g) {id = i, name = n, grade = g;}\n};\n\nbool cmp1(student a, student b) {\n    return a.id < b.id;\n}\n\nbool cmp2(student a, student b) {\n    return (a.name == b.name)?(a.id < b.id):(a.name < b.name);\n}\n\nbool cmp3(student a, student b) {\n    return (a.grade == b.grade)?(a.id < b.id):(a.grade < b.grade);\n}\n\nint main() {\n    int n,c;\n    cin>>n>>c;\n    vector<student> students;\n\n    string id,name;\n    int grade;\n    for (int i = 0; i < n; i++) {\n        cin>>id>>name>>grade;\n        students.push_back(student(id,name,grade));\n    }\n\n    if (c == 1) sort(students.begin(),students.end(),cmp1);\n    else if (c == 2) sort(students.begin(),students.end(),cmp2);\n    else sort(students.begin(),students.end(),cmp3);\n\n    if (n > 0) cout<<students[0].id<<' '<<students[0].name<<' '<<students[0].grade;\n    for (int i = 1; i < n; i++) {\n        cout<<\"\\n\"<<students[i].id<<' '<<students[i].name<<' '<<students[i].grade;\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1029-Median-25\"><a href=\"#1029-Median-25\" class=\"headerlink\" title=\"1029 Median (25)\"></a>1029 Median (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given an increasing sequence S of N integers, the <em>median</em> is the number at the middle position. For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.<br>Given two increasing sequences of integers, you are asked to find their median.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (&lt;=1000000) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of <strong>long int</strong>.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the median of the two given sequences in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4 11 12 13 14<br>5 9 10 15 16 17</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>13</p></blockquote><p><strong>实现代码</strong></p><p>用两个数组存储两组数据，每组数据一个pos，比较两个pos出的数值大小，较小值的pos向后移，直到找到中位数。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\n\nint main() {\n    int m,n;\n    cin>>m;\n    int* firstSequence = new int[m];\n    for (int i = 0; i < m; i++) cin>>firstSequence[i];\n    cin>>n;\n    int* secondSequence = new int[n];\n    for (int i = 0; i < n; i++) cin>>secondSequence[i];\n\n    int firstPos = 0, secondPos = 0;\n    for (int i = int((m+n+1)/2); i > 0; i--) {\n        if (i == 1) {\n            if (firstPos == m) cout<<secondSequence[secondPos];\n            else if (secondPos == n) cout<<firstSequence[firstPos];\n            else if (firstSequence[firstPos] < secondSequence[secondPos]) cout<<firstSequence[firstPos];\n            else cout<<secondSequence[secondPos];\n        } else {\n            if (firstPos == m) secondPos++;\n            else if (secondPos == n) firstPos++;\n            else if (firstSequence[firstPos] < secondSequence[secondPos]) firstPos++;\n            else secondPos++;\n        }\n    }\n\n    delete firstSequence;\n    delete secondSequence;\n\n    return 0;\n}\n</code></pre><h2 id=\"1030-Travel-Plan-30\"><a href=\"#1030-Travel-Plan-30\" class=\"headerlink\" title=\"1030 Travel Plan (30)\"></a>1030 Travel Plan (30)</h2><p><strong>题目描述</strong></p><blockquote><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway.<br>Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination.<br>If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><p>DECLARE: The test data in PAT is wrong,we strengthened the test data.If the same code got passed in pat,it may not be able to get passed in NOWCODER,please check your code.(This means that our test data is no problem,I guarantee.)</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (&lt;=500) is the number of cities (and hence the cities are numbered from 0 to N-1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:<br>City1 City2 Distance Cost</p><p>where the numbers are all integers no more than 500, and are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4 5 0 3</p><p>0 1 1 20</p><p>1 3 2 30</p><p>0 3 4 10</p><p>0 2 2 20</p><p>2 3 1 20</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>0 2 3 3 40</p></blockquote><p><strong>实现代码</strong></p><p>最短路问题，用Dijkstra（迪杰斯特拉）算法解即可。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n#include <climits>\nusing namespace std;\n\nstruct highway\n{\n    int endCity;\n    int distance;\n    int cost;\n    highway(int e, int d, int c) {endCity=e,distance=d,cost=c;}\n};\n\n\nint main() {\n    // N为城市数，M为公路数，S为开始城市，D为结束城市\n    int N,M,S,D;\n    cin>>N>>M>>S>>D;\n\n    // highways(i) 为与城市i相连的所有公路\n    vector<vector<highway> > highways(N);\n    bool* visited = new bool[N];\n    int* distance = new int[N];\n    int* cost = new int[N];\n    int* lastCity = new int[N];\n    for (int i = 0; i < N; i++) \n        visited[i] = false, distance[i] = cost[i] = INT_MAX;\n\n    // 读入数据，更新highways\n    int tmp_city_1, tmp_city_2, tmp_distance, tmp_cost;\n    while (M--) {\n        cin>>tmp_city_1>>tmp_city_2>>tmp_distance>>tmp_cost;\n        highways[tmp_city_1].push_back(highway(tmp_city_2,tmp_distance,tmp_cost));\n        highways[tmp_city_2].push_back(highway(tmp_city_1,tmp_distance,tmp_cost));\n    }\n\n    // dijkstra\n    int currentCity = S;\n    visited[S] = true, distance[S] = cost[S] = 0, lastCity[S] = S;\n    while (currentCity != D) {\n        for (int i = 0; i < highways[currentCity].size(); i++) {\n            int tmp_endCity = highways[currentCity][i].endCity, \n                tmp_distance = highways[currentCity][i].distance,\n                tmp_cost = highways[currentCity][i].cost;                \n            if (visited[tmp_endCity]) continue;\n            if (distance[currentCity] + tmp_distance < distance[tmp_endCity] ||\n                (distance[currentCity] + tmp_distance == distance[tmp_endCity] && \n                 cost[currentCity] + tmp_cost < cost[tmp_endCity])) {\n                distance[tmp_endCity] = distance[currentCity] + tmp_distance;\n                cost[tmp_endCity] = cost[currentCity] + tmp_cost;\n                lastCity[tmp_endCity] = currentCity;\n            }\n        }\n        int minDistance = INT_MAX;\n        for (int i = 0; i < N; i++) {\n            if (visited[i]) continue;\n            if (distance[i] < minDistance) minDistance=distance[i],currentCity = i;\n        }\n        // 添加离起始点最短的点到已访问集\n        visited[currentCity] = true;\n    }\n\n    // 逆序列逆向输出即为最短路径\n    stack<int> pathStack;\n    pathStack.push(D);\n    currentCity = D;\n    while (currentCity != S) {\n        currentCity = lastCity[currentCity];\n        pathStack.push(currentCity);\n    }\n\n    while (!pathStack.empty()) {\n        cout<<pathStack.top()<<' ';\n        pathStack.pop();\n    }\n    cout<<distance[D]<<' '<<cost[D];\n\n    delete visited,distance,cost,lastCity;\n    return 0;\n}\n\n</code></pre><h2 id=\"1035-Password-20\"><a href=\"#1035-Password-20\" class=\"headerlink\" title=\"1035 Password (20)\"></a>1035 Password (20)</h2><p><strong>题目描述</strong></p><blockquote><p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N (&lt;= 1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line “There are N accounts and no account is modified” where N is the total number of accounts. However, if N is one, you must print “There is 1 account and no account is modified” instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>Team000002 Rlsp0dfa<br>Team000003 perfectpwd<br>Team000001 R1spOdfa</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>2<br>Team000002 RLsp%dfa<br>Team000001 R@spodfa</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct account\n{\n    string id;\n    string password;\n    account(string i, string p) {id = i, password = p;}\n};\n\nint main() {\n    int n;\n    cin>>n;\n    vector<account> result;\n\n    string id,password;\n    for (int i = 0; i < n; i++) {\n        cin>>id>>password;\n        if (password.find_first_of('0') == string::npos &&\n            password.find_first_of('O') == string::npos &&\n            password.find_first_of('1') == string::npos &&\n            password.find_first_of('l') == string::npos)\n            continue;\n        for (int s = 0; s < password.size(); s++) {\n            if (password[s] == '0') password[s] = '%';\n            if (password[s] == 'O') password[s] = 'o';\n            if (password[s] == '1') password[s] = '@';\n            if (password[s] == 'l') password[s] = 'L';\n        }\n        result.push_back(account(id,password));\n    }\n\n    int result_len = result.size();\n    if (n == 1 && result_len == 0) {\n        cout<<\"There is 1 account and no account is modified\";\n    } else if (result_len == 0) {\n        cout<<\"There are \"<<n<<\" accounts and no account is modified\";\n    } else {\n        cout<<result_len;\n        for (int i = 0; i < result_len; i++) {\n            cout<<\"\\n\"<<result[i].id<<' '<<result[i].password;\n        }\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1036-Boys-vs-Girls-25\"><a href=\"#1036-Boys-vs-Girls-25\" class=\"headerlink\" title=\"1036 Boys vs Girls (25)\"></a>1036 Boys vs Girls (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF-gradeM. If one such kind of student is missing, output “Absent” in the corresponding line, and output “NA” in the third line instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>Joe M Math990112 89<br>Mike M CS991301 100<br>Mary F EE990830 95</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Mary EE990830<br>Joe Math990112<br>6</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin>>n;\n    string re_male_name, re_male_id;\n    string re_female_name, re_female_id;\n    int re_male_grade = 101, re_female_grade = -1;\n\n    string name, gender, id;\n    int grade;\n    while(n--) {\n        cin>>name>>gender>>id>>grade;\n        if (gender==\"M\") {\n            if (grade < re_male_grade) {\n                re_male_name = name;\n                re_male_id = id;\n                re_male_grade = grade;\n            }\n        } else {\n            if (grade > re_female_grade) {\n                re_female_name = name;\n                re_female_id = id;\n                re_female_grade = grade;\n            }\n        }\n    }\n\n    if (re_female_name==\"\") cout<<\"Absent\"<<endl;\n    else cout<<re_female_name<<' '<<re_female_id<<endl;\n    if (re_male_name==\"\") cout<<\"Absent\"<<endl;\n    else cout<<re_male_name<<' '<<re_male_id<<endl;\n    if (re_female_name==\"\" || re_male_name==\"\") cout<<\"NA\";\n    else cout<<re_female_grade - re_male_grade;\n\n    return 0;\n\n}\n</code></pre><h2 id=\"1037-Magic-Coupon-25\"><a href=\"#1037-Magic-Coupon-25\" class=\"headerlink\" title=\"1037 Magic Coupon (25)\"></a>1037 Magic Coupon (25)</h2><p><strong>题目描述</strong></p><blockquote><p>The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s!<br>For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M\\$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M\\$12 to the shop.<br>Each coupon and each product may be selected at most once. Your task is to get as much money back as possible.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here 1&lt;= NC, NP &lt;= 105, and it is guaranteed that all the numbers will not exceed 230.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, simply print in a line the maximum amount of money you can get back.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4<br>1 2 4 -1<br>4<br>7 6 -2 -3</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>43</p></blockquote><p><strong>实现代码</strong></p><h2 id=\"1054-The-Dominant-Color-20\"><a href=\"#1054-The-Dominant-Color-20\" class=\"headerlink\" title=\"1054 The Dominant Color (20)\"></a>1054 The Dominant Color (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. <strong>A <em>strictly</em> dominant color takes more than half of the total area.</strong> Now given an image of resolution M by N (for example, 800x600), you are supposed to point out the strictly dominant color.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (&lt;=800) and N (&lt;=600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0, 224). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, simply print the dominant color in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5 3<br>0 0 255 16777215 24<br>24 24 0 0 24<br>24 0 24 24 24</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>24</p></blockquote><p>首先要注意到dominant color是超过半数的，刚开始只想到了排序后最中间的数一定为结果，但是要存储的数据太多，后来看了<a href=\"https://blog.csdn.net/zhu_liangwei/article/details/9734671\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>，学会了下边这个方法。</p><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\nusing namespace std;\n\nint main() {\n    int m, n, all_count, tmp, re = -1, count = 0;\n    cin>>m>>n;\n    all_count = m*n;\n    while (all_count--) {\n        cin>>tmp;\n        if (count == 0) re = tmp;\n        if (re == tmp) count++;\n        else count--;\n    }\n    cout<<re;\n    return 0;\n}\n</code></pre><h2 id=\"1081-Rational-Sum-20\"><a href=\"#1081-Rational-Sum-20\" class=\"headerlink\" title=\"1081 Rational Sum (20)\"></a>1081 Rational Sum (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Given N rational numbers in the form “numerator/denominator”, you are supposed to calculate their sum.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a positive integer N (&lt;=100), followed in the next line N rational numbers “a1/b1 a2/b2 …” where all the numerators and denominators are in the range of “long int”. If there is a negative number, then the sign must appear in front of the numerator.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output the sum in the simplest form “integer numerator/denominator” where “integer” is the integer part of the sum, “numerator” &lt; “denominator”, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5<br>2/5 4/15 1/30 -2/60 8/3</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 1/3</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    return ((b==0)?abs(a):gcd(b,a%b));\n}\n\nint main() {\n    long long n, tmp_gcd;\n    cin>>n;\n    char c;\n    long long re_integer = 0, re_numerator, re_denominator;\n    cin>>re_numerator>>c>>re_denominator;\n    tmp_gcd = gcd(re_numerator,re_denominator);\n    re_numerator/=tmp_gcd,re_denominator/=tmp_gcd;\n    re_integer += int(re_numerator/re_denominator);\n    re_numerator%=re_denominator;\n    while(--n) {\n        long long tmp_nu, tmp_de, tmp_nu_re, tmp_de_re;\n        cin>>tmp_nu>>c>>tmp_de;\n        tmp_de_re = tmp_de * re_denominator;\n        tmp_nu_re = tmp_nu * re_denominator + tmp_de * re_numerator;\n        tmp_gcd = gcd(tmp_de_re,tmp_nu_re);\n        tmp_de_re/=tmp_gcd,tmp_nu_re/=tmp_gcd;\n        re_integer += int(tmp_nu_re/tmp_de_re);\n        re_numerator = tmp_nu_re % tmp_de_re;\n        re_denominator = tmp_de_re;\n    }\n    if (re_integer == 0 && re_numerator == 0) cout<<0;\n    else if (re_integer == 0) {\n        cout<<re_numerator<<'/'<<re_denominator;\n    } else if (re_numerator == 0) {\n        cout<<re_integer;\n    } else {\n        cout<<re_integer<<' '<<re_numerator<<'/'<<re_denominator;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1082-Read-Number-in-Chinese-25\"><a href=\"#1082-Read-Number-in-Chinese-25\" class=\"headerlink\" title=\"1082 Read Number in Chinese (25)\"></a>1082 Read Number in Chinese (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output “Fu” first if it is negative. For example, -123456789 is read as “Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu”. Note: zero (“ling”) must be handled correctly according to the Chinese tradition. For example, 100800 is “yi Shi Wan ling ba Bai”.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>-123456789</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</p></blockquote><p><strong>实现代码</strong></p><p>首先按照数字单位的顺序添加到结果容器中，然后遍历结果容器，如果有连续重复的”ling”只留一个，如果”Wan”前有“ling”去掉0，如果”Wan”直接跟在“Yi”后边将“Wan”换成“ling”。</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    string units[] = {\"\",\"Shi\",\"Bai\",\"Qian\",\"Wan\",\"Shi\",\"Bai\",\"Qian\",\"Yi\"};\n    string digits[] = {\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"};\n    vector<string> re;\n    int n;\n    cin>>n;\n    if (n < 0) {\n        re.push_back(\"Fu\");\n        n = -n;\n    }\n    if (n == 0) {\n        cout<<\"ling\";\n        return 0;\n    }\n    vector<int> n_digits;\n    while (n > 0) {\n        n_digits.push_back(n%10);\n        n/=10;\n    }\n    int len = n_digits.size();\n    for (int i = len-1; i >= 0; i--) {\n        re.push_back(digits[n_digits[i]]);\n        if (i==4 || n_digits[i] != 0 && i>0) re.push_back(units[i]);\n    }\n    vector<string>::iterator iter = re.begin()+1;\n    while (iter < re.end()) {\n        if (*(iter)==\"ling\" && *(iter-1)==\"ling\")\n            re.erase(iter);\n        else if (*(iter)==\"Wan\" && *(iter-1)==\"ling\")\n            re.erase((iter--)-1);\n        else if (*(iter)==\"Wan\" && *(iter-1)==\"Yi\")\n            *(iter++) = \"ling\";\n        else\n            iter++;\n    }\n    if (re.size()>1 && re[re.size()-1]==\"ling\") re.erase(re.end()-1);\n    cout<<re[0];\n    for (int i = 1; i < re.size(); i++) cout<<' '<<re[i];\n\n    return 0;\n}\n\n</code></pre><h2 id=\"1083-List-Grades-25\"><a href=\"#1083-List-Grades-25\" class=\"headerlink\" title=\"1083 List Grades (25)\"></a>1083 List Grades (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case is given in the following format:<br>N<br>name[1] ID[1] grade[1]<br>name[2] ID[2] grade[2]<br>… …<br>name[N] ID[N] grade[N]<br>grade1 grade2</p><p>where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade’s interval. It is guaranteed that all the grades are <em>distinct</em>.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output “NONE” instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4<br>Tom CS000001 59<br>Joe Math990112 89<br>Mike CS991301 100<br>Mary EE990830 95<br>60 100</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Mike CS991301<br>Mary EE990830<br>Joe Math990112</p></blockquote><p><strong>实现代码</strong></p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <vector>\nusing namespace std;\n\n\nstruct student\n{\n    string name;\n    string id;\n    int grade;\n    student(string n,string i, int g) {\n        name = n;\n        id = i;\n        grade = g;\n    }\n};\n\nint main() {\n    int n;\n    cin>>n;\n    vector<student> re;\n\n    string name,id;\n    int grade;\n    while(n--) {\n        cin>>name>>id>>grade;\n        student tmp(name,id,grade);\n        re.push_back(tmp);\n    }\n    int min_grade,max_grade;\n    cin>>min_grade>>max_grade;\n\n    vector<student>::iterator iter = re.begin();\n    while (iter != re.end()) {\n        if ((*iter).grade < min_grade || (*iter).grade > max_grade)\n            re.erase(iter);\n        else\n            iter++;\n    }\n\n    for (int k = 0 ; k < re.size(); k++) {\n        for (int i = 0 ; i < re.size()-1; i++) {\n            if (re[i].grade < re[i+1].grade) {\n                student tmp(re[i].name,re[i].id,re[i].grade);\n                re[i] = re[i+1];\n                re[i+1] = tmp;\n            }\n        }\n    }\n\n    if (re.empty()) cout<<\"NONE\";\n    else {\n        cout<<re[0].name<<' '<<re[0].id;\n        for (int i = 1; i < re.size(); i++)\n            cout<<\"\\n\"<<re[i].name<<' '<<re[i].id;\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1086-Tree-Traversals-Again-25\"><a href=\"#1086-Tree-Traversals-Again-25\" class=\"headerlink\" title=\"1086 Tree Traversals Again (25)\"></a>1086 Tree Traversals Again (25)</h2><p><strong>题目描述</strong></p><blockquote><p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src=\"/images/pat_1086.jpg\" alt=\"\"></p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>6<br>Push 1<br>Push 2<br>Push 3<br>Pop<br>Pop<br>Push 4<br>Pop<br>Pop<br>Push 5<br>Push 6<br>Pop<br>Pop</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 4 2 6 5 1</p></blockquote><p><strong>实现代码</strong></p><p>以上述例子为例，按顺序排下来123456为前序，使用栈的pop顺序为中序，利用前序和中序可以得到后序。</p><p>注意1-N为标号，每次push的为值，值有可能重复，但是push顺序为标号1-N。</p><p>可以用下边这个测试用例测试：</p><blockquote><p>//输入</p><p>19<br>Push 4<br>Push 11<br>Push 7<br>Push 12<br>Pop<br>Pop<br>Pop<br>Push 14<br>Push 17<br>Pop<br>Pop<br>Push 6<br>Push 18<br>Pop<br>Push 8<br>Pop<br>Pop<br>Push 4<br>Pop<br>Pop<br>Push 11<br>Push 16<br>Push 11<br>Push 12<br>Pop<br>Push 2<br>Pop<br>Pop<br>Pop<br>Push 7<br>Push 4<br>Pop<br>Pop<br>Push 12<br>Pop<br>Pop<br>Push 11<br>Pop</p><p>// 输出</p><p>12 7 17 8 18 4 6 14 11 2 12 11 4 12 7 16 11 11 4</p></blockquote><p>我的代码如下：</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvector<int> post;\nvoid generatePostOrder(vector<int> pre, vector<int> in, int len) {\n    if (len <= 0) return;\n    if (len == 1) {\n        post.push_back(pre[0]);\n        return;\n    }\n    int root_num = pre[0], root_pos_of_in = 0;\n    for (; root_pos_of_in < len; root_pos_of_in++) {\n        if (in[root_pos_of_in] == root_num) break;\n    }\n    int left_len = root_pos_of_in;\n    int right_len = len - left_len - 1;\n    vector<int> pre_left,pre_right,in_left,in_right;\n    pre_left.assign(pre.begin()+1, pre.begin()+1+left_len);\n    pre_right.assign(pre.begin()+1+left_len, pre.end());\n    in_left.assign(in.begin(),in.begin()+left_len);\n    in_right.assign(in.begin()+left_len+1, in.end());\n    generatePostOrder(pre_left,in_left,left_len);\n    generatePostOrder(pre_right,in_right,right_len);\n    post.push_back(root_num);\n}\n\nint main() {\n    int n, tmp;\n    cin>>n;\n    string op;\n    vector<int> pre,in,value;\n    stack<int> tmp_stack;\n    int index = 0;\n    for (int i = 0; i < 2*n; i++) {\n        cin>>op;\n        if (op == \"Push\") {\n            cin>>tmp;\n            value.push_back(tmp);\n            tmp_stack.push(index);\n            pre.push_back(index++);\n        } else {\n            in.push_back(tmp_stack.top());\n            tmp_stack.pop();\n        }\n    }\n    generatePostOrder(pre,in,n);\n    if (n > 0) cout<<value[post[0]];\n    for (int i = 1; i < n; i++) {\n        cout<<\" \"<<value[post[i]];\n    }\n    return 0;\n}\n\n</code></pre><h2 id=\"10xx\"><a href=\"#10xx\" class=\"headerlink\" title=\"10xx\"></a>10xx</h2><p><strong>题目描述</strong></p><blockquote></blockquote><p><strong>输入描述</strong></p><blockquote></blockquote><p><strong>输出描述</strong></p><blockquote></blockquote><p><strong>输入例子</strong></p><blockquote></blockquote><p><strong>输出例子</strong></p><blockquote></blockquote><p><strong>实现代码</strong></p>","site":{"data":{}},"excerpt":"<p>OJ：<a href=\"https://www.nowcoder.com/pat\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网</a></p>","more":"<hr><h2 id=\"1001-A-B-Format-20\"><a href=\"#1001-A-B-Format-20\" class=\"headerlink\" title=\"1001 A+B Format (20)\"></a>1001 A+B Format (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>-1000000 9</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>-999,991</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int digit[10];\n    for (int i = 0; i &lt; 10; i++) digit[i] = -1;\n    int a,b,re;\n    cin &gt;&gt; a &gt;&gt; b;\n    re = a + b;\n    if (re &lt; 0) {\n        cout&lt;&lt;&#39;-&#39;;\n        re = -re;\n    }\n    int i = 0;\n    while(re) {\n        digit[i] = (re%10);\n        re/=10;\n        i++;\n    }\n    for (int k = i-1; k &gt;=0; k--) {\n        cout&lt;&lt;digit[k];\n        if (k%3 == 0 &amp;&amp; k&gt;0) cout&lt;&lt;&#39;,&#39;;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1002-A-B-for-Polynomials-25\"><a href=\"#1002-A-B-for-Polynomials-25\" class=\"headerlink\" title=\"1002 A+B for Polynomials (25)\"></a>1002 A+B for Polynomials (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time, you are supposed to find A+B where A and B are two polynomials.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br>K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. <strong>Please be accurate to 1 decimal place.</strong></p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 2 1.5 1 2.9 0 3.2</p></blockquote><p><strong>实现代码</strong></p><p>注意保留小数。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct item\n{\n    int n;\n    float value;\n    item(int a, float b) {n=a,value=b;}\n};\n\nint main() {\n    vector&lt;item&gt; polynomials;\n    int k;\n\n    cin&gt;&gt;k;\n    int tmp_n;\n    float tmp_value;\n    while (k--) {\n        cin&gt;&gt;tmp_n&gt;&gt;tmp_value;\n        polynomials.push_back(item(tmp_n,tmp_value));\n    }\n\n    cin&gt;&gt;k;\n    while (k--) {\n        cin&gt;&gt;tmp_n&gt;&gt;tmp_value;\n        bool hasItem = false;\n        for (int i = 0; i &lt; polynomials.size(); i++) {\n            if (polynomials[i].n == tmp_n) {\n                hasItem = true;\n                polynomials[i].value+=tmp_value;\n                if (polynomials[i].value == 0)\n                    polynomials.erase(polynomials.begin()+i);\n                break;\n            }\n        }        \n        if (!hasItem) polynomials.push_back(item(tmp_n,tmp_value));    \n    }\n\n    for (int k = 0; k &lt; polynomials.size(); k++) {\n        for (int i = 0; i &lt; polynomials.size()-1; i++) {\n            if (polynomials[i].n &lt; polynomials[i+1].n) {\n                item tmp_item = polynomials[i];\n                polynomials[i] = polynomials[i+1];\n                polynomials[i+1] = tmp_item;\n            }\n        }\n    }\n\n    cout&lt;&lt;polynomials.size();\n    for (int i = 0; i &lt; polynomials.size(); i++)\n        printf(&quot; %d %.1f&quot;, polynomials[i].n, polynomials[i].value);\n\n    return 0;\n}\n</code></pre><h2 id=\"1003-Emergency-25\"><a href=\"#1003-Emergency-25\" class=\"headerlink\" title=\"1003 Emergency (25)\"></a>1003 Emergency (25)</h2><p><strong>题目描述</strong></p><blockquote><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively.<br>It is guaranteed that there exists at least one path from C1 to C2.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.</p><p>All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>2 4</p></blockquote><p><strong>实现代码</strong></p><p>dijkstra最短路</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nstruct road\n{\n    int endCity;\n    int length;\n    road(int e, int l) {endCity = e, length = l;}\n};\n\n\nint main() {\n    int n,m,c1,c2;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2;\n    vector&lt;int&gt; teamsCount;\n\n    int tmp1,tmp2,tmp3;\n    for (int i = 0; i &lt; n; i++) {\n        cin&gt;&gt;tmp1;\n        teamsCount.push_back(tmp1);\n    }\n\n    vector&lt;vector&lt;road&gt; &gt; roads(n);\n    for (int i = 0; i &lt; m; i++) {\n        cin&gt;&gt;tmp1&gt;&gt;tmp2&gt;&gt;tmp3;\n        roads[tmp1].push_back(road(tmp2,tmp3));\n        roads[tmp2].push_back(road(tmp1,tmp3));\n    }\n\n    vector&lt;int&gt; maxTeams(n);\n    for (int i = 0; i &lt; n; i++) maxTeams[i] = 0;\n    maxTeams[c1] = teamsCount[c1];\n\n    vector&lt;int&gt; minLen(n);\n    for (int i = 0; i &lt; n; i++) minLen[i] = INT_MAX;\n    minLen[c1] = 0;\n\n    int currentCity = c1;\n    vector&lt;int&gt; minLenRoadCount(n);\n    for (int i = 0; i &lt; n; i++) minLenRoadCount[i] = 1;\n\n    vector&lt;bool&gt; visited(n);\n    for (int i = 0; i &lt; n; i++) visited[i] = false;\n    visited[c1] = true;\n    while (currentCity != c2) {\n        int len = roads[currentCity].size();\n        for (int i = 0; i &lt; len; i++) {\n            if (visited[roads[currentCity][i].endCity]) continue;\n            int endCity = roads[currentCity][i].endCity;\n            int length = roads[currentCity][i].length;\n            if (minLen[endCity] &gt; minLen[currentCity] + length) {\n                minLen[endCity] = minLen[currentCity] + length;\n                minLenRoadCount[endCity] = 1;\n                maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n            } else if (minLen[endCity] == minLen[currentCity] + length) {\n                minLenRoadCount[endCity]++;\n                if (maxTeams[endCity] &lt; maxTeams[currentCity] + teamsCount[endCity])\n                    maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity];\n            }\n        }\n\n        int min = INT_MAX;\n        for (int i = 0; i &lt; n; i++) {\n            if (visited[i]) continue;\n            if (minLen[i] &lt; min) {\n                min = minLen[i];\n                currentCity = i;\n            }\n        }\n        visited[currentCity] = true;\n    }\n\n    cout&lt;&lt;minLenRoadCount[c2]&lt;&lt;&#39; &#39;&lt;&lt;maxTeams[c2];\n\n    return 0;\n}\n</code></pre><h2 id=\"1004-Counting-Leaves-30\"><a href=\"#1004-Counting-Leaves-30\" class=\"headerlink\" title=\"1004 Counting Leaves (30)\"></a>1004 Counting Leaves (30)</h2><p><strong>题目描述</strong></p><blockquote><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:</p><p>ID K ID[1] ID[2] … ID[K]</p><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, you are supposed to count those family members who have no child <strong>for every seniority level</strong> starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.<br>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1<br>01 1 02</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>0 1</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n#define MAX_NODES 100\n\nstruct node\n{\n    int id = -1;\n    int childs_count = 0;\n    vector&lt;int&gt; childs;\n};\n\nint main() {\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    node nodes[MAX_NODES];\n\n    int id,k,tmp;\n    while (m--) {\n        cin&gt;&gt;id&gt;&gt;k;\n        nodes[id].id = id;\n        nodes[id].childs_count = k;\n        while (k--) {\n            cin&gt;&gt;tmp;\n            (nodes[id].childs).push_back(tmp);\n        }\n    }\n\n    vector&lt;int&gt; this_level, next_level;\n    this_level.push_back(1);\n    while (1) {\n        int count_output = 0;\n        for (int i = 0; i &lt; this_level.size(); i++) {\n            if (nodes[this_level[i]].childs_count == 0) count_output++;\n            else next_level.insert(next_level.begin(),nodes[this_level[i]].childs.begin(),nodes[this_level[i]].childs.end());\n        }\n        cout&lt;&lt;count_output;\n        if (next_level.empty()) break;\n        cout&lt;&lt;&#39; &#39;;\n        this_level = next_level;\n        next_level.clear();\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1005-Spell-It-Right-20\"><a href=\"#1005-Spell-It-Right-20\" class=\"headerlink\" title=\"1005 Spell It Right (20)\"></a>1005 Spell It Right (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10^100).</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>12345</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>one five</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string n;\n    cin&gt;&gt;n;\n    int len = n.size();\n    int re = 0;\n    for (int i = 0; i &lt; len; i++) re+=(n[i]-&#39;0&#39;);\n    string english[10] = {&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;};\n    int digit[100], re_len = 0;\n    while (re) {\n        digit[re_len] = (re%10);\n        re/=10;\n        re_len++;\n    }\n    for (int i = re_len-1; i &gt;= 0; i--) {\n        cout&lt;&lt;english[digit[i]];\n        if (i != 0) cout&lt;&lt;&#39; &#39;;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1006-Sign-In-and-Sign-Out-25\"><a href=\"#1006-Sign-In-and-Sign-Out-25\" class=\"headerlink\" title=\"1006 Sign In and Sign Out (25)\"></a>1006 Sign In and Sign Out (25)</h2><p><strong>题目描述</strong></p><blockquote><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p><p>ID_number Sign_in_time Sign_out_time</p><p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.<br>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>SC3021234 CS301133</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nbool a_larger_than_b(string a, string b) {\n    for (int i = 0; i &lt; a.size(); i++) {\n        if (a[i] &lt; b[i]) return false;\n        if (a[i] &gt; b[i]) return true;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    string id,in,out;\n    string result_in_id, result_in_time, result_out_id, result_out_time;\n    cin&gt;&gt;id&gt;&gt;in&gt;&gt;out;\n    result_in_id = result_out_id = id;\n    result_in_time = in;\n    result_out_time = out;\n    n--;\n    while (n--) {\n        cin&gt;&gt;id&gt;&gt;in&gt;&gt;out;\n        if (a_larger_than_b(result_in_time,in)) {\n            result_in_id = id;\n            result_in_time = in;\n        }\n        if (a_larger_than_b(out,result_out_time)) {\n            result_out_id = id;\n            result_out_time = out;\n        }\n    }\n    cout&lt;&lt;result_in_id&lt;&lt;&#39; &#39;&lt;&lt;result_out_id;\n    return 0;\n}\n</code></pre><h2 id=\"1007-Maximum-Subsequence-Sum-25\"><a href=\"#1007-Maximum-Subsequence-Sum-25\" class=\"headerlink\" title=\"1007 Maximum Subsequence Sum (25)\"></a>1007 Maximum Subsequence Sum (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a sequence of K integers { N1<br>, N2<br>, …, NK<br>}. A continuous subsequence is defined to be { Ni<br>, Ni+1<br>, …, Nj<br>} where 1 &lt;= i &lt;= j &lt;= K. The <em>Maximum Subsequence</em><br>is the continuous subsequence which has the largest sum of its<br>elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its<br>maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first<br>and the last numbers of the maximum subsequence.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>10<br>-10 1 2 3 4 -5 -23 3 7 -21</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>10 1 4</p></blockquote><p><strong>实现代码</strong></p><p><u>和为负的子序列一定不会是最大和子序列的开头。</u></p><p>当当前和小于0时，使用临时”first number”记录下一个数，</p><p>更新最大和时，当前数为“last number”， 临时“first number”中存储的值为“first number”的值。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    int* nums = new int[n];\n    bool allNegative = true;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin&gt;&gt;nums[i];\n        if (nums[i] &gt;= 0) allNegative = false;\n    }\n\n    if (allNegative) {\n        cout&lt;&lt;0&lt;&lt;&#39; &#39;&lt;&lt;nums[0]&lt;&lt;&#39; &#39;&lt;&lt;nums[n-1];\n    } else {\n        int maxSum = 0, currentSum = 0;\n        int firstNum = nums[0], lastNum = nums[0];\n        int firstNumCurrent = firstNum;\n        for (int i = 0; i &lt; n; i++) {\n            currentSum+=nums[i];\n            if (currentSum &lt; 0) {\n                currentSum = 0;\n                firstNumCurrent = nums[i+1];\n            } else if (currentSum &gt; maxSum) {\n                maxSum = currentSum;\n                firstNum = firstNumCurrent;\n                lastNum = nums[i];\n            }\n        }\n        cout&lt;&lt;maxSum&lt;&lt;&#39; &#39;&lt;&lt;firstNum&lt;&lt;&#39; &#39;&lt;&lt;lastNum;\n    }\n\n    delete nums;\n\n    return 0;\n}\n</code></pre><h2 id=\"1008-Elevator-20\"><a href=\"#1008-Elevator-20\" class=\"headerlink\" title=\"1008 Elevator (20)\"></a>1008 Elevator (20)</h2><p><strong>题目描述</strong></p><blockquote><p>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.<br>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print the total time on a single line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3 2 3 1</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>41</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 0, b, n, re = 0;\n    cin &gt;&gt; n;\n    while (n--) {\n        cin &gt;&gt; b;\n        if (b &gt; a) {\n            re+=((b-a)*6);\n        } else {\n            re+=((a-b)*4);\n        }\n        re+=5;\n        a = b;\n    }\n    cout&lt;&lt;re;\n    return 0;\n}\n</code></pre><h2 id=\"1009-Product-of-Polynomials-25\"><a href=\"#1009-Product-of-Polynomials-25\" class=\"headerlink\" title=\"1009 Product of Polynomials (25)\"></a>1009 Product of Polynomials (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time, you are supposed to find A*B where A and B are two polynomials.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br>K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 3 3.6 2 6.0 1 1.6</p></blockquote><p><strong>实现代码</strong></p><p>把<a href=\"#1002-A-B-for-Polynomials-25\">1002 A+B for Polynomials (25)</a>稍微改一下就好。</p><p>使用<code>float</code>虽然算出来明明是对的但是过不了牛客的测试，全部换成<code>double</code>就好了，不知道是什么问题。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct item\n{\n    int n;\n    double value;\n    item(int a, double b) {n=a,value=b;}\n};\n\nint main() {\n    vector&lt;item&gt; polynomials, result;\n    int k;\n\n    cin&gt;&gt;k;\n    int tmp_n;\n    double tmp_value;\n    while (k--) {\n        cin&gt;&gt;tmp_n&gt;&gt;tmp_value;\n        polynomials.push_back(item(tmp_n,tmp_value));\n    }\n\n    cin&gt;&gt;k;\n    while (k--) {\n        cin&gt;&gt;tmp_n&gt;&gt;tmp_value;\n        for (int k = 0; k &lt; polynomials.size(); k++) {\n            bool hasItem = false;\n            for (int i = 0; i &lt; result.size(); i++) {\n                if (result[i].n == tmp_n+polynomials[k].n) {\n                    hasItem = true;\n                    result[i].value+=(tmp_value*polynomials[k].value);\n                    if (result[i].value == 0)\n                        result.erase(result.begin()+i);\n                    break;\n                }\n            }        \n            if (!hasItem) result.push_back(item(tmp_n+polynomials[k].n,tmp_value*polynomials[k].value));\n        }\n    }\n\n    for (int k = 0; k &lt; result.size(); k++) {\n        for (int i = 0; i &lt; result.size()-1; i++) {\n            if (result[i].n &lt; result[i+1].n) {\n                item tmp_item = result[i];\n                result[i] = result[i+1];\n                result[i+1] = tmp_item;\n            }\n        }\n    }\n\n    cout&lt;&lt;result.size();\n    for (int i = 0; i &lt; result.size(); i++)\n        printf(&quot; %d %.1f&quot;, result[i].n, result[i].value);\n\n    return 0;\n}\n</code></pre><h2 id=\"1015-Reversible-Primes-20\"><a href=\"#1015-Reversible-Primes-20\" class=\"headerlink\" title=\"1015 Reversible Primes (20)\"></a>1015 Reversible Primes (20)</h2><p><strong>题目描述</strong></p><blockquote><p>A <em>reversible prime</em><br>in any number system is a prime whose “reverse” in that<br>number system is also a prime. For example in the decimal system 73 is a<br>reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers N (&lt; 105<br>) and D (1 &lt; D &lt;= 10), you are supposed to tell if N is a<br>reversible prime with radix D.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line “Yes” if N is a reversible prime with radix D, or “No” if not.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>73 10<br>23 2<br>23 10<br>-2</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Yes<br>Yes<br>No</p></blockquote><p><strong>实现代码</strong></p><p>求N以及N在D进制下反转后是否均为质数。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint reverseWithRadix(int n, int d) {\n    vector&lt;int&gt; remainers;\n    while (n &gt; 0) {\n        remainers.push_back(n%d);\n        n/=d;\n    }\n    int re = 0;\n    int bit_count = remainers.size();\n    for (int i = 0; i &lt; bit_count; i++)\n        re+=(pow(d,bit_count-i-1)*remainers[i]);\n    return re;\n}\n\nbool isPrime(int n) {\n    if (n == 1) return false;\n    if (n &lt; 4) return true;\n    if (n % 2 == 0) return false;\n    int sqrt_n = sqrt(n) + 1;\n    for (int i = 3; i &lt;= sqrt_n; i+=2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n,d;\n    while (1) {\n        cin&gt;&gt;n;\n        if (n &lt; 0) break;\n        cin&gt;&gt;d;\n        if (isPrime(n) &amp;&amp; isPrime(reverseWithRadix(n,d))) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    }\n    return 0;\n}\n\n</code></pre><h2 id=\"1020-Tree-Traversals-25\"><a href=\"#1020-Tree-Traversals-25\" class=\"headerlink\" title=\"1020 Tree Traversals (25)\"></a>1020 Tree Traversals (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the <strong>postorder</strong> sequence and the third line gives the <strong>inorder</strong> sequence. All the numbers in a line are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>7<br>2 3 1 5 7 6 4<br>1 2 3 4 5 6 7</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>4 1 6 3 5 7 2</p></blockquote><p>postorder: 后序遍历</p><p>inorder: 中序遍历</p><p>level order: 层序遍历（从根开始,依次向下,对于每一层从左向右遍历）</p><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n\nstruct node\n{\n    node* left;\n    node* right;\n    int value;\n};\n\n\nnode* binaryTreeRoot(int* postorder, int* inorder, int len) {\n    if (len &lt;= 0) return NULL;\n\n    node* root = new node;\n    root-&gt;value = *(postorder+len-1);\n\n    int pos = 0;\n    for (; pos &lt; len; pos++)\n        if (*(inorder+pos) == root-&gt;value) break;\n\n    root-&gt;left = binaryTreeRoot(postorder, inorder, pos);\n    int rightLen = len - pos - 1;\n    root-&gt;right = binaryTreeRoot(postorder+pos, inorder+pos+1, rightLen);\n\n    return root;\n}\n\nvoid deleteNodes(node* root) {\n    if (root == NULL) return;\n    deleteNodes(root-&gt;left);\n    deleteNodes(root-&gt;right);\n    delete root;\n}\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    int* postorderNodes = new int[n];\n    int* inorderNodes = new int[n];\n    for (int i = 0; i &lt; n; i++) cin&gt;&gt;postorderNodes[i];\n    for (int i = 0; i &lt; n; i++) cin&gt;&gt;inorderNodes[i];\n\n    node* root = binaryTreeRoot(postorderNodes, inorderNodes, n);\n    if (!root) return 0;\n\n    queue&lt;node*&gt; levelNodes;\n    levelNodes.push(root);\n    while (1) {\n        node* tmp = levelNodes.front();\n        if (tmp-&gt;left) levelNodes.push(tmp-&gt;left);\n        if (tmp-&gt;right) levelNodes.push(tmp-&gt;right);\n        cout&lt;&lt;tmp-&gt;value;\n        levelNodes.pop();\n        if (!levelNodes.empty()) cout&lt;&lt;&#39; &#39;;\n        else break;\n    }\n\n    deleteNodes(root);\n    delete postorderNodes;\n    delete inorderNodes;\n\n    return 0;\n}\n</code></pre><h2 id=\"1023-Have-Fun-with-Numbers-20\"><a href=\"#1023-Have-Fun-with-Numbers-20\" class=\"headerlink\" title=\"1023 Have Fun with Numbers (20)\"></a>1023 Have Fun with Numbers (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains one positive integer with no more than 20 digits.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>1234567899</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Yes<br>2469135798</p></blockquote><p><strong>实现代码</strong></p><p>若双倍后多一位则为No;</p><p>使用<code>digit_count[i]</code>保存数字<code>i</code>（0-9）的个数，</p><p>再减去双倍后各个数字的个数，若每一个<code>digit_count[i]</code>均为0则为Yes,否则为No。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\n\n\nint main() {\n    int digit_count[10];\n    for (int i = 0; i &lt; 10; i++) digit_count[i] = 0;\n    string s;\n    cin&gt;&gt;s;\n    int k = s.size();\n    vector&lt;int&gt; digits;\n    for (int i = 0; i &lt; k; i++) {\n        int digit = s[i]-&#39;0&#39;;\n        digits.push_back(digit);\n        digit_count[digit]++;\n    }\n    int carry = 0;\n    for (int i = k-1; i &gt;= 0; i--) {\n        digits[i] = 2*digits[i] + carry;\n        carry = digits[i] / 10;\n        digits[i] %= 10;\n        digit_count[digits[i]]--;\n    }\n    if (carry) {\n        cout&lt;&lt;&quot;No\\n&quot;&lt;&lt;carry;\n        for (int i = 0; i &lt; k; i++) cout&lt;&lt;digits[i];\n        return 0;\n    }\n    bool result = true;\n    for (int i = 0; i &lt; 10; i++)\n        if (digit_count[i] != 0) {\n            result = false;\n            break;\n        }\n    if (result) cout&lt;&lt;&quot;Yes\\n&quot;;\n    else cout&lt;&lt;&quot;No\\n&quot;;\n    for (int i = 0; i &lt; k; i++) cout&lt;&lt;digits[i];\n\n    return 0;\n}\n\n</code></pre><h2 id=\"1027-Colors-in-Mars-20\"><a href=\"#1027-Colors-in-Mars-20\" class=\"headerlink\" title=\"1027 Colors in Mars (20)\"></a>1027 Colors in Mars (20)</h2><p><strong>题目描述</strong></p><blockquote><p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case which occupies a line containing the three decimal color values.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the Mars RGB value in the following format: first output “#”, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a “0” to the left.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>15 43 71</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>#123456</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout&lt;&lt;&#39;#&#39;;\n    int n;\n    for (int i = 0; i &lt; 3; i++) {\n        cin&gt;&gt;n;\n        int tmp = n/13;\n        if (tmp &gt; 9) cout&lt;&lt;char((tmp-10)+&#39;A&#39;);\n        else cout&lt;&lt;tmp;\n        tmp = n%13;\n        if (tmp &gt; 9) cout&lt;&lt;char((tmp-10)+&#39;A&#39;);\n        else cout&lt;&lt;tmp;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1028-List-Sorting-25\"><a href=\"#1028-List-Sorting-25\" class=\"headerlink\" title=\"1028 List Sorting (25)\"></a>1028 List Sorting (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Excel can sort records according to any column. Now you are supposed to imitate this function.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains two integers N (&lt;=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to ID’s; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. <strong>If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.</strong></p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3 1<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>000001 Zoe 60<br>000007 James 85<br>000010 Amy 90</p></blockquote><p><strong>实现代码</strong></p><p>利用结构体，使用sort函数排序。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct student\n{\n    string id;\n    string name;\n    int grade;\n    student(string i, string n, int g) {id = i, name = n, grade = g;}\n};\n\nbool cmp1(student a, student b) {\n    return a.id &lt; b.id;\n}\n\nbool cmp2(student a, student b) {\n    return (a.name == b.name)?(a.id &lt; b.id):(a.name &lt; b.name);\n}\n\nbool cmp3(student a, student b) {\n    return (a.grade == b.grade)?(a.id &lt; b.id):(a.grade &lt; b.grade);\n}\n\nint main() {\n    int n,c;\n    cin&gt;&gt;n&gt;&gt;c;\n    vector&lt;student&gt; students;\n\n    string id,name;\n    int grade;\n    for (int i = 0; i &lt; n; i++) {\n        cin&gt;&gt;id&gt;&gt;name&gt;&gt;grade;\n        students.push_back(student(id,name,grade));\n    }\n\n    if (c == 1) sort(students.begin(),students.end(),cmp1);\n    else if (c == 2) sort(students.begin(),students.end(),cmp2);\n    else sort(students.begin(),students.end(),cmp3);\n\n    if (n &gt; 0) cout&lt;&lt;students[0].id&lt;&lt;&#39; &#39;&lt;&lt;students[0].name&lt;&lt;&#39; &#39;&lt;&lt;students[0].grade;\n    for (int i = 1; i &lt; n; i++) {\n        cout&lt;&lt;&quot;\\n&quot;&lt;&lt;students[i].id&lt;&lt;&#39; &#39;&lt;&lt;students[i].name&lt;&lt;&#39; &#39;&lt;&lt;students[i].grade;\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1029-Median-25\"><a href=\"#1029-Median-25\" class=\"headerlink\" title=\"1029 Median (25)\"></a>1029 Median (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given an increasing sequence S of N integers, the <em>median</em> is the number at the middle position. For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.<br>Given two increasing sequences of integers, you are asked to find their median.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (&lt;=1000000) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of <strong>long int</strong>.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the median of the two given sequences in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4 11 12 13 14<br>5 9 10 15 16 17</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>13</p></blockquote><p><strong>实现代码</strong></p><p>用两个数组存储两组数据，每组数据一个pos，比较两个pos出的数值大小，较小值的pos向后移，直到找到中位数。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n\nint main() {\n    int m,n;\n    cin&gt;&gt;m;\n    int* firstSequence = new int[m];\n    for (int i = 0; i &lt; m; i++) cin&gt;&gt;firstSequence[i];\n    cin&gt;&gt;n;\n    int* secondSequence = new int[n];\n    for (int i = 0; i &lt; n; i++) cin&gt;&gt;secondSequence[i];\n\n    int firstPos = 0, secondPos = 0;\n    for (int i = int((m+n+1)/2); i &gt; 0; i--) {\n        if (i == 1) {\n            if (firstPos == m) cout&lt;&lt;secondSequence[secondPos];\n            else if (secondPos == n) cout&lt;&lt;firstSequence[firstPos];\n            else if (firstSequence[firstPos] &lt; secondSequence[secondPos]) cout&lt;&lt;firstSequence[firstPos];\n            else cout&lt;&lt;secondSequence[secondPos];\n        } else {\n            if (firstPos == m) secondPos++;\n            else if (secondPos == n) firstPos++;\n            else if (firstSequence[firstPos] &lt; secondSequence[secondPos]) firstPos++;\n            else secondPos++;\n        }\n    }\n\n    delete firstSequence;\n    delete secondSequence;\n\n    return 0;\n}\n</code></pre><h2 id=\"1030-Travel-Plan-30\"><a href=\"#1030-Travel-Plan-30\" class=\"headerlink\" title=\"1030 Travel Plan (30)\"></a>1030 Travel Plan (30)</h2><p><strong>题目描述</strong></p><blockquote><p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway.<br>Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination.<br>If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p><p>DECLARE: The test data in PAT is wrong,we strengthened the test data.If the same code got passed in pat,it may not be able to get passed in NOWCODER,please check your code.(This means that our test data is no problem,I guarantee.)</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (&lt;=500) is the number of cities (and hence the cities are numbered from 0 to N-1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:<br>City1 City2 Distance Cost</p><p>where the numbers are all integers no more than 500, and are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4 5 0 3</p><p>0 1 1 20</p><p>1 3 2 30</p><p>0 3 4 10</p><p>0 2 2 20</p><p>2 3 1 20</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>0 2 3 3 40</p></blockquote><p><strong>实现代码</strong></p><p>最短路问题，用Dijkstra（迪杰斯特拉）算法解即可。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nstruct highway\n{\n    int endCity;\n    int distance;\n    int cost;\n    highway(int e, int d, int c) {endCity=e,distance=d,cost=c;}\n};\n\n\nint main() {\n    // N为城市数，M为公路数，S为开始城市，D为结束城市\n    int N,M,S,D;\n    cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;\n\n    // highways(i) 为与城市i相连的所有公路\n    vector&lt;vector&lt;highway&gt; &gt; highways(N);\n    bool* visited = new bool[N];\n    int* distance = new int[N];\n    int* cost = new int[N];\n    int* lastCity = new int[N];\n    for (int i = 0; i &lt; N; i++) \n        visited[i] = false, distance[i] = cost[i] = INT_MAX;\n\n    // 读入数据，更新highways\n    int tmp_city_1, tmp_city_2, tmp_distance, tmp_cost;\n    while (M--) {\n        cin&gt;&gt;tmp_city_1&gt;&gt;tmp_city_2&gt;&gt;tmp_distance&gt;&gt;tmp_cost;\n        highways[tmp_city_1].push_back(highway(tmp_city_2,tmp_distance,tmp_cost));\n        highways[tmp_city_2].push_back(highway(tmp_city_1,tmp_distance,tmp_cost));\n    }\n\n    // dijkstra\n    int currentCity = S;\n    visited[S] = true, distance[S] = cost[S] = 0, lastCity[S] = S;\n    while (currentCity != D) {\n        for (int i = 0; i &lt; highways[currentCity].size(); i++) {\n            int tmp_endCity = highways[currentCity][i].endCity, \n                tmp_distance = highways[currentCity][i].distance,\n                tmp_cost = highways[currentCity][i].cost;                \n            if (visited[tmp_endCity]) continue;\n            if (distance[currentCity] + tmp_distance &lt; distance[tmp_endCity] ||\n                (distance[currentCity] + tmp_distance == distance[tmp_endCity] &amp;&amp; \n                 cost[currentCity] + tmp_cost &lt; cost[tmp_endCity])) {\n                distance[tmp_endCity] = distance[currentCity] + tmp_distance;\n                cost[tmp_endCity] = cost[currentCity] + tmp_cost;\n                lastCity[tmp_endCity] = currentCity;\n            }\n        }\n        int minDistance = INT_MAX;\n        for (int i = 0; i &lt; N; i++) {\n            if (visited[i]) continue;\n            if (distance[i] &lt; minDistance) minDistance=distance[i],currentCity = i;\n        }\n        // 添加离起始点最短的点到已访问集\n        visited[currentCity] = true;\n    }\n\n    // 逆序列逆向输出即为最短路径\n    stack&lt;int&gt; pathStack;\n    pathStack.push(D);\n    currentCity = D;\n    while (currentCity != S) {\n        currentCity = lastCity[currentCity];\n        pathStack.push(currentCity);\n    }\n\n    while (!pathStack.empty()) {\n        cout&lt;&lt;pathStack.top()&lt;&lt;&#39; &#39;;\n        pathStack.pop();\n    }\n    cout&lt;&lt;distance[D]&lt;&lt;&#39; &#39;&lt;&lt;cost[D];\n\n    delete visited,distance,cost,lastCity;\n    return 0;\n}\n\n</code></pre><h2 id=\"1035-Password-20\"><a href=\"#1035-Password-20\" class=\"headerlink\" title=\"1035 Password (20)\"></a>1035 Password (20)</h2><p><strong>题目描述</strong></p><blockquote><p>To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N (&lt;= 1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line “There are N accounts and no account is modified” where N is the total number of accounts. However, if N is one, you must print “There is 1 account and no account is modified” instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>Team000002 Rlsp0dfa<br>Team000003 perfectpwd<br>Team000001 R1spOdfa</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>2<br>Team000002 RLsp%dfa<br>Team000001 R@spodfa</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nstruct account\n{\n    string id;\n    string password;\n    account(string i, string p) {id = i, password = p;}\n};\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;account&gt; result;\n\n    string id,password;\n    for (int i = 0; i &lt; n; i++) {\n        cin&gt;&gt;id&gt;&gt;password;\n        if (password.find_first_of(&#39;0&#39;) == string::npos &amp;&amp;\n            password.find_first_of(&#39;O&#39;) == string::npos &amp;&amp;\n            password.find_first_of(&#39;1&#39;) == string::npos &amp;&amp;\n            password.find_first_of(&#39;l&#39;) == string::npos)\n            continue;\n        for (int s = 0; s &lt; password.size(); s++) {\n            if (password[s] == &#39;0&#39;) password[s] = &#39;%&#39;;\n            if (password[s] == &#39;O&#39;) password[s] = &#39;o&#39;;\n            if (password[s] == &#39;1&#39;) password[s] = &#39;@&#39;;\n            if (password[s] == &#39;l&#39;) password[s] = &#39;L&#39;;\n        }\n        result.push_back(account(id,password));\n    }\n\n    int result_len = result.size();\n    if (n == 1 &amp;&amp; result_len == 0) {\n        cout&lt;&lt;&quot;There is 1 account and no account is modified&quot;;\n    } else if (result_len == 0) {\n        cout&lt;&lt;&quot;There are &quot;&lt;&lt;n&lt;&lt;&quot; accounts and no account is modified&quot;;\n    } else {\n        cout&lt;&lt;result_len;\n        for (int i = 0; i &lt; result_len; i++) {\n            cout&lt;&lt;&quot;\\n&quot;&lt;&lt;result[i].id&lt;&lt;&#39; &#39;&lt;&lt;result[i].password;\n        }\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1036-Boys-vs-Girls-25\"><a href=\"#1036-Boys-vs-Girls-25\" class=\"headerlink\" title=\"1036 Boys vs Girls (25)\"></a>1036 Boys vs Girls (25)</h2><p><strong>题目描述</strong></p><blockquote><p>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF-gradeM. If one such kind of student is missing, output “Absent” in the corresponding line, and output “NA” in the third line instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>3<br>Joe M Math990112 89<br>Mike M CS991301 100<br>Mary F EE990830 95</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Mary EE990830<br>Joe Math990112<br>6</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    string re_male_name, re_male_id;\n    string re_female_name, re_female_id;\n    int re_male_grade = 101, re_female_grade = -1;\n\n    string name, gender, id;\n    int grade;\n    while(n--) {\n        cin&gt;&gt;name&gt;&gt;gender&gt;&gt;id&gt;&gt;grade;\n        if (gender==&quot;M&quot;) {\n            if (grade &lt; re_male_grade) {\n                re_male_name = name;\n                re_male_id = id;\n                re_male_grade = grade;\n            }\n        } else {\n            if (grade &gt; re_female_grade) {\n                re_female_name = name;\n                re_female_id = id;\n                re_female_grade = grade;\n            }\n        }\n    }\n\n    if (re_female_name==&quot;&quot;) cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl;\n    else cout&lt;&lt;re_female_name&lt;&lt;&#39; &#39;&lt;&lt;re_female_id&lt;&lt;endl;\n    if (re_male_name==&quot;&quot;) cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl;\n    else cout&lt;&lt;re_male_name&lt;&lt;&#39; &#39;&lt;&lt;re_male_id&lt;&lt;endl;\n    if (re_female_name==&quot;&quot; || re_male_name==&quot;&quot;) cout&lt;&lt;&quot;NA&quot;;\n    else cout&lt;&lt;re_female_grade - re_male_grade;\n\n    return 0;\n\n}\n</code></pre><h2 id=\"1037-Magic-Coupon-25\"><a href=\"#1037-Magic-Coupon-25\" class=\"headerlink\" title=\"1037 Magic Coupon (25)\"></a>1037 Magic Coupon (25)</h2><p><strong>题目描述</strong></p><blockquote><p>The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s!<br>For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M\\$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M\\$12 to the shop.<br>Each coupon and each product may be selected at most once. Your task is to get as much money back as possible.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here 1&lt;= NC, NP &lt;= 105, and it is guaranteed that all the numbers will not exceed 230.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, simply print in a line the maximum amount of money you can get back.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4<br>1 2 4 -1<br>4<br>7 6 -2 -3</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>43</p></blockquote><p><strong>实现代码</strong></p><h2 id=\"1054-The-Dominant-Color-20\"><a href=\"#1054-The-Dominant-Color-20\" class=\"headerlink\" title=\"1054 The Dominant Color (20)\"></a>1054 The Dominant Color (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. <strong>A <em>strictly</em> dominant color takes more than half of the total area.</strong> Now given an image of resolution M by N (for example, 800x600), you are supposed to point out the strictly dominant color.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (&lt;=800) and N (&lt;=600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0, 224). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, simply print the dominant color in a line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5 3<br>0 0 255 16777215 24<br>24 24 0 0 24<br>24 0 24 24 24</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>24</p></blockquote><p>首先要注意到dominant color是超过半数的，刚开始只想到了排序后最中间的数一定为结果，但是要存储的数据太多，后来看了<a href=\"https://blog.csdn.net/zhu_liangwei/article/details/9734671\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>，学会了下边这个方法。</p><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int m, n, all_count, tmp, re = -1, count = 0;\n    cin&gt;&gt;m&gt;&gt;n;\n    all_count = m*n;\n    while (all_count--) {\n        cin&gt;&gt;tmp;\n        if (count == 0) re = tmp;\n        if (re == tmp) count++;\n        else count--;\n    }\n    cout&lt;&lt;re;\n    return 0;\n}\n</code></pre><h2 id=\"1081-Rational-Sum-20\"><a href=\"#1081-Rational-Sum-20\" class=\"headerlink\" title=\"1081 Rational Sum (20)\"></a>1081 Rational Sum (20)</h2><p><strong>题目描述</strong></p><blockquote><p>Given N rational numbers in the form “numerator/denominator”, you are supposed to calculate their sum.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case starts with a positive integer N (&lt;=100), followed in the next line N rational numbers “a1/b1 a2/b2 …” where all the numerators and denominators are in the range of “long int”. If there is a negative number, then the sign must appear in front of the numerator.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, output the sum in the simplest form “integer numerator/denominator” where “integer” is the integer part of the sum, “numerator” &lt; “denominator”, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>5<br>2/5 4/15 1/30 -2/60 8/3</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 1/3</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n    return ((b==0)?abs(a):gcd(b,a%b));\n}\n\nint main() {\n    long long n, tmp_gcd;\n    cin&gt;&gt;n;\n    char c;\n    long long re_integer = 0, re_numerator, re_denominator;\n    cin&gt;&gt;re_numerator&gt;&gt;c&gt;&gt;re_denominator;\n    tmp_gcd = gcd(re_numerator,re_denominator);\n    re_numerator/=tmp_gcd,re_denominator/=tmp_gcd;\n    re_integer += int(re_numerator/re_denominator);\n    re_numerator%=re_denominator;\n    while(--n) {\n        long long tmp_nu, tmp_de, tmp_nu_re, tmp_de_re;\n        cin&gt;&gt;tmp_nu&gt;&gt;c&gt;&gt;tmp_de;\n        tmp_de_re = tmp_de * re_denominator;\n        tmp_nu_re = tmp_nu * re_denominator + tmp_de * re_numerator;\n        tmp_gcd = gcd(tmp_de_re,tmp_nu_re);\n        tmp_de_re/=tmp_gcd,tmp_nu_re/=tmp_gcd;\n        re_integer += int(tmp_nu_re/tmp_de_re);\n        re_numerator = tmp_nu_re % tmp_de_re;\n        re_denominator = tmp_de_re;\n    }\n    if (re_integer == 0 &amp;&amp; re_numerator == 0) cout&lt;&lt;0;\n    else if (re_integer == 0) {\n        cout&lt;&lt;re_numerator&lt;&lt;&#39;/&#39;&lt;&lt;re_denominator;\n    } else if (re_numerator == 0) {\n        cout&lt;&lt;re_integer;\n    } else {\n        cout&lt;&lt;re_integer&lt;&lt;&#39; &#39;&lt;&lt;re_numerator&lt;&lt;&#39;/&#39;&lt;&lt;re_denominator;\n    }\n    return 0;\n}\n</code></pre><h2 id=\"1082-Read-Number-in-Chinese-25\"><a href=\"#1082-Read-Number-in-Chinese-25\" class=\"headerlink\" title=\"1082 Read Number in Chinese (25)\"></a>1082 Read Number in Chinese (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output “Fu” first if it is negative. For example, -123456789 is read as “Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu”. Note: zero (“ling”) must be handled correctly according to the Chinese tradition. For example, 100800 is “yi Shi Wan ling ba Bai”.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>-123456789</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</p></blockquote><p><strong>实现代码</strong></p><p>首先按照数字单位的顺序添加到结果容器中，然后遍历结果容器，如果有连续重复的”ling”只留一个，如果”Wan”前有“ling”去掉0，如果”Wan”直接跟在“Yi”后边将“Wan”换成“ling”。</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string units[] = {&quot;&quot;,&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Yi&quot;};\n    string digits[] = {&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};\n    vector&lt;string&gt; re;\n    int n;\n    cin&gt;&gt;n;\n    if (n &lt; 0) {\n        re.push_back(&quot;Fu&quot;);\n        n = -n;\n    }\n    if (n == 0) {\n        cout&lt;&lt;&quot;ling&quot;;\n        return 0;\n    }\n    vector&lt;int&gt; n_digits;\n    while (n &gt; 0) {\n        n_digits.push_back(n%10);\n        n/=10;\n    }\n    int len = n_digits.size();\n    for (int i = len-1; i &gt;= 0; i--) {\n        re.push_back(digits[n_digits[i]]);\n        if (i==4 || n_digits[i] != 0 &amp;&amp; i&gt;0) re.push_back(units[i]);\n    }\n    vector&lt;string&gt;::iterator iter = re.begin()+1;\n    while (iter &lt; re.end()) {\n        if (*(iter)==&quot;ling&quot; &amp;&amp; *(iter-1)==&quot;ling&quot;)\n            re.erase(iter);\n        else if (*(iter)==&quot;Wan&quot; &amp;&amp; *(iter-1)==&quot;ling&quot;)\n            re.erase((iter--)-1);\n        else if (*(iter)==&quot;Wan&quot; &amp;&amp; *(iter-1)==&quot;Yi&quot;)\n            *(iter++) = &quot;ling&quot;;\n        else\n            iter++;\n    }\n    if (re.size()&gt;1 &amp;&amp; re[re.size()-1]==&quot;ling&quot;) re.erase(re.end()-1);\n    cout&lt;&lt;re[0];\n    for (int i = 1; i &lt; re.size(); i++) cout&lt;&lt;&#39; &#39;&lt;&lt;re[i];\n\n    return 0;\n}\n\n</code></pre><h2 id=\"1083-List-Grades-25\"><a href=\"#1083-List-Grades-25\" class=\"headerlink\" title=\"1083 List Grades (25)\"></a>1083 List Grades (25)</h2><p><strong>题目描述</strong></p><blockquote><p>Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. Each case is given in the following format:<br>N<br>name[1] ID[1] grade[1]<br>name[2] ID[2] grade[2]<br>… …<br>name[N] ID[N] grade[N]<br>grade1 grade2</p><p>where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade’s interval. It is guaranteed that all the grades are <em>distinct</em>.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output “NONE” instead.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>4<br>Tom CS000001 59<br>Joe Math990112 89<br>Mike CS991301 100<br>Mary EE990830 95<br>60 100</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>Mike CS991301<br>Mary EE990830<br>Joe Math990112</p></blockquote><p><strong>实现代码</strong></p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n\nstruct student\n{\n    string name;\n    string id;\n    int grade;\n    student(string n,string i, int g) {\n        name = n;\n        id = i;\n        grade = g;\n    }\n};\n\nint main() {\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;student&gt; re;\n\n    string name,id;\n    int grade;\n    while(n--) {\n        cin&gt;&gt;name&gt;&gt;id&gt;&gt;grade;\n        student tmp(name,id,grade);\n        re.push_back(tmp);\n    }\n    int min_grade,max_grade;\n    cin&gt;&gt;min_grade&gt;&gt;max_grade;\n\n    vector&lt;student&gt;::iterator iter = re.begin();\n    while (iter != re.end()) {\n        if ((*iter).grade &lt; min_grade || (*iter).grade &gt; max_grade)\n            re.erase(iter);\n        else\n            iter++;\n    }\n\n    for (int k = 0 ; k &lt; re.size(); k++) {\n        for (int i = 0 ; i &lt; re.size()-1; i++) {\n            if (re[i].grade &lt; re[i+1].grade) {\n                student tmp(re[i].name,re[i].id,re[i].grade);\n                re[i] = re[i+1];\n                re[i+1] = tmp;\n            }\n        }\n    }\n\n    if (re.empty()) cout&lt;&lt;&quot;NONE&quot;;\n    else {\n        cout&lt;&lt;re[0].name&lt;&lt;&#39; &#39;&lt;&lt;re[0].id;\n        for (int i = 1; i &lt; re.size(); i++)\n            cout&lt;&lt;&quot;\\n&quot;&lt;&lt;re[i].name&lt;&lt;&#39; &#39;&lt;&lt;re[i].id;\n    }\n\n    return 0;\n}\n</code></pre><h2 id=\"1086-Tree-Traversals-Again-25\"><a href=\"#1086-Tree-Traversals-Again-25\" class=\"headerlink\" title=\"1086 Tree Traversals Again (25)\"></a>1086 Tree Traversals Again (25)</h2><p><strong>题目描述</strong></p><blockquote><p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src=\"/images/pat_1086.jpg\" alt=\"\"></p></blockquote><p><strong>输入描述</strong></p><blockquote><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p></blockquote><p><strong>输入例子</strong></p><blockquote><p>6<br>Push 1<br>Push 2<br>Push 3<br>Pop<br>Pop<br>Push 4<br>Pop<br>Pop<br>Push 5<br>Push 6<br>Pop<br>Pop</p></blockquote><p><strong>输出例子</strong></p><blockquote><p>3 4 2 6 5 1</p></blockquote><p><strong>实现代码</strong></p><p>以上述例子为例，按顺序排下来123456为前序，使用栈的pop顺序为中序，利用前序和中序可以得到后序。</p><p>注意1-N为标号，每次push的为值，值有可能重复，但是push顺序为标号1-N。</p><p>可以用下边这个测试用例测试：</p><blockquote><p>//输入</p><p>19<br>Push 4<br>Push 11<br>Push 7<br>Push 12<br>Pop<br>Pop<br>Pop<br>Push 14<br>Push 17<br>Pop<br>Pop<br>Push 6<br>Push 18<br>Pop<br>Push 8<br>Pop<br>Pop<br>Push 4<br>Pop<br>Pop<br>Push 11<br>Push 16<br>Push 11<br>Push 12<br>Pop<br>Push 2<br>Pop<br>Pop<br>Pop<br>Push 7<br>Push 4<br>Pop<br>Pop<br>Push 12<br>Pop<br>Pop<br>Push 11<br>Pop</p><p>// 输出</p><p>12 7 17 8 18 4 6 14 11 2 12 11 4 12 7 16 11 11 4</p></blockquote><p>我的代码如下：</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\nvector&lt;int&gt; post;\nvoid generatePostOrder(vector&lt;int&gt; pre, vector&lt;int&gt; in, int len) {\n    if (len &lt;= 0) return;\n    if (len == 1) {\n        post.push_back(pre[0]);\n        return;\n    }\n    int root_num = pre[0], root_pos_of_in = 0;\n    for (; root_pos_of_in &lt; len; root_pos_of_in++) {\n        if (in[root_pos_of_in] == root_num) break;\n    }\n    int left_len = root_pos_of_in;\n    int right_len = len - left_len - 1;\n    vector&lt;int&gt; pre_left,pre_right,in_left,in_right;\n    pre_left.assign(pre.begin()+1, pre.begin()+1+left_len);\n    pre_right.assign(pre.begin()+1+left_len, pre.end());\n    in_left.assign(in.begin(),in.begin()+left_len);\n    in_right.assign(in.begin()+left_len+1, in.end());\n    generatePostOrder(pre_left,in_left,left_len);\n    generatePostOrder(pre_right,in_right,right_len);\n    post.push_back(root_num);\n}\n\nint main() {\n    int n, tmp;\n    cin&gt;&gt;n;\n    string op;\n    vector&lt;int&gt; pre,in,value;\n    stack&lt;int&gt; tmp_stack;\n    int index = 0;\n    for (int i = 0; i &lt; 2*n; i++) {\n        cin&gt;&gt;op;\n        if (op == &quot;Push&quot;) {\n            cin&gt;&gt;tmp;\n            value.push_back(tmp);\n            tmp_stack.push(index);\n            pre.push_back(index++);\n        } else {\n            in.push_back(tmp_stack.top());\n            tmp_stack.pop();\n        }\n    }\n    generatePostOrder(pre,in,n);\n    if (n &gt; 0) cout&lt;&lt;value[post[0]];\n    for (int i = 1; i &lt; n; i++) {\n        cout&lt;&lt;&quot; &quot;&lt;&lt;value[post[i]];\n    }\n    return 0;\n}\n\n</code></pre><h2 id=\"10xx\"><a href=\"#10xx\" class=\"headerlink\" title=\"10xx\"></a>10xx</h2><p><strong>题目描述</strong></p><blockquote></blockquote><p><strong>输入描述</strong></p><blockquote></blockquote><p><strong>输出描述</strong></p><blockquote></blockquote><p><strong>输入例子</strong></p><blockquote></blockquote><p><strong>输出例子</strong></p><blockquote></blockquote><p><strong>实现代码</strong></p>"},{"title":"Ubuntu下使用Deepin-wine的移植版安装qq微信等","toc":false,"date":"2018-09-18T08:12:49.000Z","_content":"\n下载Deepin-wine的Ubuntu移植版：\n\n`git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git`\n\n进入 `deepin-wine-for-ubuntu/`文件夹\n\n在终端内运行`./install.sh`\n\n<!-- more -->\n\n这样就安装完成啦，现在就可以安装qq微信之类的软件啦：\n\n[所有deepin-wine内支持的windows软件下载地址](http://mirrors.aliyun.com/deepin/pool/non-free/d/)\n\n其中qq下载地址为：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb\n\n微信下载地址为：http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb\n\n下载之后进入下载目录，终端内运行：\n\n`sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb `\n\n和\n\n`sudo dpkg -i deepin.com.wechat_2.6.2.31deepin0_i386.deb`即可。\n\n然后在自己的应用程序目录就可以看到qq和微信了。","source":"_posts/Ubuntu下使用Deepin-wine的移植版安装qq微信等.md","raw":"---\ntitle: Ubuntu下使用Deepin-wine的移植版安装qq微信等\ntoc: false\ndate: 2018-09-18 16:12:49\ncategories:\n- methods\ntags:\n- ubuntu\n---\n\n下载Deepin-wine的Ubuntu移植版：\n\n`git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git`\n\n进入 `deepin-wine-for-ubuntu/`文件夹\n\n在终端内运行`./install.sh`\n\n<!-- more -->\n\n这样就安装完成啦，现在就可以安装qq微信之类的软件啦：\n\n[所有deepin-wine内支持的windows软件下载地址](http://mirrors.aliyun.com/deepin/pool/non-free/d/)\n\n其中qq下载地址为：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb\n\n微信下载地址为：http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb\n\n下载之后进入下载目录，终端内运行：\n\n`sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb `\n\n和\n\n`sudo dpkg -i deepin.com.wechat_2.6.2.31deepin0_i386.deb`即可。\n\n然后在自己的应用程序目录就可以看到qq和微信了。","slug":"Ubuntu下使用Deepin-wine的移植版安装qq微信等","published":1,"updated":"2018-10-10T08:40:27.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vt0014fmag7tiswv7p","content":"<p>下载Deepin-wine的Ubuntu移植版：</p><p><code>git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</code></p><p>进入 <code>deepin-wine-for-ubuntu/</code>文件夹</p><p>在终端内运行<code>./install.sh</code></p><a id=\"more\"></a><p>这样就安装完成啦，现在就可以安装qq微信之类的软件啦：</p><p><a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/d/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">所有deepin-wine内支持的windows软件下载地址</a></p><p>其中qq下载地址为：<a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb</a></p><p>微信下载地址为：<a href=\"http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb</a></p><p>下载之后进入下载目录，终端内运行：</p><p><code>sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb</code></p><p>和</p><p><code>sudo dpkg -i deepin.com.wechat_2.6.2.31deepin0_i386.deb</code>即可。</p><p>然后在自己的应用程序目录就可以看到qq和微信了。</p>","site":{"data":{}},"excerpt":"<p>下载Deepin-wine的Ubuntu移植版：</p><p><code>git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</code></p><p>进入 <code>deepin-wine-for-ubuntu/</code>文件夹</p><p>在终端内运行<code>./install.sh</code></p>","more":"<p>这样就安装完成啦，现在就可以安装qq微信之类的软件啦：</p><p><a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/d/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">所有deepin-wine内支持的windows软件下载地址</a></p><p>其中qq下载地址为：<a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb</a></p><p>微信下载地址为：<a href=\"http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb</a></p><p>下载之后进入下载目录，终端内运行：</p><p><code>sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb</code></p><p>和</p><p><code>sudo dpkg -i deepin.com.wechat_2.6.2.31deepin0_i386.deb</code>即可。</p><p>然后在自己的应用程序目录就可以看到qq和微信了。</p>"},{"title":"Vuex入门","toc":true,"date":"2018-09-23T14:30:52.000Z","_content":"\nvuex文档学习笔记。\n\n<!-- more -->\n\n## 安装\n\n比较常用的两种：\n\n### 直接下载或CDN引用\n\n从<https://unpkg.com/vuex>下载后利用script标签在vue后引入：\n\n```html\n<script src=\"/path/to/vue.js\"></script>\n<script src=\"/path/to/vuex.js\"></script>\n```\n\n或\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vuex@3.0.1/dist/vuex.js\"></script>\n```\n\n### 使用npm\n\n在项目目录下运行：\n\n```powershell\nnpm install vuex --save\n```\n\n在模块化的打包系统中利用这种方法时，必须显式地利用`Vue.use()`来安装Vuex（而script标签引入后是自动安装的）：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n\n## 介绍\n\n功能：把组件的共享状态抽取出来，用一个全局单例模式管理。\n\n核心：store（仓库），它包含了应用中的大部分state（状态，驱动应用的数据源）。\n\n这种全局单例模式管理和单纯的全局变量的区别：\n\n- **Vuex 的状态存储是响应式的**。若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n- **不能直接改变store中的state**。改变 store 中的state的唯一途径就是显式地**commit (提交) mutation（变化）**。这样我们可以方便地跟踪每一个状态的变化。\n\n一个栗子：\n\n```js\n// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n// 触发状态变更\nstore.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n```\n\n**再次强调，使用提交 mutation ，而不是直接改变 `store.state.count`，**\n\n**是因为我们想要更明确地追踪到状态的变化。**\n\n当然，使用 Vuex 并**不意味着**需要将**所有的**状态放入 Vuex。\n\n虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。\n\n如果有些状态严格属于单个组件，最好还是作为组件的局部状态。\n\n你应该根据你的应用开发需要进行权衡和确定。\n\n## 核心概念\n\n### State\n\n每个应用只包含一个 store 实例，它包含了所有需要vuex管理的状态。\n\n#### 利用计算属性读取state\n\n从 store 实例中读取状态最简单的方法就是在[计算属性](https://cn.vuejs.org/guide/computed.html)中返回某个状态：\n\n```js\n// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n\n但这种模式导致组件依赖全局状态单例。\n\n#### 注册 `store` 选项\n\n为了解决上述模式导致的组件依赖全局状态单例的问题，\n\n我们可以通过在**根实例**中注册 `store` 选项——\n\n这样 store 实例会注入到根组件下的所有子组件中，\n\n且子组件能通过 `this.$store` 访问到：（需调用 `Vue.use(Vuex)`）\n\n```js\n// 根组件\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n\n```js\n// 子组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      // 通过 this.$store 访问store\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n#### `mapState`辅助函数\n\n当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。\n\n为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：\n\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    // 将 `this.count` 映射为 `this.$store.state.count\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。\n\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n#### 对象展开操作符\n\nES6引入的新语法，由名字就可以看出来这个操作符的含义：把对象展开，\n\n来个栗子更容易理解：\n\n```js\nvar a = {'a':1, 'b':2, 'c':3};\n{...a,'d':4} // {a: 1, b: 2, c: 3, d: 4}\n\nvar b = [1,2,3];\n[...b,4] // [1, 2, 3, 4]\n```\n\n有了这个操作符，我们就可以把`mapState`函数和局部计算属性混合使用了：\n\n```js\ncomputed: {\n  // 局部计算属性\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象展开混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n```\n\n### Getter\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。\n\n就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值；getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\nGetter 接受 state 作为其第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\n\nGetter 也可以接受其他 getter 作为第二个参数：\n\n```js\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n\nstore.getters.doneTodosCount // -> 1\n```\n\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组**进行查询**时非常有用。\n\n```js\ngetters: {\n  // ...\n  // getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n\n我们可以很容易地在任何组件中使用getter：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n\n我们也可以使用`mapGetters` 辅助函数将 store 中的 getter 映射到局部计算属性：\n\n```js\nimport { mapGetters } from 'vuex'\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n      doneCount: 'doneTodosCount',\n      // ...\n    ])\n  }\n}\n```\n\n### Mutation\n\n**更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。**\n\nVuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。\n\n这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    // 这里的事件类型为 'increment' \n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n但我们不能直接调用一个 mutation 回调函数，就像前面说的，我们只能提交 mutation。\n\n就像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”\n\n要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法（即提交mutation）：\n\n```js\nstore.commit('increment')\n```\n\n#### 提交载荷Payload\n\n我们还可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段，并且记录的 mutation 会更易读：\n\n```js\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n// ...\n\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n我们可以使用对象风格的提交方式，将一个直接包含 `type` 属性的对象作为载荷传给 mutations ：\n\n```js\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n并且handler 无需改变：\n\n```js\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n#### Mutation 需遵守 Vue 的响应规则\n\n因为 Vuex 的 store 中的状态是响应式的，那么当我们使用Mutation变更状态时，监视状态的 Vue 组件也会自动更新。\n\n因此使用 Vuex 中的 mutation 也需要像使用Vue 一样遵守一些注意事项：\n\n1. 提前在 store 中初始化好所有所需属性。\n\n2. 当需要在对象上添加新属性时，你应该\n\n   - 使用 `Vue.set(obj, 'newProp', 123)`, 或者\n\n   - 以新对象替换老对象。例如利用ES6的对象展开运算符：\n\n     ```js\n     state.obj = { ...state.obj, newProp: 123 }\n     ```\n\n#### Mutation 必须是同步函数\n\n **mutation 必须是同步函数**。为什么？请参考下面的例子：\n\n```js\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n假设我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志：\n\n每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。\n\n然而，在上面的例子中 mutation 中的**异步函数**中的回调让这不可能完成：\n\n当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——\n\n实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n#### 在组件中提交 Mutation\n\n我们可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，\n\n或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）：\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n#### 使用常量替代 Mutation 事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n用不用常量取决于实际情况——在需要多人协作的大型项目中，这会很有帮助。你果然如果不想用，也完全可以不用。\n\n### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 是提交 mutation，而不是直接变更状态。\n- Action 可以包含任意异步操作。\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  },\n  actions: {\n    // 接受一个与 store 实例具有相同方法和属性的 context 对象\n    increment (context) {\n      // 提交mutation\n      context.commit('increment')\n    }\n  }\n})\n```\n\n实践中，我们可以使用 ES2015 的 **参数解构** 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：\n\n```js\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n#### 进行异步操作\n\n因为action是提交mutation而不是直接变更状态，因此我们就可以在action内部执行异步操作了：\n\n```js\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n\n#### 分发Action\n\nAction 通过 `store.dispatch` 方法触发：\n\n```js\nstore.dispatch('increment')\n```\n\nActions 支持Mutation同样的载荷方式和对象方式进行分发：\n\n```js\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\n也可以在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 `store`）：\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n#### 组合 Action\n\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n##### 使用promise\n\n`store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，\n\n然后返回这个 Promise：\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n\n现在我们就可以：\n\n```js\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n在另外一个 action 中也可以：\n\n```js\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n##### 使用async / await\n\n如果我们可以利用 **async / await**，我们还可以如下组合 action：\n\n```js\n// 假设 gotData() 和 gotOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n> 一个 `store.dispatch` 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n\n### Module\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n#### 模块的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。\n\n```js\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n\n同样，对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`：\n\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n对于模块内部的 getter，根节点状态也会作为第三个参数暴露出来：\n\n```js\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n## 项目结构\n\nVuex 并不限制我们的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n\n```bash\n├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n```\n\n\n\n\n\n---\n\n有时候看不进去[文档](https://vuex.vuejs.org/zh/)，一边总结一边看就能看进去了 :)","source":"_posts/Vuex入门.md","raw":"---\ntitle: Vuex入门\ntoc: true\ndate: 2018-09-23 22:30:52\ncategories:\n- Web\ntags:\n- Vue\n- Vuex\n---\n\nvuex文档学习笔记。\n\n<!-- more -->\n\n## 安装\n\n比较常用的两种：\n\n### 直接下载或CDN引用\n\n从<https://unpkg.com/vuex>下载后利用script标签在vue后引入：\n\n```html\n<script src=\"/path/to/vue.js\"></script>\n<script src=\"/path/to/vuex.js\"></script>\n```\n\n或\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vuex@3.0.1/dist/vuex.js\"></script>\n```\n\n### 使用npm\n\n在项目目录下运行：\n\n```powershell\nnpm install vuex --save\n```\n\n在模块化的打包系统中利用这种方法时，必须显式地利用`Vue.use()`来安装Vuex（而script标签引入后是自动安装的）：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n\n## 介绍\n\n功能：把组件的共享状态抽取出来，用一个全局单例模式管理。\n\n核心：store（仓库），它包含了应用中的大部分state（状态，驱动应用的数据源）。\n\n这种全局单例模式管理和单纯的全局变量的区别：\n\n- **Vuex 的状态存储是响应式的**。若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n- **不能直接改变store中的state**。改变 store 中的state的唯一途径就是显式地**commit (提交) mutation（变化）**。这样我们可以方便地跟踪每一个状态的变化。\n\n一个栗子：\n\n```js\n// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n// 触发状态变更\nstore.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n```\n\n**再次强调，使用提交 mutation ，而不是直接改变 `store.state.count`，**\n\n**是因为我们想要更明确地追踪到状态的变化。**\n\n当然，使用 Vuex 并**不意味着**需要将**所有的**状态放入 Vuex。\n\n虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。\n\n如果有些状态严格属于单个组件，最好还是作为组件的局部状态。\n\n你应该根据你的应用开发需要进行权衡和确定。\n\n## 核心概念\n\n### State\n\n每个应用只包含一个 store 实例，它包含了所有需要vuex管理的状态。\n\n#### 利用计算属性读取state\n\n从 store 实例中读取状态最简单的方法就是在[计算属性](https://cn.vuejs.org/guide/computed.html)中返回某个状态：\n\n```js\n// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n\n但这种模式导致组件依赖全局状态单例。\n\n#### 注册 `store` 选项\n\n为了解决上述模式导致的组件依赖全局状态单例的问题，\n\n我们可以通过在**根实例**中注册 `store` 选项——\n\n这样 store 实例会注入到根组件下的所有子组件中，\n\n且子组件能通过 `this.$store` 访问到：（需调用 `Vue.use(Vuex)`）\n\n```js\n// 根组件\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n\n```js\n// 子组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      // 通过 this.$store 访问store\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n#### `mapState`辅助函数\n\n当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。\n\n为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：\n\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    // 将 `this.count` 映射为 `this.$store.state.count\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。\n\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n#### 对象展开操作符\n\nES6引入的新语法，由名字就可以看出来这个操作符的含义：把对象展开，\n\n来个栗子更容易理解：\n\n```js\nvar a = {'a':1, 'b':2, 'c':3};\n{...a,'d':4} // {a: 1, b: 2, c: 3, d: 4}\n\nvar b = [1,2,3];\n[...b,4] // [1, 2, 3, 4]\n```\n\n有了这个操作符，我们就可以把`mapState`函数和局部计算属性混合使用了：\n\n```js\ncomputed: {\n  // 局部计算属性\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象展开混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n```\n\n### Getter\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。\n\n就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值；getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\nGetter 接受 state 作为其第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\n\nGetter 也可以接受其他 getter 作为第二个参数：\n\n```js\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n\nstore.getters.doneTodosCount // -> 1\n```\n\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组**进行查询**时非常有用。\n\n```js\ngetters: {\n  // ...\n  // getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n\n我们可以很容易地在任何组件中使用getter：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n\n我们也可以使用`mapGetters` 辅助函数将 store 中的 getter 映射到局部计算属性：\n\n```js\nimport { mapGetters } from 'vuex'\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n      doneCount: 'doneTodosCount',\n      // ...\n    ])\n  }\n}\n```\n\n### Mutation\n\n**更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。**\n\nVuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。\n\n这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    // 这里的事件类型为 'increment' \n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n但我们不能直接调用一个 mutation 回调函数，就像前面说的，我们只能提交 mutation。\n\n就像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”\n\n要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法（即提交mutation）：\n\n```js\nstore.commit('increment')\n```\n\n#### 提交载荷Payload\n\n我们还可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段，并且记录的 mutation 会更易读：\n\n```js\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n// ...\n\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n我们可以使用对象风格的提交方式，将一个直接包含 `type` 属性的对象作为载荷传给 mutations ：\n\n```js\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n并且handler 无需改变：\n\n```js\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n#### Mutation 需遵守 Vue 的响应规则\n\n因为 Vuex 的 store 中的状态是响应式的，那么当我们使用Mutation变更状态时，监视状态的 Vue 组件也会自动更新。\n\n因此使用 Vuex 中的 mutation 也需要像使用Vue 一样遵守一些注意事项：\n\n1. 提前在 store 中初始化好所有所需属性。\n\n2. 当需要在对象上添加新属性时，你应该\n\n   - 使用 `Vue.set(obj, 'newProp', 123)`, 或者\n\n   - 以新对象替换老对象。例如利用ES6的对象展开运算符：\n\n     ```js\n     state.obj = { ...state.obj, newProp: 123 }\n     ```\n\n#### Mutation 必须是同步函数\n\n **mutation 必须是同步函数**。为什么？请参考下面的例子：\n\n```js\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n假设我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志：\n\n每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。\n\n然而，在上面的例子中 mutation 中的**异步函数**中的回调让这不可能完成：\n\n当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——\n\n实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n#### 在组件中提交 Mutation\n\n我们可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，\n\n或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）：\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n#### 使用常量替代 Mutation 事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n用不用常量取决于实际情况——在需要多人协作的大型项目中，这会很有帮助。你果然如果不想用，也完全可以不用。\n\n### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 是提交 mutation，而不是直接变更状态。\n- Action 可以包含任意异步操作。\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  },\n  actions: {\n    // 接受一个与 store 实例具有相同方法和属性的 context 对象\n    increment (context) {\n      // 提交mutation\n      context.commit('increment')\n    }\n  }\n})\n```\n\n实践中，我们可以使用 ES2015 的 **参数解构** 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：\n\n```js\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n#### 进行异步操作\n\n因为action是提交mutation而不是直接变更状态，因此我们就可以在action内部执行异步操作了：\n\n```js\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n\n#### 分发Action\n\nAction 通过 `store.dispatch` 方法触发：\n\n```js\nstore.dispatch('increment')\n```\n\nActions 支持Mutation同样的载荷方式和对象方式进行分发：\n\n```js\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\n也可以在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 `store`）：\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n#### 组合 Action\n\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n##### 使用promise\n\n`store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，\n\n然后返回这个 Promise：\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n\n现在我们就可以：\n\n```js\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n在另外一个 action 中也可以：\n\n```js\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n##### 使用async / await\n\n如果我们可以利用 **async / await**，我们还可以如下组合 action：\n\n```js\n// 假设 gotData() 和 gotOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n> 一个 `store.dispatch` 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n\n### Module\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n#### 模块的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。\n\n```js\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n\n同样，对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`：\n\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n对于模块内部的 getter，根节点状态也会作为第三个参数暴露出来：\n\n```js\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n## 项目结构\n\nVuex 并不限制我们的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n\n```bash\n├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n```\n\n\n\n\n\n---\n\n有时候看不进去[文档](https://vuex.vuejs.org/zh/)，一边总结一边看就能看进去了 :)","slug":"Vuex入门","published":1,"updated":"2018-10-10T08:41:20.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vv0017fmagdkkbu7qf","content":"<p>vuex文档学习笔记。</p><a id=\"more\"></a><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>比较常用的两种：</p><h3 id=\"直接下载或CDN引用\"><a href=\"#直接下载或CDN引用\" class=\"headerlink\" title=\"直接下载或CDN引用\"></a>直接下载或CDN引用</h3><p>从<a href=\"https://unpkg.com/vuex\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://unpkg.com/vuex</a>下载后利用script标签在vue后引入：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/path/to/vue.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/path/to/vuex.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>或</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vuex@3.0.1/dist/vuex.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n</code></pre><h3 id=\"使用npm\"><a href=\"#使用npm\" class=\"headerlink\" title=\"使用npm\"></a>使用npm</h3><p>在项目目录下运行：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">npm install vuex <span class=\"token operator\">--</span>save\n</code></pre><p>在模块化的打包系统中利用这种方法时，必须显式地利用<code>Vue.use()</code>来安装Vuex（而script标签引入后是自动安装的）：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span>\n<span class=\"token keyword\">import</span> Vuex <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Vuex<span class=\"token punctuation\">)</span>\n</code></pre><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>功能：把组件的共享状态抽取出来，用一个全局单例模式管理。</p><p>核心：store（仓库），它包含了应用中的大部分state（状态，驱动应用的数据源）。</p><p>这种全局单例模式管理和单纯的全局变量的区别：</p><ul><li><strong>Vuex 的状态存储是响应式的</strong>。若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li><strong>不能直接改变store中的state</strong>。改变 store 中的state的唯一途径就是显式地<strong>commit (提交) mutation（变化）</strong>。这样我们可以方便地跟踪每一个状态的变化。</li></ul><p>一个栗子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 触发状态变更</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> 1</span>\n</code></pre><p><strong>再次强调，使用提交 mutation ，而不是直接改变 <code>store.state.count</code>，</strong></p><p><strong>是因为我们想要更明确地追踪到状态的变化。</strong></p><p>当然，使用 Vuex 并<strong>不意味着</strong>需要将<strong>所有的</strong>状态放入 Vuex。</p><p>虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。</p><p>如果有些状态严格属于单个组件，最好还是作为组件的局部状态。</p><p>你应该根据你的应用开发需要进行权衡和确定。</p><h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>每个应用只包含一个 store 实例，它包含了所有需要vuex管理的状态。</p><h4 id=\"利用计算属性读取state\"><a href=\"#利用计算属性读取state\" class=\"headerlink\" title=\"利用计算属性读取state\"></a>利用计算属性读取state</h4><p>从 store 实例中读取状态最简单的方法就是在<a href=\"https://cn.vuejs.org/guide/computed.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">计算属性</a>中返回某个状态：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 创建一个 Counter 组件</span>\n<span class=\"token keyword\">const</span> Counter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`&lt;div>{{ count }}&lt;/div>`</span></span><span class=\"token punctuation\">,</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>但这种模式导致组件依赖全局状态单例。</p><h4 id=\"注册-store-选项\"><a href=\"#注册-store-选项\" class=\"headerlink\" title=\"注册 store 选项\"></a>注册 <code>store</code> 选项</h4><p>为了解决上述模式导致的组件依赖全局状态单例的问题，</p><p>我们可以通过在<strong>根实例</strong>中注册 <code>store</code> 选项——</p><p>这样 store 实例会注入到根组件下的所有子组件中，</p><p>且子组件能通过 <code>this.$store</code> 访问到：（需调用 <code>Vue.use(Vuex)</code>）</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 根组件</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token string\">'#app'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span>\n  store<span class=\"token punctuation\">,</span>\n  components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> Counter <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`\n    &lt;div class=\"app\">\n      &lt;counter>&lt;/counter>\n    &lt;/div>\n  `</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 子组件</span>\n<span class=\"token keyword\">const</span> Counter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`&lt;div>{{ count }}&lt;/div>`</span></span><span class=\"token punctuation\">,</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 通过 this.$store 访问store</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a><code>mapState</code>辅助函数</h4><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。</p><p>为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 在单独构建的版本中辅助函数为 Vuex.mapState</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 箭头函数可使代码更简练</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将 `this.count` 映射为 `this.$store.state.count</span>\n    count<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 传字符串参数 'count' 等同于 `state => state.count`</span>\n    countAlias<span class=\"token punctuation\">:</span> <span class=\"token string\">'count'</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>\n    countPlusLocalState <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>localCount\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p><pre class=\" language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 映射 this.count 为 store.state.count</span>\n  <span class=\"token string\">'count'</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre><h4 id=\"对象展开操作符\"><a href=\"#对象展开操作符\" class=\"headerlink\" title=\"对象展开操作符\"></a>对象展开操作符</h4><p>ES6引入的新语法，由名字就可以看出来这个操作符的含义：把对象展开，</p><p>来个栗子更容易理解：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>a<span class=\"token punctuation\">,</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// {a: 1, b: 2, c: 3, d: 4}</span>\n\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>b<span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3, 4]</span>\n</code></pre><p>有了这个操作符，我们就可以把<code>mapState</code>函数和局部计算属性混合使用了：</p><pre class=\" language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 局部计算属性</span>\n  localComputed <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">/* ... */</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 使用对象展开运算符将此对象展开混入到外部对象中</span>\n  <span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。</p><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值；getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><p>Getter 接受 state 作为其第一个参数：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    todos<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    doneTodos<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=</span><span class=\"token operator\">></span> todo<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nstore<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span>doneTodos <span class=\"token comment\" spellcheck=\"true\">// -> [{ id: 1, text: '...', done: true }]</span>\n</code></pre><p>Getter 也可以接受其他 getter 作为第二个参数：</p><pre class=\" language-js\"><code class=\"language-js\">getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  doneTodosCount<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> getters<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> getters<span class=\"token punctuation\">.</span>doneTodos<span class=\"token punctuation\">.</span>length\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nstore<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span>doneTodosCount <span class=\"token comment\" spellcheck=\"true\">// -> 1</span>\n</code></pre><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组<strong>进行查询</strong>时非常有用。</p><pre class=\" language-js\"><code class=\"language-js\">getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token comment\" spellcheck=\"true\">// getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</span>\n  getTodoById<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=</span><span class=\"token operator\">></span> todo<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nstore<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span><span class=\"token function\">getTodoById</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> { id: 2, text: '...', done: false }</span>\n</code></pre><p>我们可以很容易地在任何组件中使用getter：</p><pre class=\" language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  doneTodosCount <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span>doneTodosCount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>我们也可以使用<code>mapGetters</code> 辅助函数将 store 中的 getter 映射到局部计算属性：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapGetters <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 使用对象展开运算符将 getter 混入 computed 对象中</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapGetters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'doneTodosCount'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'anotherGetter'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span>\n      doneCount<span class=\"token punctuation\">:</span> <span class=\"token string\">'doneTodosCount'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</strong></p><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p><p>这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里的事件类型为 'increment' </span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 变更状态</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>但我们不能直接调用一个 mutation 回调函数，就像前面说的，我们只能提交 mutation。</p><p>就像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”</p><p>要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法（即提交mutation）：</p><pre class=\" language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n</code></pre><h4 id=\"提交载荷Payload\"><a href=\"#提交载荷Payload\" class=\"headerlink\" title=\"提交载荷Payload\"></a>提交载荷Payload</h4><p>我们还可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\nmutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段，并且记录的 mutation 会更易读：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\nmutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>amount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>我们可以使用对象风格的提交方式，将一个直接包含 <code>type</code> 属性的对象作为载荷传给 mutations ：</p><pre class=\" language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>并且handler 无需改变：</p><pre class=\" language-js\"><code class=\"language-js\">mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>amount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"Mutation-需遵守-Vue-的响应规则\"><a href=\"#Mutation-需遵守-Vue-的响应规则\" class=\"headerlink\" title=\"Mutation 需遵守 Vue 的响应规则\"></a>Mutation 需遵守 Vue 的响应规则</h4><p>因为 Vuex 的 store 中的状态是响应式的，那么当我们使用Mutation变更状态时，监视状态的 Vue 组件也会自动更新。</p><p>因此使用 Vuex 中的 mutation 也需要像使用Vue 一样遵守一些注意事项：</p><ol><li><p>提前在 store 中初始化好所有所需属性。</p></li><li><p>当需要在对象上添加新属性时，你应该</p><ul><li><p>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者</p></li><li><p>以新对象替换老对象。例如利用ES6的对象展开运算符：</p><pre class=\" language-js\"><code class=\"language-js\">state<span class=\"token punctuation\">.</span>obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>state<span class=\"token punctuation\">.</span>obj<span class=\"token punctuation\">,</span> newProp<span class=\"token punctuation\">:</span> <span class=\"token number\">123</span> <span class=\"token punctuation\">}</span>\n</code></pre></li></ul></li></ol><h4 id=\"Mutation-必须是同步函数\"><a href=\"#Mutation-必须是同步函数\" class=\"headerlink\" title=\"Mutation 必须是同步函数\"></a>Mutation 必须是同步函数</h4><p><strong>mutation 必须是同步函数</strong>。为什么？请参考下面的例子：</p><pre class=\" language-js\"><code class=\"language-js\">mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  someMutation <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    api<span class=\"token punctuation\">.</span><span class=\"token function\">callAsyncMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>假设我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志：</p><p>每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。</p><p>然而，在上面的例子中 mutation 中的<strong>异步函数</strong>中的回调让这不可能完成：</p><p>当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——</p><p>实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h4 id=\"在组件中提交-Mutation\"><a href=\"#在组件中提交-Mutation\" class=\"headerlink\" title=\"在组件中提交 Mutation\"></a>在组件中提交 Mutation</h4><p>我们可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，</p><p>或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapMutations <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapMutations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// `mapMutations` 也支持载荷：</span>\n      <span class=\"token string\">'incrementBy'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapMutations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      add<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"使用常量替代-Mutation-事件类型\"><a href=\"#使用常量替代-Mutation-事件类型\" class=\"headerlink\" title=\"使用常量替代 Mutation 事件类型\"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// mutation-types.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> SOME_MUTATION <span class=\"token operator\">=</span> <span class=\"token string\">'SOME_MUTATION'</span>\n<span class=\"token comment\" spellcheck=\"true\">// store.js</span>\n<span class=\"token keyword\">import</span> Vuex <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SOME_MUTATION <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./mutation-types'</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>\n    <span class=\"token punctuation\">[</span>SOME_MUTATION<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// mutate state</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>用不用常量取决于实际情况——在需要多人协作的大型项目中，这会很有帮助。你果然如果不想用，也完全可以不用。</p><h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 是提交 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 变更状态</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 接受一个与 store 实例具有相同方法和属性的 context 对象</span>\n    increment <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 提交mutation</span>\n      context<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>实践中，我们可以使用 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p><pre class=\" language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"进行异步操作\"><a href=\"#进行异步操作\" class=\"headerlink\" title=\"进行异步操作\"></a>进行异步操作</h4><p>因为action是提交mutation而不是直接变更状态，因此我们就可以在action内部执行异步操作了：</p><pre class=\" language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  incrementAsync <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h4><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><pre class=\" language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n</code></pre><p>Actions 支持Mutation同样的载荷方式和对象方式进行分发：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 以载荷形式分发</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'incrementAsync'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 以对象形式分发</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'incrementAsync'</span><span class=\"token punctuation\">,</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>也可以在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapActions <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// `mapActions` 也支持载荷：</span>\n      <span class=\"token string\">'incrementBy'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      add<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h4 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><h5 id=\"使用promise\"><a href=\"#使用promise\" class=\"headerlink\" title=\"使用promise\"></a>使用promise</h5><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，</p><p>然后返回这个 Promise：</p><pre class=\" language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  actionA <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someMutation'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>现在我们就可以：</p><pre class=\" language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre><p>在另外一个 action 中也可以：</p><pre class=\" language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  actionB <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someOtherMutation'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h5 id=\"使用async-await\"><a href=\"#使用async-await\" class=\"headerlink\" title=\"使用async / await\"></a>使用async / await</h5><p>如果我们可以利用 <strong>async / await</strong>，我们还可以如下组合 action：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 假设 gotData() 和 gotOtherData() 返回的是 Promise</span>\n\nactions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">async</span> actionA <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'gotData'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> actionB <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 等待 actionA 完成</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'gotOtherData'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getOtherData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><blockquote><p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote><h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> moduleB <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> moduleA<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> moduleB\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>a <span class=\"token comment\" spellcheck=\"true\">// -> moduleA 的状态</span>\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>b <span class=\"token comment\" spellcheck=\"true\">// -> moduleB 的状态</span>\n</code></pre><h4 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 这里的 `state` 对象是模块的局部状态</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    doubleCount <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    incrementIfOddOnRootSum <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> state<span class=\"token punctuation\">,</span> commit<span class=\"token punctuation\">,</span> rootState <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> rootState<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>对于模块内部的 getter，根节点状态也会作为第三个参数暴露出来：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    sumWithRootCount <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> getters<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> rootState<span class=\"token punctuation\">.</span>count\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>Vuex 并不限制我们的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><p>如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><pre class=\" language-bash\"><code class=\"language-bash\">├── index.html\n├── main.js\n├── api\n│   └── <span class=\"token punctuation\">..</span>. <span class=\"token comment\" spellcheck=\"true\"># 抽取出API请求</span>\n├── components\n│   ├── App.vue\n│   └── <span class=\"token punctuation\">..</span>.\n└── store\n    ├── index.js          <span class=\"token comment\" spellcheck=\"true\"># 我们组装模块并导出 store 的地方</span>\n    ├── actions.js        <span class=\"token comment\" spellcheck=\"true\"># 根级别的 action</span>\n    ├── mutations.js      <span class=\"token comment\" spellcheck=\"true\"># 根级别的 mutation</span>\n    └── modules\n        ├── cart.js       <span class=\"token comment\" spellcheck=\"true\"># 购物车模块</span>\n        └── products.js   <span class=\"token comment\" spellcheck=\"true\"># 产品模块</span>\n</code></pre><hr><p>有时候看不进去<a href=\"https://vuex.vuejs.org/zh/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">文档</a>，一边总结一边看就能看进去了 :)</p>","site":{"data":{}},"excerpt":"<p>vuex文档学习笔记。</p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>比较常用的两种：</p><h3 id=\"直接下载或CDN引用\"><a href=\"#直接下载或CDN引用\" class=\"headerlink\" title=\"直接下载或CDN引用\"></a>直接下载或CDN引用</h3><p>从<a href=\"https://unpkg.com/vuex\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://unpkg.com/vuex</a>下载后利用script标签在vue后引入：</p><pre><code class=\"html\">&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>或</p><pre><code class=\"html\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://unpkg.com/vuex@3.0.1/dist/vuex.js&quot;&gt;&lt;/script&gt;\n</code></pre><h3 id=\"使用npm\"><a href=\"#使用npm\" class=\"headerlink\" title=\"使用npm\"></a>使用npm</h3><p>在项目目录下运行：</p><pre><code class=\"powershell\">npm install vuex --save\n</code></pre><p>在模块化的打包系统中利用这种方法时，必须显式地利用<code>Vue.use()</code>来安装Vuex（而script标签引入后是自动安装的）：</p><pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nVue.use(Vuex)\n</code></pre><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>功能：把组件的共享状态抽取出来，用一个全局单例模式管理。</p><p>核心：store（仓库），它包含了应用中的大部分state（状态，驱动应用的数据源）。</p><p>这种全局单例模式管理和单纯的全局变量的区别：</p><ul><li><strong>Vuex 的状态存储是响应式的</strong>。若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li><strong>不能直接改变store中的state</strong>。改变 store 中的state的唯一途径就是显式地<strong>commit (提交) mutation（变化）</strong>。这样我们可以方便地跟踪每一个状态的变化。</li></ul><p>一个栗子：</p><pre><code class=\"js\">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n\n// 触发状态变更\nstore.commit(&#39;increment&#39;)\n\nconsole.log(store.state.count) // -&gt; 1\n</code></pre><p><strong>再次强调，使用提交 mutation ，而不是直接改变 <code>store.state.count</code>，</strong></p><p><strong>是因为我们想要更明确地追踪到状态的变化。</strong></p><p>当然，使用 Vuex 并<strong>不意味着</strong>需要将<strong>所有的</strong>状态放入 Vuex。</p><p>虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。</p><p>如果有些状态严格属于单个组件，最好还是作为组件的局部状态。</p><p>你应该根据你的应用开发需要进行权衡和确定。</p><h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>每个应用只包含一个 store 实例，它包含了所有需要vuex管理的状态。</p><h4 id=\"利用计算属性读取state\"><a href=\"#利用计算属性读取state\" class=\"headerlink\" title=\"利用计算属性读取state\"></a>利用计算属性读取state</h4><p>从 store 实例中读取状态最简单的方法就是在<a href=\"https://cn.vuejs.org/guide/computed.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">计算属性</a>中返回某个状态：</p><pre><code class=\"js\">// 创建一个 Counter 组件\nconst Counter = {\n  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n</code></pre><p>但这种模式导致组件依赖全局状态单例。</p><h4 id=\"注册-store-选项\"><a href=\"#注册-store-选项\" class=\"headerlink\" title=\"注册 store 选项\"></a>注册 <code>store</code> 选项</h4><p>为了解决上述模式导致的组件依赖全局状态单例的问题，</p><p>我们可以通过在<strong>根实例</strong>中注册 <code>store</code> 选项——</p><p>这样 store 实例会注入到根组件下的所有子组件中，</p><p>且子组件能通过 <code>this.$store</code> 访问到：（需调用 <code>Vue.use(Vuex)</code>）</p><pre><code class=\"js\">// 根组件\nconst app = new Vue({\n  el: &#39;#app&#39;,\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    &lt;div class=&quot;app&quot;&gt;\n      &lt;counter&gt;&lt;/counter&gt;\n    &lt;/div&gt;\n  `\n})\n</code></pre><pre><code class=\"js\">// 子组件\nconst Counter = {\n  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\n  computed: {\n    count () {\n      // 通过 this.$store 访问store\n      return this.$store.state.count\n    }\n  }\n}\n</code></pre><h4 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a><code>mapState</code>辅助函数</h4><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。</p><p>为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p><pre><code class=\"js\">// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    // 将 `this.count` 映射为 `this.$store.state.count\n    count: state =&gt; state.count,\n\n    // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`\n    countAlias: &#39;count&#39;,\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n</code></pre><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p><pre><code class=\"js\">computed: mapState([\n  // 映射 this.count 为 store.state.count\n  &#39;count&#39;\n])\n</code></pre><h4 id=\"对象展开操作符\"><a href=\"#对象展开操作符\" class=\"headerlink\" title=\"对象展开操作符\"></a>对象展开操作符</h4><p>ES6引入的新语法，由名字就可以看出来这个操作符的含义：把对象展开，</p><p>来个栗子更容易理解：</p><pre><code class=\"js\">var a = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3};\n{...a,&#39;d&#39;:4} // {a: 1, b: 2, c: 3, d: 4}\n\nvar b = [1,2,3];\n[...b,4] // [1, 2, 3, 4]\n</code></pre><p>有了这个操作符，我们就可以把<code>mapState</code>函数和局部计算属性混合使用了：</p><pre><code class=\"js\">computed: {\n  // 局部计算属性\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象展开混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n</code></pre><h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。</p><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值；getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><p>Getter 接受 state 作为其第一个参数：</p><pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -&gt; [{ id: 1, text: &#39;...&#39;, done: true }]\n</code></pre><p>Getter 也可以接受其他 getter 作为第二个参数：</p><pre><code class=\"js\">getters: {\n  // ...\n  doneTodosCount: (state, getters) =&gt; {\n    return getters.doneTodos.length\n  }\n}\n\nstore.getters.doneTodosCount // -&gt; 1\n</code></pre><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组<strong>进行查询</strong>时非常有用。</p><pre><code class=\"js\">getters: {\n  // ...\n  // getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n  getTodoById: (state) =&gt; (id) =&gt; {\n    return state.todos.find(todo =&gt; todo.id === id)\n  }\n}\n\nstore.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }\n</code></pre><p>我们可以很容易地在任何组件中使用getter：</p><pre><code class=\"js\">computed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n</code></pre><p>我们也可以使用<code>mapGetters</code> 辅助函数将 store 中的 getter 映射到局部计算属性：</p><pre><code class=\"js\">import { mapGetters } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      &#39;doneTodosCount&#39;,\n      &#39;anotherGetter&#39;,\n      // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n      doneCount: &#39;doneTodosCount&#39;,\n      // ...\n    ])\n  }\n}\n</code></pre><h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</strong></p><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。</p><p>这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    // 这里的事件类型为 &#39;increment&#39; \n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n</code></pre><p>但我们不能直接调用一个 mutation 回调函数，就像前面说的，我们只能提交 mutation。</p><p>就像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”</p><p>要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法（即提交mutation）：</p><pre><code class=\"js\">store.commit(&#39;increment&#39;)\n</code></pre><h4 id=\"提交载荷Payload\"><a href=\"#提交载荷Payload\" class=\"headerlink\" title=\"提交载荷Payload\"></a>提交载荷Payload</h4><p>我们还可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p><pre><code class=\"js\">// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit(&#39;increment&#39;, 10)\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段，并且记录的 mutation 会更易读：</p><pre><code class=\"js\">// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n// ...\n\nstore.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre><p>我们可以使用对象风格的提交方式，将一个直接包含 <code>type</code> 属性的对象作为载荷传给 mutations ：</p><pre><code class=\"js\">store.commit({\n  type: &#39;increment&#39;,\n  amount: 10\n})\n</code></pre><p>并且handler 无需改变：</p><pre><code class=\"js\">mutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre><h4 id=\"Mutation-需遵守-Vue-的响应规则\"><a href=\"#Mutation-需遵守-Vue-的响应规则\" class=\"headerlink\" title=\"Mutation 需遵守 Vue 的响应规则\"></a>Mutation 需遵守 Vue 的响应规则</h4><p>因为 Vuex 的 store 中的状态是响应式的，那么当我们使用Mutation变更状态时，监视状态的 Vue 组件也会自动更新。</p><p>因此使用 Vuex 中的 mutation 也需要像使用Vue 一样遵守一些注意事项：</p><ol><li><p>提前在 store 中初始化好所有所需属性。</p></li><li><p>当需要在对象上添加新属性时，你应该</p><ul><li><p>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者</p></li><li><p>以新对象替换老对象。例如利用ES6的对象展开运算符：</p><pre><code class=\"js\">state.obj = { ...state.obj, newProp: 123 }\n</code></pre></li></ul></li></ol><h4 id=\"Mutation-必须是同步函数\"><a href=\"#Mutation-必须是同步函数\" class=\"headerlink\" title=\"Mutation 必须是同步函数\"></a>Mutation 必须是同步函数</h4><p><strong>mutation 必须是同步函数</strong>。为什么？请参考下面的例子：</p><pre><code class=\"js\">mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() =&gt; {\n      state.count++\n    })\n  }\n}\n</code></pre><p>假设我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志：</p><p>每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。</p><p>然而，在上面的例子中 mutation 中的<strong>异步函数</strong>中的回调让这不可能完成：</p><p>当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——</p><p>实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h4 id=\"在组件中提交-Mutation\"><a href=\"#在组件中提交-Mutation\" class=\"headerlink\" title=\"在组件中提交 Mutation\"></a>在组件中提交 Mutation</h4><p>我们可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，</p><p>或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）：</p><pre><code class=\"js\">import { mapMutations } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n\n      // `mapMutations` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapMutations({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h4 id=\"使用常量替代-Mutation-事件类型\"><a href=\"#使用常量替代-Mutation-事件类型\" class=\"headerlink\" title=\"使用常量替代 Mutation 事件类型\"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p><pre><code class=\"js\">// mutation-types.js\nexport const SOME_MUTATION = &#39;SOME_MUTATION&#39;\n// store.js\nimport Vuex from &#39;vuex&#39;\nimport { SOME_MUTATION } from &#39;./mutation-types&#39;\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n</code></pre><p>用不用常量取决于实际情况——在需要多人协作的大型项目中，这会很有帮助。你果然如果不想用，也完全可以不用。</p><h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 是提交 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  },\n  actions: {\n    // 接受一个与 store 实例具有相同方法和属性的 context 对象\n    increment (context) {\n      // 提交mutation\n      context.commit(&#39;increment&#39;)\n    }\n  }\n})\n</code></pre><p>实践中，我们可以使用 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p><pre><code class=\"js\">actions: {\n  increment ({ commit }) {\n    commit(&#39;increment&#39;)\n  }\n}\n</code></pre><h4 id=\"进行异步操作\"><a href=\"#进行异步操作\" class=\"headerlink\" title=\"进行异步操作\"></a>进行异步操作</h4><p>因为action是提交mutation而不是直接变更状态，因此我们就可以在action内部执行异步操作了：</p><pre><code class=\"js\">actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() =&gt; {\n      commit(&#39;increment&#39;)\n    }, 1000)\n  }\n}\n</code></pre><h4 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h4><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><pre><code class=\"js\">store.dispatch(&#39;increment&#39;)\n</code></pre><p>Actions 支持Mutation同样的载荷方式和对象方式进行分发：</p><pre><code class=\"js\">// 以载荷形式分发\nstore.dispatch(&#39;incrementAsync&#39;, {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: &#39;incrementAsync&#39;,\n  amount: 10\n})\n</code></pre><p>也可以在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p><pre><code class=\"js\">import { mapActions } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n\n      // `mapActions` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapActions({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h4 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><h5 id=\"使用promise\"><a href=\"#使用promise\" class=\"headerlink\" title=\"使用promise\"></a>使用promise</h5><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，</p><p>然后返回这个 Promise：</p><pre><code class=\"js\">actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        commit(&#39;someMutation&#39;)\n        resolve()\n      }, 1000)\n    })\n  }\n}\n</code></pre><p>现在我们就可以：</p><pre><code class=\"js\">store.dispatch(&#39;actionA&#39;).then(() =&gt; {\n  // ...\n})\n</code></pre><p>在另外一个 action 中也可以：</p><pre><code class=\"js\">actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch(&#39;actionA&#39;).then(() =&gt; {\n      commit(&#39;someOtherMutation&#39;)\n    })\n  }\n}\n</code></pre><h5 id=\"使用async-await\"><a href=\"#使用async-await\" class=\"headerlink\" title=\"使用async / await\"></a>使用async / await</h5><p>如果我们可以利用 <strong>async / await</strong>，我们还可以如下组合 action：</p><pre><code class=\"js\">// 假设 gotData() 和 gotOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit(&#39;gotData&#39;, await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成\n    commit(&#39;gotOtherData&#39;, await getOtherData())\n  }\n}\n</code></pre><blockquote><p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote><h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><pre><code class=\"js\">const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre><h4 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p><pre><code class=\"js\">const moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n</code></pre><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p><pre><code class=\"js\">const moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit(&#39;increment&#39;)\n      }\n    }\n  }\n}\n</code></pre><p>对于模块内部的 getter，根节点状态也会作为第三个参数暴露出来：</p><pre><code class=\"js\">const moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n</code></pre><h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>Vuex 并不限制我们的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><p>如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><pre><code class=\"bash\">├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n</code></pre><hr><p>有时候看不进去<a href=\"https://vuex.vuejs.org/zh/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">文档</a>，一边总结一边看就能看进去了 :)</p>"},{"title":"Web前端错题模糊题记录","toc":true,"date":"2018-09-20T02:04:36.000Z","_content":"\n## HTML\n\n<u>**元素的alt和title有什么异同？**</u>\n\nalt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。\n\n<!-- more -->\n\n**<u>关于html5标签？</u>**\n\n\\<audio\\> 标签定义声音，比如音乐或其他音频流。\n\\<canvas\\> 标签定义图形，比如图表和其他图像。\\<canvas\\> 标签只是图形容器，必须使用脚本来绘制图形。\n\\<article\\>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\n\\<menu\\> 标签定义命令的列表或菜单。\\<menu\\> 标签用于上下文菜单、工具栏以及用于列出表单控件和命令。command 元素表示用户能够调用的命令。\\<command\\> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。 \n\n**<u>有关HTML的Doctype和严格模式与混杂模式？</u>**\n\n> **文档类型**\n>\n>  DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。\n>\n>  DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。\n>\n> 如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。\n>\n>  **浏览器模式**\n>\n>     浏览器有两种呈现模式：标准模式和混杂模式（quirks mode，也叫兼容模式）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。\n>\n> ** DOCTYPE 切换 **\n>\n> 对于 HTML 4.01 文档，\n>\n> - 包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。\n> - 包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。\n> - 但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。\n> - DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。\n> \n\n**<u>NOSCRIPT标签是做什么用的？</u>**\n\nnoscript 元素用来定义在脚本未被执行时的替代内容（文本）。\n\n## CSS\n\n**<u>关于CSS的position属性？</u>**\n\nstatic没有定位，元素出现在正常的流中。\n\nfixed是相对于窗口的固定定位。\n\n**<u>关于border:none以及border:0?</u>**\n\n当定义border:none时，表示无边框样式，浏览器并不会对边框进行渲染，也就没有实际的宽度；\n\n定义边框时，除了设置宽度外，还必须设置边框的样式才能显示出来。\n\n**<u>关于CSS sprites图片字节？</u>**\n\nCSS Sprites能减少图片的字节，曾经比较过多次，3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n**<u>关于浏览器引擎？</u>**\n\nWekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。\n\n另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。\n\n还有Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台--Opera mini。\n\n另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核。\n\n## JavaScript\n\n<u>**flash和js通过什么类如何交互?**</u>\n\nExternalInterface。Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。\n\n**<u>有关浏览器中使用js跨域获取数据？</u>**\n\n只要<u>协议 、 域名 、 端口</u>有任何一个不同, 都被当作是 **不同** 的域。\n\n> **1.CORS**\n>\n> CORS（Cross-Origin Resource Sharing，跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。\n>\n> **2.document.domain**\n>\n> 将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。\n>\n> 注意：\n>\n> 不能将值设置为URL中不包含的域；\n>\n> 松散的域名不能再设置为紧绷的域名。\n>\n> **3.图像Ping**\n>\n> var img=new Image();\n>\n> img.onload=img.onerror=function(){\n>\n> ... ...\n>\n> }\n>\n> img.src=\"url?name=value\";\n>\n> 请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。\n>\n> 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。\n>\n> 缺点：\n>\n> 只能发送GET请求；\n>\n> 无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。\n>\n> **4.Jsonp**\n>\n> var script=document.createElement(\"script\");\n>\n> script.src=\"url?callback=handleResponse\";\n>\n> document.body.insertBefore(script,document.body.firstChild);\n>\n> JSONP由两部分组成：回调函数和数据\n>\n> 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。\n>\n> 数据是传入回调函数中的JSON数据。\n>\n> 优点：\n>\n> 能够直接访问响应文本，可用于浏览器与服务器间的双向通信。\n>\n> 缺点：\n>\n> JSONP从其他域中加载代码执行，其他域可能不安全；\n>\n> 难以确定JSONP请求是否失败。\n>\n> **5.Comet**\n>\n> Comet可实现服务器向浏览器推送数据。\n>\n> Comet是实现方式：长轮询和流\n>\n> 短轮询即浏览器定时向服务器发送请求，看有没有数据更新。\n>\n> 长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。\n>\n> 流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。\n>\n> **6.WebSocket**\n>\n> WebSocket可在一个单独的持久连接上提供全双工、双向通信。\n>\n> WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。\n>\n> var webSocket=new WebSocket(\"ws://\");\n>\n> webSocket.send(message);\n>\n> webSocket.onmessage=function(event){\n>\n> var data=event.data;\n>\n> ... ....\n>\n> }\n>\n> 注意：\n>\n> 必须给WebSocket构造函数传入绝对URL；\n>\n> WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；\n>\n> WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。\n>\n> 优点：\n>\n> 在客户端和服务器之间发送非常少的数据，减少字节开销。\n\n**<u>如何获取一个元素节点（id 为 test）的父元素，找到之后如何删除这个元素节点（id 为 test）？</u>**\n\n```js\nvar testNode = document.getElementById('test');\nvar parentNode = testNode.parentNode;\nparentNode.removeChild(testNode);\t\n```\n\n**<u>!编写一个 js 函数 jsonp 的处理函数:</u>**\n\n[讲解链接](https://blog.csdn.net/u013830811/article/details/52718664)\n\n```js\n// 手写jsonp\nfunction myCallback(data) {\n    console.log(data)\n}\n \nfunction jsonp(url, data, callback) {\n    // data是否是字符串，是的话证明data值就是函数名\n    if (typeof data == 'string') {\n        callback = data\n        data = {}\n    }\n    // 拼接data\n    url += url.indexOf('?') === -1 ? '?' : '&'\n    url += 'callback=' + callback\n    var params = \"\"\n    for (var i in data) {\n        params += '&' + i + '=' + data[i]\n    }\n    url += params\n    // 在页面插入script标签\n    var script = document.createElement('script')\n    script.setAttribute('src', url)\n    document.querySelector('head').appendChild(script)\n \n}\n \njsonp('http://baidu.com/index.html', { id: 34 }, 'myCallback')\njsonp('http://baidu.com/index.html?name=\"zjn\"', { id: 34 }, 'myCallback')\n```\n\n**<u>编写一个函数判断参数是否是数组类型，如果是返回 true</u>**\n\n```js\n// 方法一：\nfunction isArray(arg){\n  return (arg instanceof Array);\n}\n// 方法二：\nfunction isArray(arg){\n  return Object.prototype.toString.call(arg) == '[object Array]' ? true : false;\n}\n// 方法三：\nfunction isArray(arg){\n  return arg.__proto__.constructor.name == 'Array' ？true : false;\n}\n```\n\n**<u>关于对象的length属性：</u>**\n\nWindow.length //返回在当前窗口中frames的数量（包括IFRAMES）\n\nString.length //返回字符串中的字符数目\n\nFunction.length //获取一个函数定义的参数数目\n\nArray.length //返回数组中元素的数目\n\n**如何获取 url 中的 query 字段对应的值，比如：[https://m.mobike.com?source=part1](https://m.mobike.com/?source=part1)，编写一个函数获取 source 对应的值 part1**\n\n```js\nlet query = (url) => {\n  let p = url.split('?')[1];\n  let sourcePos = p.indexOf('source');\n  if (sourcePos > -1) {\n    if (p.indexOf('&', sourcePos+7) > -1) {\n      return p.substring(sourcePos+7,p.indexOf('&', sourcePos+7));\n    } else {\n      return p.substring(sourcePos+7);\n    }\n  }\n};\n```\n\n**<u>关于IE的event对象支持的方法：</u>**\n\nIE的所有事件对象都支持的方法和属性：\n\n- cancelBubble 默认为false，设置为true就可以取消事件冒泡\n- returnValue 默认为true，设置为false可以取消事件的默认行为\n- srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用\n- type 被触发事件的类型\n\nDOM事件的方法（IE的事件模型不支持）：\n\n- initEvent() 初始化新创建的 Event 对象的属性\n- preventDefault() 通知浏览器不要执行与事件关联的默认动作\n- stopPropagation() 不再派发事件\n\n<u>**JavaScript的函数调用有哪几种方式？请举例说明，并分析其不同之处。**</u>\n\n![img](https://uploadfiles.nowcoder.com/images/20180906/5405985_1536239169184_7CB0EB2AC29A9E988352087AAD2B0C2F)\n\n**<u>以下 javascript 代码，在浏览器中运行的结果是</u>**\n\n![img](https://uploadfiles.nowcoder.net/images/20161128/5918115_1480305918764_CF08B543645A55F242CA55EB20727AE6)\n\n先全部输出first，然后全部输出second。\n\njs 是运行于单线程环境中，定时器作用是在规定时间内将事件加入执行队列，而加入的前提是当前事件队列没有任何东西。\n\n## 其他\n\n**<u>和后端 API 服务通信的方式有哪些</u>**\n\n1. ajax\n2. websocket\n3. SSE\n4. 服务器端渲染\n\n**<u>POST 提交的时候，content-type 有哪几种？</u>**\n\n常见的有四种\n\n1. application/x-www-form-urlencoded\n2. application/json \n3. multipart/form-data\n4. text/xml \n\n**<u>对前端工程化的理解，以及任意构建工具(webpack、gulp、grunt、rollup)的某一个使用的一些描述</u>**\n\n**前端工程化**\n\nhttps://blog.csdn.net/mayfla/article/details/78697020\n\n**webpack**\n\nwebpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。\n\n**<u>Node.js 的核心模块</u>**\n\nHTTP模块、URL模块、Query Strings模块、File System模块、Path模块、Global模块。\n\n**<u>ajax事件有哪些</u>**\n\n![img](https://uploadfiles.nowcoder.net/images/20170311/6901516_1489199810009_E2168FD8E97D4BF6646E2043D52753FD)\n\n\n\n","source":"_posts/Web前端错题模糊题记录.md","raw":"---\ntitle: Web前端错题模糊题记录\ntoc: true\ndate: 2018-09-20 10:04:36\ncategories:\n- Web\ntags:\n- HTML\n- CSS\n- JavaScript\n---\n\n## HTML\n\n<u>**元素的alt和title有什么异同？**</u>\n\nalt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。\n\n<!-- more -->\n\n**<u>关于html5标签？</u>**\n\n\\<audio\\> 标签定义声音，比如音乐或其他音频流。\n\\<canvas\\> 标签定义图形，比如图表和其他图像。\\<canvas\\> 标签只是图形容器，必须使用脚本来绘制图形。\n\\<article\\>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\n\\<menu\\> 标签定义命令的列表或菜单。\\<menu\\> 标签用于上下文菜单、工具栏以及用于列出表单控件和命令。command 元素表示用户能够调用的命令。\\<command\\> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。 \n\n**<u>有关HTML的Doctype和严格模式与混杂模式？</u>**\n\n> **文档类型**\n>\n>  DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。\n>\n>  DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。\n>\n> 如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。\n>\n>  **浏览器模式**\n>\n>     浏览器有两种呈现模式：标准模式和混杂模式（quirks mode，也叫兼容模式）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。\n>\n> ** DOCTYPE 切换 **\n>\n> 对于 HTML 4.01 文档，\n>\n> - 包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。\n> - 包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。\n> - 但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。\n> - DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。\n> \n\n**<u>NOSCRIPT标签是做什么用的？</u>**\n\nnoscript 元素用来定义在脚本未被执行时的替代内容（文本）。\n\n## CSS\n\n**<u>关于CSS的position属性？</u>**\n\nstatic没有定位，元素出现在正常的流中。\n\nfixed是相对于窗口的固定定位。\n\n**<u>关于border:none以及border:0?</u>**\n\n当定义border:none时，表示无边框样式，浏览器并不会对边框进行渲染，也就没有实际的宽度；\n\n定义边框时，除了设置宽度外，还必须设置边框的样式才能显示出来。\n\n**<u>关于CSS sprites图片字节？</u>**\n\nCSS Sprites能减少图片的字节，曾经比较过多次，3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n**<u>关于浏览器引擎？</u>**\n\nWekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。\n\n另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。\n\n还有Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台--Opera mini。\n\n另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核。\n\n## JavaScript\n\n<u>**flash和js通过什么类如何交互?**</u>\n\nExternalInterface。Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。\n\n**<u>有关浏览器中使用js跨域获取数据？</u>**\n\n只要<u>协议 、 域名 、 端口</u>有任何一个不同, 都被当作是 **不同** 的域。\n\n> **1.CORS**\n>\n> CORS（Cross-Origin Resource Sharing，跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。\n>\n> **2.document.domain**\n>\n> 将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。\n>\n> 注意：\n>\n> 不能将值设置为URL中不包含的域；\n>\n> 松散的域名不能再设置为紧绷的域名。\n>\n> **3.图像Ping**\n>\n> var img=new Image();\n>\n> img.onload=img.onerror=function(){\n>\n> ... ...\n>\n> }\n>\n> img.src=\"url?name=value\";\n>\n> 请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。\n>\n> 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。\n>\n> 缺点：\n>\n> 只能发送GET请求；\n>\n> 无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。\n>\n> **4.Jsonp**\n>\n> var script=document.createElement(\"script\");\n>\n> script.src=\"url?callback=handleResponse\";\n>\n> document.body.insertBefore(script,document.body.firstChild);\n>\n> JSONP由两部分组成：回调函数和数据\n>\n> 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。\n>\n> 数据是传入回调函数中的JSON数据。\n>\n> 优点：\n>\n> 能够直接访问响应文本，可用于浏览器与服务器间的双向通信。\n>\n> 缺点：\n>\n> JSONP从其他域中加载代码执行，其他域可能不安全；\n>\n> 难以确定JSONP请求是否失败。\n>\n> **5.Comet**\n>\n> Comet可实现服务器向浏览器推送数据。\n>\n> Comet是实现方式：长轮询和流\n>\n> 短轮询即浏览器定时向服务器发送请求，看有没有数据更新。\n>\n> 长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。\n>\n> 流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。\n>\n> **6.WebSocket**\n>\n> WebSocket可在一个单独的持久连接上提供全双工、双向通信。\n>\n> WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。\n>\n> var webSocket=new WebSocket(\"ws://\");\n>\n> webSocket.send(message);\n>\n> webSocket.onmessage=function(event){\n>\n> var data=event.data;\n>\n> ... ....\n>\n> }\n>\n> 注意：\n>\n> 必须给WebSocket构造函数传入绝对URL；\n>\n> WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；\n>\n> WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。\n>\n> 优点：\n>\n> 在客户端和服务器之间发送非常少的数据，减少字节开销。\n\n**<u>如何获取一个元素节点（id 为 test）的父元素，找到之后如何删除这个元素节点（id 为 test）？</u>**\n\n```js\nvar testNode = document.getElementById('test');\nvar parentNode = testNode.parentNode;\nparentNode.removeChild(testNode);\t\n```\n\n**<u>!编写一个 js 函数 jsonp 的处理函数:</u>**\n\n[讲解链接](https://blog.csdn.net/u013830811/article/details/52718664)\n\n```js\n// 手写jsonp\nfunction myCallback(data) {\n    console.log(data)\n}\n \nfunction jsonp(url, data, callback) {\n    // data是否是字符串，是的话证明data值就是函数名\n    if (typeof data == 'string') {\n        callback = data\n        data = {}\n    }\n    // 拼接data\n    url += url.indexOf('?') === -1 ? '?' : '&'\n    url += 'callback=' + callback\n    var params = \"\"\n    for (var i in data) {\n        params += '&' + i + '=' + data[i]\n    }\n    url += params\n    // 在页面插入script标签\n    var script = document.createElement('script')\n    script.setAttribute('src', url)\n    document.querySelector('head').appendChild(script)\n \n}\n \njsonp('http://baidu.com/index.html', { id: 34 }, 'myCallback')\njsonp('http://baidu.com/index.html?name=\"zjn\"', { id: 34 }, 'myCallback')\n```\n\n**<u>编写一个函数判断参数是否是数组类型，如果是返回 true</u>**\n\n```js\n// 方法一：\nfunction isArray(arg){\n  return (arg instanceof Array);\n}\n// 方法二：\nfunction isArray(arg){\n  return Object.prototype.toString.call(arg) == '[object Array]' ? true : false;\n}\n// 方法三：\nfunction isArray(arg){\n  return arg.__proto__.constructor.name == 'Array' ？true : false;\n}\n```\n\n**<u>关于对象的length属性：</u>**\n\nWindow.length //返回在当前窗口中frames的数量（包括IFRAMES）\n\nString.length //返回字符串中的字符数目\n\nFunction.length //获取一个函数定义的参数数目\n\nArray.length //返回数组中元素的数目\n\n**如何获取 url 中的 query 字段对应的值，比如：[https://m.mobike.com?source=part1](https://m.mobike.com/?source=part1)，编写一个函数获取 source 对应的值 part1**\n\n```js\nlet query = (url) => {\n  let p = url.split('?')[1];\n  let sourcePos = p.indexOf('source');\n  if (sourcePos > -1) {\n    if (p.indexOf('&', sourcePos+7) > -1) {\n      return p.substring(sourcePos+7,p.indexOf('&', sourcePos+7));\n    } else {\n      return p.substring(sourcePos+7);\n    }\n  }\n};\n```\n\n**<u>关于IE的event对象支持的方法：</u>**\n\nIE的所有事件对象都支持的方法和属性：\n\n- cancelBubble 默认为false，设置为true就可以取消事件冒泡\n- returnValue 默认为true，设置为false可以取消事件的默认行为\n- srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用\n- type 被触发事件的类型\n\nDOM事件的方法（IE的事件模型不支持）：\n\n- initEvent() 初始化新创建的 Event 对象的属性\n- preventDefault() 通知浏览器不要执行与事件关联的默认动作\n- stopPropagation() 不再派发事件\n\n<u>**JavaScript的函数调用有哪几种方式？请举例说明，并分析其不同之处。**</u>\n\n![img](https://uploadfiles.nowcoder.com/images/20180906/5405985_1536239169184_7CB0EB2AC29A9E988352087AAD2B0C2F)\n\n**<u>以下 javascript 代码，在浏览器中运行的结果是</u>**\n\n![img](https://uploadfiles.nowcoder.net/images/20161128/5918115_1480305918764_CF08B543645A55F242CA55EB20727AE6)\n\n先全部输出first，然后全部输出second。\n\njs 是运行于单线程环境中，定时器作用是在规定时间内将事件加入执行队列，而加入的前提是当前事件队列没有任何东西。\n\n## 其他\n\n**<u>和后端 API 服务通信的方式有哪些</u>**\n\n1. ajax\n2. websocket\n3. SSE\n4. 服务器端渲染\n\n**<u>POST 提交的时候，content-type 有哪几种？</u>**\n\n常见的有四种\n\n1. application/x-www-form-urlencoded\n2. application/json \n3. multipart/form-data\n4. text/xml \n\n**<u>对前端工程化的理解，以及任意构建工具(webpack、gulp、grunt、rollup)的某一个使用的一些描述</u>**\n\n**前端工程化**\n\nhttps://blog.csdn.net/mayfla/article/details/78697020\n\n**webpack**\n\nwebpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。\n\n**<u>Node.js 的核心模块</u>**\n\nHTTP模块、URL模块、Query Strings模块、File System模块、Path模块、Global模块。\n\n**<u>ajax事件有哪些</u>**\n\n![img](https://uploadfiles.nowcoder.net/images/20170311/6901516_1489199810009_E2168FD8E97D4BF6646E2043D52753FD)\n\n\n\n","slug":"Web前端错题模糊题记录","published":1,"updated":"2018-10-10T08:41:31.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vw001afmagybii45mi","content":"<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><u><strong>元素的alt和title有什么异同？</strong></u></p><p>alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。</p><a id=\"more\"></a><p><strong><u>关于html5标签？</u></strong></p><p>\\&lt;audio> 标签定义声音，比如音乐或其他音频流。<br>\\&lt;canvas> 标签定义图形，比如图表和其他图像。\\&lt;canvas> 标签只是图形容器，必须使用脚本来绘制图形。<br>\\&lt;article>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。<br>\\&lt;menu> 标签定义命令的列表或菜单。\\&lt;menu> 标签用于上下文菜单、工具栏以及用于列出表单控件和命令。command 元素表示用户能够调用的命令。\\&lt;command> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</p><p><strong><u>有关HTML的Doctype和严格模式与混杂模式？</u></strong></p><blockquote><p><strong>文档类型</strong></p><p>DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。</p><p>DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。</p><p>如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。</p><p><strong>浏览器模式</strong></p><pre><code>浏览器有两种呈现模式：标准模式和混杂模式（quirks mode，也叫兼容模式）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。\n</code></pre><p><strong>DOCTYPE 切换</strong></p><p>对于 HTML 4.01 文档，</p><ul><li>包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。</li><li>包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。</li><li>但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。</li><li>DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。</li></ul></blockquote><p><strong><u>NOSCRIPT标签是做什么用的？</u></strong></p><p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p><h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p><strong><u>关于CSS的position属性？</u></strong></p><p>static没有定位，元素出现在正常的流中。</p><p>fixed是相对于窗口的固定定位。</p><p><strong><u>关于border:none以及border:0?</u></strong></p><p>当定义border:none时，表示无边框样式，浏览器并不会对边框进行渲染，也就没有实际的宽度；</p><p>定义边框时，除了设置宽度外，还必须设置边框的样式才能显示出来。</p><p><strong><u>关于CSS sprites图片字节？</u></strong></p><p>CSS Sprites能减少图片的字节，曾经比较过多次，3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p><p><strong><u>关于浏览器引擎？</u></strong></p><p>Wekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。</p><p>另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。</p><p>还有Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。</p><p>另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核。</p><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><u><strong>flash和js通过什么类如何交互?</strong></u></p><p>ExternalInterface。Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p><p><strong><u>有关浏览器中使用js跨域获取数据？</u></strong></p><p>只要<u>协议 、 域名 、 端口</u>有任何一个不同, 都被当作是 <strong>不同</strong> 的域。</p><blockquote><p><strong>1.CORS</strong></p><p>CORS（Cross-Origin Resource Sharing，跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。</p><p><strong>2.document.domain</strong></p><p>将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。</p><p>注意：</p><p>不能将值设置为URL中不包含的域；</p><p>松散的域名不能再设置为紧绷的域名。</p><p><strong>3.图像Ping</strong></p><p>var img=new Image();</p><p>img.onload=img.onerror=function(){</p><p>… …</p><p>}</p><p>img.src=”url?name=value”;</p><p>请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。</p><p>图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。</p><p>缺点：</p><p>只能发送GET请求；</p><p>无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。</p><p><strong>4.Jsonp</strong></p><p>var script=document.createElement(“script”);</p><p>script.src=”url?callback=handleResponse”;</p><p>document.body.insertBefore(script,document.body.firstChild);</p><p>JSONP由两部分组成：回调函数和数据</p><p>回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。</p><p>数据是传入回调函数中的JSON数据。</p><p>优点：</p><p>能够直接访问响应文本，可用于浏览器与服务器间的双向通信。</p><p>缺点：</p><p>JSONP从其他域中加载代码执行，其他域可能不安全；</p><p>难以确定JSONP请求是否失败。</p><p><strong>5.Comet</strong></p><p>Comet可实现服务器向浏览器推送数据。</p><p>Comet是实现方式：长轮询和流</p><p>短轮询即浏览器定时向服务器发送请求，看有没有数据更新。</p><p>长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。</p><p>流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。</p><p><strong>6.WebSocket</strong></p><p>WebSocket可在一个单独的持久连接上提供全双工、双向通信。</p><p>WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。</p><p>var webSocket=new WebSocket(“ws://“);</p><p>webSocket.send(message);</p><p>webSocket.onmessage=function(event){</p><p>var data=event.data;</p><p>… ….</p><p>}</p><p>注意：</p><p>必须给WebSocket构造函数传入绝对URL；</p><p>WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；</p><p>WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。</p><p>优点：</p><p>在客户端和服务器之间发送非常少的数据，减少字节开销。</p></blockquote><p><strong><u>如何获取一个元素节点（id 为 test）的父元素，找到之后如何删除这个元素节点（id 为 test）？</u></strong></p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> testNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> parentNode <span class=\"token operator\">=</span> testNode<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">;</span>\nparentNode<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>testNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n</code></pre><p><strong><u>!编写一个 js 函数 jsonp 的处理函数:</u></strong></p><p><a href=\"https://blog.csdn.net/u013830811/article/details/52718664\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">讲解链接</a></p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 手写jsonp</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">myCallback</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">jsonp</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// data是否是字符串，是的话证明data值就是函数名</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> data <span class=\"token operator\">==</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        callback <span class=\"token operator\">=</span> data\n        data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 拼接data</span>\n    url <span class=\"token operator\">+</span><span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">?</span> <span class=\"token string\">'?'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'&amp;'</span>\n    url <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">'callback='</span> <span class=\"token operator\">+</span> callback\n    <span class=\"token keyword\">var</span> params <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token keyword\">in</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        params <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">'&amp;'</span> <span class=\"token operator\">+</span> i <span class=\"token operator\">+</span> <span class=\"token string\">'='</span> <span class=\"token operator\">+</span> data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    url <span class=\"token operator\">+</span><span class=\"token operator\">=</span> params\n    <span class=\"token comment\" spellcheck=\"true\">// 在页面插入script标签</span>\n    <span class=\"token keyword\">var</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span>\n    script<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'head'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">jsonp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://baidu.com/index.html'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">34</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'myCallback'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">jsonp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://baidu.com/index.html?name=\"zjn\"'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">34</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'myCallback'</span><span class=\"token punctuation\">)</span>\n</code></pre><p><strong><u>编写一个函数判断参数是否是数组类型，如果是返回 true</u></strong></p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 方法一：</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>arg <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法二：</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'[object Array]'</span> <span class=\"token operator\">?</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法三：</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">.</span>name <span class=\"token operator\">==</span> <span class=\"token string\">'Array'</span> ？<span class=\"token boolean\">true</span> <span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p><strong><u>关于对象的length属性：</u></strong></p><p>Window.length //返回在当前窗口中frames的数量（包括IFRAMES）</p><p>String.length //返回字符串中的字符数目</p><p>Function.length //获取一个函数定义的参数数目</p><p>Array.length //返回数组中元素的数目</p><p><strong>如何获取 url 中的 query 字段对应的值，比如：<a href=\"https://m.mobike.com/?source=part1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://m.mobike.com?source=part1</a>，编写一个函数获取 source 对应的值 part1</strong></p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> query <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> sourcePos <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'source'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sourcePos <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">,</span> sourcePos<span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>sourcePos<span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">,</span> sourcePos<span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>sourcePos<span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre><p><strong><u>关于IE的event对象支持的方法：</u></strong></p><p>IE的所有事件对象都支持的方法和属性：</p><ul><li>cancelBubble 默认为false，设置为true就可以取消事件冒泡</li><li>returnValue 默认为true，设置为false可以取消事件的默认行为</li><li>srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用</li><li>type 被触发事件的类型</li></ul><p>DOM事件的方法（IE的事件模型不支持）：</p><ul><li>initEvent() 初始化新创建的 Event 对象的属性</li><li>preventDefault() 通知浏览器不要执行与事件关联的默认动作</li><li>stopPropagation() 不再派发事件</li></ul><p><u><strong>JavaScript的函数调用有哪几种方式？请举例说明，并分析其不同之处。</strong></u></p><p><img src=\"https://uploadfiles.nowcoder.com/images/20180906/5405985_1536239169184_7CB0EB2AC29A9E988352087AAD2B0C2F\" alt=\"img\"></p><p><strong><u>以下 javascript 代码，在浏览器中运行的结果是</u></strong></p><p><img src=\"https://uploadfiles.nowcoder.net/images/20161128/5918115_1480305918764_CF08B543645A55F242CA55EB20727AE6\" alt=\"img\"></p><p>先全部输出first，然后全部输出second。</p><p>js 是运行于单线程环境中，定时器作用是在规定时间内将事件加入执行队列，而加入的前提是当前事件队列没有任何东西。</p><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p><strong><u>和后端 API 服务通信的方式有哪些</u></strong></p><ol><li>ajax</li><li>websocket</li><li>SSE</li><li>服务器端渲染</li></ol><p><strong><u>POST 提交的时候，content-type 有哪几种？</u></strong></p><p>常见的有四种</p><ol><li>application/x-www-form-urlencoded</li><li>application/json</li><li>multipart/form-data</li><li>text/xml</li></ol><p><strong><u>对前端工程化的理解，以及任意构建工具(webpack、gulp、grunt、rollup)的某一个使用的一些描述</u></strong></p><p><strong>前端工程化</strong></p><p><a href=\"https://blog.csdn.net/mayfla/article/details/78697020\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.csdn.net/mayfla/article/details/78697020</a></p><p><strong>webpack</strong></p><p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。</p><p><strong><u>Node.js 的核心模块</u></strong></p><p>HTTP模块、URL模块、Query Strings模块、File System模块、Path模块、Global模块。</p><p><strong><u>ajax事件有哪些</u></strong></p><p><img src=\"https://uploadfiles.nowcoder.net/images/20170311/6901516_1489199810009_E2168FD8E97D4BF6646E2043D52753FD\" alt=\"img\"></p>","site":{"data":{}},"excerpt":"<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><u><strong>元素的alt和title有什么异同？</strong></u></p><p>alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。</p>","more":"<p><strong><u>关于html5标签？</u></strong></p><p>\\&lt;audio> 标签定义声音，比如音乐或其他音频流。<br>\\&lt;canvas> 标签定义图形，比如图表和其他图像。\\&lt;canvas> 标签只是图形容器，必须使用脚本来绘制图形。<br>\\&lt;article>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。<br>\\&lt;menu> 标签定义命令的列表或菜单。\\&lt;menu> 标签用于上下文菜单、工具栏以及用于列出表单控件和命令。command 元素表示用户能够调用的命令。\\&lt;command> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。</p><p><strong><u>有关HTML的Doctype和严格模式与混杂模式？</u></strong></p><blockquote><p><strong>文档类型</strong></p><p>DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。</p><p>DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。</p><p>如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。</p><p><strong>浏览器模式</strong></p><pre><code>浏览器有两种呈现模式：标准模式和混杂模式（quirks mode，也叫兼容模式）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。\n</code></pre><p><strong>DOCTYPE 切换</strong></p><p>对于 HTML 4.01 文档，</p><ul><li>包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。</li><li>包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。</li><li>但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。</li><li>DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。</li></ul></blockquote><p><strong><u>NOSCRIPT标签是做什么用的？</u></strong></p><p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p><h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p><strong><u>关于CSS的position属性？</u></strong></p><p>static没有定位，元素出现在正常的流中。</p><p>fixed是相对于窗口的固定定位。</p><p><strong><u>关于border:none以及border:0?</u></strong></p><p>当定义border:none时，表示无边框样式，浏览器并不会对边框进行渲染，也就没有实际的宽度；</p><p>定义边框时，除了设置宽度外，还必须设置边框的样式才能显示出来。</p><p><strong><u>关于CSS sprites图片字节？</u></strong></p><p>CSS Sprites能减少图片的字节，曾经比较过多次，3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</p><p><strong><u>关于浏览器引擎？</u></strong></p><p>Wekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。</p><p>另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。</p><p>还有Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。</p><p>另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核。</p><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><u><strong>flash和js通过什么类如何交互?</strong></u></p><p>ExternalInterface。Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p><p><strong><u>有关浏览器中使用js跨域获取数据？</u></strong></p><p>只要<u>协议 、 域名 、 端口</u>有任何一个不同, 都被当作是 <strong>不同</strong> 的域。</p><blockquote><p><strong>1.CORS</strong></p><p>CORS（Cross-Origin Resource Sharing，跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。</p><p><strong>2.document.domain</strong></p><p>将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。</p><p>注意：</p><p>不能将值设置为URL中不包含的域；</p><p>松散的域名不能再设置为紧绷的域名。</p><p><strong>3.图像Ping</strong></p><p>var img=new Image();</p><p>img.onload=img.onerror=function(){</p><p>… …</p><p>}</p><p>img.src=”url?name=value”;</p><p>请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。</p><p>图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。</p><p>缺点：</p><p>只能发送GET请求；</p><p>无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。</p><p><strong>4.Jsonp</strong></p><p>var script=document.createElement(“script”);</p><p>script.src=”url?callback=handleResponse”;</p><p>document.body.insertBefore(script,document.body.firstChild);</p><p>JSONP由两部分组成：回调函数和数据</p><p>回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。</p><p>数据是传入回调函数中的JSON数据。</p><p>优点：</p><p>能够直接访问响应文本，可用于浏览器与服务器间的双向通信。</p><p>缺点：</p><p>JSONP从其他域中加载代码执行，其他域可能不安全；</p><p>难以确定JSONP请求是否失败。</p><p><strong>5.Comet</strong></p><p>Comet可实现服务器向浏览器推送数据。</p><p>Comet是实现方式：长轮询和流</p><p>短轮询即浏览器定时向服务器发送请求，看有没有数据更新。</p><p>长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。</p><p>流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。</p><p><strong>6.WebSocket</strong></p><p>WebSocket可在一个单独的持久连接上提供全双工、双向通信。</p><p>WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。</p><p>var webSocket=new WebSocket(“ws://“);</p><p>webSocket.send(message);</p><p>webSocket.onmessage=function(event){</p><p>var data=event.data;</p><p>… ….</p><p>}</p><p>注意：</p><p>必须给WebSocket构造函数传入绝对URL；</p><p>WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；</p><p>WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。</p><p>优点：</p><p>在客户端和服务器之间发送非常少的数据，减少字节开销。</p></blockquote><p><strong><u>如何获取一个元素节点（id 为 test）的父元素，找到之后如何删除这个元素节点（id 为 test）？</u></strong></p><pre><code class=\"js\">var testNode = document.getElementById(&#39;test&#39;);\nvar parentNode = testNode.parentNode;\nparentNode.removeChild(testNode);    \n</code></pre><p><strong><u>!编写一个 js 函数 jsonp 的处理函数:</u></strong></p><p><a href=\"https://blog.csdn.net/u013830811/article/details/52718664\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">讲解链接</a></p><pre><code class=\"js\">// 手写jsonp\nfunction myCallback(data) {\n    console.log(data)\n}\n\nfunction jsonp(url, data, callback) {\n    // data是否是字符串，是的话证明data值就是函数名\n    if (typeof data == &#39;string&#39;) {\n        callback = data\n        data = {}\n    }\n    // 拼接data\n    url += url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;\n    url += &#39;callback=&#39; + callback\n    var params = &quot;&quot;\n    for (var i in data) {\n        params += &#39;&amp;&#39; + i + &#39;=&#39; + data[i]\n    }\n    url += params\n    // 在页面插入script标签\n    var script = document.createElement(&#39;script&#39;)\n    script.setAttribute(&#39;src&#39;, url)\n    document.querySelector(&#39;head&#39;).appendChild(script)\n\n}\n\njsonp(&#39;http://baidu.com/index.html&#39;, { id: 34 }, &#39;myCallback&#39;)\njsonp(&#39;http://baidu.com/index.html?name=&quot;zjn&quot;&#39;, { id: 34 }, &#39;myCallback&#39;)\n</code></pre><p><strong><u>编写一个函数判断参数是否是数组类型，如果是返回 true</u></strong></p><pre><code class=\"js\">// 方法一：\nfunction isArray(arg){\n  return (arg instanceof Array);\n}\n// 方法二：\nfunction isArray(arg){\n  return Object.prototype.toString.call(arg) == &#39;[object Array]&#39; ? true : false;\n}\n// 方法三：\nfunction isArray(arg){\n  return arg.__proto__.constructor.name == &#39;Array&#39; ？true : false;\n}\n</code></pre><p><strong><u>关于对象的length属性：</u></strong></p><p>Window.length //返回在当前窗口中frames的数量（包括IFRAMES）</p><p>String.length //返回字符串中的字符数目</p><p>Function.length //获取一个函数定义的参数数目</p><p>Array.length //返回数组中元素的数目</p><p><strong>如何获取 url 中的 query 字段对应的值，比如：<a href=\"https://m.mobike.com/?source=part1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://m.mobike.com?source=part1</a>，编写一个函数获取 source 对应的值 part1</strong></p><pre><code class=\"js\">let query = (url) =&gt; {\n  let p = url.split(&#39;?&#39;)[1];\n  let sourcePos = p.indexOf(&#39;source&#39;);\n  if (sourcePos &gt; -1) {\n    if (p.indexOf(&#39;&amp;&#39;, sourcePos+7) &gt; -1) {\n      return p.substring(sourcePos+7,p.indexOf(&#39;&amp;&#39;, sourcePos+7));\n    } else {\n      return p.substring(sourcePos+7);\n    }\n  }\n};\n</code></pre><p><strong><u>关于IE的event对象支持的方法：</u></strong></p><p>IE的所有事件对象都支持的方法和属性：</p><ul><li>cancelBubble 默认为false，设置为true就可以取消事件冒泡</li><li>returnValue 默认为true，设置为false可以取消事件的默认行为</li><li>srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用</li><li>type 被触发事件的类型</li></ul><p>DOM事件的方法（IE的事件模型不支持）：</p><ul><li>initEvent() 初始化新创建的 Event 对象的属性</li><li>preventDefault() 通知浏览器不要执行与事件关联的默认动作</li><li>stopPropagation() 不再派发事件</li></ul><p><u><strong>JavaScript的函数调用有哪几种方式？请举例说明，并分析其不同之处。</strong></u></p><p><img src=\"https://uploadfiles.nowcoder.com/images/20180906/5405985_1536239169184_7CB0EB2AC29A9E988352087AAD2B0C2F\" alt=\"img\"></p><p><strong><u>以下 javascript 代码，在浏览器中运行的结果是</u></strong></p><p><img src=\"https://uploadfiles.nowcoder.net/images/20161128/5918115_1480305918764_CF08B543645A55F242CA55EB20727AE6\" alt=\"img\"></p><p>先全部输出first，然后全部输出second。</p><p>js 是运行于单线程环境中，定时器作用是在规定时间内将事件加入执行队列，而加入的前提是当前事件队列没有任何东西。</p><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p><strong><u>和后端 API 服务通信的方式有哪些</u></strong></p><ol><li>ajax</li><li>websocket</li><li>SSE</li><li>服务器端渲染</li></ol><p><strong><u>POST 提交的时候，content-type 有哪几种？</u></strong></p><p>常见的有四种</p><ol><li>application/x-www-form-urlencoded</li><li>application/json</li><li>multipart/form-data</li><li>text/xml</li></ol><p><strong><u>对前端工程化的理解，以及任意构建工具(webpack、gulp、grunt、rollup)的某一个使用的一些描述</u></strong></p><p><strong>前端工程化</strong></p><p><a href=\"https://blog.csdn.net/mayfla/article/details/78697020\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.csdn.net/mayfla/article/details/78697020</a></p><p><strong>webpack</strong></p><p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。</p><p><strong><u>Node.js 的核心模块</u></strong></p><p>HTTP模块、URL模块、Query Strings模块、File System模块、Path模块、Global模块。</p><p><strong><u>ajax事件有哪些</u></strong></p><p><img src=\"https://uploadfiles.nowcoder.net/images/20170311/6901516_1489199810009_E2168FD8E97D4BF6646E2043D52753FD\" alt=\"img\"></p>"},{"title":"cookie、sessionStorage和localStorage","toc":false,"date":"2018-09-25T08:49:57.000Z","_content":"\n## cookie\n\n由于HTTP协议是无状态的，它自身不对请求和响应之间的通信状态进行保存，因此为了实现保持登录状态等功能，引入了**Cookie**。\n\nCookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。\n\n若不为Cookie设置过期时间，那么Cookie会在浏览器关闭时被删除。\n\n因为Cookie被携带在http报文中，所以Cookie只适合存储比较小的数据，不能超过4KB。\n\n<!-- more -->\n\n## webstorage\n\nHTML5提供的在客户端存储数据的方式。\n\nwebstorage有两种存储数据的方式：\n\n- sessionStorage，针对一个session（会话）的存储\n- localStorages，持久化的本地存储\n\n容量上限：\n\n| Feature        | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari (WebKit) |\n| -------------- | ------ | --------------- | ----------------- | ----- | --------------- |\n| localStorage   | 4      | 3.5             | 8                 | 10.50 | 4               |\n| sessionStorage | 5      | 2               | 8                 | 10.50 | 4               |\n\n","source":"_posts/cookie、sessionStorage和localStorage.md","raw":"---\ntitle: cookie、sessionStorage和localStorage\ntoc: false\ndate: 2018-09-25 16:49:57\ncategories:\n- Web\ntags:\n- cookie\n- webstorage\n---\n\n## cookie\n\n由于HTTP协议是无状态的，它自身不对请求和响应之间的通信状态进行保存，因此为了实现保持登录状态等功能，引入了**Cookie**。\n\nCookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。\n\n若不为Cookie设置过期时间，那么Cookie会在浏览器关闭时被删除。\n\n因为Cookie被携带在http报文中，所以Cookie只适合存储比较小的数据，不能超过4KB。\n\n<!-- more -->\n\n## webstorage\n\nHTML5提供的在客户端存储数据的方式。\n\nwebstorage有两种存储数据的方式：\n\n- sessionStorage，针对一个session（会话）的存储\n- localStorages，持久化的本地存储\n\n容量上限：\n\n| Feature        | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari (WebKit) |\n| -------------- | ------ | --------------- | ----------------- | ----- | --------------- |\n| localStorage   | 4      | 3.5             | 8                 | 10.50 | 4               |\n| sessionStorage | 5      | 2               | 8                 | 10.50 | 4               |\n\n","slug":"cookie、sessionStorage和localStorage","published":1,"updated":"2018-10-10T08:53:12.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1vy001dfmagbqf4czw7","content":"<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>由于HTTP协议是无状态的，它自身不对请求和响应之间的通信状态进行保存，因此为了实现保持登录状态等功能，引入了<strong>Cookie</strong>。</p><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p><p>若不为Cookie设置过期时间，那么Cookie会在浏览器关闭时被删除。</p><p>因为Cookie被携带在http报文中，所以Cookie只适合存储比较小的数据，不能超过4KB。</p><a id=\"more\"></a><h2 id=\"webstorage\"><a href=\"#webstorage\" class=\"headerlink\" title=\"webstorage\"></a>webstorage</h2><p>HTML5提供的在客户端存储数据的方式。</p><p>webstorage有两种存储数据的方式：</p><ul><li>sessionStorage，针对一个session（会话）的存储</li><li>localStorages，持久化的本地存储</li></ul><p>容量上限：</p><table><thead><tr><th>Feature</th><th>Chrome</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari (WebKit)</th></tr></thead><tbody><tr><td>localStorage</td><td>4</td><td>3.5</td><td>8</td><td>10.50</td><td>4</td></tr><tr><td>sessionStorage</td><td>5</td><td>2</td><td>8</td><td>10.50</td><td>4</td></tr></tbody></table>","site":{"data":{}},"excerpt":"<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>由于HTTP协议是无状态的，它自身不对请求和响应之间的通信状态进行保存，因此为了实现保持登录状态等功能，引入了<strong>Cookie</strong>。</p><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p><p>若不为Cookie设置过期时间，那么Cookie会在浏览器关闭时被删除。</p><p>因为Cookie被携带在http报文中，所以Cookie只适合存储比较小的数据，不能超过4KB。</p>","more":"<h2 id=\"webstorage\"><a href=\"#webstorage\" class=\"headerlink\" title=\"webstorage\"></a>webstorage</h2><p>HTML5提供的在客户端存储数据的方式。</p><p>webstorage有两种存储数据的方式：</p><ul><li>sessionStorage，针对一个session（会话）的存储</li><li>localStorages，持久化的本地存储</li></ul><p>容量上限：</p><table><thead><tr><th>Feature</th><th>Chrome</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari (WebKit)</th></tr></thead><tbody><tr><td>localStorage</td><td>4</td><td>3.5</td><td>8</td><td>10.50</td><td>4</td></tr><tr><td>sessionStorage</td><td>5</td><td>2</td><td>8</td><td>10.50</td><td>4</td></tr></tbody></table>"},{"title":"git相关整理","toc":false,"date":"2018-09-24T12:42:55.000Z","_content":"\n## git merge 和 git merge --no--ff有什么区别?\n\n`git merge`命令用于合并指定分支到当前分支。默认情况下，执行`快进式合并`（fast-farward merge），直接通过把master指向feature来将两个分支并为一个分支，只保存master的分支信息。\n\n`git merge --no--ff`执行正常合并，在master分支上生成新的节点，就可以保存之前的feature分支历史。能够更好的查看merge历史和branch状态。\n\n因此为了保证版本演进的清晰，推荐使用`--no--ff`的方法。\n\n<!-- more -->\n\n![img](http://www.ruanyifeng.com/blogimg/asset/201207/bg2012070505.png)\n\n![Image result for git merge -- no ff](https://i.stack.imgur.com/FMD5h.png)\n\n## 工作区与暂存区\n\n**工作区**：workspace，git管理的当前文件夹\n\n**暂存区**：stage/index，工作区与分支之间的中转站\n\n![工作区与暂存区](http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg)\n\n`git add`——将修改添加到暂存区\n\n`git checkout -- filename`——撤销工作区中指定文件的修改\n\n`git checkout .`  ——撤销工作区中当前目录中的所有更改\n\n`git rm --cached filename`——删除暂存区中的指定文件，但保留本地文件\n\n`git rm filename`——删除暂存区中的指定文件，同时删除本地文件\n\n## 版本回退\n\n### reset\n\n`git reset --soft` ——只回退commit，暂存区和工作区不做出改变。\n\n`git reset --hard`——回退commit、暂存区、工作区，即本地的代码也会回退，**慎用！**\n\n`git reset --mixed`——回退commit和暂存区，以上两种情况的中和版本，reset不带参数的**默认方式**\n\n<u>关于版本：</u>\n\n`HEAD`——当前版本\n\n`HEAD^`——上一个版本\n\n`HEAD^^`——上上一个版本\n\n`HEAD^^^`——上上上一个版本\n\n`HEAD~n`——上n个版本\n\n也可以使用`commitID`\n\n<u>一个栗子：</u>\n\n`git reset --soft HEAD^`\n\n只回退commit到上一个版本\n\n**reset回退不会保留回退到的版本之后的所有commit**，因此在push时会因为落后于远程commit而报错，若想强制覆盖，可以为push命令加上`--force`或`-f`来进行强制操作。\n\n### revert\n\nrevert用一个新提交来消除一个历史提交所做的所有修改，即\n\n**revert不影响以前的所有commit**\n\n```shell\ngit revert HEAD // 撤销最近一次提交\ngit revert HEAD^ // 撤销上上次提交\ngit revert commitID // 撤销指定id的提交\n```\n\n## 回退暂存区的修改\n\n`git reset HEAD`，命令具体含义看上边的版本回退。\n\n## 删除分支\n\n`git branch -d BranchName`——删除本地分支\n\n`git push origin --delete BranchName`/`git push origin :BranchName`——删除远程分支\n\n## git pull 与 git fetch 区别\n\n`git fetch`——拉取远程分支并更新到`origin/BranchName`分支中\n\n`git pull`——拉取远程分支后与本地当前分支合并\n\n```shell\ngit fetch origin master // 保存在本地'origin/master'分支中\ngit merge origin/master // 将fetch到的分支合并到本地的当前分支中\n\ngit pull origin master // 以上两句命令相当于这一句命令\n```\n\n## 合并时出现冲突的解决办法\n\n`git merge`显示冲突时，\n\n使用`git status`查看冲突的文件，\n\n冲突部分用`<<<<<<< =======  >>>>>>>`标示，\n\n编辑冲突的文件：\n\n```\n// ……\n\n<<<<<<< HEAD // 合并当前分支的内容\n// ……\n=======\n// ……\n>>>>>>> BranchName // 合并前要合并的分支的内容\n\n// ……\n```\n\n然后`git add`冲突文件发现成功了！秒啊！\n\n\n\n","source":"_posts/git相关整理.md","raw":"---\ntitle: git相关整理\ntoc: false\ndate: 2018-09-24 20:42:55\ncategories:\n- Web\ntags:\n- git\n---\n\n## git merge 和 git merge --no--ff有什么区别?\n\n`git merge`命令用于合并指定分支到当前分支。默认情况下，执行`快进式合并`（fast-farward merge），直接通过把master指向feature来将两个分支并为一个分支，只保存master的分支信息。\n\n`git merge --no--ff`执行正常合并，在master分支上生成新的节点，就可以保存之前的feature分支历史。能够更好的查看merge历史和branch状态。\n\n因此为了保证版本演进的清晰，推荐使用`--no--ff`的方法。\n\n<!-- more -->\n\n![img](http://www.ruanyifeng.com/blogimg/asset/201207/bg2012070505.png)\n\n![Image result for git merge -- no ff](https://i.stack.imgur.com/FMD5h.png)\n\n## 工作区与暂存区\n\n**工作区**：workspace，git管理的当前文件夹\n\n**暂存区**：stage/index，工作区与分支之间的中转站\n\n![工作区与暂存区](http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg)\n\n`git add`——将修改添加到暂存区\n\n`git checkout -- filename`——撤销工作区中指定文件的修改\n\n`git checkout .`  ——撤销工作区中当前目录中的所有更改\n\n`git rm --cached filename`——删除暂存区中的指定文件，但保留本地文件\n\n`git rm filename`——删除暂存区中的指定文件，同时删除本地文件\n\n## 版本回退\n\n### reset\n\n`git reset --soft` ——只回退commit，暂存区和工作区不做出改变。\n\n`git reset --hard`——回退commit、暂存区、工作区，即本地的代码也会回退，**慎用！**\n\n`git reset --mixed`——回退commit和暂存区，以上两种情况的中和版本，reset不带参数的**默认方式**\n\n<u>关于版本：</u>\n\n`HEAD`——当前版本\n\n`HEAD^`——上一个版本\n\n`HEAD^^`——上上一个版本\n\n`HEAD^^^`——上上上一个版本\n\n`HEAD~n`——上n个版本\n\n也可以使用`commitID`\n\n<u>一个栗子：</u>\n\n`git reset --soft HEAD^`\n\n只回退commit到上一个版本\n\n**reset回退不会保留回退到的版本之后的所有commit**，因此在push时会因为落后于远程commit而报错，若想强制覆盖，可以为push命令加上`--force`或`-f`来进行强制操作。\n\n### revert\n\nrevert用一个新提交来消除一个历史提交所做的所有修改，即\n\n**revert不影响以前的所有commit**\n\n```shell\ngit revert HEAD // 撤销最近一次提交\ngit revert HEAD^ // 撤销上上次提交\ngit revert commitID // 撤销指定id的提交\n```\n\n## 回退暂存区的修改\n\n`git reset HEAD`，命令具体含义看上边的版本回退。\n\n## 删除分支\n\n`git branch -d BranchName`——删除本地分支\n\n`git push origin --delete BranchName`/`git push origin :BranchName`——删除远程分支\n\n## git pull 与 git fetch 区别\n\n`git fetch`——拉取远程分支并更新到`origin/BranchName`分支中\n\n`git pull`——拉取远程分支后与本地当前分支合并\n\n```shell\ngit fetch origin master // 保存在本地'origin/master'分支中\ngit merge origin/master // 将fetch到的分支合并到本地的当前分支中\n\ngit pull origin master // 以上两句命令相当于这一句命令\n```\n\n## 合并时出现冲突的解决办法\n\n`git merge`显示冲突时，\n\n使用`git status`查看冲突的文件，\n\n冲突部分用`<<<<<<< =======  >>>>>>>`标示，\n\n编辑冲突的文件：\n\n```\n// ……\n\n<<<<<<< HEAD // 合并当前分支的内容\n// ……\n=======\n// ……\n>>>>>>> BranchName // 合并前要合并的分支的内容\n\n// ……\n```\n\n然后`git add`冲突文件发现成功了！秒啊！\n\n\n\n","slug":"git相关整理","published":1,"updated":"2018-10-10T08:36:24.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w0001hfmagz26wsyf1","content":"<h2 id=\"git-merge-和-git-merge-–no–ff有什么区别\"><a href=\"#git-merge-和-git-merge-–no–ff有什么区别\" class=\"headerlink\" title=\"git merge 和 git merge –no–ff有什么区别?\"></a>git merge 和 git merge –no–ff有什么区别?</h2><p><code>git merge</code>命令用于合并指定分支到当前分支。默认情况下，执行<code>快进式合并</code>（fast-farward merge），直接通过把master指向feature来将两个分支并为一个分支，只保存master的分支信息。</p><p><code>git merge --no--ff</code>执行正常合并，在master分支上生成新的节点，就可以保存之前的feature分支历史。能够更好的查看merge历史和branch状态。</p><p>因此为了保证版本演进的清晰，推荐使用<code>--no--ff</code>的方法。</p><a id=\"more\"></a><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/201207/bg2012070505.png\" alt=\"img\"></p><p><img src=\"https://i.stack.imgur.com/FMD5h.png\" alt=\"Image result for git merge -- no ff\"></p><h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p><strong>工作区</strong>：workspace，git管理的当前文件夹</p><p><strong>暂存区</strong>：stage/index，工作区与分支之间的中转站</p><p><img src=\"http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg\" alt=\"工作区与暂存区\"></p><p><code>git add</code>——将修改添加到暂存区</p><p><code>git checkout -- filename</code>——撤销工作区中指定文件的修改</p><p><code>git checkout .</code> ——撤销工作区中当前目录中的所有更改</p><p><code>git rm --cached filename</code>——删除暂存区中的指定文件，但保留本地文件</p><p><code>git rm filename</code>——删除暂存区中的指定文件，同时删除本地文件</p><h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><p><code>git reset --soft</code> ——只回退commit，暂存区和工作区不做出改变。</p><p><code>git reset --hard</code>——回退commit、暂存区、工作区，即本地的代码也会回退，<strong>慎用！</strong></p><p><code>git reset --mixed</code>——回退commit和暂存区，以上两种情况的中和版本，reset不带参数的<strong>默认方式</strong></p><p><u>关于版本：</u></p><p><code>HEAD</code>——当前版本</p><p><code>HEAD^</code>——上一个版本</p><p><code>HEAD^^</code>——上上一个版本</p><p><code>HEAD^^^</code>——上上上一个版本</p><p><code>HEAD~n</code>——上n个版本</p><p>也可以使用<code>commitID</code></p><p><u>一个栗子：</u></p><p><code>git reset --soft HEAD^</code></p><p>只回退commit到上一个版本</p><p><strong>reset回退不会保留回退到的版本之后的所有commit</strong>，因此在push时会因为落后于远程commit而报错，若想强制覆盖，可以为push命令加上<code>--force</code>或<code>-f</code>来进行强制操作。</p><h3 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h3><p>revert用一个新提交来消除一个历史提交所做的所有修改，即</p><p><strong>revert不影响以前的所有commit</strong></p><pre class=\" language-shell\"><code class=\"language-shell\">git revert HEAD // 撤销最近一次提交\ngit revert HEAD^ // 撤销上上次提交\ngit revert commitID // 撤销指定id的提交\n</code></pre><h2 id=\"回退暂存区的修改\"><a href=\"#回退暂存区的修改\" class=\"headerlink\" title=\"回退暂存区的修改\"></a>回退暂存区的修改</h2><p><code>git reset HEAD</code>，命令具体含义看上边的版本回退。</p><h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><p><code>git branch -d BranchName</code>——删除本地分支</p><p><code>git push origin --delete BranchName</code>/<code>git push origin :BranchName</code>——删除远程分支</p><h2 id=\"git-pull-与-git-fetch-区别\"><a href=\"#git-pull-与-git-fetch-区别\" class=\"headerlink\" title=\"git pull 与 git fetch 区别\"></a>git pull 与 git fetch 区别</h2><p><code>git fetch</code>——拉取远程分支并更新到<code>origin/BranchName</code>分支中</p><p><code>git pull</code>——拉取远程分支后与本地当前分支合并</p><pre class=\" language-shell\"><code class=\"language-shell\">git fetch origin master // 保存在本地'origin/master'分支中\ngit merge origin/master // 将fetch到的分支合并到本地的当前分支中\n\ngit pull origin master // 以上两句命令相当于这一句命令\n</code></pre><h2 id=\"合并时出现冲突的解决办法\"><a href=\"#合并时出现冲突的解决办法\" class=\"headerlink\" title=\"合并时出现冲突的解决办法\"></a>合并时出现冲突的解决办法</h2><p><code>git merge</code>显示冲突时，</p><p>使用<code>git status</code>查看冲突的文件，</p><p>冲突部分用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标示，</p><p>编辑冲突的文件：</p><pre><code>// ……\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 合并当前分支的内容\n// ……\n=======\n// ……\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; BranchName // 合并前要合并的分支的内容\n\n// ……\n</code></pre><p>然后<code>git add</code>冲突文件发现成功了！秒啊！</p>","site":{"data":{}},"excerpt":"<h2 id=\"git-merge-和-git-merge-–no–ff有什么区别\"><a href=\"#git-merge-和-git-merge-–no–ff有什么区别\" class=\"headerlink\" title=\"git merge 和 git merge –no–ff有什么区别?\"></a>git merge 和 git merge –no–ff有什么区别?</h2><p><code>git merge</code>命令用于合并指定分支到当前分支。默认情况下，执行<code>快进式合并</code>（fast-farward merge），直接通过把master指向feature来将两个分支并为一个分支，只保存master的分支信息。</p><p><code>git merge --no--ff</code>执行正常合并，在master分支上生成新的节点，就可以保存之前的feature分支历史。能够更好的查看merge历史和branch状态。</p><p>因此为了保证版本演进的清晰，推荐使用<code>--no--ff</code>的方法。</p>","more":"<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/201207/bg2012070505.png\" alt=\"img\"></p><p><img src=\"https://i.stack.imgur.com/FMD5h.png\" alt=\"Image result for git merge -- no ff\"></p><h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p><strong>工作区</strong>：workspace，git管理的当前文件夹</p><p><strong>暂存区</strong>：stage/index，工作区与分支之间的中转站</p><p><img src=\"http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg\" alt=\"工作区与暂存区\"></p><p><code>git add</code>——将修改添加到暂存区</p><p><code>git checkout -- filename</code>——撤销工作区中指定文件的修改</p><p><code>git checkout .</code> ——撤销工作区中当前目录中的所有更改</p><p><code>git rm --cached filename</code>——删除暂存区中的指定文件，但保留本地文件</p><p><code>git rm filename</code>——删除暂存区中的指定文件，同时删除本地文件</p><h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><p><code>git reset --soft</code> ——只回退commit，暂存区和工作区不做出改变。</p><p><code>git reset --hard</code>——回退commit、暂存区、工作区，即本地的代码也会回退，<strong>慎用！</strong></p><p><code>git reset --mixed</code>——回退commit和暂存区，以上两种情况的中和版本，reset不带参数的<strong>默认方式</strong></p><p><u>关于版本：</u></p><p><code>HEAD</code>——当前版本</p><p><code>HEAD^</code>——上一个版本</p><p><code>HEAD^^</code>——上上一个版本</p><p><code>HEAD^^^</code>——上上上一个版本</p><p><code>HEAD~n</code>——上n个版本</p><p>也可以使用<code>commitID</code></p><p><u>一个栗子：</u></p><p><code>git reset --soft HEAD^</code></p><p>只回退commit到上一个版本</p><p><strong>reset回退不会保留回退到的版本之后的所有commit</strong>，因此在push时会因为落后于远程commit而报错，若想强制覆盖，可以为push命令加上<code>--force</code>或<code>-f</code>来进行强制操作。</p><h3 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h3><p>revert用一个新提交来消除一个历史提交所做的所有修改，即</p><p><strong>revert不影响以前的所有commit</strong></p><pre><code class=\"shell\">git revert HEAD // 撤销最近一次提交\ngit revert HEAD^ // 撤销上上次提交\ngit revert commitID // 撤销指定id的提交\n</code></pre><h2 id=\"回退暂存区的修改\"><a href=\"#回退暂存区的修改\" class=\"headerlink\" title=\"回退暂存区的修改\"></a>回退暂存区的修改</h2><p><code>git reset HEAD</code>，命令具体含义看上边的版本回退。</p><h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><p><code>git branch -d BranchName</code>——删除本地分支</p><p><code>git push origin --delete BranchName</code>/<code>git push origin :BranchName</code>——删除远程分支</p><h2 id=\"git-pull-与-git-fetch-区别\"><a href=\"#git-pull-与-git-fetch-区别\" class=\"headerlink\" title=\"git pull 与 git fetch 区别\"></a>git pull 与 git fetch 区别</h2><p><code>git fetch</code>——拉取远程分支并更新到<code>origin/BranchName</code>分支中</p><p><code>git pull</code>——拉取远程分支后与本地当前分支合并</p><pre><code class=\"shell\">git fetch origin master // 保存在本地&#39;origin/master&#39;分支中\ngit merge origin/master // 将fetch到的分支合并到本地的当前分支中\n\ngit pull origin master // 以上两句命令相当于这一句命令\n</code></pre><h2 id=\"合并时出现冲突的解决办法\"><a href=\"#合并时出现冲突的解决办法\" class=\"headerlink\" title=\"合并时出现冲突的解决办法\"></a>合并时出现冲突的解决办法</h2><p><code>git merge</code>显示冲突时，</p><p>使用<code>git status</code>查看冲突的文件，</p><p>冲突部分用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标示，</p><p>编辑冲突的文件：</p><pre><code>// ……\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 合并当前分支的内容\n// ……\n=======\n// ……\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; BranchName // 合并前要合并的分支的内容\n\n// ……\n</code></pre><p>然后<code>git add</code>冲突文件发现成功了！秒啊！</p>"},{"title":"hexo创建的tags和categories页面为空的解决办法","toc":false,"date":"2018-04-15T18:26:10.000Z","_content":"\n\n\n主题：landscape\n\n添加type以及menu后仍然显示空白的解决办法：\n\n打开landscape/_partial/article.ejs，\n\n在`<div class=\"article-entry\" itemprop=\"articleBody\">`的div内添加代码：\n\n<!-- more -->\n\n```ejs\n<% if (page.type === \"tags\") { %>\n  <div class=\"tag-cloud\">\n    <div class=\"tag-cloud-title\">\n    <%- \"TOTAl : \" + site.tags.length %>\n    </div>\n\n    <div class=\"tag-cloud-tags\">\n    <%- tagcloud({\n      min_font: 12,\n      max_font: 30,\n      amount: 200,\n      color: true,\n      start_color: '#555',\n      end_color: '#111'\n      }) %>\n    </div>\n  </div>\n\n  <% } else if (page.type === 'categories') { %>\n\n  <div class=\"category-all-page\">\n    <div class=\"category-all-title\">\n    <%- \"TOTAL : \" + site.categories.length %>\n    </div>\n\n    <div class=\"category-all\">\n    <%- list_categories() %>\n    </div>\n\n  </div>\n<% } %>\n```\n\n重新打开即可看到正常显示的标签和分类页。\n\n\n\n修改categories页面样式（也可以自己设计修改）：\n\n打开landscape/source/css/_partial/article.styl，在尾部添加：\n\n```css\n.category-all-page {\n  a:link {\n    font-size: 14px;\n    color: #333;\n    text-decoration: none;\n  }\n  a:hover {\n    font-size: 14px;\n    color: #d8d;\n    text-decoration: none;\n    font-weight: bold;\n  }\n  .category-all-title { text-align: left; }\n\n  .category-all { \n    margin-top: 20px; \n  }\n\n  .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  .category-list-item { \n    text-align: center;\n    display: inline-block;\n    margin: 8px; \n    padding: 8px;\n    width: 150px;\n    position: relative;\n    background-color: rgba(237, 237, 237, 0.53);\n    border-radius: 1px;\n    box-shadow:0px 0px  0px 1px #ccc;\n  }\n\n  .category-list-link {\n  \tcolor: #333;\n  }\n\n  .category-list-count {\n    color: #333;\n    &:before {\n      display: inline;\n      content: \" (\"\n    }\n    &:after {\n      display: inline;\n      content: \") \"\n    }\n  }\n\n  .category-list-child { padding-left: 10px; color: #333;}\n}\n\n\n```\n\n","source":"_posts/hexo创建的tags和categories页面为空的解决办法.md","raw":"---\ntitle: hexo创建的tags和categories页面为空的解决办法\ntoc: false\ndate: 2018-04-16 02:26:10\ncategories:\n- methods\ntags:\n- hexo\n---\n\n\n\n主题：landscape\n\n添加type以及menu后仍然显示空白的解决办法：\n\n打开landscape/_partial/article.ejs，\n\n在`<div class=\"article-entry\" itemprop=\"articleBody\">`的div内添加代码：\n\n<!-- more -->\n\n```ejs\n<% if (page.type === \"tags\") { %>\n  <div class=\"tag-cloud\">\n    <div class=\"tag-cloud-title\">\n    <%- \"TOTAl : \" + site.tags.length %>\n    </div>\n\n    <div class=\"tag-cloud-tags\">\n    <%- tagcloud({\n      min_font: 12,\n      max_font: 30,\n      amount: 200,\n      color: true,\n      start_color: '#555',\n      end_color: '#111'\n      }) %>\n    </div>\n  </div>\n\n  <% } else if (page.type === 'categories') { %>\n\n  <div class=\"category-all-page\">\n    <div class=\"category-all-title\">\n    <%- \"TOTAL : \" + site.categories.length %>\n    </div>\n\n    <div class=\"category-all\">\n    <%- list_categories() %>\n    </div>\n\n  </div>\n<% } %>\n```\n\n重新打开即可看到正常显示的标签和分类页。\n\n\n\n修改categories页面样式（也可以自己设计修改）：\n\n打开landscape/source/css/_partial/article.styl，在尾部添加：\n\n```css\n.category-all-page {\n  a:link {\n    font-size: 14px;\n    color: #333;\n    text-decoration: none;\n  }\n  a:hover {\n    font-size: 14px;\n    color: #d8d;\n    text-decoration: none;\n    font-weight: bold;\n  }\n  .category-all-title { text-align: left; }\n\n  .category-all { \n    margin-top: 20px; \n  }\n\n  .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  .category-list-item { \n    text-align: center;\n    display: inline-block;\n    margin: 8px; \n    padding: 8px;\n    width: 150px;\n    position: relative;\n    background-color: rgba(237, 237, 237, 0.53);\n    border-radius: 1px;\n    box-shadow:0px 0px  0px 1px #ccc;\n  }\n\n  .category-list-link {\n  \tcolor: #333;\n  }\n\n  .category-list-count {\n    color: #333;\n    &:before {\n      display: inline;\n      content: \" (\"\n    }\n    &:after {\n      display: inline;\n      content: \") \"\n    }\n  }\n\n  .category-list-child { padding-left: 10px; color: #333;}\n}\n\n\n```\n\n","slug":"hexo创建的tags和categories页面为空的解决办法","published":1,"updated":"2018-10-10T08:36:49.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w1001kfmagfshxz64x","content":"<p>主题：landscape</p><p>添加type以及menu后仍然显示空白的解决办法：</p><p>打开landscape/_partial/article.ejs，</p><p>在<code>&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;</code>的div内添加代码：</p><a id=\"more\"></a><pre class=\" language-ejs\"><code class=\"language-ejs\"><% if (page.type === \"tags\") { %>\n  <div class=\"tag-cloud\">\n    <div class=\"tag-cloud-title\">\n    <%- \"TOTAl : \" + site.tags.length %>\n    </div>\n\n    <div class=\"tag-cloud-tags\">\n    <%- tagcloud({\n      min_font: 12,\n      max_font: 30,\n      amount: 200,\n      color: true,\n      start_color: '#555',\n      end_color: '#111'\n      }) %>\n    </div>\n  </div>\n\n  <% } else if (page.type === 'categories') { %>\n\n  <div class=\"category-all-page\">\n    <div class=\"category-all-title\">\n    <%- \"TOTAL : \" + site.categories.length %>\n    </div>\n\n    <div class=\"category-all\">\n    <%- list_categories() %>\n    </div>\n\n  </div>\n<% } %>\n</code></pre><p>重新打开即可看到正常显示的标签和分类页。</p><p>修改categories页面样式（也可以自己设计修改）：</p><p>打开landscape/source/css/_partial/article.styl，在尾部添加：</p><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.category-all-page</span> </span><span class=\"token punctuation\">{</span>\n  <span class=\"token selector\">a<span class=\"token pseudo-class\">:link</span> </span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">14</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#333</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">text-decoration</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token selector\">a<span class=\"token pseudo-class\">:hover</span> </span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">14</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#d8d</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">text-decoration</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">font-weight</span><span class=\"token punctuation\">:</span> bold<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token selector\"><span class=\"token class\">.category-all-title</span> </span><span class=\"token punctuation\">{</span> <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> left<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-all</span> </span><span class=\"token punctuation\">{</span> \n    <span class=\"token property\">margin-top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">20</span>px<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-list</span> </span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">list-style</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-list-item</span> </span><span class=\"token punctuation\">{</span> \n    <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> inline-block<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>px<span class=\"token punctuation\">;</span> \n    <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">150</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rgba</span><span class=\"token punctuation\">(</span><span class=\"token number\">237</span>, <span class=\"token number\">237</span>, <span class=\"token number\">237</span>, <span class=\"token number\">0.53</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">box-shadow</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span>px <span class=\"token number\">0</span>px  <span class=\"token number\">0</span>px <span class=\"token number\">1</span>px <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-list-link</span> </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#333</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-list-count</span> </span><span class=\"token punctuation\">{</span>\n    <span class=\"token selector\">color: <span class=\"token id\">#333</span>;\n    &amp;<span class=\"token pseudo-element\">:before</span> </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> inline<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">content</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\" (\"</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\">&amp;<span class=\"token pseudo-element\">:after</span> </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> inline<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">content</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\") \"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token selector\"><span class=\"token class\">.category-list-child</span> </span><span class=\"token punctuation\">{</span> <span class=\"token property\">padding-left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>px<span class=\"token punctuation\">;</span> <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#333</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n</code></pre>","site":{"data":{}},"excerpt":"<p>主题：landscape</p><p>添加type以及menu后仍然显示空白的解决办法：</p><p>打开landscape/_partial/article.ejs，</p><p>在<code>&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;</code>的div内添加代码：</p>","more":"<pre><code class=\"ejs\">&lt;% if (page.type === &quot;tags&quot;) { %&gt;\n  &lt;div class=&quot;tag-cloud&quot;&gt;\n    &lt;div class=&quot;tag-cloud-title&quot;&gt;\n    &lt;%- &quot;TOTAl : &quot; + site.tags.length %&gt;\n    &lt;/div&gt;\n\n    &lt;div class=&quot;tag-cloud-tags&quot;&gt;\n    &lt;%- tagcloud({\n      min_font: 12,\n      max_font: 30,\n      amount: 200,\n      color: true,\n      start_color: &#39;#555&#39;,\n      end_color: &#39;#111&#39;\n      }) %&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  &lt;% } else if (page.type === &#39;categories&#39;) { %&gt;\n\n  &lt;div class=&quot;category-all-page&quot;&gt;\n    &lt;div class=&quot;category-all-title&quot;&gt;\n    &lt;%- &quot;TOTAL : &quot; + site.categories.length %&gt;\n    &lt;/div&gt;\n\n    &lt;div class=&quot;category-all&quot;&gt;\n    &lt;%- list_categories() %&gt;\n    &lt;/div&gt;\n\n  &lt;/div&gt;\n&lt;% } %&gt;\n</code></pre><p>重新打开即可看到正常显示的标签和分类页。</p><p>修改categories页面样式（也可以自己设计修改）：</p><p>打开landscape/source/css/_partial/article.styl，在尾部添加：</p><pre><code class=\"css\">.category-all-page {\n  a:link {\n    font-size: 14px;\n    color: #333;\n    text-decoration: none;\n  }\n  a:hover {\n    font-size: 14px;\n    color: #d8d;\n    text-decoration: none;\n    font-weight: bold;\n  }\n  .category-all-title { text-align: left; }\n\n  .category-all { \n    margin-top: 20px; \n  }\n\n  .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  .category-list-item { \n    text-align: center;\n    display: inline-block;\n    margin: 8px; \n    padding: 8px;\n    width: 150px;\n    position: relative;\n    background-color: rgba(237, 237, 237, 0.53);\n    border-radius: 1px;\n    box-shadow:0px 0px  0px 1px #ccc;\n  }\n\n  .category-list-link {\n      color: #333;\n  }\n\n  .category-list-count {\n    color: #333;\n    &amp;:before {\n      display: inline;\n      content: &quot; (&quot;\n    }\n    &amp;:after {\n      display: inline;\n      content: &quot;) &quot;\n    }\n  }\n\n  .category-list-child { padding-left: 10px; color: #333;}\n}\n\n\n</code></pre>"},{"title":"hexo博客谷歌百度收录踩坑日记","toc":false,"date":"2018-04-16T16:09:38.000Z","_content":"\n## 百度收录文件验证\n\n无论怎么把渲染关掉或者render_skip都说我的格式错误，看了一下源代码发现即使不渲染最后也会加上html的标签，于是放弃这个放弃了这个方式。\n\n<!-- more -->\n\n## 百度收录html验证\n\n本来以为这个应该会直接就验证通过了，但是只要我修改了html，百度就无法访问我的博客，遂也放弃了这个方法..\n\n## 百度收录CNAME验证\n\n使用阿里云进行云解析但是阿里云现在不支持xxx.github.io的域名...\n\n于是踏上了新征程：\n\n## 自定义域名\n\n在阿里云买了一个最便宜的.top域名，把自定义域名和博客绑定上之后博客就无法访问了，需要细心等待，谷歌了一下一般不会超过48h就会绑定成功可以正常使用。\n\n阿里云的速度挺快，不到一个小时就好了。\n\n弄好自定义域名之后就悲催地发现评论板块无法登陆...磕磕绊绊[改好配置](http://blog.zmj97.top/2018/04/16/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法)后，终于开始重新进行百度收录了！\n\n## 谷歌收录\n\n由于白天的阴影先弄了谷歌收录，没有遇到什么大坑，一切都非常顺利，直到上sitemap时出现了两个问题：\n\n### sitmap.xml不存在\n\n安装sitemap插件时一定要加上`--save`！！：\n\n```shell\nnpm install hexo-generator-sitemap --save\n```\n\n而不是\n\n```shell\nnpm install hexo-generator-sitemap\n```\n\n### 测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址\n\n搜了一下，各家有各家的错误原因，我的是因为我在谷歌收录的网址是原网址`https://mikqueenge.github.io`，而上传的sitemap.xml的地址自动被解析为自定义域名`http://blog.zmj97.top/sitemap.xml`才出现了错误，再添加收录网站`http://blog.zmj97.top`然后在这个地址下添加sitemap即可。\n\n## 百度收录\n\n### `token`\n\n数据引入->链接提交->自动提交->主动推送（实时）->推送接口 中的接口调用地址中有token的值。\n\n### 自动抓取sitemap失败\n\n直接访问提交的数据文件地址`http://blog.zmj97.top/baidu_sitemap.txt`是可以看到的，但是因为 GitHub 屏蔽了百度的爬虫所以百度无法抓取...\n\n然后发现我的配置跟主动推送的配置（[参考链接](http://www.yuan-ji.me/Hexo-优化%EF%BC%9A提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题/)）很像，但是deploy baidu_submitter一直出错，看了错误信息才发现是因为把`baidu_url_submit:`下的`path: baidu_urls.txt`擅自改了文件名导致的...\n\n终于好了...踩坑结束！","source":"_posts/hexo博客谷歌百度收录踩坑日记.md","raw":"---\ntitle: hexo博客谷歌百度收录踩坑日记\ntoc: false\ndate: 2018-04-17 00:09:38\ncategories:\n- methods\ntags:\n- hexo\n- 网站收录\n---\n\n## 百度收录文件验证\n\n无论怎么把渲染关掉或者render_skip都说我的格式错误，看了一下源代码发现即使不渲染最后也会加上html的标签，于是放弃这个放弃了这个方式。\n\n<!-- more -->\n\n## 百度收录html验证\n\n本来以为这个应该会直接就验证通过了，但是只要我修改了html，百度就无法访问我的博客，遂也放弃了这个方法..\n\n## 百度收录CNAME验证\n\n使用阿里云进行云解析但是阿里云现在不支持xxx.github.io的域名...\n\n于是踏上了新征程：\n\n## 自定义域名\n\n在阿里云买了一个最便宜的.top域名，把自定义域名和博客绑定上之后博客就无法访问了，需要细心等待，谷歌了一下一般不会超过48h就会绑定成功可以正常使用。\n\n阿里云的速度挺快，不到一个小时就好了。\n\n弄好自定义域名之后就悲催地发现评论板块无法登陆...磕磕绊绊[改好配置](http://blog.zmj97.top/2018/04/16/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法)后，终于开始重新进行百度收录了！\n\n## 谷歌收录\n\n由于白天的阴影先弄了谷歌收录，没有遇到什么大坑，一切都非常顺利，直到上sitemap时出现了两个问题：\n\n### sitmap.xml不存在\n\n安装sitemap插件时一定要加上`--save`！！：\n\n```shell\nnpm install hexo-generator-sitemap --save\n```\n\n而不是\n\n```shell\nnpm install hexo-generator-sitemap\n```\n\n### 测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址\n\n搜了一下，各家有各家的错误原因，我的是因为我在谷歌收录的网址是原网址`https://mikqueenge.github.io`，而上传的sitemap.xml的地址自动被解析为自定义域名`http://blog.zmj97.top/sitemap.xml`才出现了错误，再添加收录网站`http://blog.zmj97.top`然后在这个地址下添加sitemap即可。\n\n## 百度收录\n\n### `token`\n\n数据引入->链接提交->自动提交->主动推送（实时）->推送接口 中的接口调用地址中有token的值。\n\n### 自动抓取sitemap失败\n\n直接访问提交的数据文件地址`http://blog.zmj97.top/baidu_sitemap.txt`是可以看到的，但是因为 GitHub 屏蔽了百度的爬虫所以百度无法抓取...\n\n然后发现我的配置跟主动推送的配置（[参考链接](http://www.yuan-ji.me/Hexo-优化%EF%BC%9A提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题/)）很像，但是deploy baidu_submitter一直出错，看了错误信息才发现是因为把`baidu_url_submit:`下的`path: baidu_urls.txt`擅自改了文件名导致的...\n\n终于好了...踩坑结束！","slug":"hexo博客谷歌百度收录踩坑日记","published":1,"updated":"2018-10-10T08:37:05.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w3001ofmag1zz34iy7","content":"<h2 id=\"百度收录文件验证\"><a href=\"#百度收录文件验证\" class=\"headerlink\" title=\"百度收录文件验证\"></a>百度收录文件验证</h2><p>无论怎么把渲染关掉或者render_skip都说我的格式错误，看了一下源代码发现即使不渲染最后也会加上html的标签，于是放弃这个放弃了这个方式。</p><a id=\"more\"></a><h2 id=\"百度收录html验证\"><a href=\"#百度收录html验证\" class=\"headerlink\" title=\"百度收录html验证\"></a>百度收录html验证</h2><p>本来以为这个应该会直接就验证通过了，但是只要我修改了html，百度就无法访问我的博客，遂也放弃了这个方法..</p><h2 id=\"百度收录CNAME验证\"><a href=\"#百度收录CNAME验证\" class=\"headerlink\" title=\"百度收录CNAME验证\"></a>百度收录CNAME验证</h2><p>使用阿里云进行云解析但是阿里云现在不支持xxx.github.io的域名…</p><p>于是踏上了新征程：</p><h2 id=\"自定义域名\"><a href=\"#自定义域名\" class=\"headerlink\" title=\"自定义域名\"></a>自定义域名</h2><p>在阿里云买了一个最便宜的.top域名，把自定义域名和博客绑定上之后博客就无法访问了，需要细心等待，谷歌了一下一般不会超过48h就会绑定成功可以正常使用。</p><p>阿里云的速度挺快，不到一个小时就好了。</p><p>弄好自定义域名之后就悲催地发现评论板块无法登陆…磕磕绊绊<a href=\"http://blog.zmj97.top/2018/04/16/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法\" target=\"_blank\" rel=\"noopener\">改好配置</a>后，终于开始重新进行百度收录了！</p><h2 id=\"谷歌收录\"><a href=\"#谷歌收录\" class=\"headerlink\" title=\"谷歌收录\"></a>谷歌收录</h2><p>由于白天的阴影先弄了谷歌收录，没有遇到什么大坑，一切都非常顺利，直到上sitemap时出现了两个问题：</p><h3 id=\"sitmap-xml不存在\"><a href=\"#sitmap-xml不存在\" class=\"headerlink\" title=\"sitmap.xml不存在\"></a>sitmap.xml不存在</h3><p>安装sitemap插件时一定要加上<code>--save</code>！！：</p><pre class=\" language-shell\"><code class=\"language-shell\">npm install hexo-generator-sitemap --save\n</code></pre><p>而不是</p><pre class=\" language-shell\"><code class=\"language-shell\">npm install hexo-generator-sitemap\n</code></pre><h3 id=\"测试sitmap-xml出现错误：此位置的-Sitemap-不允许此网址\"><a href=\"#测试sitmap-xml出现错误：此位置的-Sitemap-不允许此网址\" class=\"headerlink\" title=\"测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址\"></a>测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址</h3><p>搜了一下，各家有各家的错误原因，我的是因为我在谷歌收录的网址是原网址<code>https://mikqueenge.github.io</code>，而上传的sitemap.xml的地址自动被解析为自定义域名<code>http://blog.zmj97.top/sitemap.xml</code>才出现了错误，再添加收录网站<code>http://blog.zmj97.top</code>然后在这个地址下添加sitemap即可。</p><h2 id=\"百度收录\"><a href=\"#百度收录\" class=\"headerlink\" title=\"百度收录\"></a>百度收录</h2><h3 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a><code>token</code></h3><p>数据引入-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）-&gt;推送接口 中的接口调用地址中有token的值。</p><h3 id=\"自动抓取sitemap失败\"><a href=\"#自动抓取sitemap失败\" class=\"headerlink\" title=\"自动抓取sitemap失败\"></a>自动抓取sitemap失败</h3><p>直接访问提交的数据文件地址<code>http://blog.zmj97.top/baidu_sitemap.txt</code>是可以看到的，但是因为 GitHub 屏蔽了百度的爬虫所以百度无法抓取…</p><p>然后发现我的配置跟主动推送的配置（<a href=\"http://www.yuan-ji.me/Hexo-优化%EF%BC%9A提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>）很像，但是deploy baidu_submitter一直出错，看了错误信息才发现是因为把<code>baidu_url_submit:</code>下的<code>path: baidu_urls.txt</code>擅自改了文件名导致的…</p><p>终于好了…踩坑结束！</p>","site":{"data":{}},"excerpt":"<h2 id=\"百度收录文件验证\"><a href=\"#百度收录文件验证\" class=\"headerlink\" title=\"百度收录文件验证\"></a>百度收录文件验证</h2><p>无论怎么把渲染关掉或者render_skip都说我的格式错误，看了一下源代码发现即使不渲染最后也会加上html的标签，于是放弃这个放弃了这个方式。</p>","more":"<h2 id=\"百度收录html验证\"><a href=\"#百度收录html验证\" class=\"headerlink\" title=\"百度收录html验证\"></a>百度收录html验证</h2><p>本来以为这个应该会直接就验证通过了，但是只要我修改了html，百度就无法访问我的博客，遂也放弃了这个方法..</p><h2 id=\"百度收录CNAME验证\"><a href=\"#百度收录CNAME验证\" class=\"headerlink\" title=\"百度收录CNAME验证\"></a>百度收录CNAME验证</h2><p>使用阿里云进行云解析但是阿里云现在不支持xxx.github.io的域名…</p><p>于是踏上了新征程：</p><h2 id=\"自定义域名\"><a href=\"#自定义域名\" class=\"headerlink\" title=\"自定义域名\"></a>自定义域名</h2><p>在阿里云买了一个最便宜的.top域名，把自定义域名和博客绑定上之后博客就无法访问了，需要细心等待，谷歌了一下一般不会超过48h就会绑定成功可以正常使用。</p><p>阿里云的速度挺快，不到一个小时就好了。</p><p>弄好自定义域名之后就悲催地发现评论板块无法登陆…磕磕绊绊<a href=\"http://blog.zmj97.top/2018/04/16/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法\" target=\"_blank\" rel=\"noopener\">改好配置</a>后，终于开始重新进行百度收录了！</p><h2 id=\"谷歌收录\"><a href=\"#谷歌收录\" class=\"headerlink\" title=\"谷歌收录\"></a>谷歌收录</h2><p>由于白天的阴影先弄了谷歌收录，没有遇到什么大坑，一切都非常顺利，直到上sitemap时出现了两个问题：</p><h3 id=\"sitmap-xml不存在\"><a href=\"#sitmap-xml不存在\" class=\"headerlink\" title=\"sitmap.xml不存在\"></a>sitmap.xml不存在</h3><p>安装sitemap插件时一定要加上<code>--save</code>！！：</p><pre><code class=\"shell\">npm install hexo-generator-sitemap --save\n</code></pre><p>而不是</p><pre><code class=\"shell\">npm install hexo-generator-sitemap\n</code></pre><h3 id=\"测试sitmap-xml出现错误：此位置的-Sitemap-不允许此网址\"><a href=\"#测试sitmap-xml出现错误：此位置的-Sitemap-不允许此网址\" class=\"headerlink\" title=\"测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址\"></a>测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址</h3><p>搜了一下，各家有各家的错误原因，我的是因为我在谷歌收录的网址是原网址<code>https://mikqueenge.github.io</code>，而上传的sitemap.xml的地址自动被解析为自定义域名<code>http://blog.zmj97.top/sitemap.xml</code>才出现了错误，再添加收录网站<code>http://blog.zmj97.top</code>然后在这个地址下添加sitemap即可。</p><h2 id=\"百度收录\"><a href=\"#百度收录\" class=\"headerlink\" title=\"百度收录\"></a>百度收录</h2><h3 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a><code>token</code></h3><p>数据引入-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）-&gt;推送接口 中的接口调用地址中有token的值。</p><h3 id=\"自动抓取sitemap失败\"><a href=\"#自动抓取sitemap失败\" class=\"headerlink\" title=\"自动抓取sitemap失败\"></a>自动抓取sitemap失败</h3><p>直接访问提交的数据文件地址<code>http://blog.zmj97.top/baidu_sitemap.txt</code>是可以看到的，但是因为 GitHub 屏蔽了百度的爬虫所以百度无法抓取…</p><p>然后发现我的配置跟主动推送的配置（<a href=\"http://www.yuan-ji.me/Hexo-优化%EF%BC%9A提交sitemap及解决百度爬虫抓取-GitHub-Pages-问题/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>）很像，但是deploy baidu_submitter一直出错，看了错误信息才发现是因为把<code>baidu_url_submit:</code>下的<code>path: baidu_urls.txt</code>擅自改了文件名导致的…</p><p>终于好了…踩坑结束！</p>"},{"title":"numpy常用函数和数据类型","date":"2018-04-01T08:27:34.000Z","_content":"\n\n\n### np.random.rand\n\nnp.random.rand(d0,d1,...,dn)表示创造一个(n+1)维的大小为d0\\*d1\\*...\\*dn的数组，其中每一个数都是随机产生的[0, 1)内的数。\n\n<!-- more -->\n\n```python\n>>> np.random.rand(3,2)\narray([[0.91184685, 0.81463722],\n       [0.9261665 , 0.960428  ],\n       [0.52837831, 0.61184641]])\n```\n\n### np.float32\n\n数据类型，32位浮点数。\n\n### np.dot\n\n矩阵乘法。np.dot(x, y)表示矩阵x和y相乘。\n\n```python\n>>> a = [1, 2]\n>>> b = [[3], [4]]\n>>> np.dot(a,b)\narray([11])\n```\n\n\n\n","source":"_posts/numpy常用函数和数据类型.md","raw":"---\ntitle: numpy常用函数和数据类型\ndate: 2018-04-01 16:27:34\ncategories: \n- Python\ntags:\n- numpy\n---\n\n\n\n### np.random.rand\n\nnp.random.rand(d0,d1,...,dn)表示创造一个(n+1)维的大小为d0\\*d1\\*...\\*dn的数组，其中每一个数都是随机产生的[0, 1)内的数。\n\n<!-- more -->\n\n```python\n>>> np.random.rand(3,2)\narray([[0.91184685, 0.81463722],\n       [0.9261665 , 0.960428  ],\n       [0.52837831, 0.61184641]])\n```\n\n### np.float32\n\n数据类型，32位浮点数。\n\n### np.dot\n\n矩阵乘法。np.dot(x, y)表示矩阵x和y相乘。\n\n```python\n>>> a = [1, 2]\n>>> b = [[3], [4]]\n>>> np.dot(a,b)\narray([11])\n```\n\n\n\n","slug":"numpy常用函数和数据类型","published":1,"updated":"2018-10-10T08:39:05.813Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w4001rfmagturhei1u","content":"<h3 id=\"np-random-rand\"><a href=\"#np-random-rand\" class=\"headerlink\" title=\"np.random.rand\"></a>np.random.rand</h3><p>np.random.rand(d0,d1,…,dn)表示创造一个(n+1)维的大小为d0*d1*…*dn的数组，其中每一个数都是随机产生的[0, 1)内的数。</p><a id=\"more\"></a><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0.91184685</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.81463722</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n       <span class=\"token punctuation\">[</span><span class=\"token number\">0.9261665</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0.960428</span>  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n       <span class=\"token punctuation\">[</span><span class=\"token number\">0.52837831</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.61184641</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre><h3 id=\"np-float32\"><a href=\"#np-float32\" class=\"headerlink\" title=\"np.float32\"></a>np.float32</h3><p>数据类型，32位浮点数。</p><h3 id=\"np-dot\"><a href=\"#np-dot\" class=\"headerlink\" title=\"np.dot\"></a>np.dot</h3><p>矩阵乘法。np.dot(x, y)表示矩阵x和y相乘。</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> np<span class=\"token punctuation\">.</span>dot<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"np-random-rand\"><a href=\"#np-random-rand\" class=\"headerlink\" title=\"np.random.rand\"></a>np.random.rand</h3><p>np.random.rand(d0,d1,…,dn)表示创造一个(n+1)维的大小为d0*d1*…*dn的数组，其中每一个数都是随机产生的[0, 1)内的数。</p>","more":"<pre><code class=\"python\">&gt;&gt;&gt; np.random.rand(3,2)\narray([[0.91184685, 0.81463722],\n       [0.9261665 , 0.960428  ],\n       [0.52837831, 0.61184641]])\n</code></pre><h3 id=\"np-float32\"><a href=\"#np-float32\" class=\"headerlink\" title=\"np.float32\"></a>np.float32</h3><p>数据类型，32位浮点数。</p><h3 id=\"np-dot\"><a href=\"#np-dot\" class=\"headerlink\" title=\"np.dot\"></a>np.dot</h3><p>矩阵乘法。np.dot(x, y)表示矩阵x和y相乘。</p><pre><code class=\"python\">&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [[3], [4]]\n&gt;&gt;&gt; np.dot(a,b)\narray([11])\n</code></pre>"},{"title":"ubuntu 18.04下安装稳定版Chrome谷歌浏览器","toc":false,"date":"2018-09-02T00:30:57.000Z","_content":"\n\n\n由于官方下载页面打不开，因此找了一个网盘下载的，[网盘下载点击这里](https://pan.baidu.com/s/1vC974ES6Y4UPdyRNTAJpZg)。\n\n<!-- more -->\n\n安装相关依赖：\n\n```powershell\nsudo apt-get install libcurl3\nsudo apt-get install libappindicator1\nsudo apt-get install libpango1.0-0\nsudo apt-get install libgooglepinyin0\n```\n\n\n\n进入下载目录，运行下列命令即可：\n\n```powershell\nsudo mv google-chrome-stable_current_amd64.deb /usr/local\ncd /usr/local\nsudo dpkg -i google-chrome-stable_current_amd64.deb\n```\n\n\n\n进行更新：\n\n```powershell\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n\n\n\n\n显示如下提示即安装成功：\n\n```powershell\nzmj@zmj:/usr/local$ sudo dpkg -i google-chrome-stable_current_amd64.deb\nSelecting previously unselected package google-chrome-stable.\n(Reading database ... 217976 files and directories currently installed.)\nPreparing to unpack google-chrome-stable_current_amd64.deb ...\nUnpacking google-chrome-stable (51.0.2704.106-1) ...\nSetting up google-chrome-stable (51.0.2704.106-1) ...\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/x-www-browser (x-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/gnome-www-browser (gnome-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/google-chrome (google-chrome) in auto mode\nProcessing triggers for gnome-menus (3.13.3-11ubuntu1.1) ...\nProcessing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.1) ...\nProcessing triggers for mime-support (3.60ubuntu1) ...\nProcessing triggers for man-db (2.8.3-2ubuntu0.1) ...\n\n```\n\n","source":"_posts/ubuntu-18-04下安装稳定版Chrome谷歌浏览器.md","raw":"---\ntitle: ubuntu 18.04下安装稳定版Chrome谷歌浏览器\ntoc: false\ndate: 2018-09-02 08:30:57\ncategories:\n- methods\ntags:\n- ubuntu\n- Chrome\n---\n\n\n\n由于官方下载页面打不开，因此找了一个网盘下载的，[网盘下载点击这里](https://pan.baidu.com/s/1vC974ES6Y4UPdyRNTAJpZg)。\n\n<!-- more -->\n\n安装相关依赖：\n\n```powershell\nsudo apt-get install libcurl3\nsudo apt-get install libappindicator1\nsudo apt-get install libpango1.0-0\nsudo apt-get install libgooglepinyin0\n```\n\n\n\n进入下载目录，运行下列命令即可：\n\n```powershell\nsudo mv google-chrome-stable_current_amd64.deb /usr/local\ncd /usr/local\nsudo dpkg -i google-chrome-stable_current_amd64.deb\n```\n\n\n\n进行更新：\n\n```powershell\nsudo apt-get update\nsudo apt-get upgrade\n```\n\n\n\n\n\n显示如下提示即安装成功：\n\n```powershell\nzmj@zmj:/usr/local$ sudo dpkg -i google-chrome-stable_current_amd64.deb\nSelecting previously unselected package google-chrome-stable.\n(Reading database ... 217976 files and directories currently installed.)\nPreparing to unpack google-chrome-stable_current_amd64.deb ...\nUnpacking google-chrome-stable (51.0.2704.106-1) ...\nSetting up google-chrome-stable (51.0.2704.106-1) ...\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/x-www-browser (x-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/gnome-www-browser (gnome-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/google-chrome (google-chrome) in auto mode\nProcessing triggers for gnome-menus (3.13.3-11ubuntu1.1) ...\nProcessing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.1) ...\nProcessing triggers for mime-support (3.60ubuntu1) ...\nProcessing triggers for man-db (2.8.3-2ubuntu0.1) ...\n\n```\n\n","slug":"ubuntu-18-04下安装稳定版Chrome谷歌浏览器","published":1,"updated":"2018-10-10T08:40:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w7001vfmagvue96jov","content":"<p>由于官方下载页面打不开，因此找了一个网盘下载的，<a href=\"https://pan.baidu.com/s/1vC974ES6Y4UPdyRNTAJpZg\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">网盘下载点击这里</a>。</p><a id=\"more\"></a><p>安装相关依赖：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo apt<span class=\"token operator\">-</span>get install libcurl3\nsudo apt<span class=\"token operator\">-</span>get install libappindicator1\nsudo apt<span class=\"token operator\">-</span>get install libpango1<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0\nsudo apt<span class=\"token operator\">-</span>get install libgooglepinyin0\n</code></pre><p>进入下载目录，运行下列命令即可：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo <span class=\"token function\">mv</span> google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable_current_amd64<span class=\"token punctuation\">.</span>deb <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local\ncd <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local\nsudo dpkg <span class=\"token operator\">-</span>i google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable_current_amd64<span class=\"token punctuation\">.</span>deb\n</code></pre><p>进行更新：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo apt<span class=\"token operator\">-</span>get update\nsudo apt<span class=\"token operator\">-</span>get upgrade\n</code></pre><p>显示如下提示即安装成功：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">zmj@zmj:<span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local$ sudo dpkg <span class=\"token operator\">-</span>i google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable_current_amd64<span class=\"token punctuation\">.</span>deb\nSelecting previously unselected package google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>Reading database <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> 217976 files and directories currently installed<span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\nPreparing to unpack google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable_current_amd64<span class=\"token punctuation\">.</span>deb <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nUnpacking google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable <span class=\"token punctuation\">(</span>51<span class=\"token punctuation\">.</span>0<span class=\"token punctuation\">.</span>2704<span class=\"token punctuation\">.</span>106<span class=\"token operator\">-</span>1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nSetting up google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable <span class=\"token punctuation\">(</span>51<span class=\"token punctuation\">.</span>0<span class=\"token punctuation\">.</span>2704<span class=\"token punctuation\">.</span>106<span class=\"token operator\">-</span>1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nupdate<span class=\"token operator\">-</span>alternatives: <span class=\"token keyword\">using</span> <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable to provide <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>x<span class=\"token operator\">-</span>www<span class=\"token operator\">-</span>browser <span class=\"token punctuation\">(</span>x<span class=\"token operator\">-</span>www<span class=\"token operator\">-</span>browser<span class=\"token punctuation\">)</span> in auto mode\nupdate<span class=\"token operator\">-</span>alternatives: <span class=\"token keyword\">using</span> <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable to provide <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>gnome<span class=\"token operator\">-</span>www<span class=\"token operator\">-</span>browser <span class=\"token punctuation\">(</span>gnome<span class=\"token operator\">-</span>www<span class=\"token operator\">-</span>browser<span class=\"token punctuation\">)</span> in auto mode\nupdate<span class=\"token operator\">-</span>alternatives: <span class=\"token keyword\">using</span> <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>google<span class=\"token operator\">-</span>chrome<span class=\"token operator\">-</span>stable to provide <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>google<span class=\"token operator\">-</span>chrome <span class=\"token punctuation\">(</span>google<span class=\"token operator\">-</span>chrome<span class=\"token punctuation\">)</span> in auto mode\nProcessing triggers <span class=\"token keyword\">for</span> gnome<span class=\"token operator\">-</span>menus <span class=\"token punctuation\">(</span>3<span class=\"token punctuation\">.</span>13<span class=\"token punctuation\">.</span>3<span class=\"token operator\">-</span>11ubuntu1<span class=\"token punctuation\">.</span>1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nProcessing triggers <span class=\"token keyword\">for</span> desktop<span class=\"token operator\">-</span>file<span class=\"token operator\">-</span>utils <span class=\"token punctuation\">(</span>0<span class=\"token punctuation\">.</span>23<span class=\"token operator\">-</span>1ubuntu3<span class=\"token punctuation\">.</span>18<span class=\"token punctuation\">.</span>04<span class=\"token punctuation\">.</span>1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nProcessing triggers <span class=\"token keyword\">for</span> mime<span class=\"token operator\">-</span>support <span class=\"token punctuation\">(</span>3<span class=\"token punctuation\">.</span>60ubuntu1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nProcessing triggers <span class=\"token keyword\">for</span> man<span class=\"token operator\">-</span>db <span class=\"token punctuation\">(</span>2<span class=\"token punctuation\">.</span>8<span class=\"token punctuation\">.</span>3<span class=\"token operator\">-</span>2ubuntu0<span class=\"token punctuation\">.</span>1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n</code></pre>","site":{"data":{}},"excerpt":"<p>由于官方下载页面打不开，因此找了一个网盘下载的，<a href=\"https://pan.baidu.com/s/1vC974ES6Y4UPdyRNTAJpZg\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">网盘下载点击这里</a>。</p>","more":"<p>安装相关依赖：</p><pre><code class=\"powershell\">sudo apt-get install libcurl3\nsudo apt-get install libappindicator1\nsudo apt-get install libpango1.0-0\nsudo apt-get install libgooglepinyin0\n</code></pre><p>进入下载目录，运行下列命令即可：</p><pre><code class=\"powershell\">sudo mv google-chrome-stable_current_amd64.deb /usr/local\ncd /usr/local\nsudo dpkg -i google-chrome-stable_current_amd64.deb\n</code></pre><p>进行更新：</p><pre><code class=\"powershell\">sudo apt-get update\nsudo apt-get upgrade\n</code></pre><p>显示如下提示即安装成功：</p><pre><code class=\"powershell\">zmj@zmj:/usr/local$ sudo dpkg -i google-chrome-stable_current_amd64.deb\nSelecting previously unselected package google-chrome-stable.\n(Reading database ... 217976 files and directories currently installed.)\nPreparing to unpack google-chrome-stable_current_amd64.deb ...\nUnpacking google-chrome-stable (51.0.2704.106-1) ...\nSetting up google-chrome-stable (51.0.2704.106-1) ...\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/x-www-browser (x-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/gnome-www-browser (gnome-www-browser) in auto mode\nupdate-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/google-chrome (google-chrome) in auto mode\nProcessing triggers for gnome-menus (3.13.3-11ubuntu1.1) ...\nProcessing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.1) ...\nProcessing triggers for mime-support (3.60ubuntu1) ...\nProcessing triggers for man-db (2.8.3-2ubuntu0.1) ...\n\n</code></pre>"},{"title":"ubuntu18.04中安装iNode","toc":false,"date":"2018-09-01T09:52:20.000Z","_content":"\n\n\n\n\n首先在学校官网下载32位版本的iNode包（64位一直无法安装成功因此选择安装32位版本的）。\n\n<!-- more -->\n\n解压。\n\n\n\n安装各种依赖库（如果某个命令无法运行可以在安装目录下运行`./iNodeClient.sh`查看当前需要安装的依赖）：\n\n```powershell\nsudo apt-get install lib32ncurses5\nsudo apt-get install lib32z1\nsudo aptitude install libgtk-x11-2.0\nsudo apt-get install libgtk2.0-0:i386 libnss3:i386 libcurl3-gnutls:i386 libidn11:i386 libpango1.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386\nsudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6\nsudo apt-get dist-upgrade\nsudo ln -s /usr/lib/i386-linux-gnu/libjpeg.so.8 /usr/lib/i386-linux-gnu/libjpeg.so.62\nsudo ln -s /usr/lib/i386-linux-gnu/libtiff.so.5 /usr/lib/i386-linux-gnu/libtiff.so.3\nsudo apt-get install murrine-themes\nsudo apt-get install gtk2-engines-murrine\nsudo apt-get install libgtkmm-2.4-dev\nsudo apt-get install libcanberra-gtk-module:i386\n```\n\n\n\n在解压后的目录中运行：\n\n```powershell\nsudo ./install.sh\n```\n\n\n\n这个时候`iNodeClient.destop`就可以点击运行了。\n\n\n\n添加用户名和密码后将`NIC`修改为`enp7s0`即可成功连接。\n\n\n\n[参考链接](https://blog.csdn.net/a845717607/article/details/52563005)","source":"_posts/ubuntu18-04中安装iNode.md","raw":"---\ntitle: ubuntu18.04中安装iNode\ntoc: false\ndate: 2018-09-01 17:52:20\ncategories:\n- methods\ntags:\n- ubuntu\n- iNode\n---\n\n\n\n\n\n首先在学校官网下载32位版本的iNode包（64位一直无法安装成功因此选择安装32位版本的）。\n\n<!-- more -->\n\n解压。\n\n\n\n安装各种依赖库（如果某个命令无法运行可以在安装目录下运行`./iNodeClient.sh`查看当前需要安装的依赖）：\n\n```powershell\nsudo apt-get install lib32ncurses5\nsudo apt-get install lib32z1\nsudo aptitude install libgtk-x11-2.0\nsudo apt-get install libgtk2.0-0:i386 libnss3:i386 libcurl3-gnutls:i386 libidn11:i386 libpango1.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386\nsudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6\nsudo apt-get dist-upgrade\nsudo ln -s /usr/lib/i386-linux-gnu/libjpeg.so.8 /usr/lib/i386-linux-gnu/libjpeg.so.62\nsudo ln -s /usr/lib/i386-linux-gnu/libtiff.so.5 /usr/lib/i386-linux-gnu/libtiff.so.3\nsudo apt-get install murrine-themes\nsudo apt-get install gtk2-engines-murrine\nsudo apt-get install libgtkmm-2.4-dev\nsudo apt-get install libcanberra-gtk-module:i386\n```\n\n\n\n在解压后的目录中运行：\n\n```powershell\nsudo ./install.sh\n```\n\n\n\n这个时候`iNodeClient.destop`就可以点击运行了。\n\n\n\n添加用户名和密码后将`NIC`修改为`enp7s0`即可成功连接。\n\n\n\n[参考链接](https://blog.csdn.net/a845717607/article/details/52563005)","slug":"ubuntu18-04中安装iNode","published":1,"updated":"2018-10-10T08:39:45.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1w9001zfmagfochq6ro","content":"<p>首先在学校官网下载32位版本的iNode包（64位一直无法安装成功因此选择安装32位版本的）。</p><a id=\"more\"></a><p>解压。</p><p>安装各种依赖库（如果某个命令无法运行可以在安装目录下运行<code>./iNodeClient.sh</code>查看当前需要安装的依赖）：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo apt<span class=\"token operator\">-</span>get install lib32ncurses5\nsudo apt<span class=\"token operator\">-</span>get install lib32z1\nsudo aptitude install libgtk<span class=\"token operator\">-</span>x11<span class=\"token operator\">-</span>2<span class=\"token punctuation\">.</span>0\nsudo apt<span class=\"token operator\">-</span>get install libgtk2<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0:i386 libnss3:i386 libcurl3<span class=\"token operator\">-</span>gnutls:i386 libidn11:i386 libpango1<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0:i386 libpangox<span class=\"token operator\">-</span>1<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0:i386 libpangoxft<span class=\"token operator\">-</span>1<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0:i386\nsudo apt<span class=\"token operator\">-</span>get install libgtk2<span class=\"token punctuation\">.</span>0<span class=\"token operator\">-</span>0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc+<span class=\"token operator\">+</span>6\nsudo apt<span class=\"token operator\">-</span>get dist<span class=\"token operator\">-</span>upgrade\nsudo ln <span class=\"token operator\">-</span>s <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>i386<span class=\"token operator\">-</span>linux<span class=\"token operator\">-</span>gnu<span class=\"token operator\">/</span>libjpeg<span class=\"token punctuation\">.</span>so<span class=\"token punctuation\">.</span>8 <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>i386<span class=\"token operator\">-</span>linux<span class=\"token operator\">-</span>gnu<span class=\"token operator\">/</span>libjpeg<span class=\"token punctuation\">.</span>so<span class=\"token punctuation\">.</span>62\nsudo ln <span class=\"token operator\">-</span>s <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>i386<span class=\"token operator\">-</span>linux<span class=\"token operator\">-</span>gnu<span class=\"token operator\">/</span>libtiff<span class=\"token punctuation\">.</span>so<span class=\"token punctuation\">.</span>5 <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>i386<span class=\"token operator\">-</span>linux<span class=\"token operator\">-</span>gnu<span class=\"token operator\">/</span>libtiff<span class=\"token punctuation\">.</span>so<span class=\"token punctuation\">.</span>3\nsudo apt<span class=\"token operator\">-</span>get install murrine<span class=\"token operator\">-</span>themes\nsudo apt<span class=\"token operator\">-</span>get install gtk2<span class=\"token operator\">-</span>engines<span class=\"token operator\">-</span>murrine\nsudo apt<span class=\"token operator\">-</span>get install libgtkmm<span class=\"token operator\">-</span>2<span class=\"token punctuation\">.</span>4<span class=\"token operator\">-</span>dev\nsudo apt<span class=\"token operator\">-</span>get install libcanberra<span class=\"token operator\">-</span>gtk<span class=\"token operator\">-</span>module:i386\n</code></pre><p>在解压后的目录中运行：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>install<span class=\"token punctuation\">.</span>sh\n</code></pre><p>这个时候<code>iNodeClient.destop</code>就可以点击运行了。</p><p>添加用户名和密码后将<code>NIC</code>修改为<code>enp7s0</code>即可成功连接。</p><p><a href=\"https://blog.csdn.net/a845717607/article/details/52563005\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>","site":{"data":{}},"excerpt":"<p>首先在学校官网下载32位版本的iNode包（64位一直无法安装成功因此选择安装32位版本的）。</p>","more":"<p>解压。</p><p>安装各种依赖库（如果某个命令无法运行可以在安装目录下运行<code>./iNodeClient.sh</code>查看当前需要安装的依赖）：</p><pre><code class=\"powershell\">sudo apt-get install lib32ncurses5\nsudo apt-get install lib32z1\nsudo aptitude install libgtk-x11-2.0\nsudo apt-get install libgtk2.0-0:i386 libnss3:i386 libcurl3-gnutls:i386 libidn11:i386 libpango1.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386\nsudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6\nsudo apt-get dist-upgrade\nsudo ln -s /usr/lib/i386-linux-gnu/libjpeg.so.8 /usr/lib/i386-linux-gnu/libjpeg.so.62\nsudo ln -s /usr/lib/i386-linux-gnu/libtiff.so.5 /usr/lib/i386-linux-gnu/libtiff.so.3\nsudo apt-get install murrine-themes\nsudo apt-get install gtk2-engines-murrine\nsudo apt-get install libgtkmm-2.4-dev\nsudo apt-get install libcanberra-gtk-module:i386\n</code></pre><p>在解压后的目录中运行：</p><pre><code class=\"powershell\">sudo ./install.sh\n</code></pre><p>这个时候<code>iNodeClient.destop</code>就可以点击运行了。</p><p>添加用户名和密码后将<code>NIC</code>修改为<code>enp7s0</code>即可成功连接。</p><p><a href=\"https://blog.csdn.net/a845717607/article/details/52563005\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>"},{"title":"ubuntu18.04开机慢的解决办法","toc":false,"date":"2018-09-24T04:49:31.000Z","_content":"\n在终端中输入：\n\n```powershell\nsudo gedit /etc/default/grub \n```\n\n将打开的文件中的`GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"`\n\n修改为`GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash noresume\"`\n\n保存退出后在终端中运行下面的命令来让修改生效：\n\n```powershell\nsudo update-grub\n```\n\n重启电脑感受一下吧！","source":"_posts/ubuntu18-04开机慢的解决办法.md","raw":"---\ntitle: ubuntu18.04开机慢的解决办法\ntoc: false\ndate: 2018-09-24 12:49:31\ncategories:\n- methods\ntags:\n- ubuntu\n---\n\n在终端中输入：\n\n```powershell\nsudo gedit /etc/default/grub \n```\n\n将打开的文件中的`GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"`\n\n修改为`GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash noresume\"`\n\n保存退出后在终端中运行下面的命令来让修改生效：\n\n```powershell\nsudo update-grub\n```\n\n重启电脑感受一下吧！","slug":"ubuntu18-04开机慢的解决办法","published":1,"updated":"2018-10-10T08:39:57.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wa0023fmagrk6t3y1b","content":"<p>在终端中输入：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo gedit <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>default<span class=\"token operator\">/</span>grub \n</code></pre><p>将打开的文件中的<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</code></p><p>修改为<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash noresume&quot;</code></p><p>保存退出后在终端中运行下面的命令来让修改生效：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo update<span class=\"token operator\">-</span>grub\n</code></pre><p>重启电脑感受一下吧！</p>","site":{"data":{}},"excerpt":"","more":"<p>在终端中输入：</p><pre><code class=\"powershell\">sudo gedit /etc/default/grub \n</code></pre><p>将打开的文件中的<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</code></p><p>修改为<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash noresume&quot;</code></p><p>保存退出后在终端中运行下面的命令来让修改生效：</p><pre><code class=\"powershell\">sudo update-grub\n</code></pre><p>重启电脑感受一下吧！</p>"},{"title":"ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法","toc":false,"date":"2018-09-02T06:37:26.000Z","_content":"\n\n\n由于Chrome设置了使用微软雅黑字体导致了部分图片显示不正常，\n\n在浏览器设置中将字体换回ubuntu刷新页面会发现图片已经显示正常。\n\n","source":"_posts/ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法.md","raw":"---\ntitle: ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法\ntoc: false\ndate: 2018-09-02 14:37:26\ncategories:\n- methods\ntags:\n- ubuntu\n- Chrome\n- 图片显示\n---\n\n\n\n由于Chrome设置了使用微软雅黑字体导致了部分图片显示不正常，\n\n在浏览器设置中将字体换回ubuntu刷新页面会发现图片已经显示正常。\n\n","slug":"ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法","published":1,"updated":"2018-09-11T05:46:12.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wc0026fmag4qlle4uh","content":"<p>由于Chrome设置了使用微软雅黑字体导致了部分图片显示不正常，</p><p>在浏览器设置中将字体换回ubuntu刷新页面会发现图片已经显示正常。</p>","site":{"data":{}},"excerpt":"","more":"<p>由于Chrome设置了使用微软雅黑字体导致了部分图片显示不正常，</p><p>在浏览器设置中将字体换回ubuntu刷新页面会发现图片已经显示正常。</p>"},{"title":"ubuntu下创建文件夹快捷方式","toc":false,"date":"2018-09-01T09:22:28.000Z","_content":"\n\n\n```powershell\nsudo ln -sT [srcDir] [dstDir/name]\n```\n\n例如创建`hexo`文件夹的桌面快捷方式：\n\n```powershell\nsudo ln -sT '/media/zmj/本地磁盘/hexo' '/home/zmj/Desktop/hexo'\n```\n\n\n\n[参考链接](https://www.cnblogs.com/tergeldev/p/6336836.html)","source":"_posts/ubuntu下创建文件夹快捷方式.md","raw":"---\ntitle: ubuntu下创建文件夹快捷方式\ntoc: false\ndate: 2018-09-01 17:22:28\ncategories:\n- methods\ntags:\n- ubuntu\n- 快捷方式\n---\n\n\n\n```powershell\nsudo ln -sT [srcDir] [dstDir/name]\n```\n\n例如创建`hexo`文件夹的桌面快捷方式：\n\n```powershell\nsudo ln -sT '/media/zmj/本地磁盘/hexo' '/home/zmj/Desktop/hexo'\n```\n\n\n\n[参考链接](https://www.cnblogs.com/tergeldev/p/6336836.html)","slug":"ubuntu下创建文件夹快捷方式","published":1,"updated":"2018-09-11T05:46:12.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1we0029fmagtp2mymdc","content":"<pre class=\" language-powershell\"><code class=\"language-powershell\">sudo ln <span class=\"token operator\">-</span>sT <span class=\"token namespace\">[srcDir]</span> <span class=\"token namespace\">[dstDir/name]</span>\n</code></pre><p>例如创建<code>hexo</code>文件夹的桌面快捷方式：</p><pre class=\" language-powershell\"><code class=\"language-powershell\">sudo ln <span class=\"token operator\">-</span>sT <span class=\"token string\">'/media/zmj/本地磁盘/hexo'</span> <span class=\"token string\">'/home/zmj/Desktop/hexo'</span>\n</code></pre><p><a href=\"https://www.cnblogs.com/tergeldev/p/6336836.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"powershell\">sudo ln -sT [srcDir] [dstDir/name]\n</code></pre><p>例如创建<code>hexo</code>文件夹的桌面快捷方式：</p><pre><code class=\"powershell\">sudo ln -sT &#39;/media/zmj/本地磁盘/hexo&#39; &#39;/home/zmj/Desktop/hexo&#39;\n</code></pre><p><a href=\"https://www.cnblogs.com/tergeldev/p/6336836.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>"},{"title":"ubuntu下无法将iNode绑定到侧边栏的解决办法","toc":false,"date":"2018-09-01T09:43:52.000Z","_content":"\n\n\n\n\n将`iNodeClient.desktop`添加到`/usr/share/applications`中（`cp`命令）后，右键侧边栏上打开的iNode的图标即可`Add to Favorites`。","source":"_posts/ubuntu下无法将iNode绑定到侧边栏的解决办法.md","raw":"---\ntitle: ubuntu下无法将iNode绑定到侧边栏的解决办法\ntoc: false\ndate: 2018-09-01 17:43:52\ncategories:\n- methods\ntags:\n- ubuntu\n- iNode\n---\n\n\n\n\n\n将`iNodeClient.desktop`添加到`/usr/share/applications`中（`cp`命令）后，右键侧边栏上打开的iNode的图标即可`Add to Favorites`。","slug":"ubuntu下无法将iNode绑定到侧边栏的解决办法","published":1,"updated":"2018-09-11T05:46:12.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wg002cfmagrpjs7dxd","content":"<p>将<code>iNodeClient.desktop</code>添加到<code>/usr/share/applications</code>中（<code>cp</code>命令）后，右键侧边栏上打开的iNode的图标即可<code>Add to Favorites</code>。</p>","site":{"data":{}},"excerpt":"","more":"<p>将<code>iNodeClient.desktop</code>添加到<code>/usr/share/applications</code>中（<code>cp</code>命令）后，右键侧边栏上打开的iNode的图标即可<code>Add to Favorites</code>。</p>"},{"title":"ubuntu修改顶栏颜色","toc":false,"date":"2018-09-29T11:14:01.000Z","_content":"\n编辑shell主题的css文件，比如我的shell主题是`Vimix-Beryl`：\n\n```shell\nsudo gedit /usr/share/themes/Vimix-Beryl/gnome-shell/gnome-shell.css\n```\n\n<!-- more -->\n\n打开之后搜索`top bar`，会看到这样一段：\n\n```css\n/* TOP BAR */\n#panel {\n  background-color: rgba(0, 0, 0, 0.6);\n  /* transition from solid to transparent */\n  transition-duration: 250ms;\n  font-weight: bold;\n  height: 32px;\n}\n```\n\n按照自己的喜好修改`background-color`即可^_^\n\n\n\n补充：修改完可能并不能直接看到效果，可以在tweaks里先切换成别的主题再换成修改了的主题。\n\n\n\n再补充：因为我是把透明度调到了大概0.2左右，导致使用hide top bar扩展时使用鼠标触发top bar后几乎看不清，可以往下找一下`#panel.solid`，把`background-color`改成这样：\n\n```css\n#panel.solid {\n  background-color: rgba(0, 0, 0, 0.5);;\n  /* transition from transparent to solid */\n  transition-duration: 250ms;\n  background-gradient-direction: none;\n  text-shadow: none;\n}\n```\n\n","source":"_posts/ubuntu修改顶栏颜色.md","raw":"---\ntitle: ubuntu修改顶栏颜色\ntoc: false\ndate: 2018-09-29 19:14:01\ncategories:\n- methods\ntags:\n- Ubuntu\n---\n\n编辑shell主题的css文件，比如我的shell主题是`Vimix-Beryl`：\n\n```shell\nsudo gedit /usr/share/themes/Vimix-Beryl/gnome-shell/gnome-shell.css\n```\n\n<!-- more -->\n\n打开之后搜索`top bar`，会看到这样一段：\n\n```css\n/* TOP BAR */\n#panel {\n  background-color: rgba(0, 0, 0, 0.6);\n  /* transition from solid to transparent */\n  transition-duration: 250ms;\n  font-weight: bold;\n  height: 32px;\n}\n```\n\n按照自己的喜好修改`background-color`即可^_^\n\n\n\n补充：修改完可能并不能直接看到效果，可以在tweaks里先切换成别的主题再换成修改了的主题。\n\n\n\n再补充：因为我是把透明度调到了大概0.2左右，导致使用hide top bar扩展时使用鼠标触发top bar后几乎看不清，可以往下找一下`#panel.solid`，把`background-color`改成这样：\n\n```css\n#panel.solid {\n  background-color: rgba(0, 0, 0, 0.5);;\n  /* transition from transparent to solid */\n  transition-duration: 250ms;\n  background-gradient-direction: none;\n  text-shadow: none;\n}\n```\n\n","slug":"ubuntu修改顶栏颜色","published":1,"updated":"2018-10-10T08:40:48.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wh002ffmagrja1ce06","content":"<p>编辑shell主题的css文件，比如我的shell主题是<code>Vimix-Beryl</code>：</p><pre class=\" language-shell\"><code class=\"language-shell\">sudo gedit /usr/share/themes/Vimix-Beryl/gnome-shell/gnome-shell.css\n</code></pre><a id=\"more\"></a><p>打开之后搜索<code>top bar</code>，会看到这样一段：</p><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token comment\" spellcheck=\"true\">/* TOP BAR */</span>\n<span class=\"token selector\"><span class=\"token id\">#panel</span> </span><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rgba</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span>, <span class=\"token number\">0</span>, <span class=\"token number\">0</span>, <span class=\"token number\">0.6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* transition from solid to transparent */</span>\n  <span class=\"token property\">transition-duration</span><span class=\"token punctuation\">:</span> <span class=\"token number\">250</span>ms<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">font-weight</span><span class=\"token punctuation\">:</span> bold<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">32</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>按照自己的喜好修改<code>background-color</code>即可^_^</p><p>补充：修改完可能并不能直接看到效果，可以在tweaks里先切换成别的主题再换成修改了的主题。</p><p>再补充：因为我是把透明度调到了大概0.2左右，导致使用hide top bar扩展时使用鼠标触发top bar后几乎看不清，可以往下找一下<code>#panel.solid</code>，把<code>background-color</code>改成这样：</p><pre class=\" language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token id\">#panel</span><span class=\"token class\">.solid</span> </span><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rgba</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span>, <span class=\"token number\">0</span>, <span class=\"token number\">0</span>, <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* transition from transparent to solid */</span>\n  <span class=\"token property\">transition-duration</span><span class=\"token punctuation\">:</span> <span class=\"token number\">250</span>ms<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">background-gradient-direction</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">text-shadow</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>","site":{"data":{}},"excerpt":"<p>编辑shell主题的css文件，比如我的shell主题是<code>Vimix-Beryl</code>：</p><pre><code class=\"shell\">sudo gedit /usr/share/themes/Vimix-Beryl/gnome-shell/gnome-shell.css\n</code></pre>","more":"<p>打开之后搜索<code>top bar</code>，会看到这样一段：</p><pre><code class=\"css\">/* TOP BAR */\n#panel {\n  background-color: rgba(0, 0, 0, 0.6);\n  /* transition from solid to transparent */\n  transition-duration: 250ms;\n  font-weight: bold;\n  height: 32px;\n}\n</code></pre><p>按照自己的喜好修改<code>background-color</code>即可^_^</p><p>补充：修改完可能并不能直接看到效果，可以在tweaks里先切换成别的主题再换成修改了的主题。</p><p>再补充：因为我是把透明度调到了大概0.2左右，导致使用hide top bar扩展时使用鼠标触发top bar后几乎看不清，可以往下找一下<code>#panel.solid</code>，把<code>background-color</code>改成这样：</p><pre><code class=\"css\">#panel.solid {\n  background-color: rgba(0, 0, 0, 0.5);;\n  /* transition from transparent to solid */\n  transition-duration: 250ms;\n  background-gradient-direction: none;\n  text-shadow: none;\n}\n</code></pre>"},{"title":"使用TensorBoard可视化工具","date":"2018-04-01T05:04:00.000Z","_content":"\n图表可视化在理解和调试时显得非常有帮助。\n\n<!-- more -->\n\n# 安装：\n\n```shell\npip3 install --upgrade tensorboard\n```\n\n# 名称域（Name scoping）和节点（Node）\n\n典型的TensorFlow有数以千计的节点，为了简单起见，我们可以为变量名（节点）划分范围。\n\n这个范围称为名称域，即`tf.name_scope('xxx')`，其中xxx是这个名称域的名字。\n\n在定义好名称域后，TensorBoard的显示界面里这个名称域内的变量并不会显示，而是只显示一个xxx节点，这个点是可展开的，展开后才会显示这个名称域内的节点。\n\nTensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头表示，控制依赖用虚线表示。\n\n具体的符号表：\n\n| 符号                                       | 意义                                 |\n| ---------------------------------------- | ---------------------------------- |\n| ![名称域](http://www.tensorfly.cn/tfdoc/images/namespace_node.png) | *High-level*节点代表一个名称域，双击则展开一个高层节点。 |\n| ![断线节点序列](http://www.tensorfly.cn/tfdoc/images/horizontal_stack.png) | 彼此之间不连接的有限个节点序列。                   |\n| ![相连节点序列](http://www.tensorfly.cn/tfdoc/images/vertical_stack.png) | 彼此之间相连的有限个节点序列。                    |\n| ![操作节点](http://www.tensorfly.cn/tfdoc/images/op_node.png) | 一个单独的操作节点。                         |\n| ![常量节点](http://www.tensorfly.cn/tfdoc/images/constant.png) | 一个常量结点。                            |\n| ![摘要节点](http://www.tensorfly.cn/tfdoc/images/summary.png) | 一个摘要节点。                            |\n| ![数据流边](http://www.tensorfly.cn/tfdoc/images/dataflow_edge.png) | 显示各操作间的数据流边。                       |\n| ![控制依赖边](http://www.tensorfly.cn/tfdoc/images/control_edge.png) | 显示各操作间的控制依赖边。                      |\n| ![引用边](http://www.tensorfly.cn/tfdoc/images/reference_edge.png) | 引用边，表示出度操作节点可以使入度tensor发生变化。       |\n\n# Scalar\n\n使用summary scalar（标量统计）:\n\n```python\nxentropy = ... # xentropy的定义\ntf.summary.scalar('xentropy_mean', xentropy)\t# xentropy_mean为定义的xentropy的标签名\n```\n\n![MNIST TensorBoard](http://www.tensorfly.cn/tfdoc/images/mnist_tensorboard.png)\n\n# Histogram\n\n使用summary histogram统计某个Tensor的取值分布:\n\n```python\n with tf.name_scope('layer1'):\n          with tf.name_scope('biases'):\n              biases = ... # 具体声明这里不再给出\n              tf.summary.histogram('layer1' + '/biases', biases)\n\n          with tf.name_scope('weights'):\n              weights= ...\n              tf.summary.histogram('layer1' + '/weights', weights)\n        \n          with tf.name_scope('outputs'):\n              outputs= ...\n              tf.summary.histogram('layer1' + '/weights', outputs)\n```\n\n\n\n[![Tensorboard 可视化好帮手 2](https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png)](https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png)\n\n# 合并Summary\n\n```python\n\n# 将各个summary操作合并为一个操作merged_summary_op\nmerged_summary_op = tf.summary.merge_all()\n# 数据写入器，'/logs'为训练日志的存储路径\nsummary_writer = tf.summary.FileWriter('./logs', sess.graph) \n\ntotal_step = 0\nwhile training:\n  total_step += 1\n  session.run(training_op)\n  if total_step % 100 == 0:\n    ...\n    summary_str = sess.run(merged_summary_op, feed_dict{...}) # 注意这里必须加feed_dict否则会报错\n    summary_writer.add_summary(summary_str, total_step) # 使用summary_writer将数据写入磁盘\n```\n\n# 生成TensorBoard界面\n\n运行添加了各种summary的操作的代码后，打开cmd，进入代码所在文件夹，输入：\n\n```shell\ntensorboard --logdir=logs\n```\n\n按照运行后的提示：\n\n```shell\nTensorBoard 1.7.0 at http://MengjieZhang:6006 (Press CTRL+C to quit)\n```\n\n打开浏览器，输入地址 `http://MengjieZhang:6006` 即可以看到TensorBoard界面。\n\n\n\n# 具体代码：\n\n[input_data下载链接](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/mnist/input_data.py)\n\n```python\nimport input_data\nimport tensorflow as tf\n\ndef weight_variable(shape):\n  initial = tf.truncated_normal(shape, stddev=0.1)\n  return tf.Variable(initial)\n\ndef bias_variable(shape):\n  initial = tf.constant(0.1, shape=shape)\n  return tf.Variable(initial)\n\ndef conv2d(x, W):\n  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')\n\ndef max_pool_2x2(x):\n  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],\n                        strides=[1, 2, 2, 1], padding='SAME')\n\nmnist = input_data.read_data_sets('data', one_hot=True)\n\nmnistGraph = tf.Graph()\nwith mnistGraph.as_default():\n    with tf.name_scope('input'):\n        x = tf.placeholder(\"float\", shape=[None, 784])\n        y_ = tf.placeholder(\"float\", shape=[None, 10])\n        W = tf.Variable(tf.zeros([784,10]))\n        b = tf.Variable(tf.zeros([10]))\n\n    with tf.name_scope('hidden1'):\n        W_conv1 = weight_variable([5, 5, 1, 32])\n        b_conv1 = bias_variable([32])\n        x_image = tf.reshape(x, [-1,28,28,1])\n        h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n        h_pool1 = max_pool_2x2(h_conv1)\n        tf.summary.histogram('W_conv1', W_conv1)\n        tf.summary.histogram('b_conv1', b_conv1)\n\n    with tf.name_scope('hidden2'):\n        W_conv2 = weight_variable([5, 5, 32, 64])\n        b_conv2 = bias_variable([64])\n        h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n        h_pool2 = max_pool_2x2(h_conv2)\n        tf.summary.histogram('W_conv2', W_conv2)\n        tf.summary.histogram('b_conv2', b_conv2)\n\n    with tf.name_scope('fc1'):\n        W_fc1 = weight_variable([7 * 7 * 64, 1024])\n        b_fc1 = bias_variable([1024])\n        h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])\n        h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n        keep_prob = tf.placeholder(\"float\")\n        h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n        tf.summary.histogram('W_fc1', W_fc1)\n        tf.summary.histogram('b_fc1', b_fc1)\n\n    with tf.name_scope('fc2'):\n        W_fc2 = weight_variable([1024, 10])\n        b_fc2 = bias_variable([10])\n        y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)\n        tf.summary.histogram('W_fc2', W_fc2)\n        tf.summary.histogram('b_fc2', b_fc2)\n\n    with tf.name_scope('train'):\n        cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv))\n        train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)\n        correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1))\n        accuracy = tf.reduce_mean(tf.cast(correct_prediction, \"float\"))\n        tf.summary.scalar('loss', cross_entropy)\n        tf.summary.scalar('accuracy', accuracy)      \n\nwith tf.Session(graph=mnistGraph) as sess:\n    sess.run(tf.initialize_all_variables())\n    merged_summary_op = tf.summary.merge_all() \n    summary_writer = tf.summary.FileWriter('./logs', sess.graph) \n    for i in range(3000):\n      batch = mnist.train.next_batch(50)\n      if i%100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x:batch[0], y_: batch[1], keep_prob: 1.0})\n        print (\"step %d, training accuracy %g\" % (i, train_accuracy))\n        summary_str = sess.run(merged_summary_op, feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n        summary_writer.add_summary(summary_str, i) \n      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n\n    accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\n    good = 0\n    total = 0\n    for i in range(10):\n        testSet = mnist.test.next_batch(50)\n        good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n        total += testSet[0].shape[0]\n    print (\"test accuracy %g\"%(good/total))\n```\n\n运行后的TensorBoard界面：\n\n![运行后的TensorBoard界面](http://chuantu.biz/t6/270/1522570657x1822611335.png)","source":"_posts/使用TensorBoard可视化工具.md","raw":"---\ntitle: 使用TensorBoard可视化工具\ndate: 2018-04-01 13:04:00\ncategories: \n- deep learning\ntags:\n- TensorFlow\n- TensorBoard\n---\n\n图表可视化在理解和调试时显得非常有帮助。\n\n<!-- more -->\n\n# 安装：\n\n```shell\npip3 install --upgrade tensorboard\n```\n\n# 名称域（Name scoping）和节点（Node）\n\n典型的TensorFlow有数以千计的节点，为了简单起见，我们可以为变量名（节点）划分范围。\n\n这个范围称为名称域，即`tf.name_scope('xxx')`，其中xxx是这个名称域的名字。\n\n在定义好名称域后，TensorBoard的显示界面里这个名称域内的变量并不会显示，而是只显示一个xxx节点，这个点是可展开的，展开后才会显示这个名称域内的节点。\n\nTensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头表示，控制依赖用虚线表示。\n\n具体的符号表：\n\n| 符号                                       | 意义                                 |\n| ---------------------------------------- | ---------------------------------- |\n| ![名称域](http://www.tensorfly.cn/tfdoc/images/namespace_node.png) | *High-level*节点代表一个名称域，双击则展开一个高层节点。 |\n| ![断线节点序列](http://www.tensorfly.cn/tfdoc/images/horizontal_stack.png) | 彼此之间不连接的有限个节点序列。                   |\n| ![相连节点序列](http://www.tensorfly.cn/tfdoc/images/vertical_stack.png) | 彼此之间相连的有限个节点序列。                    |\n| ![操作节点](http://www.tensorfly.cn/tfdoc/images/op_node.png) | 一个单独的操作节点。                         |\n| ![常量节点](http://www.tensorfly.cn/tfdoc/images/constant.png) | 一个常量结点。                            |\n| ![摘要节点](http://www.tensorfly.cn/tfdoc/images/summary.png) | 一个摘要节点。                            |\n| ![数据流边](http://www.tensorfly.cn/tfdoc/images/dataflow_edge.png) | 显示各操作间的数据流边。                       |\n| ![控制依赖边](http://www.tensorfly.cn/tfdoc/images/control_edge.png) | 显示各操作间的控制依赖边。                      |\n| ![引用边](http://www.tensorfly.cn/tfdoc/images/reference_edge.png) | 引用边，表示出度操作节点可以使入度tensor发生变化。       |\n\n# Scalar\n\n使用summary scalar（标量统计）:\n\n```python\nxentropy = ... # xentropy的定义\ntf.summary.scalar('xentropy_mean', xentropy)\t# xentropy_mean为定义的xentropy的标签名\n```\n\n![MNIST TensorBoard](http://www.tensorfly.cn/tfdoc/images/mnist_tensorboard.png)\n\n# Histogram\n\n使用summary histogram统计某个Tensor的取值分布:\n\n```python\n with tf.name_scope('layer1'):\n          with tf.name_scope('biases'):\n              biases = ... # 具体声明这里不再给出\n              tf.summary.histogram('layer1' + '/biases', biases)\n\n          with tf.name_scope('weights'):\n              weights= ...\n              tf.summary.histogram('layer1' + '/weights', weights)\n        \n          with tf.name_scope('outputs'):\n              outputs= ...\n              tf.summary.histogram('layer1' + '/weights', outputs)\n```\n\n\n\n[![Tensorboard 可视化好帮手 2](https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png)](https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png)\n\n# 合并Summary\n\n```python\n\n# 将各个summary操作合并为一个操作merged_summary_op\nmerged_summary_op = tf.summary.merge_all()\n# 数据写入器，'/logs'为训练日志的存储路径\nsummary_writer = tf.summary.FileWriter('./logs', sess.graph) \n\ntotal_step = 0\nwhile training:\n  total_step += 1\n  session.run(training_op)\n  if total_step % 100 == 0:\n    ...\n    summary_str = sess.run(merged_summary_op, feed_dict{...}) # 注意这里必须加feed_dict否则会报错\n    summary_writer.add_summary(summary_str, total_step) # 使用summary_writer将数据写入磁盘\n```\n\n# 生成TensorBoard界面\n\n运行添加了各种summary的操作的代码后，打开cmd，进入代码所在文件夹，输入：\n\n```shell\ntensorboard --logdir=logs\n```\n\n按照运行后的提示：\n\n```shell\nTensorBoard 1.7.0 at http://MengjieZhang:6006 (Press CTRL+C to quit)\n```\n\n打开浏览器，输入地址 `http://MengjieZhang:6006` 即可以看到TensorBoard界面。\n\n\n\n# 具体代码：\n\n[input_data下载链接](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/mnist/input_data.py)\n\n```python\nimport input_data\nimport tensorflow as tf\n\ndef weight_variable(shape):\n  initial = tf.truncated_normal(shape, stddev=0.1)\n  return tf.Variable(initial)\n\ndef bias_variable(shape):\n  initial = tf.constant(0.1, shape=shape)\n  return tf.Variable(initial)\n\ndef conv2d(x, W):\n  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')\n\ndef max_pool_2x2(x):\n  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],\n                        strides=[1, 2, 2, 1], padding='SAME')\n\nmnist = input_data.read_data_sets('data', one_hot=True)\n\nmnistGraph = tf.Graph()\nwith mnistGraph.as_default():\n    with tf.name_scope('input'):\n        x = tf.placeholder(\"float\", shape=[None, 784])\n        y_ = tf.placeholder(\"float\", shape=[None, 10])\n        W = tf.Variable(tf.zeros([784,10]))\n        b = tf.Variable(tf.zeros([10]))\n\n    with tf.name_scope('hidden1'):\n        W_conv1 = weight_variable([5, 5, 1, 32])\n        b_conv1 = bias_variable([32])\n        x_image = tf.reshape(x, [-1,28,28,1])\n        h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n        h_pool1 = max_pool_2x2(h_conv1)\n        tf.summary.histogram('W_conv1', W_conv1)\n        tf.summary.histogram('b_conv1', b_conv1)\n\n    with tf.name_scope('hidden2'):\n        W_conv2 = weight_variable([5, 5, 32, 64])\n        b_conv2 = bias_variable([64])\n        h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n        h_pool2 = max_pool_2x2(h_conv2)\n        tf.summary.histogram('W_conv2', W_conv2)\n        tf.summary.histogram('b_conv2', b_conv2)\n\n    with tf.name_scope('fc1'):\n        W_fc1 = weight_variable([7 * 7 * 64, 1024])\n        b_fc1 = bias_variable([1024])\n        h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])\n        h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n        keep_prob = tf.placeholder(\"float\")\n        h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n        tf.summary.histogram('W_fc1', W_fc1)\n        tf.summary.histogram('b_fc1', b_fc1)\n\n    with tf.name_scope('fc2'):\n        W_fc2 = weight_variable([1024, 10])\n        b_fc2 = bias_variable([10])\n        y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)\n        tf.summary.histogram('W_fc2', W_fc2)\n        tf.summary.histogram('b_fc2', b_fc2)\n\n    with tf.name_scope('train'):\n        cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv))\n        train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)\n        correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1))\n        accuracy = tf.reduce_mean(tf.cast(correct_prediction, \"float\"))\n        tf.summary.scalar('loss', cross_entropy)\n        tf.summary.scalar('accuracy', accuracy)      \n\nwith tf.Session(graph=mnistGraph) as sess:\n    sess.run(tf.initialize_all_variables())\n    merged_summary_op = tf.summary.merge_all() \n    summary_writer = tf.summary.FileWriter('./logs', sess.graph) \n    for i in range(3000):\n      batch = mnist.train.next_batch(50)\n      if i%100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x:batch[0], y_: batch[1], keep_prob: 1.0})\n        print (\"step %d, training accuracy %g\" % (i, train_accuracy))\n        summary_str = sess.run(merged_summary_op, feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n        summary_writer.add_summary(summary_str, i) \n      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n\n    accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\n    good = 0\n    total = 0\n    for i in range(10):\n        testSet = mnist.test.next_batch(50)\n        good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n        total += testSet[0].shape[0]\n    print (\"test accuracy %g\"%(good/total))\n```\n\n运行后的TensorBoard界面：\n\n![运行后的TensorBoard界面](http://chuantu.biz/t6/270/1522570657x1822611335.png)","slug":"使用TensorBoard可视化工具","published":1,"updated":"2018-10-10T08:41:36.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wj002hfmag3hlsffxw","content":"<p>图表可视化在理解和调试时显得非常有帮助。</p><a id=\"more\"></a><h1 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h1><pre class=\" language-shell\"><code class=\"language-shell\">pip3 install --upgrade tensorboard\n</code></pre><h1 id=\"名称域（Name-scoping）和节点（Node）\"><a href=\"#名称域（Name-scoping）和节点（Node）\" class=\"headerlink\" title=\"名称域（Name scoping）和节点（Node）\"></a>名称域（Name scoping）和节点（Node）</h1><p>典型的TensorFlow有数以千计的节点，为了简单起见，我们可以为变量名（节点）划分范围。</p><p>这个范围称为名称域，即<code>tf.name_scope(&#39;xxx&#39;)</code>，其中xxx是这个名称域的名字。</p><p>在定义好名称域后，TensorBoard的显示界面里这个名称域内的变量并不会显示，而是只显示一个xxx节点，这个点是可展开的，展开后才会显示这个名称域内的节点。</p><p>TensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头表示，控制依赖用虚线表示。</p><p>具体的符号表：</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/namespace_node.png\" alt=\"名称域\"></td><td><em>High-level</em>节点代表一个名称域，双击则展开一个高层节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/horizontal_stack.png\" alt=\"断线节点序列\"></td><td>彼此之间不连接的有限个节点序列。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/vertical_stack.png\" alt=\"相连节点序列\"></td><td>彼此之间相连的有限个节点序列。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/op_node.png\" alt=\"操作节点\"></td><td>一个单独的操作节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/constant.png\" alt=\"常量节点\"></td><td>一个常量结点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/summary.png\" alt=\"摘要节点\"></td><td>一个摘要节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/dataflow_edge.png\" alt=\"数据流边\"></td><td>显示各操作间的数据流边。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/control_edge.png\" alt=\"控制依赖边\"></td><td>显示各操作间的控制依赖边。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/reference_edge.png\" alt=\"引用边\"></td><td>引用边，表示出度操作节点可以使入度tensor发生变化。</td></tr></tbody></table><h1 id=\"Scalar\"><a href=\"#Scalar\" class=\"headerlink\" title=\"Scalar\"></a>Scalar</h1><p>使用summary scalar（标量统计）:</p><pre class=\" language-python\"><code class=\"language-python\">xentropy <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\" spellcheck=\"true\"># xentropy的定义</span>\ntf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>scalar<span class=\"token punctuation\">(</span><span class=\"token string\">'xentropy_mean'</span><span class=\"token punctuation\">,</span> xentropy<span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\"># xentropy_mean为定义的xentropy的标签名</span>\n</code></pre><p><img src=\"http://www.tensorfly.cn/tfdoc/images/mnist_tensorboard.png\" alt=\"MNIST TensorBoard\"></p><h1 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h1><p>使用summary histogram统计某个Tensor的取值分布:</p><pre class=\" language-python\"><code class=\"language-python\"> <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'layer1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n          <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'biases'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n              biases <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\" spellcheck=\"true\"># 具体声明这里不再给出</span>\n              tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'layer1'</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/biases'</span><span class=\"token punctuation\">,</span> biases<span class=\"token punctuation\">)</span>\n\n          <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'weights'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n              weights<span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n              tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'layer1'</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/weights'</span><span class=\"token punctuation\">,</span> weights<span class=\"token punctuation\">)</span>\n\n          <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'outputs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n              outputs<span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n              tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'layer1'</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/weights'</span><span class=\"token punctuation\">,</span> outputs<span class=\"token punctuation\">)</span>\n</code></pre><p><a href=\"https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><img src=\"https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png\" alt=\"Tensorboard 可视化好帮手 2\"></a></p><h1 id=\"合并Summary\"><a href=\"#合并Summary\" class=\"headerlink\" title=\"合并Summary\"></a>合并Summary</h1><pre class=\" language-python\"><code class=\"language-python\">\n<span class=\"token comment\" spellcheck=\"true\"># 将各个summary操作合并为一个操作merged_summary_op</span>\nmerged_summary_op <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>merge_all<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 数据写入器，'/logs'为训练日志的存储路径</span>\nsummary_writer <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>FileWriter<span class=\"token punctuation\">(</span><span class=\"token string\">'./logs'</span><span class=\"token punctuation\">,</span> sess<span class=\"token punctuation\">.</span>graph<span class=\"token punctuation\">)</span> \n\ntotal_step <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">while</span> training<span class=\"token punctuation\">:</span>\n  total_step <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n  session<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>training_op<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> total_step <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    summary_str <span class=\"token operator\">=</span> sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>merged_summary_op<span class=\"token punctuation\">,</span> feed_dict<span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 注意这里必须加feed_dict否则会报错</span>\n    summary_writer<span class=\"token punctuation\">.</span>add_summary<span class=\"token punctuation\">(</span>summary_str<span class=\"token punctuation\">,</span> total_step<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 使用summary_writer将数据写入磁盘</span>\n</code></pre><h1 id=\"生成TensorBoard界面\"><a href=\"#生成TensorBoard界面\" class=\"headerlink\" title=\"生成TensorBoard界面\"></a>生成TensorBoard界面</h1><p>运行添加了各种summary的操作的代码后，打开cmd，进入代码所在文件夹，输入：</p><pre class=\" language-shell\"><code class=\"language-shell\">tensorboard --logdir=logs\n</code></pre><p>按照运行后的提示：</p><pre class=\" language-shell\"><code class=\"language-shell\">TensorBoard 1.7.0 at http://MengjieZhang:6006 (Press CTRL+C to quit)\n</code></pre><p>打开浏览器，输入地址 <code>http://MengjieZhang:6006</code> 即可以看到TensorBoard界面。</p><h1 id=\"具体代码：\"><a href=\"#具体代码：\" class=\"headerlink\" title=\"具体代码：\"></a>具体代码：</h1><p><a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/mnist/input_data.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">input_data下载链接</a></p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> input_data\n<span class=\"token keyword\">import</span> tensorflow <span class=\"token keyword\">as</span> tf\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">weight_variable</span><span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  initial <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>truncated_normal<span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">,</span> stddev<span class=\"token operator\">=</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> tf<span class=\"token punctuation\">.</span>Variable<span class=\"token punctuation\">(</span>initial<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bias_variable</span><span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  initial <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>constant<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> shape<span class=\"token operator\">=</span>shape<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> tf<span class=\"token punctuation\">.</span>Variable<span class=\"token punctuation\">(</span>initial<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">conv2d</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> W<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">return</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>conv2d<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> W<span class=\"token punctuation\">,</span> strides<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> padding<span class=\"token operator\">=</span><span class=\"token string\">'SAME'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">max_pool_2x2</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">return</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>max_pool<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> ksize<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                        strides<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> padding<span class=\"token operator\">=</span><span class=\"token string\">'SAME'</span><span class=\"token punctuation\">)</span>\n\nmnist <span class=\"token operator\">=</span> input_data<span class=\"token punctuation\">.</span>read_data_sets<span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span> one_hot<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\nmnistGraph <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>Graph<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">with</span> mnistGraph<span class=\"token punctuation\">.</span>as_default<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        x <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>placeholder<span class=\"token punctuation\">(</span><span class=\"token string\">\"float\"</span><span class=\"token punctuation\">,</span> shape<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>None<span class=\"token punctuation\">,</span> <span class=\"token number\">784</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        y_ <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>placeholder<span class=\"token punctuation\">(</span><span class=\"token string\">\"float\"</span><span class=\"token punctuation\">,</span> shape<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>None<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        W <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>Variable<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">784</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        b <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>Variable<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'hidden1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        W_conv1 <span class=\"token operator\">=</span> weight_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        b_conv1 <span class=\"token operator\">=</span> bias_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        x_image <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        h_conv1 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>conv2d<span class=\"token punctuation\">(</span>x_image<span class=\"token punctuation\">,</span> W_conv1<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> b_conv1<span class=\"token punctuation\">)</span>\n        h_pool1 <span class=\"token operator\">=</span> max_pool_2x2<span class=\"token punctuation\">(</span>h_conv1<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'W_conv1'</span><span class=\"token punctuation\">,</span> W_conv1<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'b_conv1'</span><span class=\"token punctuation\">,</span> b_conv1<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'hidden2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        W_conv2 <span class=\"token operator\">=</span> weight_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        b_conv2 <span class=\"token operator\">=</span> bias_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">64</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        h_conv2 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>conv2d<span class=\"token punctuation\">(</span>h_pool1<span class=\"token punctuation\">,</span> W_conv2<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> b_conv2<span class=\"token punctuation\">)</span>\n        h_pool2 <span class=\"token operator\">=</span> max_pool_2x2<span class=\"token punctuation\">(</span>h_conv2<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'W_conv2'</span><span class=\"token punctuation\">,</span> W_conv2<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'b_conv2'</span><span class=\"token punctuation\">,</span> b_conv2<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'fc1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        W_fc1 <span class=\"token operator\">=</span> weight_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">7</span> <span class=\"token operator\">*</span> <span class=\"token number\">7</span> <span class=\"token operator\">*</span> <span class=\"token number\">64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        b_fc1 <span class=\"token operator\">=</span> bias_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        h_pool2_flat <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>h_pool2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token operator\">*</span><span class=\"token number\">7</span><span class=\"token operator\">*</span><span class=\"token number\">64</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        h_fc1 <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>matmul<span class=\"token punctuation\">(</span>h_pool2_flat<span class=\"token punctuation\">,</span> W_fc1<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> b_fc1<span class=\"token punctuation\">)</span>\n        keep_prob <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>placeholder<span class=\"token punctuation\">(</span><span class=\"token string\">\"float\"</span><span class=\"token punctuation\">)</span>\n        h_fc1_drop <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>dropout<span class=\"token punctuation\">(</span>h_fc1<span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'W_fc1'</span><span class=\"token punctuation\">,</span> W_fc1<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'b_fc1'</span><span class=\"token punctuation\">,</span> b_fc1<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'fc2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        W_fc2 <span class=\"token operator\">=</span> weight_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        b_fc2 <span class=\"token operator\">=</span> bias_variable<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        y_conv<span class=\"token operator\">=</span>tf<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>softmax<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>matmul<span class=\"token punctuation\">(</span>h_fc1_drop<span class=\"token punctuation\">,</span> W_fc2<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> b_fc2<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'W_fc2'</span><span class=\"token punctuation\">,</span> W_fc2<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>histogram<span class=\"token punctuation\">(</span><span class=\"token string\">'b_fc2'</span><span class=\"token punctuation\">,</span> b_fc2<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>name_scope<span class=\"token punctuation\">(</span><span class=\"token string\">'train'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        cross_entropy <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>tf<span class=\"token punctuation\">.</span>reduce_sum<span class=\"token punctuation\">(</span>y_<span class=\"token operator\">*</span>tf<span class=\"token punctuation\">.</span>log<span class=\"token punctuation\">(</span>y_conv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        train_step <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>train<span class=\"token punctuation\">.</span>AdamOptimizer<span class=\"token punctuation\">(</span><span class=\"token number\">1e</span><span class=\"token operator\">-</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>minimize<span class=\"token punctuation\">(</span>cross_entropy<span class=\"token punctuation\">)</span>\n        correct_prediction <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>equal<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>argmax<span class=\"token punctuation\">(</span>y_conv<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tf<span class=\"token punctuation\">.</span>argmax<span class=\"token punctuation\">(</span>y_<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        accuracy <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>reduce_mean<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>cast<span class=\"token punctuation\">(</span>correct_prediction<span class=\"token punctuation\">,</span> <span class=\"token string\">\"float\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>scalar<span class=\"token punctuation\">(</span><span class=\"token string\">'loss'</span><span class=\"token punctuation\">,</span> cross_entropy<span class=\"token punctuation\">)</span>\n        tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>scalar<span class=\"token punctuation\">(</span><span class=\"token string\">'accuracy'</span><span class=\"token punctuation\">,</span> accuracy<span class=\"token punctuation\">)</span>      \n\n<span class=\"token keyword\">with</span> tf<span class=\"token punctuation\">.</span>Session<span class=\"token punctuation\">(</span>graph<span class=\"token operator\">=</span>mnistGraph<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> sess<span class=\"token punctuation\">:</span>\n    sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>initialize_all_variables<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    merged_summary_op <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>merge_all<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n    summary_writer <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>summary<span class=\"token punctuation\">.</span>FileWriter<span class=\"token punctuation\">(</span><span class=\"token string\">'./logs'</span><span class=\"token punctuation\">,</span> sess<span class=\"token punctuation\">.</span>graph<span class=\"token punctuation\">)</span> \n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n      batch <span class=\"token operator\">=</span> mnist<span class=\"token punctuation\">.</span>train<span class=\"token punctuation\">.</span>next_batch<span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> i<span class=\"token operator\">%</span><span class=\"token number\">100</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        train_accuracy <span class=\"token operator\">=</span> accuracy<span class=\"token punctuation\">.</span>eval<span class=\"token punctuation\">(</span>feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n            x<span class=\"token punctuation\">:</span>batch<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y_<span class=\"token punctuation\">:</span> batch<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">:</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"step %d, training accuracy %g\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> train_accuracy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        summary_str <span class=\"token operator\">=</span> sess<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>merged_summary_op<span class=\"token punctuation\">,</span> feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">:</span> batch<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y_<span class=\"token punctuation\">:</span> batch<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">:</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        summary_writer<span class=\"token punctuation\">.</span>add_summary<span class=\"token punctuation\">(</span>summary_str<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span> \n      train_step<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">:</span> batch<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y_<span class=\"token punctuation\">:</span> batch<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">:</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    accuracy_sum <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">.</span>reduce_sum<span class=\"token punctuation\">(</span>tf<span class=\"token punctuation\">.</span>cast<span class=\"token punctuation\">(</span>correct_prediction<span class=\"token punctuation\">,</span> tf<span class=\"token punctuation\">.</span>float32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    good <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    total <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        testSet <span class=\"token operator\">=</span> mnist<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">.</span>next_batch<span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n        good <span class=\"token operator\">+=</span> accuracy_sum<span class=\"token punctuation\">.</span>eval<span class=\"token punctuation\">(</span>feed_dict<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y_<span class=\"token punctuation\">:</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_prob<span class=\"token punctuation\">:</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        total <span class=\"token operator\">+=</span> testSet<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"test accuracy %g\"</span><span class=\"token operator\">%</span><span class=\"token punctuation\">(</span>good<span class=\"token operator\">/</span>total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre><p>运行后的TensorBoard界面：</p><p><img src=\"http://chuantu.biz/t6/270/1522570657x1822611335.png\" alt=\"运行后的TensorBoard界面\"></p>","site":{"data":{}},"excerpt":"<p>图表可视化在理解和调试时显得非常有帮助。</p>","more":"<h1 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h1><pre><code class=\"shell\">pip3 install --upgrade tensorboard\n</code></pre><h1 id=\"名称域（Name-scoping）和节点（Node）\"><a href=\"#名称域（Name-scoping）和节点（Node）\" class=\"headerlink\" title=\"名称域（Name scoping）和节点（Node）\"></a>名称域（Name scoping）和节点（Node）</h1><p>典型的TensorFlow有数以千计的节点，为了简单起见，我们可以为变量名（节点）划分范围。</p><p>这个范围称为名称域，即<code>tf.name_scope(&#39;xxx&#39;)</code>，其中xxx是这个名称域的名字。</p><p>在定义好名称域后，TensorBoard的显示界面里这个名称域内的变量并不会显示，而是只显示一个xxx节点，这个点是可展开的，展开后才会显示这个名称域内的节点。</p><p>TensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头表示，控制依赖用虚线表示。</p><p>具体的符号表：</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/namespace_node.png\" alt=\"名称域\"></td><td><em>High-level</em>节点代表一个名称域，双击则展开一个高层节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/horizontal_stack.png\" alt=\"断线节点序列\"></td><td>彼此之间不连接的有限个节点序列。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/vertical_stack.png\" alt=\"相连节点序列\"></td><td>彼此之间相连的有限个节点序列。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/op_node.png\" alt=\"操作节点\"></td><td>一个单独的操作节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/constant.png\" alt=\"常量节点\"></td><td>一个常量结点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/summary.png\" alt=\"摘要节点\"></td><td>一个摘要节点。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/dataflow_edge.png\" alt=\"数据流边\"></td><td>显示各操作间的数据流边。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/control_edge.png\" alt=\"控制依赖边\"></td><td>显示各操作间的控制依赖边。</td></tr><tr><td><img src=\"http://www.tensorfly.cn/tfdoc/images/reference_edge.png\" alt=\"引用边\"></td><td>引用边，表示出度操作节点可以使入度tensor发生变化。</td></tr></tbody></table><h1 id=\"Scalar\"><a href=\"#Scalar\" class=\"headerlink\" title=\"Scalar\"></a>Scalar</h1><p>使用summary scalar（标量统计）:</p><pre><code class=\"python\">xentropy = ... # xentropy的定义\ntf.summary.scalar(&#39;xentropy_mean&#39;, xentropy)    # xentropy_mean为定义的xentropy的标签名\n</code></pre><p><img src=\"http://www.tensorfly.cn/tfdoc/images/mnist_tensorboard.png\" alt=\"MNIST TensorBoard\"></p><h1 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h1><p>使用summary histogram统计某个Tensor的取值分布:</p><pre><code class=\"python\"> with tf.name_scope(&#39;layer1&#39;):\n          with tf.name_scope(&#39;biases&#39;):\n              biases = ... # 具体声明这里不再给出\n              tf.summary.histogram(&#39;layer1&#39; + &#39;/biases&#39;, biases)\n\n          with tf.name_scope(&#39;weights&#39;):\n              weights= ...\n              tf.summary.histogram(&#39;layer1&#39; + &#39;/weights&#39;, weights)\n\n          with tf.name_scope(&#39;outputs&#39;):\n              outputs= ...\n              tf.summary.histogram(&#39;layer1&#39; + &#39;/weights&#39;, outputs)\n</code></pre><p><a href=\"https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><img src=\"https://morvanzhou.github.io/static/results/tensorflow/4_2_2.png\" alt=\"Tensorboard 可视化好帮手 2\"></a></p><h1 id=\"合并Summary\"><a href=\"#合并Summary\" class=\"headerlink\" title=\"合并Summary\"></a>合并Summary</h1><pre><code class=\"python\">\n# 将各个summary操作合并为一个操作merged_summary_op\nmerged_summary_op = tf.summary.merge_all()\n# 数据写入器，&#39;/logs&#39;为训练日志的存储路径\nsummary_writer = tf.summary.FileWriter(&#39;./logs&#39;, sess.graph) \n\ntotal_step = 0\nwhile training:\n  total_step += 1\n  session.run(training_op)\n  if total_step % 100 == 0:\n    ...\n    summary_str = sess.run(merged_summary_op, feed_dict{...}) # 注意这里必须加feed_dict否则会报错\n    summary_writer.add_summary(summary_str, total_step) # 使用summary_writer将数据写入磁盘\n</code></pre><h1 id=\"生成TensorBoard界面\"><a href=\"#生成TensorBoard界面\" class=\"headerlink\" title=\"生成TensorBoard界面\"></a>生成TensorBoard界面</h1><p>运行添加了各种summary的操作的代码后，打开cmd，进入代码所在文件夹，输入：</p><pre><code class=\"shell\">tensorboard --logdir=logs\n</code></pre><p>按照运行后的提示：</p><pre><code class=\"shell\">TensorBoard 1.7.0 at http://MengjieZhang:6006 (Press CTRL+C to quit)\n</code></pre><p>打开浏览器，输入地址 <code>http://MengjieZhang:6006</code> 即可以看到TensorBoard界面。</p><h1 id=\"具体代码：\"><a href=\"#具体代码：\" class=\"headerlink\" title=\"具体代码：\"></a>具体代码：</h1><p><a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/mnist/input_data.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">input_data下载链接</a></p><pre><code class=\"python\">import input_data\nimport tensorflow as tf\n\ndef weight_variable(shape):\n  initial = tf.truncated_normal(shape, stddev=0.1)\n  return tf.Variable(initial)\n\ndef bias_variable(shape):\n  initial = tf.constant(0.1, shape=shape)\n  return tf.Variable(initial)\n\ndef conv2d(x, W):\n  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&#39;SAME&#39;)\n\ndef max_pool_2x2(x):\n  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],\n                        strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)\n\nmnist = input_data.read_data_sets(&#39;data&#39;, one_hot=True)\n\nmnistGraph = tf.Graph()\nwith mnistGraph.as_default():\n    with tf.name_scope(&#39;input&#39;):\n        x = tf.placeholder(&quot;float&quot;, shape=[None, 784])\n        y_ = tf.placeholder(&quot;float&quot;, shape=[None, 10])\n        W = tf.Variable(tf.zeros([784,10]))\n        b = tf.Variable(tf.zeros([10]))\n\n    with tf.name_scope(&#39;hidden1&#39;):\n        W_conv1 = weight_variable([5, 5, 1, 32])\n        b_conv1 = bias_variable([32])\n        x_image = tf.reshape(x, [-1,28,28,1])\n        h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n        h_pool1 = max_pool_2x2(h_conv1)\n        tf.summary.histogram(&#39;W_conv1&#39;, W_conv1)\n        tf.summary.histogram(&#39;b_conv1&#39;, b_conv1)\n\n    with tf.name_scope(&#39;hidden2&#39;):\n        W_conv2 = weight_variable([5, 5, 32, 64])\n        b_conv2 = bias_variable([64])\n        h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n        h_pool2 = max_pool_2x2(h_conv2)\n        tf.summary.histogram(&#39;W_conv2&#39;, W_conv2)\n        tf.summary.histogram(&#39;b_conv2&#39;, b_conv2)\n\n    with tf.name_scope(&#39;fc1&#39;):\n        W_fc1 = weight_variable([7 * 7 * 64, 1024])\n        b_fc1 = bias_variable([1024])\n        h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])\n        h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n        keep_prob = tf.placeholder(&quot;float&quot;)\n        h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n        tf.summary.histogram(&#39;W_fc1&#39;, W_fc1)\n        tf.summary.histogram(&#39;b_fc1&#39;, b_fc1)\n\n    with tf.name_scope(&#39;fc2&#39;):\n        W_fc2 = weight_variable([1024, 10])\n        b_fc2 = bias_variable([10])\n        y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)\n        tf.summary.histogram(&#39;W_fc2&#39;, W_fc2)\n        tf.summary.histogram(&#39;b_fc2&#39;, b_fc2)\n\n    with tf.name_scope(&#39;train&#39;):\n        cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv))\n        train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)\n        correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1))\n        accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))\n        tf.summary.scalar(&#39;loss&#39;, cross_entropy)\n        tf.summary.scalar(&#39;accuracy&#39;, accuracy)      \n\nwith tf.Session(graph=mnistGraph) as sess:\n    sess.run(tf.initialize_all_variables())\n    merged_summary_op = tf.summary.merge_all() \n    summary_writer = tf.summary.FileWriter(&#39;./logs&#39;, sess.graph) \n    for i in range(3000):\n      batch = mnist.train.next_batch(50)\n      if i%100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x:batch[0], y_: batch[1], keep_prob: 1.0})\n        print (&quot;step %d, training accuracy %g&quot; % (i, train_accuracy))\n        summary_str = sess.run(merged_summary_op, feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n        summary_writer.add_summary(summary_str, i) \n      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n\n    accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32))\n    good = 0\n    total = 0\n    for i in range(10):\n        testSet = mnist.test.next_batch(50)\n        good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0})\n        total += testSet[0].shape[0]\n    print (&quot;test accuracy %g&quot;%(good/total))\n</code></pre><p>运行后的TensorBoard界面：</p><p><img src=\"http://chuantu.biz/t6/270/1522570657x1822611335.png\" alt=\"运行后的TensorBoard界面\"></p>"},{"title":"关于hexo markdown添加的图片在github page中无法显示的问题","date":"2018-03-30T16:21:18.000Z","_content":"\n**云端**\n\n试了很多网站的图片，发现主要是CSDN和博客园的图片无法显示。\n\n推荐用Bing或者Google搜索外网图片添加。\n\n**本地**\n\n在source目录下新建images目录，将要添加的图片存放在这个目录下，md引用时使用/images/...","source":"_posts/关于hexo-markdown添加的图片在github-page中无法显示的问题.md","raw":"---\ntitle: 关于hexo markdown添加的图片在github page中无法显示的问题\ndate: 2018-03-31 00:21:18\ncategories: \n- methods\ntags:\n- hexo\n- markdown\n---\n\n**云端**\n\n试了很多网站的图片，发现主要是CSDN和博客园的图片无法显示。\n\n推荐用Bing或者Google搜索外网图片添加。\n\n**本地**\n\n在source目录下新建images目录，将要添加的图片存放在这个目录下，md引用时使用/images/...","slug":"关于hexo-markdown添加的图片在github-page中无法显示的问题","published":1,"updated":"2018-10-10T08:48:33.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wl002kfmagl93tgmxc","content":"<p><strong>云端</strong></p><p>试了很多网站的图片，发现主要是CSDN和博客园的图片无法显示。</p><p>推荐用Bing或者Google搜索外网图片添加。</p><p><strong>本地</strong></p><p>在source目录下新建images目录，将要添加的图片存放在这个目录下，md引用时使用/images/…</p>","site":{"data":{}},"excerpt":"","more":"<p><strong>云端</strong></p><p>试了很多网站的图片，发现主要是CSDN和博客园的图片无法显示。</p><p>推荐用Bing或者Google搜索外网图片添加。</p><p><strong>本地</strong></p><p>在source目录下新建images目录，将要添加的图片存放在这个目录下，md引用时使用/images/…</p>"},{"title":"关于hexo博客自定义域名后gitment评论系统登陆出现redirect error返回主页的解决办法","toc":false,"date":"2018-04-16T14:57:50.000Z","_content":"\n>  背景：\n>\n> 原地址：`https://mikqueenge.github.io`\n>\n> 新域名：`http://blog.zmj97.top`(这里一定要注意！从阿里云买的域名使用的协议是http！)\n\n<!-- more -->\n\n今天下午兴致勃勃地买了个域名绑定到这个博客上后，发现昨天好不容易跳了各种坑才实现的**评论功能无法登陆**了！\n\n每一次点击评论里的登陆都会回到index页面，地址栏显示地地址为`https://blog.zmj97.top/?error=redirect_uri_mismatch&error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&error_uri=https%3A%2F%2Fdeveloper.github.com%2Fv3%2Foauth%2F%23redirect-uri-mismatch`\n\n一看这个提示，`redirect error` 让人不禁想到OAuth应用注册时填写的`Authorization callback URL`回调URL，\n\n各种百度谷歌了一下，如果自定义了域名的话<u>回调URL要填写自定义域名</u>，而且**一个字符都不能出错**！否则就会出现上述无法登陆的情况...\n\n试了一晚上，回调URL可能出现的字符错误有以下几个：\n\n- 多加空格\n- 协议错误，区分http和https\n- 多加/\n\n最后终于成功时我的OAuth应用信息的究极形态如下：\n\n![](/images/Capture5.PNG)\n\n心好累...","source":"_posts/关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法.md","raw":"---\ntitle: 关于hexo博客自定义域名后gitment评论系统登陆出现redirect error返回主页的解决办法\ntoc: false\ndate: 2018-04-16 22:57:50\ncategories:\n- methods\ntags:\n- hexo\n- gitment\n- OAuth\n- 阿里云\n---\n\n>  背景：\n>\n> 原地址：`https://mikqueenge.github.io`\n>\n> 新域名：`http://blog.zmj97.top`(这里一定要注意！从阿里云买的域名使用的协议是http！)\n\n<!-- more -->\n\n今天下午兴致勃勃地买了个域名绑定到这个博客上后，发现昨天好不容易跳了各种坑才实现的**评论功能无法登陆**了！\n\n每一次点击评论里的登陆都会回到index页面，地址栏显示地地址为`https://blog.zmj97.top/?error=redirect_uri_mismatch&error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&error_uri=https%3A%2F%2Fdeveloper.github.com%2Fv3%2Foauth%2F%23redirect-uri-mismatch`\n\n一看这个提示，`redirect error` 让人不禁想到OAuth应用注册时填写的`Authorization callback URL`回调URL，\n\n各种百度谷歌了一下，如果自定义了域名的话<u>回调URL要填写自定义域名</u>，而且**一个字符都不能出错**！否则就会出现上述无法登陆的情况...\n\n试了一晚上，回调URL可能出现的字符错误有以下几个：\n\n- 多加空格\n- 协议错误，区分http和https\n- 多加/\n\n最后终于成功时我的OAuth应用信息的究极形态如下：\n\n![](/images/Capture5.PNG)\n\n心好累...","slug":"关于hexo博客自定义域名后gitment评论系统登陆出现redirect-error返回主页的解决办法","published":1,"updated":"2018-10-10T08:41:52.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wn002nfmagxiopfes5","content":"<blockquote><p>背景：</p><p>原地址：<code>https://mikqueenge.github.io</code></p><p>新域名：<code>http://blog.zmj97.top</code>(这里一定要注意！从阿里云买的域名使用的协议是http！)</p></blockquote><a id=\"more\"></a><p>今天下午兴致勃勃地买了个域名绑定到这个博客上后，发现昨天好不容易跳了各种坑才实现的<strong>评论功能无法登陆</strong>了！</p><p>每一次点击评论里的登陆都会回到index页面，地址栏显示地地址为<code>https://blog.zmj97.top/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fv3%2Foauth%2F%23redirect-uri-mismatch</code></p><p>一看这个提示，<code>redirect error</code> 让人不禁想到OAuth应用注册时填写的<code>Authorization callback URL</code>回调URL，</p><p>各种百度谷歌了一下，如果自定义了域名的话<u>回调URL要填写自定义域名</u>，而且<strong>一个字符都不能出错</strong>！否则就会出现上述无法登陆的情况…</p><p>试了一晚上，回调URL可能出现的字符错误有以下几个：</p><ul><li>多加空格</li><li>协议错误，区分http和https</li><li>多加/</li></ul><p>最后终于成功时我的OAuth应用信息的究极形态如下：</p><p><img src=\"/images/Capture5.PNG\" alt=\"\"></p><p>心好累…</p>","site":{"data":{}},"excerpt":"<blockquote><p>背景：</p><p>原地址：<code>https://mikqueenge.github.io</code></p><p>新域名：<code>http://blog.zmj97.top</code>(这里一定要注意！从阿里云买的域名使用的协议是http！)</p></blockquote>","more":"<p>今天下午兴致勃勃地买了个域名绑定到这个博客上后，发现昨天好不容易跳了各种坑才实现的<strong>评论功能无法登陆</strong>了！</p><p>每一次点击评论里的登陆都会回到index页面，地址栏显示地地址为<code>https://blog.zmj97.top/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fv3%2Foauth%2F%23redirect-uri-mismatch</code></p><p>一看这个提示，<code>redirect error</code> 让人不禁想到OAuth应用注册时填写的<code>Authorization callback URL</code>回调URL，</p><p>各种百度谷歌了一下，如果自定义了域名的话<u>回调URL要填写自定义域名</u>，而且<strong>一个字符都不能出错</strong>！否则就会出现上述无法登陆的情况…</p><p>试了一晚上，回调URL可能出现的字符错误有以下几个：</p><ul><li>多加空格</li><li>协议错误，区分http和https</li><li>多加/</li></ul><p>最后终于成功时我的OAuth应用信息的究极形态如下：</p><p><img src=\"/images/Capture5.PNG\" alt=\"\"></p><p>心好累…</p>"},{"title":"前端向后台发送请求有哪些方式","toc":false,"date":"2018-09-25T03:46:21.000Z","_content":"\n共七种：\n\n1. link标签的href属性\n2. script标签的src属性\n3. img标签的src属性\n4. iframe标签的src属性\n5. a标签的href属性\n6. 表单提交发送请求\n7. ajax发送请求","source":"_posts/前端向后台发送请求有哪些方式.md","raw":"---\ntitle: 前端向后台发送请求有哪些方式\ntoc: false\ndate: 2018-09-25 11:46:21\ncategories:\n- Web\ntags:\n- HTML\n- ajax\n- form\n---\n\n共七种：\n\n1. link标签的href属性\n2. script标签的src属性\n3. img标签的src属性\n4. iframe标签的src属性\n5. a标签的href属性\n6. 表单提交发送请求\n7. ajax发送请求","slug":"前端向后台发送请求有哪些方式","published":1,"updated":"2018-09-25T04:32:05.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wp002rfmag9t4np1jo","content":"<p>共七种：</p><ol><li>link标签的href属性</li><li>script标签的src属性</li><li>img标签的src属性</li><li>iframe标签的src属性</li><li>a标签的href属性</li><li>表单提交发送请求</li><li>ajax发送请求</li></ol>","site":{"data":{}},"excerpt":"","more":"<p>共七种：</p><ol><li>link标签的href属性</li><li>script标签的src属性</li><li>img标签的src属性</li><li>iframe标签的src属性</li><li>a标签的href属性</li><li>表单提交发送请求</li><li>ajax发送请求</li></ol>"},{"title":"同步与异步","toc":false,"date":"2018-10-04T06:09:46.000Z","_content":"\n转自：https://www.cnblogs.com/anny0404/p/5691379.html\n\n**同步**和**异步**通常用来形容一次方法调用。\n\n<!-- more -->\n\n- **同步方法**调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。\n- **异步方法**调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。\n- ![异步](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539167567509&di=8edfd394105296d7270fe8952ebd9aed&imgtype=0&src=http%3A%2F%2Fstatic.open-open.com%2Flib%2FuploadImg%2F20160118%2F20160118091954_419.png)\n\n**栗子**：\n\n\t打个比方，比如我们去购物，如果你去商场实体店买一台空调，当你到了商场看中了一款空调，你就想售货员下单。售货员去仓库帮你调配物品。这天你热的实在不行了。就催着商家赶紧给你配送，于是你就等在商场里，候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。**这就是同步调用。**\n\n　　不过，如果我们赶时髦，就坐再家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。**这就是异步调用。**","source":"_posts/同步与异步.md","raw":"---\ntitle: 同步与异步\ntoc: false\ndate: 2018-10-04 14:09:46\ncategories:\n- Web\ntags:\n- 同步\n- 异步\n---\n\n转自：https://www.cnblogs.com/anny0404/p/5691379.html\n\n**同步**和**异步**通常用来形容一次方法调用。\n\n<!-- more -->\n\n- **同步方法**调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。\n- **异步方法**调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。\n- ![异步](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539167567509&di=8edfd394105296d7270fe8952ebd9aed&imgtype=0&src=http%3A%2F%2Fstatic.open-open.com%2Flib%2FuploadImg%2F20160118%2F20160118091954_419.png)\n\n**栗子**：\n\n\t打个比方，比如我们去购物，如果你去商场实体店买一台空调，当你到了商场看中了一款空调，你就想售货员下单。售货员去仓库帮你调配物品。这天你热的实在不行了。就催着商家赶紧给你配送，于是你就等在商场里，候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。**这就是同步调用。**\n\n　　不过，如果我们赶时髦，就坐再家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。**这就是异步调用。**","slug":"同步与异步","published":1,"updated":"2018-10-10T08:42:14.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wr002ufmag3jnhawh0","content":"<p>转自：<a href=\"https://www.cnblogs.com/anny0404/p/5691379.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/anny0404/p/5691379.html</a></p><p><strong>同步</strong>和<strong>异步</strong>通常用来形容一次方法调用。</p><a id=\"more\"></a><ul><li><strong>同步方法</strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li><strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</li><li><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1539167567509&amp;di=8edfd394105296d7270fe8952ebd9aed&amp;imgtype=0&amp;src=http%3A%2F%2Fstatic.open-open.com%2Flib%2FuploadImg%2F20160118%2F20160118091954_419.png\" alt=\"异步\"></li></ul><p><strong>栗子</strong>：</p><pre><code>打个比方，比如我们去购物，如果你去商场实体店买一台空调，当你到了商场看中了一款空调，你就想售货员下单。售货员去仓库帮你调配物品。这天你热的实在不行了。就催着商家赶紧给你配送，于是你就等在商场里，候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。**这就是同步调用。**\n</code></pre><p>　　不过，如果我们赶时髦，就坐再家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。<strong>这就是异步调用。</strong></p>","site":{"data":{}},"excerpt":"<p>转自：<a href=\"https://www.cnblogs.com/anny0404/p/5691379.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/anny0404/p/5691379.html</a></p><p><strong>同步</strong>和<strong>异步</strong>通常用来形容一次方法调用。</p>","more":"<ul><li><strong>同步方法</strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li><li><strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</li><li><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1539167567509&amp;di=8edfd394105296d7270fe8952ebd9aed&amp;imgtype=0&amp;src=http%3A%2F%2Fstatic.open-open.com%2Flib%2FuploadImg%2F20160118%2F20160118091954_419.png\" alt=\"异步\"></li></ul><p><strong>栗子</strong>：</p><pre><code>打个比方，比如我们去购物，如果你去商场实体店买一台空调，当你到了商场看中了一款空调，你就想售货员下单。售货员去仓库帮你调配物品。这天你热的实在不行了。就催着商家赶紧给你配送，于是你就等在商场里，候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。**这就是同步调用。**\n</code></pre><p>　　不过，如果我们赶时髦，就坐再家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。<strong>这就是异步调用。</strong></p>"},{"title":"在ubuntu中安装Markdown神器Typora","toc":false,"date":"2018-09-01T09:48:15.000Z","_content":"\n\n\n在终端中执行以下命令即可：\n\n```powershell\n# optional, but recommended\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n\n# add Typora's repository\n\nsudo add-apt-repository 'deb http://typora.io linux/'\n\nsudo apt-get update\n\n# install typora\n\nsudo apt-get install typora\n```\n\n\n\n[参考链接](https://blog.csdn.net/caoyangyang123/article/details/79484697)","source":"_posts/在ubuntu中安装Markdown神器Typora.md","raw":"---\ntitle: 在ubuntu中安装Markdown神器Typora\ntoc: false\ndate: 2018-09-01 17:48:15\ncategories:\n- methods\ntags:\n- ubuntu\n- Typora\n- Markdown\n---\n\n\n\n在终端中执行以下命令即可：\n\n```powershell\n# optional, but recommended\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n\n# add Typora's repository\n\nsudo add-apt-repository 'deb http://typora.io linux/'\n\nsudo apt-get update\n\n# install typora\n\nsudo apt-get install typora\n```\n\n\n\n[参考链接](https://blog.csdn.net/caoyangyang123/article/details/79484697)","slug":"在ubuntu中安装Markdown神器Typora","published":1,"updated":"2018-09-11T05:46:12.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wu002xfmag3xmdw03w","content":"<p>在终端中执行以下命令即可：</p><pre class=\" language-powershell\"><code class=\"language-powershell\"><span class=\"token comment\" spellcheck=\"true\"># optional, but recommended</span>\n\nsudo apt<span class=\"token operator\">-</span>key adv <span class=\"token operator\">--</span>keyserver keyserver<span class=\"token punctuation\">.</span>ubuntu<span class=\"token punctuation\">.</span>com <span class=\"token operator\">--</span>recv<span class=\"token operator\">-</span>keys BA300B7755AFCFAE\n\n<span class=\"token comment\" spellcheck=\"true\"># add Typora's repository</span>\n\nsudo add<span class=\"token operator\">-</span>apt<span class=\"token operator\">-</span>repository <span class=\"token string\">'deb http://typora.io linux/'</span>\n\nsudo apt<span class=\"token operator\">-</span>get update\n\n<span class=\"token comment\" spellcheck=\"true\"># install typora</span>\n\nsudo apt<span class=\"token operator\">-</span>get install typora\n</code></pre><p><a href=\"https://blog.csdn.net/caoyangyang123/article/details/79484697\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>","site":{"data":{}},"excerpt":"","more":"<p>在终端中执行以下命令即可：</p><pre><code class=\"powershell\"># optional, but recommended\n\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n\n# add Typora&#39;s repository\n\nsudo add-apt-repository &#39;deb http://typora.io linux/&#39;\n\nsudo apt-get update\n\n# install typora\n\nsudo apt-get install typora\n</code></pre><p><a href=\"https://blog.csdn.net/caoyangyang123/article/details/79484697\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p>"},{"title":"堆和栈的区别","date":"2018-03-30T03:48:51.000Z","_content":"\n参考：\n\n[链接1](https://blog.csdn.net/u013321328/article/details/44172689) [链接2](https://blog.csdn.net/shanshanhi/article/details/50904706)\n\n<!-- more -->\n\n# 一个由C/C++编译的程序占用的内存分为以下几个部分：\n## 1、栈区（stack）\n由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n## 2、堆区（heap）\n一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式倒是类似于数据结构中的链表。\n## 3、全局区/静态区（static）\n全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。\n## 4、文字常量区\n存放常量字符串。程序结束后由系统释放。\n## 5、程序代码区\n存放函数体的二进制代码。\n# 堆和栈的区别：\n## 1、申请方式\n### 栈区：\n由编译器自动分配释放，存放函数的参数值，局部变量值等。\n### 堆区：\n一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。\n## 2、操作方式\n### 栈区：\n操作方式类似于数据结构中的栈。\n### 堆区：\n不同于数据结构中的堆，分配方式类似于链表。\n## 3、申请后系统的响应 \n### 栈区：\n只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（overflow）。\n### 堆区：\n操作系统有一个记录空闲内存地址的链表，\n当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，\n对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，从而代码中的delete语句才能正确的释放本内存空间，\n由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 \n## 4、申请大小的限制\n### 栈区：\n在Windows下,栈是是一块确定的连续内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\n### 堆区：\n堆是向高地址扩展的数据结构，由于系统是用链表来存储的空闲内存地址的，它是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。\n## 5、申请效率的比较\n### 栈区：\n系统自动分配，速度较快。但程序员是无法控制的。\n### 堆区：\n由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. \n注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不在堆也不在栈，而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。\n## 6、堆和栈中的存储内容\n### 栈区：\n在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，接着是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。\n### 堆区：\n一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。","source":"_posts/堆和栈的区别.md","raw":"---\ntitle: 堆和栈的区别\ndate: 2018-03-30 11:48:51\ntags: \n- 内存\ncategories:\n- C/C++\n---\n\n参考：\n\n[链接1](https://blog.csdn.net/u013321328/article/details/44172689) [链接2](https://blog.csdn.net/shanshanhi/article/details/50904706)\n\n<!-- more -->\n\n# 一个由C/C++编译的程序占用的内存分为以下几个部分：\n## 1、栈区（stack）\n由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n## 2、堆区（heap）\n一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式倒是类似于数据结构中的链表。\n## 3、全局区/静态区（static）\n全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。\n## 4、文字常量区\n存放常量字符串。程序结束后由系统释放。\n## 5、程序代码区\n存放函数体的二进制代码。\n# 堆和栈的区别：\n## 1、申请方式\n### 栈区：\n由编译器自动分配释放，存放函数的参数值，局部变量值等。\n### 堆区：\n一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。\n## 2、操作方式\n### 栈区：\n操作方式类似于数据结构中的栈。\n### 堆区：\n不同于数据结构中的堆，分配方式类似于链表。\n## 3、申请后系统的响应 \n### 栈区：\n只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（overflow）。\n### 堆区：\n操作系统有一个记录空闲内存地址的链表，\n当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，\n对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，从而代码中的delete语句才能正确的释放本内存空间，\n由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 \n## 4、申请大小的限制\n### 栈区：\n在Windows下,栈是是一块确定的连续内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\n### 堆区：\n堆是向高地址扩展的数据结构，由于系统是用链表来存储的空闲内存地址的，它是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。\n## 5、申请效率的比较\n### 栈区：\n系统自动分配，速度较快。但程序员是无法控制的。\n### 堆区：\n由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. \n注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不在堆也不在栈，而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。\n## 6、堆和栈中的存储内容\n### 栈区：\n在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，接着是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。\n### 堆区：\n一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。","slug":"堆和栈的区别","published":1,"updated":"2018-10-10T08:42:35.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1ww002zfmagxnn0g680","content":"<p>参考：</p><p><a href=\"https://blog.csdn.net/u013321328/article/details/44172689\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接1</a> <a href=\"https://blog.csdn.net/shanshanhi/article/details/50904706\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接2</a></p><a id=\"more\"></a><h1 id=\"一个由C-C-编译的程序占用的内存分为以下几个部分：\"><a href=\"#一个由C-C-编译的程序占用的内存分为以下几个部分：\" class=\"headerlink\" title=\"一个由C/C++编译的程序占用的内存分为以下几个部分：\"></a>一个由C/C++编译的程序占用的内存分为以下几个部分：</h1><h2 id=\"1、栈区（stack）\"><a href=\"#1、栈区（stack）\" class=\"headerlink\" title=\"1、栈区（stack）\"></a>1、栈区（stack）</h2><p>由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><h2 id=\"2、堆区（heap）\"><a href=\"#2、堆区（heap）\" class=\"headerlink\" title=\"2、堆区（heap）\"></a>2、堆区（heap）</h2><p>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式倒是类似于数据结构中的链表。</p><h2 id=\"3、全局区-静态区（static）\"><a href=\"#3、全局区-静态区（static）\" class=\"headerlink\" title=\"3、全局区/静态区（static）\"></a>3、全局区/静态区（static）</h2><p>全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><h2 id=\"4、文字常量区\"><a href=\"#4、文字常量区\" class=\"headerlink\" title=\"4、文字常量区\"></a>4、文字常量区</h2><p>存放常量字符串。程序结束后由系统释放。</p><h2 id=\"5、程序代码区\"><a href=\"#5、程序代码区\" class=\"headerlink\" title=\"5、程序代码区\"></a>5、程序代码区</h2><p>存放函数体的二进制代码。</p><h1 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h1><h2 id=\"1、申请方式\"><a href=\"#1、申请方式\" class=\"headerlink\" title=\"1、申请方式\"></a>1、申请方式</h2><h3 id=\"栈区：\"><a href=\"#栈区：\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>由编译器自动分配释放，存放函数的参数值，局部变量值等。</p><h3 id=\"堆区：\"><a href=\"#堆区：\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。</p><h2 id=\"2、操作方式\"><a href=\"#2、操作方式\" class=\"headerlink\" title=\"2、操作方式\"></a>2、操作方式</h2><h3 id=\"栈区：-1\"><a href=\"#栈区：-1\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>操作方式类似于数据结构中的栈。</p><h3 id=\"堆区：-1\"><a href=\"#堆区：-1\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>不同于数据结构中的堆，分配方式类似于链表。</p><h2 id=\"3、申请后系统的响应\"><a href=\"#3、申请后系统的响应\" class=\"headerlink\" title=\"3、申请后系统的响应\"></a>3、申请后系统的响应</h2><h3 id=\"栈区：-2\"><a href=\"#栈区：-2\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（overflow）。</p><h3 id=\"堆区：-2\"><a href=\"#堆区：-2\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>操作系统有一个记录空闲内存地址的链表，<br>当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，<br>对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，从而代码中的delete语句才能正确的释放本内存空间，<br>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><h2 id=\"4、申请大小的限制\"><a href=\"#4、申请大小的限制\" class=\"headerlink\" title=\"4、申请大小的限制\"></a>4、申请大小的限制</h2><h3 id=\"栈区：-3\"><a href=\"#栈区：-3\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>在Windows下,栈是是一块确定的连续内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><h3 id=\"堆区：-3\"><a href=\"#堆区：-3\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>堆是向高地址扩展的数据结构，由于系统是用链表来存储的空闲内存地址的，它是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h2 id=\"5、申请效率的比较\"><a href=\"#5、申请效率的比较\" class=\"headerlink\" title=\"5、申请效率的比较\"></a>5、申请效率的比较</h2><h3 id=\"栈区：-4\"><a href=\"#栈区：-4\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>系统自动分配，速度较快。但程序员是无法控制的。</p><h3 id=\"堆区：-4\"><a href=\"#堆区：-4\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不在堆也不在栈，而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><h2 id=\"6、堆和栈中的存储内容\"><a href=\"#6、堆和栈中的存储内容\" class=\"headerlink\" title=\"6、堆和栈中的存储内容\"></a>6、堆和栈中的存储内容</h2><h3 id=\"栈区：-5\"><a href=\"#栈区：-5\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，接着是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><h3 id=\"堆区：-5\"><a href=\"#堆区：-5\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>","site":{"data":{}},"excerpt":"<p>参考：</p><p><a href=\"https://blog.csdn.net/u013321328/article/details/44172689\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接1</a> <a href=\"https://blog.csdn.net/shanshanhi/article/details/50904706\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接2</a></p>","more":"<h1 id=\"一个由C-C-编译的程序占用的内存分为以下几个部分：\"><a href=\"#一个由C-C-编译的程序占用的内存分为以下几个部分：\" class=\"headerlink\" title=\"一个由C/C++编译的程序占用的内存分为以下几个部分：\"></a>一个由C/C++编译的程序占用的内存分为以下几个部分：</h1><h2 id=\"1、栈区（stack）\"><a href=\"#1、栈区（stack）\" class=\"headerlink\" title=\"1、栈区（stack）\"></a>1、栈区（stack）</h2><p>由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><h2 id=\"2、堆区（heap）\"><a href=\"#2、堆区（heap）\" class=\"headerlink\" title=\"2、堆区（heap）\"></a>2、堆区（heap）</h2><p>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式倒是类似于数据结构中的链表。</p><h2 id=\"3、全局区-静态区（static）\"><a href=\"#3、全局区-静态区（static）\" class=\"headerlink\" title=\"3、全局区/静态区（static）\"></a>3、全局区/静态区（static）</h2><p>全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><h2 id=\"4、文字常量区\"><a href=\"#4、文字常量区\" class=\"headerlink\" title=\"4、文字常量区\"></a>4、文字常量区</h2><p>存放常量字符串。程序结束后由系统释放。</p><h2 id=\"5、程序代码区\"><a href=\"#5、程序代码区\" class=\"headerlink\" title=\"5、程序代码区\"></a>5、程序代码区</h2><p>存放函数体的二进制代码。</p><h1 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h1><h2 id=\"1、申请方式\"><a href=\"#1、申请方式\" class=\"headerlink\" title=\"1、申请方式\"></a>1、申请方式</h2><h3 id=\"栈区：\"><a href=\"#栈区：\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>由编译器自动分配释放，存放函数的参数值，局部变量值等。</p><h3 id=\"堆区：\"><a href=\"#堆区：\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。</p><h2 id=\"2、操作方式\"><a href=\"#2、操作方式\" class=\"headerlink\" title=\"2、操作方式\"></a>2、操作方式</h2><h3 id=\"栈区：-1\"><a href=\"#栈区：-1\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>操作方式类似于数据结构中的栈。</p><h3 id=\"堆区：-1\"><a href=\"#堆区：-1\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>不同于数据结构中的堆，分配方式类似于链表。</p><h2 id=\"3、申请后系统的响应\"><a href=\"#3、申请后系统的响应\" class=\"headerlink\" title=\"3、申请后系统的响应\"></a>3、申请后系统的响应</h2><h3 id=\"栈区：-2\"><a href=\"#栈区：-2\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（overflow）。</p><h3 id=\"堆区：-2\"><a href=\"#堆区：-2\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>操作系统有一个记录空闲内存地址的链表，<br>当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，<br>对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，从而代码中的delete语句才能正确的释放本内存空间，<br>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><h2 id=\"4、申请大小的限制\"><a href=\"#4、申请大小的限制\" class=\"headerlink\" title=\"4、申请大小的限制\"></a>4、申请大小的限制</h2><h3 id=\"栈区：-3\"><a href=\"#栈区：-3\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>在Windows下,栈是是一块确定的连续内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><h3 id=\"堆区：-3\"><a href=\"#堆区：-3\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>堆是向高地址扩展的数据结构，由于系统是用链表来存储的空闲内存地址的，它是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h2 id=\"5、申请效率的比较\"><a href=\"#5、申请效率的比较\" class=\"headerlink\" title=\"5、申请效率的比较\"></a>5、申请效率的比较</h2><h3 id=\"栈区：-4\"><a href=\"#栈区：-4\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>系统自动分配，速度较快。但程序员是无法控制的。</p><h3 id=\"堆区：-4\"><a href=\"#堆区：-4\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不在堆也不在栈，而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><h2 id=\"6、堆和栈中的存储内容\"><a href=\"#6、堆和栈中的存储内容\" class=\"headerlink\" title=\"6、堆和栈中的存储内容\"></a>6、堆和栈中的存储内容</h2><h3 id=\"栈区：-5\"><a href=\"#栈区：-5\" class=\"headerlink\" title=\"栈区：\"></a>栈区：</h3><p>在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，接着是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><h3 id=\"堆区：-5\"><a href=\"#堆区：-5\" class=\"headerlink\" title=\"堆区：\"></a>堆区：</h3><p>一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>"},{"title":"将hexo的评论系统由gitment改为Valine","toc":false,"date":"2018-09-13T07:10:56.000Z","_content":"\n首先注册[LeanCloud](https://leancloud.cn/)，注册后添加应用，然后选择`应用>设置>应用key`就可以看到自己的AppID和AppKey了。\n\n<!-- more -->\n\n然后进入自己的主题目录（比如我的主题是默认的`landscape`）：\n\n删除配置gitment时`/themes/landscape/layout/_partial/post`目录下添加的`git.ejs`文件，\n\n然后编辑`/themes/landscape/layout/_partial/`目录下的`article.ejs`，将原本配置gitment时添加在最后的那段代码删掉，添加：\n\n```ejs\n<% if (!index){ %>\n  <% if (post.comments){ %>\n    <div id=\"vcomments\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '#vcomments',\n            appId: '你的appid',\n            appKey: '你的appkey',\n            notify:true, \n            verify:true, \n            visitor:true,\n            avatar:'mm', \n            placeholder: '嘻嘻嘻' \n        })\n    </script>\n  <% } else { %>\n    <div class=\"vcomments\"></div>\n  <% } %>\n<% } %>\n```\n\n其中notify为邮件提醒功能是否开启，verify为验证码功能，visitor为文章访问量统计功能，[avatar](https://valine.js.org/avatar.html)为`Gravatar` 头像展示方式。\n\n在leancloud的`应用>设置>安全中心>Web安全域名`中添加你的域名。\n\n然后就OK啦！！\n\n有其他问题可以访问[Valine官方文档](https://valine.js.org/quickstart.html)查看。\n\n\n\n关于出现`Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置.`的问题：\n\n我的问题是同时在github和coding上部署了，但是在leancloud的`应用>设置>安全中心>Web安全域名`中只添加了github的域名，因此在coding的那个域名访问时就会出现上述问题，添加域名即可解决问题。","source":"_posts/将hexo的评论系统由gitment改为Valine.md","raw":"---\ntitle: 将hexo的评论系统由gitment改为Valine\ntoc: false\ndate: 2018-09-13 15:10:56\ncategories:\n- methods\ntags:\n- hexo\n- gitment\n- Valine\n---\n\n首先注册[LeanCloud](https://leancloud.cn/)，注册后添加应用，然后选择`应用>设置>应用key`就可以看到自己的AppID和AppKey了。\n\n<!-- more -->\n\n然后进入自己的主题目录（比如我的主题是默认的`landscape`）：\n\n删除配置gitment时`/themes/landscape/layout/_partial/post`目录下添加的`git.ejs`文件，\n\n然后编辑`/themes/landscape/layout/_partial/`目录下的`article.ejs`，将原本配置gitment时添加在最后的那段代码删掉，添加：\n\n```ejs\n<% if (!index){ %>\n  <% if (post.comments){ %>\n    <div id=\"vcomments\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '#vcomments',\n            appId: '你的appid',\n            appKey: '你的appkey',\n            notify:true, \n            verify:true, \n            visitor:true,\n            avatar:'mm', \n            placeholder: '嘻嘻嘻' \n        })\n    </script>\n  <% } else { %>\n    <div class=\"vcomments\"></div>\n  <% } %>\n<% } %>\n```\n\n其中notify为邮件提醒功能是否开启，verify为验证码功能，visitor为文章访问量统计功能，[avatar](https://valine.js.org/avatar.html)为`Gravatar` 头像展示方式。\n\n在leancloud的`应用>设置>安全中心>Web安全域名`中添加你的域名。\n\n然后就OK啦！！\n\n有其他问题可以访问[Valine官方文档](https://valine.js.org/quickstart.html)查看。\n\n\n\n关于出现`Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置.`的问题：\n\n我的问题是同时在github和coding上部署了，但是在leancloud的`应用>设置>安全中心>Web安全域名`中只添加了github的域名，因此在coding的那个域名访问时就会出现上述问题，添加域名即可解决问题。","slug":"将hexo的评论系统由gitment改为Valine","published":1,"updated":"2018-10-10T08:43:32.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wx0031fmagakyr3bga","content":"<p>首先注册<a href=\"https://leancloud.cn/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">LeanCloud</a>，注册后添加应用，然后选择<code>应用&gt;设置&gt;应用key</code>就可以看到自己的AppID和AppKey了。</p><a id=\"more\"></a><p>然后进入自己的主题目录（比如我的主题是默认的<code>landscape</code>）：</p><p>删除配置gitment时<code>/themes/landscape/layout/_partial/post</code>目录下添加的<code>git.ejs</code>文件，</p><p>然后编辑<code>/themes/landscape/layout/_partial/</code>目录下的<code>article.ejs</code>，将原本配置gitment时添加在最后的那段代码删掉，添加：</p><pre class=\" language-ejs\"><code class=\"language-ejs\"><% if (!index){ %>\n  <% if (post.comments){ %>\n    <div id=\"vcomments\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '#vcomments',\n            appId: '你的appid',\n            appKey: '你的appkey',\n            notify:true, \n            verify:true, \n            visitor:true,\n            avatar:'mm', \n            placeholder: '嘻嘻嘻' \n        })\n    </script>\n  <% } else { %>\n    <div class=\"vcomments\"></div>\n  <% } %>\n<% } %>\n</code></pre><p>其中notify为邮件提醒功能是否开启，verify为验证码功能，visitor为文章访问量统计功能，<a href=\"https://valine.js.org/avatar.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">avatar</a>为<code>Gravatar</code> 头像展示方式。</p><p>在leancloud的<code>应用&gt;设置&gt;安全中心&gt;Web安全域名</code>中添加你的域名。</p><p>然后就OK啦！！</p><p>有其他问题可以访问<a href=\"https://valine.js.org/quickstart.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Valine官方文档</a>查看。</p><p>关于出现<code>Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置.</code>的问题：</p><p>我的问题是同时在github和coding上部署了，但是在leancloud的<code>应用&gt;设置&gt;安全中心&gt;Web安全域名</code>中只添加了github的域名，因此在coding的那个域名访问时就会出现上述问题，添加域名即可解决问题。</p>","site":{"data":{}},"excerpt":"<p>首先注册<a href=\"https://leancloud.cn/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">LeanCloud</a>，注册后添加应用，然后选择<code>应用&gt;设置&gt;应用key</code>就可以看到自己的AppID和AppKey了。</p>","more":"<p>然后进入自己的主题目录（比如我的主题是默认的<code>landscape</code>）：</p><p>删除配置gitment时<code>/themes/landscape/layout/_partial/post</code>目录下添加的<code>git.ejs</code>文件，</p><p>然后编辑<code>/themes/landscape/layout/_partial/</code>目录下的<code>article.ejs</code>，将原本配置gitment时添加在最后的那段代码删掉，添加：</p><pre><code class=\"ejs\">&lt;% if (!index){ %&gt;\n  &lt;% if (post.comments){ %&gt;\n    &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&#39;//unpkg.com/valine/dist/Valine.min.js&#39;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        new Valine({\n            el: &#39;#vcomments&#39;,\n            appId: &#39;你的appid&#39;,\n            appKey: &#39;你的appkey&#39;,\n            notify:true, \n            verify:true, \n            visitor:true,\n            avatar:&#39;mm&#39;, \n            placeholder: &#39;嘻嘻嘻&#39; \n        })\n    &lt;/script&gt;\n  &lt;% } else { %&gt;\n    &lt;div class=&quot;vcomments&quot;&gt;&lt;/div&gt;\n  &lt;% } %&gt;\n&lt;% } %&gt;\n</code></pre><p>其中notify为邮件提醒功能是否开启，verify为验证码功能，visitor为文章访问量统计功能，<a href=\"https://valine.js.org/avatar.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">avatar</a>为<code>Gravatar</code> 头像展示方式。</p><p>在leancloud的<code>应用&gt;设置&gt;安全中心&gt;Web安全域名</code>中添加你的域名。</p><p>然后就OK啦！！</p><p>有其他问题可以访问<a href=\"https://valine.js.org/quickstart.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Valine官方文档</a>查看。</p><p>关于出现<code>Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置.</code>的问题：</p><p>我的问题是同时在github和coding上部署了，但是在leancloud的<code>应用&gt;设置&gt;安全中心&gt;Web安全域名</code>中只添加了github的域名，因此在coding的那个域名访问时就会出现上述问题，添加域名即可解决问题。</p>"},{"title":"常用SQL语句","toc":true,"date":"2018-09-29T03:55:20.000Z","_content":"\n## 一些最重要的 SQL 命令\n\n- **SELECT** - 从数据库中提取数据\n- **UPDATE** - 更新数据库中的数据\n- **DELETE** - 从数据库中删除数据\n- **INSERT INTO** - 向数据库中插入新数据<!-- more -->\n- **CREATE DATABASE** - 创建新数据库\n- **ALTER DATABASE** - 修改数据库\n- **CREATE TABLE** - 创建新表\n- **ALTER TABLE** - 变更（改变）数据库表\n- **DROP TABLE** - 删除表\n- **CREATE INDEX** - 创建索引（搜索键）\n- **DROP INDEX** - 删除索引\n\n### SELECT\n\n```sql\nSELECT column1, column2, ...\nFROM table_name;\n```\n\n这里，column1，column2，...是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法：\n\n```sql\nSELECT * FROM table_name;\n```\n\n**SELECT DISTINCT**语法用于仅返回不同的（different）值。\n\n```sql\nSELECT DISTINCT column1, column2, ...\nFROM table_name;\n```\n\n可以用**COUNT**获取不同值的数量：\n\n```sql\nSELECT COUNT(DISTINCT Country) FROM Customers;\n```\n\n### WHERE\n\n**WHERE**子句用于提取满足指定标准的记录，WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等。\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n```\n\n例如：\n\n```sql\nSELECT * FROM Customers\nWHERE Country='Mexico';\n```\n\nWHERE子句中可以使用以下运算符：\n\n| 运算符  | 描述                                                        |\n| ------- | ----------------------------------------------------------- |\n| =       | 等于                                                        |\n| <>      | 不等于。 **注意**：在某些版本的SQL中，这个操作符可能写成！= |\n| >       | 大于                                                        |\n| <       | 小于                                                        |\n| >=      | 大于等于                                                    |\n| <=      | 小于等于                                                    |\n| BETWEEN | 在某个范围内                                                |\n| LIKE    | 搜索某种模式                                                |\n| IN      | 为列指定多个可能的值                                        |\n\n### AND & OR & NOT\n\nWHERE子句可以与AND，OR和NOT运算符结合使用。\n\nAND和OR运算符用于根据多个条件筛选记录：\n\n- 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。\n- 如果由OR分隔的任何条件为真，则OR运算符显示记录。\n\n如果条件不为真，则利用NOT运算符显示记录。 \n\n**AND**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...;\n```\n\n**OR**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition1 OR condition2 OR condition3 ...;\n```\n\n**NOT**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE NOT condition;\n```\n\n### ORDER BY\n\nORDER BY 关键字用于按升序或降序对结果集进行排序。\n\nORDER BY 关键字默认情况下按升序排序记录。\n\n如果需要按降序对记录进行排序，可以使用DESC关键字。\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;\n```\n\n例如：\n\n```sql\nSELECT * FROM Customers\nORDER BY Country DESC;\n```\n\n### UPDATE\n\nUPDATE 语句用于更新表中已存在的记录。 \n\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n```\n\nWHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！\n\n栗子：\n\n```sql\nUPDATE Customers\nSET ContactName='Juan'\nWHERE Country='Mexico';\n```\n\n### DELETE\n\nDELETE 语句用于删除表中的行。\n\n```sql\nDELETE FROM table_name\nWHERE condition;\n```\n\nWHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！\n\n栗子：\n\n```sql\nDELETE FROM Customers\nWHERE CustomerName='Alfreds Futterkiste';\n```\n\n### INSERT INTO\n\nINSERT INTO 语句用于向表中插入新记录。\n\nINSERT INTO 语句可以用两种形式编写。\n\n指定要插入数据的列的名称，提供要插入的值：\n\n```sql\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n```\n\n如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示：\n\n```sql\nINSERT INTO table_name\nVALUES (value1, value2, value3, ...);\n```\n\n### 空值\n\n**NULL**用于表示缺失的值。\n\n数据表中的 NULL 值表示该值所处的字段为空。\n\n具有NULL值的字段是没有值的字段。\n\n**如何测试NULL值？**\n\n使用比较运算符（例如=，<或<>）来测试NULL值是不可行的。\n\n我们将不得不使用IS NULL和IS NOT NULL运算符。\n\n**IS NULL语法**\n\n```sql\nSELECT column_names\nFROM table_name\nWHERE column_name IS NULL;\n```\n\n**IS NOT NULL语法**\n\n```sql\nSELECT column_names\nFROM table_name\nWHERE column_name IS NOT NULL;\n```\n\n更多的可以看：\n\nhttps://www.cnblogs.com/acpe/p/4970765.html\n\nhttps://www.w3cschool.cn/sql/dlwiyfom.html","source":"_posts/常用SQL语句.md","raw":"---\ntitle: 常用SQL语句\ntoc: true\ndate: 2018-09-29 11:55:20\ncategories:\n- Web\ntags:\n- 数据库\n- SQL\n---\n\n## 一些最重要的 SQL 命令\n\n- **SELECT** - 从数据库中提取数据\n- **UPDATE** - 更新数据库中的数据\n- **DELETE** - 从数据库中删除数据\n- **INSERT INTO** - 向数据库中插入新数据<!-- more -->\n- **CREATE DATABASE** - 创建新数据库\n- **ALTER DATABASE** - 修改数据库\n- **CREATE TABLE** - 创建新表\n- **ALTER TABLE** - 变更（改变）数据库表\n- **DROP TABLE** - 删除表\n- **CREATE INDEX** - 创建索引（搜索键）\n- **DROP INDEX** - 删除索引\n\n### SELECT\n\n```sql\nSELECT column1, column2, ...\nFROM table_name;\n```\n\n这里，column1，column2，...是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法：\n\n```sql\nSELECT * FROM table_name;\n```\n\n**SELECT DISTINCT**语法用于仅返回不同的（different）值。\n\n```sql\nSELECT DISTINCT column1, column2, ...\nFROM table_name;\n```\n\n可以用**COUNT**获取不同值的数量：\n\n```sql\nSELECT COUNT(DISTINCT Country) FROM Customers;\n```\n\n### WHERE\n\n**WHERE**子句用于提取满足指定标准的记录，WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等。\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n```\n\n例如：\n\n```sql\nSELECT * FROM Customers\nWHERE Country='Mexico';\n```\n\nWHERE子句中可以使用以下运算符：\n\n| 运算符  | 描述                                                        |\n| ------- | ----------------------------------------------------------- |\n| =       | 等于                                                        |\n| <>      | 不等于。 **注意**：在某些版本的SQL中，这个操作符可能写成！= |\n| >       | 大于                                                        |\n| <       | 小于                                                        |\n| >=      | 大于等于                                                    |\n| <=      | 小于等于                                                    |\n| BETWEEN | 在某个范围内                                                |\n| LIKE    | 搜索某种模式                                                |\n| IN      | 为列指定多个可能的值                                        |\n\n### AND & OR & NOT\n\nWHERE子句可以与AND，OR和NOT运算符结合使用。\n\nAND和OR运算符用于根据多个条件筛选记录：\n\n- 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。\n- 如果由OR分隔的任何条件为真，则OR运算符显示记录。\n\n如果条件不为真，则利用NOT运算符显示记录。 \n\n**AND**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...;\n```\n\n**OR**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition1 OR condition2 OR condition3 ...;\n```\n\n**NOT**语法\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE NOT condition;\n```\n\n### ORDER BY\n\nORDER BY 关键字用于按升序或降序对结果集进行排序。\n\nORDER BY 关键字默认情况下按升序排序记录。\n\n如果需要按降序对记录进行排序，可以使用DESC关键字。\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;\n```\n\n例如：\n\n```sql\nSELECT * FROM Customers\nORDER BY Country DESC;\n```\n\n### UPDATE\n\nUPDATE 语句用于更新表中已存在的记录。 \n\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n```\n\nWHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！\n\n栗子：\n\n```sql\nUPDATE Customers\nSET ContactName='Juan'\nWHERE Country='Mexico';\n```\n\n### DELETE\n\nDELETE 语句用于删除表中的行。\n\n```sql\nDELETE FROM table_name\nWHERE condition;\n```\n\nWHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！\n\n栗子：\n\n```sql\nDELETE FROM Customers\nWHERE CustomerName='Alfreds Futterkiste';\n```\n\n### INSERT INTO\n\nINSERT INTO 语句用于向表中插入新记录。\n\nINSERT INTO 语句可以用两种形式编写。\n\n指定要插入数据的列的名称，提供要插入的值：\n\n```sql\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n```\n\n如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示：\n\n```sql\nINSERT INTO table_name\nVALUES (value1, value2, value3, ...);\n```\n\n### 空值\n\n**NULL**用于表示缺失的值。\n\n数据表中的 NULL 值表示该值所处的字段为空。\n\n具有NULL值的字段是没有值的字段。\n\n**如何测试NULL值？**\n\n使用比较运算符（例如=，<或<>）来测试NULL值是不可行的。\n\n我们将不得不使用IS NULL和IS NOT NULL运算符。\n\n**IS NULL语法**\n\n```sql\nSELECT column_names\nFROM table_name\nWHERE column_name IS NULL;\n```\n\n**IS NOT NULL语法**\n\n```sql\nSELECT column_names\nFROM table_name\nWHERE column_name IS NOT NULL;\n```\n\n更多的可以看：\n\nhttps://www.cnblogs.com/acpe/p/4970765.html\n\nhttps://www.w3cschool.cn/sql/dlwiyfom.html","slug":"常用SQL语句","published":1,"updated":"2018-10-10T08:48:25.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1wz0036fmaghyviq3en","content":"<h2 id=\"一些最重要的-SQL-命令\"><a href=\"#一些最重要的-SQL-命令\" class=\"headerlink\" title=\"一些最重要的 SQL 命令\"></a>一些最重要的 SQL 命令</h2><ul><li><strong>SELECT</strong> - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据<a id=\"more\"></a></li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul><h3 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span>\n</code></pre><p>这里，column1，column2，…是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span>\n</code></pre><p><strong>SELECT DISTINCT</strong>语法用于仅返回不同的（different）值。</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span>\n</code></pre><p>可以用<strong>COUNT</strong>获取不同值的数量：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">DISTINCT</span> Country<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> Customers<span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><p><strong>WHERE</strong>子句用于提取满足指定标准的记录，WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等。</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span>\n</code></pre><p>例如：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Customers\n<span class=\"token keyword\">WHERE</span> Country<span class=\"token operator\">=</span><span class=\"token string\">'Mexico'</span><span class=\"token punctuation\">;</span>\n</code></pre><p>WHERE子句中可以使用以下运算符：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。 <strong>注意</strong>：在某些版本的SQL中，这个操作符可能写成！=</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>为列指定多个可能的值</td></tr></tbody></table><h3 id=\"AND-amp-OR-amp-NOT\"><a href=\"#AND-amp-OR-amp-NOT\" class=\"headerlink\" title=\"AND &amp; OR &amp; NOT\"></a>AND &amp; OR &amp; NOT</h3><p>WHERE子句可以与AND，OR和NOT运算符结合使用。</p><p>AND和OR运算符用于根据多个条件筛选记录：</p><ul><li>如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。</li><li>如果由OR分隔的任何条件为真，则OR运算符显示记录。</li></ul><p>如果条件不为真，则利用NOT运算符显示记录。</p><p><strong>AND</strong>语法</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> condition1 <span class=\"token operator\">AND</span> condition2 <span class=\"token operator\">AND</span> condition3 <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n</code></pre><p><strong>OR</strong>语法</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> condition1 <span class=\"token operator\">OR</span> condition2 <span class=\"token operator\">OR</span> condition3 <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n</code></pre><p><strong>NOT</strong>语法</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> <span class=\"token operator\">NOT</span> condition<span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ORDER BY 关键字用于按升序或降序对结果集进行排序。</p><p>ORDER BY 关键字默认情况下按升序排序记录。</p><p>如果需要按降序对记录进行排序，可以使用DESC关键字。</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">ASC</span><span class=\"token operator\">|</span><span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span>\n</code></pre><p>例如：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Customers\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> Country <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><p>UPDATE 语句用于更新表中已存在的记录。</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> table_name\n<span class=\"token keyword\">SET</span> column1 <span class=\"token operator\">=</span> value1<span class=\"token punctuation\">,</span> column2 <span class=\"token operator\">=</span> value2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span>\n</code></pre><p>WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！</p><p>栗子：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> Customers\n<span class=\"token keyword\">SET</span> ContactName<span class=\"token operator\">=</span><span class=\"token string\">'Juan'</span>\n<span class=\"token keyword\">WHERE</span> Country<span class=\"token operator\">=</span><span class=\"token string\">'Mexico'</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><p>DELETE 语句用于删除表中的行。</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span>\n</code></pre><p>WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！</p><p>栗子：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> Customers\n<span class=\"token keyword\">WHERE</span> CustomerName<span class=\"token operator\">=</span><span class=\"token string\">'Alfreds Futterkiste'</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><p>INSERT INTO 语句用于向表中插入新记录。</p><p>INSERT INTO 语句可以用两种形式编写。</p><p>指定要插入数据的列的名称，提供要插入的值：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name <span class=\"token punctuation\">(</span>column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> column3<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span> value2<span class=\"token punctuation\">,</span> value3<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示：</p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name\n<span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span> value2<span class=\"token punctuation\">,</span> value3<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><h3 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h3><p><strong>NULL</strong>用于表示缺失的值。</p><p>数据表中的 NULL 值表示该值所处的字段为空。</p><p>具有NULL值的字段是没有值的字段。</p><p><strong>如何测试NULL值？</strong></p><p>使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。</p><p>我们将不得不使用IS NULL和IS NOT NULL运算符。</p><p><strong>IS NULL语法</strong></p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column_names\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> column_name <span class=\"token operator\">IS</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span>\n</code></pre><p><strong>IS NOT NULL语法</strong></p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> column_names\n<span class=\"token keyword\">FROM</span> table_name\n<span class=\"token keyword\">WHERE</span> column_name <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span>\n</code></pre><p>更多的可以看：</p><p><a href=\"https://www.cnblogs.com/acpe/p/4970765.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/acpe/p/4970765.html</a></p><p><a href=\"https://www.w3cschool.cn/sql/dlwiyfom.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.w3cschool.cn/sql/dlwiyfom.html</a></p>","site":{"data":{}},"excerpt":"<h2 id=\"一些最重要的-SQL-命令\"><a href=\"#一些最重要的-SQL-命令\" class=\"headerlink\" title=\"一些最重要的 SQL 命令\"></a>一些最重要的 SQL 命令</h2><ul><li><strong>SELECT</strong> - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据","more":"</li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul><h3 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h3><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name;\n</code></pre><p>这里，column1，column2，…是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法：</p><pre><code class=\"sql\">SELECT * FROM table_name;\n</code></pre><p><strong>SELECT DISTINCT</strong>语法用于仅返回不同的（different）值。</p><pre><code class=\"sql\">SELECT DISTINCT column1, column2, ...\nFROM table_name;\n</code></pre><p>可以用<strong>COUNT</strong>获取不同值的数量：</p><pre><code class=\"sql\">SELECT COUNT(DISTINCT Country) FROM Customers;\n</code></pre><h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><p><strong>WHERE</strong>子句用于提取满足指定标准的记录，WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等。</p><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n</code></pre><p>例如：</p><pre><code class=\"sql\">SELECT * FROM Customers\nWHERE Country=&#39;Mexico&#39;;\n</code></pre><p>WHERE子句中可以使用以下运算符：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。 <strong>注意</strong>：在某些版本的SQL中，这个操作符可能写成！=</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>为列指定多个可能的值</td></tr></tbody></table><h3 id=\"AND-amp-OR-amp-NOT\"><a href=\"#AND-amp-OR-amp-NOT\" class=\"headerlink\" title=\"AND &amp; OR &amp; NOT\"></a>AND &amp; OR &amp; NOT</h3><p>WHERE子句可以与AND，OR和NOT运算符结合使用。</p><p>AND和OR运算符用于根据多个条件筛选记录：</p><ul><li>如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。</li><li>如果由OR分隔的任何条件为真，则OR运算符显示记录。</li></ul><p>如果条件不为真，则利用NOT运算符显示记录。</p><p><strong>AND</strong>语法</p><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...;\n</code></pre><p><strong>OR</strong>语法</p><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 OR condition2 OR condition3 ...;\n</code></pre><p><strong>NOT</strong>语法</p><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE NOT condition;\n</code></pre><h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ORDER BY 关键字用于按升序或降序对结果集进行排序。</p><p>ORDER BY 关键字默认情况下按升序排序记录。</p><p>如果需要按降序对记录进行排序，可以使用DESC关键字。</p><pre><code class=\"sql\">SELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;\n</code></pre><p>例如：</p><pre><code class=\"sql\">SELECT * FROM Customers\nORDER BY Country DESC;\n</code></pre><h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><p>UPDATE 语句用于更新表中已存在的记录。</p><pre><code class=\"sql\">UPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n</code></pre><p>WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！</p><p>栗子：</p><pre><code class=\"sql\">UPDATE Customers\nSET ContactName=&#39;Juan&#39;\nWHERE Country=&#39;Mexico&#39;;\n</code></pre><h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><p>DELETE 语句用于删除表中的行。</p><pre><code class=\"sql\">DELETE FROM table_name\nWHERE condition;\n</code></pre><p>WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！</p><p>栗子：</p><pre><code class=\"sql\">DELETE FROM Customers\nWHERE CustomerName=&#39;Alfreds Futterkiste&#39;;\n</code></pre><h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><p>INSERT INTO 语句用于向表中插入新记录。</p><p>INSERT INTO 语句可以用两种形式编写。</p><p>指定要插入数据的列的名称，提供要插入的值：</p><pre><code class=\"sql\">INSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n</code></pre><p>如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示：</p><pre><code class=\"sql\">INSERT INTO table_name\nVALUES (value1, value2, value3, ...);\n</code></pre><h3 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h3><p><strong>NULL</strong>用于表示缺失的值。</p><p>数据表中的 NULL 值表示该值所处的字段为空。</p><p>具有NULL值的字段是没有值的字段。</p><p><strong>如何测试NULL值？</strong></p><p>使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。</p><p>我们将不得不使用IS NULL和IS NOT NULL运算符。</p><p><strong>IS NULL语法</strong></p><pre><code class=\"sql\">SELECT column_names\nFROM table_name\nWHERE column_name IS NULL;\n</code></pre><p><strong>IS NOT NULL语法</strong></p><pre><code class=\"sql\">SELECT column_names\nFROM table_name\nWHERE column_name IS NOT NULL;\n</code></pre><p>更多的可以看：</p><p><a href=\"https://www.cnblogs.com/acpe/p/4970765.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/acpe/p/4970765.html</a></p><p><a href=\"https://www.w3cschool.cn/sql/dlwiyfom.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.w3cschool.cn/sql/dlwiyfom.html</a></p>"},{"title":"接入gitment为hexo添加评论功能","toc":false,"date":"2018-04-16T02:59:56.000Z","_content":"\n## 注册一个OAuth application \n\n[注册链接](https://github.com/settings/applications/new)\n\n<!-- more -->\n\n![](/images/Capture3.PNG)\n\n其中：\n\nApplication name 为应用名，取一个跟自己博客相关的名字即可；\n\nHomepage URL 为博客地址，例如我的为：https://mikqueenge.github.io；\n\nApplication description 为应用描述，可不填；\n\nAuthorization callback URL 为回调URL，可不填；\n\n\n\n点击 Register application 祝成功后会得到这个应用的 **client ID** 和 **client secret**，等下配置文件时会用到。\n\n\n\n## 配置文件 \n\n主题：landscape\n\n### 创建git.ejs\n\n在`themes/landscape/layout/_partial/post`文件夹中创建文件`git.ejs`，写入下面的代码：\n\n```ejs\n<!-- Gitment评论插件通用代码 -->\n<div id=\"git\"></div>\n<!-- 汉化版 -->\n<link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\">\n<script src=\"https://billts.site/js/gitment.js\"></script>\n<script>\nvar gitment = new Gitment({\n  id: '{{ page.date }}', //添加此句解决Error：validation failed的问题\n  owner: \"%%%%%%%\",//github用户名，例如MIKQUEENGE\n  repo: \"%%%%%%%\",//用户存储评论的github项目名称，例如MIKQUEENGE.github.io\n  oauth: {\n    client_id: \"%%%%%%%%%%%%\",//注册OAuth Application时生产的ClinetID\n    client_secret:\"%%%%%%%%%%\",//注册OAuth Application时生成的Client Secret\n  },\n})\ngitment.render('git')\n</script>\n<!-- Gitment代码结束 -->\n```\n\n### 配置article.ejs\n\n在`themes/landscape/layout/_partial/article.ejs`文件的结尾添加：\n\n```ejs\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/git') %>\n  <% } else { %>\n    <div class=\"git\"></div>\n  <% } %>\n<% } %>\n```\n\n## 登陆与添加评论\n\n完成上述配置后部署并打开某篇文章，拉到最底部可以看到评论区：\n\n![](/images/Capture4.PNG)\n\n点击登陆后就可以添加评论啦！\n\n## 遇到问题Error：validation failed\n\nmd文件名太长导致id出现问题，使用上述代码是不会出现这个问题的。\n\n如果出现这个问题，解决方案为在gitment配置文件（如上述的`git.ejs`）中的`var gitment = new Gitment({})`内添加`id: '{{ page.date }}',`（不要忘记这个逗号）\n\n\n\n---\n\n参考链接：\n\n[Hexo博客yelee主题添加Gitment评论系统 ](https://blog.csdn.net/stven_king/article/details/78357753)\n\n[Gitment评论功能接入踩坑教程](http://ihtc.cc/2018/02/25/2018-02-25%20_Gitment评论功能接入踩坑教程/)","source":"_posts/接入gitment为hexo添加评论功能.md","raw":"---\ntitle: 接入gitment为hexo添加评论功能\ntoc: false\ndate: 2018-04-16 10:59:56\ncategories:\n- methods\ntags:\n- hexo\n- gitment\n---\n\n## 注册一个OAuth application \n\n[注册链接](https://github.com/settings/applications/new)\n\n<!-- more -->\n\n![](/images/Capture3.PNG)\n\n其中：\n\nApplication name 为应用名，取一个跟自己博客相关的名字即可；\n\nHomepage URL 为博客地址，例如我的为：https://mikqueenge.github.io；\n\nApplication description 为应用描述，可不填；\n\nAuthorization callback URL 为回调URL，可不填；\n\n\n\n点击 Register application 祝成功后会得到这个应用的 **client ID** 和 **client secret**，等下配置文件时会用到。\n\n\n\n## 配置文件 \n\n主题：landscape\n\n### 创建git.ejs\n\n在`themes/landscape/layout/_partial/post`文件夹中创建文件`git.ejs`，写入下面的代码：\n\n```ejs\n<!-- Gitment评论插件通用代码 -->\n<div id=\"git\"></div>\n<!-- 汉化版 -->\n<link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\">\n<script src=\"https://billts.site/js/gitment.js\"></script>\n<script>\nvar gitment = new Gitment({\n  id: '{{ page.date }}', //添加此句解决Error：validation failed的问题\n  owner: \"%%%%%%%\",//github用户名，例如MIKQUEENGE\n  repo: \"%%%%%%%\",//用户存储评论的github项目名称，例如MIKQUEENGE.github.io\n  oauth: {\n    client_id: \"%%%%%%%%%%%%\",//注册OAuth Application时生产的ClinetID\n    client_secret:\"%%%%%%%%%%\",//注册OAuth Application时生成的Client Secret\n  },\n})\ngitment.render('git')\n</script>\n<!-- Gitment代码结束 -->\n```\n\n### 配置article.ejs\n\n在`themes/landscape/layout/_partial/article.ejs`文件的结尾添加：\n\n```ejs\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/git') %>\n  <% } else { %>\n    <div class=\"git\"></div>\n  <% } %>\n<% } %>\n```\n\n## 登陆与添加评论\n\n完成上述配置后部署并打开某篇文章，拉到最底部可以看到评论区：\n\n![](/images/Capture4.PNG)\n\n点击登陆后就可以添加评论啦！\n\n## 遇到问题Error：validation failed\n\nmd文件名太长导致id出现问题，使用上述代码是不会出现这个问题的。\n\n如果出现这个问题，解决方案为在gitment配置文件（如上述的`git.ejs`）中的`var gitment = new Gitment({})`内添加`id: '{{ page.date }}',`（不要忘记这个逗号）\n\n\n\n---\n\n参考链接：\n\n[Hexo博客yelee主题添加Gitment评论系统 ](https://blog.csdn.net/stven_king/article/details/78357753)\n\n[Gitment评论功能接入踩坑教程](http://ihtc.cc/2018/02/25/2018-02-25%20_Gitment评论功能接入踩坑教程/)","slug":"接入gitment为hexo添加评论功能","published":1,"updated":"2018-10-10T08:48:19.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1x00039fmagqs0pj7he","content":"<h2 id=\"注册一个OAuth-application\"><a href=\"#注册一个OAuth-application\" class=\"headerlink\" title=\"注册一个OAuth application\"></a>注册一个OAuth application</h2><p><a href=\"https://github.com/settings/applications/new\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">注册链接</a></p><a id=\"more\"></a><p><img src=\"/images/Capture3.PNG\" alt=\"\"></p><p>其中：</p><p>Application name 为应用名，取一个跟自己博客相关的名字即可；</p><p>Homepage URL 为博客地址，例如我的为：<a href=\"https://mikqueenge.github.io；\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://mikqueenge.github.io；</a></p><p>Application description 为应用描述，可不填；</p><p>Authorization callback URL 为回调URL，可不填；</p><p>点击 Register application 祝成功后会得到这个应用的 <strong>client ID</strong> 和 <strong>client secret</strong>，等下配置文件时会用到。</p><h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>主题：landscape</p><h3 id=\"创建git-ejs\"><a href=\"#创建git-ejs\" class=\"headerlink\" title=\"创建git.ejs\"></a>创建git.ejs</h3><p>在<code>themes/landscape/layout/_partial/post</code>文件夹中创建文件<code>git.ejs</code>，写入下面的代码：</p><pre class=\" language-ejs\"><code class=\"language-ejs\"><!-- Gitment评论插件通用代码 -->\n<div id=\"git\"></div>\n<!-- 汉化版 -->\n<link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\">\n<script src=\"https://billts.site/js/gitment.js\"></script>\n<script>\nvar gitment = new Gitment({\n  id: '{{ page.date }}', //添加此句解决Error：validation failed的问题\n  owner: \"%%%%%%%\",//github用户名，例如MIKQUEENGE\n  repo: \"%%%%%%%\",//用户存储评论的github项目名称，例如MIKQUEENGE.github.io\n  oauth: {\n    client_id: \"%%%%%%%%%%%%\",//注册OAuth Application时生产的ClinetID\n    client_secret:\"%%%%%%%%%%\",//注册OAuth Application时生成的Client Secret\n  },\n})\ngitment.render('git')\n</script>\n<!-- Gitment代码结束 -->\n</code></pre><h3 id=\"配置article-ejs\"><a href=\"#配置article-ejs\" class=\"headerlink\" title=\"配置article.ejs\"></a>配置article.ejs</h3><p>在<code>themes/landscape/layout/_partial/article.ejs</code>文件的结尾添加：</p><pre class=\" language-ejs\"><code class=\"language-ejs\"><% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/git') %>\n  <% } else { %>\n    <div class=\"git\"></div>\n  <% } %>\n<% } %>\n</code></pre><h2 id=\"登陆与添加评论\"><a href=\"#登陆与添加评论\" class=\"headerlink\" title=\"登陆与添加评论\"></a>登陆与添加评论</h2><p>完成上述配置后部署并打开某篇文章，拉到最底部可以看到评论区：</p><p><img src=\"/images/Capture4.PNG\" alt=\"\"></p><p>点击登陆后就可以添加评论啦！</p><h2 id=\"遇到问题Error：validation-failed\"><a href=\"#遇到问题Error：validation-failed\" class=\"headerlink\" title=\"遇到问题Error：validation failed\"></a>遇到问题Error：validation failed</h2><p>md文件名太长导致id出现问题，使用上述代码是不会出现这个问题的。</p><p>如果出现这个问题，解决方案为在gitment配置文件（如上述的<code>git.ejs</code>）中的<code>var gitment = new Gitment({})</code>内添加<code>id: &#39;&#39;,</code>（不要忘记这个逗号）</p><hr><p>参考链接：</p><p><a href=\"https://blog.csdn.net/stven_king/article/details/78357753\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Hexo博客yelee主题添加Gitment评论系统</a></p><p><a href=\"http://ihtc.cc/2018/02/25/2018-02-25%20_Gitment评论功能接入踩坑教程/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Gitment评论功能接入踩坑教程</a></p>","site":{"data":{}},"excerpt":"<h2 id=\"注册一个OAuth-application\"><a href=\"#注册一个OAuth-application\" class=\"headerlink\" title=\"注册一个OAuth application\"></a>注册一个OAuth application</h2><p><a href=\"https://github.com/settings/applications/new\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">注册链接</a></p>","more":"<p><img src=\"/images/Capture3.PNG\" alt=\"\"></p><p>其中：</p><p>Application name 为应用名，取一个跟自己博客相关的名字即可；</p><p>Homepage URL 为博客地址，例如我的为：<a href=\"https://mikqueenge.github.io；\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://mikqueenge.github.io；</a></p><p>Application description 为应用描述，可不填；</p><p>Authorization callback URL 为回调URL，可不填；</p><p>点击 Register application 祝成功后会得到这个应用的 <strong>client ID</strong> 和 <strong>client secret</strong>，等下配置文件时会用到。</p><h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>主题：landscape</p><h3 id=\"创建git-ejs\"><a href=\"#创建git-ejs\" class=\"headerlink\" title=\"创建git.ejs\"></a>创建git.ejs</h3><p>在<code>themes/landscape/layout/_partial/post</code>文件夹中创建文件<code>git.ejs</code>，写入下面的代码：</p><pre><code class=\"ejs\">&lt;!-- Gitment评论插件通用代码 --&gt;\n&lt;div id=&quot;git&quot;&gt;&lt;/div&gt;\n&lt;!-- 汉化版 --&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://billts.site/extra_css/gitment.css&quot;&gt;\n&lt;script src=&quot;https://billts.site/js/gitment.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar gitment = new Gitment({\n  id: &#39;{{ page.date }}&#39;, //添加此句解决Error：validation failed的问题\n  owner: &quot;%%%%%%%&quot;,//github用户名，例如MIKQUEENGE\n  repo: &quot;%%%%%%%&quot;,//用户存储评论的github项目名称，例如MIKQUEENGE.github.io\n  oauth: {\n    client_id: &quot;%%%%%%%%%%%%&quot;,//注册OAuth Application时生产的ClinetID\n    client_secret:&quot;%%%%%%%%%%&quot;,//注册OAuth Application时生成的Client Secret\n  },\n})\ngitment.render(&#39;git&#39;)\n&lt;/script&gt;\n&lt;!-- Gitment代码结束 --&gt;\n</code></pre><h3 id=\"配置article-ejs\"><a href=\"#配置article-ejs\" class=\"headerlink\" title=\"配置article.ejs\"></a>配置article.ejs</h3><p>在<code>themes/landscape/layout/_partial/article.ejs</code>文件的结尾添加：</p><pre><code class=\"ejs\">&lt;% if (!index){ %&gt;\n  &lt;% if (post.comments){ %&gt;\n  &lt;%- partial(&#39;post/git&#39;) %&gt;\n  &lt;% } else { %&gt;\n    &lt;div class=&quot;git&quot;&gt;&lt;/div&gt;\n  &lt;% } %&gt;\n&lt;% } %&gt;\n</code></pre><h2 id=\"登陆与添加评论\"><a href=\"#登陆与添加评论\" class=\"headerlink\" title=\"登陆与添加评论\"></a>登陆与添加评论</h2><p>完成上述配置后部署并打开某篇文章，拉到最底部可以看到评论区：</p><p><img src=\"/images/Capture4.PNG\" alt=\"\"></p><p>点击登陆后就可以添加评论啦！</p><h2 id=\"遇到问题Error：validation-failed\"><a href=\"#遇到问题Error：validation-failed\" class=\"headerlink\" title=\"遇到问题Error：validation failed\"></a>遇到问题Error：validation failed</h2><p>md文件名太长导致id出现问题，使用上述代码是不会出现这个问题的。</p><p>如果出现这个问题，解决方案为在gitment配置文件（如上述的<code>git.ejs</code>）中的<code>var gitment = new Gitment({})</code>内添加<code>id: &#39;&#39;,</code>（不要忘记这个逗号）</p><hr><p>参考链接：</p><p><a href=\"https://blog.csdn.net/stven_king/article/details/78357753\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Hexo博客yelee主题添加Gitment评论系统</a></p><p><a href=\"http://ihtc.cc/2018/02/25/2018-02-25%20_Gitment评论功能接入踩坑教程/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Gitment评论功能接入踩坑教程</a></p>"},{"title":"操作系统面试相关总结","toc":true,"date":"2018-09-28T09:08:01.000Z","_content":"\n参考课程：[操作系统](https://www.bilibili.com/video/av6538245?from=search&seid=2726829833194936883)\n\n参考资料：[计算机操作系统教程](https://link.juejin.im/?target=http%3A%2F%2Fc.biancheng.net%2Fcpp%2Fu%2Fxitong%2F)\n\n<!-- more -->\n\n---\n\n\n\n## 操作系统的四个特性\n\n- **并发**：同一<u>时间段</u>内多个程序执行\n  - 需要区别并行和并发\n  - 并行为同一<u>时刻</u>多个程序执行\n- **共享**：系统中的资源可以被内存中的多个并发执行的进线程共同使用\n- **虚拟**：通过时分复用和空分复用技术实现把一个物理实体虚拟为多个\n  - 时分复用：如分时系统，就是将提供给整个信道传输信息的事件划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用\n  - 空分复用：如虚拟内存，指让同一个频段在不同的空间内得到重复利用\n\n- **异步**：操作系统允许多个程序并发执行，<u>但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可知的速度向前推进</u>\n  - 这导致当操作系统运行在一种随机的环境下时，可能导致进程产生与时间有关的错误\n  - 但只要运行环境相同，操作系统必须保证多次运行进程都获得相同的结果\n\n## 操作系统的主要功能\n\n- **进程管理**：包括进程控制、进程同步、进程通信和进程调度\n- **内存管理**：包括内存分配、内存保护、地址映射和内存扩充\n- **设备管理**：负责管理各类外围设备（简称：外设），包括分配、启动和故障处理等\n  - 完成用户的IO请求\n  - 为用户进程分配IO设备\n  - 提高IO设备利用率\n  - 提高IO速度\n  - 方便IO的使用\n\n- **文件管理**：管理系统文件和用户文件，方便使用同时保证安全性\n  - 磁盘存储空间管理\n  - 目录管理\n  - 文件读写管理\n  - 文件共享和保护\n- **作业管理**：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制（根据用户的需要控制作业运行的步骤）\n\n## 进程的状态与转换\n\n![进程状态转换图](/images/进程状态转换图.jpg)\n\n- **新建**： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息\n- **运行**：当一个进程在处理机上运行时，则称该进程处于运行状态\n  - 处于此状态的进程的数目小于等于处理器的数目\n  - 对于单处理机系统，处于运行状态的进程只有一个\n  - 在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。\n- **就绪**：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个<u>优先级</u>来划分队列:\n  - 当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列\n  - 当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。\n- **阻塞**：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态\n\n- **终止**：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程）\n\n## 进程与线程\n\n| 方面     | 进程                                                         | 线程                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 根本区别 | 操作系统资源分配的基本单位                                   | 任务调度和执行的基本单位                                     |\n| 开销方面 | 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销 | 线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小 |\n| 所处环境 | 操作系统中多个进程可以并发运行                               | 同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） |\n| 内存分配 | 系统在运行时会为每个进程分配不同的内存空间                   | 除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源 |\n| 包含关系 | 进程可以包含多个线程，且这些线程可以并发运行                 | 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程   |\n\n## 进程通信\n\n进程之间的信息交换。\n\n- 共享内存\n- 信息传递\n- 管道通信\n  - 管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件\n  - 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道\n  - 而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据\n  - 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在\n\n## 进程同步\n\n多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。\n\n**进程同步**的任务就是对多个相关进程在<u>执行顺序上进行协调</u>，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。\n\n同步机制需要遵循的原则：\n\n1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请\n2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问\n3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等\n4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，以免陷入忙等\n\n经典的进程同步问题：\n\n- 生产者-消费者问题\n- 哲学家进餐问题\n- 读者-写者问题\n\n同步的解决方案：\n\n- 管程\n- 信号量\n\n## 用户态和内核态\n\n![img](https://user-gold-cdn.xitu.io/2017/5/22/08d8fe2bdd546e97085f4f1d69281c9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n运行在**用户态**下的程序**不能**直接访问操作系统内核数据结构和程序。\n\n**用户态切换到内核态的3种方式**\n\n1. **系统调用**：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。\n2. **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\n3. **外围设备的中断**：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\n\n## 死锁\n\n多个进程在运行过程中，因为争夺资源而造成的一种僵局。\n\n### 死锁原因\n\n1. **竞争资源**：请求同一有限资源的进程数多于可用资源数\n2. **进程推进顺序不当**：进程执行中，请求和释放资源顺序不合理，如资源等待链\n\n### 死锁的四个必要条件\n\n1. **互斥**:在一个时间只能有一个进程使用资源\n2. **持有并等待**：进程持有至少一个资源时，等待获取其他进程持有的额外资源\n3. **无抢占**：进程对于已经申请到的资源在使用完成之前不可以被剥夺\n4. **循环等待**：存在进程集合{P0,P1,...,PN}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，PN-1正在等待PN占用的资源，PN正在等待P0占用的资源\n\n### 死锁处理\n\n- 确保系统永远不会进入死锁状态\n- 系统可能进入死锁状态，若进入死锁状态则进行恢复\n- 忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX。\n\n\n\n1. **死锁预防**：破坏产生死锁的4个必要条件中的一个或者多个\n   1. **互斥**：不互斥可能带来不确定性问题\n   2. **持有并等待**：让一个资源在请求资源时，不持有任何其他资源。为请求资源的进程分配所有资源；仅当进程不占有资源时才可以请求资源。但是这会导致<u>资源利用率低，还可能发生饥饿</u>。\n   3. **无抢占**：抢占资源只能kill掉正在占有资源的进程，不合理\n   4. **循环等待**：对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。在<u>嵌入式系统</u>中经常这种方法，因为嵌入式系统资源比较有限\n2. **死锁避免**：额外的先行验证\n   1. 最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的**最大数目**\n   2. 限定**提供与分配**的资源数量和进程的**最大需求**\n   3. 在进程申请资源时检查资源分配状态来进行资源分配，以确保永远不会有一个环形等待状态\n   4. **银行家算法**：死锁避免的著名算法。以银行借贷系统的分配策略为基础，判断并保证系统的安全运行\n3. **死锁检测**：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大\n4. **死锁恢复**：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。\n\n## 进程调度算法\n\n- **先来先服务调度算法FCFS：**既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；\n\n- **短作业优先调度算法SJF：**作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；\n\n- **高相应比算法HRN：**响应比=(等待时间+要求服务时间)/要求服务时间；\n\n- **时间片轮转调度RR：**按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;\n\n- **多级反馈队列调度算法：**目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。\n\n## 内存连续分配\n\n动态分区分配时所采用的几种算法。\n\n动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。\n\n这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。\n\n因此系统中分区的大小和数目是可变的。\n\n- **首次适应(First Fit)算法：**空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。\n\n- **最佳适应(Best Fit)算法：**空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。\n\n- **最坏适应(Worst Fit)算法：**又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。\n\n## 基本分页储存管理方式\n\n把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。\n\n每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。\n\n因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，**因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。**\n\n由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要**两次的内存访问**(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。\n\n为了减少两次访问内存导致的效率影响，分页管理中引入了**快表机制**，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。\n\n在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用**两级页表或者多级页表的方法**，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。\n\n## 基本分段储存管理方式\n\n分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。\n\n分段内存管理当中，**地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的**。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。\n\n访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。\n\n## 分段分页方式的比较\n\n页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；\n\n段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。\n\n页的大小是固定的，由系统决定；\n\n段的大小是不确定的，由用户决定。\n\n## 段页式存储\n\n### 基本思想\n\n分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。\n\n在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。\n\n段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量\n\n程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。\n\n为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。\n\n### 地址变换的过程\n\n1. 程序执行时，从PCB（进程控制块）中取出段表始址和段表长度，装入段表寄存器。\n2. 由地址变换机构将逻辑地址自动分成段号、页号和页内地址。\n3. 将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。\n4. 将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。\n5. 取出段描述子得到该段的页表始址和页表长度。\n6. 将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。\n7. 将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。\n8. 取出页描述子得到该页的物理块号。\n9. 对该页的存取控制进行检查。\n10. 将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。\n\n## 虚拟内存\n\n如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。\n\n单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。\n\n因此可以从逻辑的角度扩充内存容量，即可解决上述两种问题。\n\n基于局部性原理，<u>在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存</u>，就可以启动程序执行。\n\n在程序执行过程中，<u>当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序</u>。\n\n另一方面，操作系统将内存中<u>暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息</u>。\n\n这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为**虚拟存储器**。\n\n**虚拟存储器**的特征：\n\n1. **多次性**：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性\n2. **对换性**：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)\n3. **虚拟性**：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上\n\n## 页面置换算法\n\n- **最佳置换算法：**只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。\n\n- **先进先出置换算法：**简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。\n\n- **最近最久未使用算法LRU：**算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。\n\n- **时钟算法clock(也被称为是最近未使用算法NRU)：**页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。\n\n- **改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。\n\n- **最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。\n\n","source":"_posts/操作系统面试相关总结.md","raw":"---\ntitle: 操作系统面试相关总结\ntoc: true\ndate: 2018-09-28 17:08:01\ncategories:\n- Web\ntags:\n- 操作系统\n---\n\n参考课程：[操作系统](https://www.bilibili.com/video/av6538245?from=search&seid=2726829833194936883)\n\n参考资料：[计算机操作系统教程](https://link.juejin.im/?target=http%3A%2F%2Fc.biancheng.net%2Fcpp%2Fu%2Fxitong%2F)\n\n<!-- more -->\n\n---\n\n\n\n## 操作系统的四个特性\n\n- **并发**：同一<u>时间段</u>内多个程序执行\n  - 需要区别并行和并发\n  - 并行为同一<u>时刻</u>多个程序执行\n- **共享**：系统中的资源可以被内存中的多个并发执行的进线程共同使用\n- **虚拟**：通过时分复用和空分复用技术实现把一个物理实体虚拟为多个\n  - 时分复用：如分时系统，就是将提供给整个信道传输信息的事件划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用\n  - 空分复用：如虚拟内存，指让同一个频段在不同的空间内得到重复利用\n\n- **异步**：操作系统允许多个程序并发执行，<u>但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可知的速度向前推进</u>\n  - 这导致当操作系统运行在一种随机的环境下时，可能导致进程产生与时间有关的错误\n  - 但只要运行环境相同，操作系统必须保证多次运行进程都获得相同的结果\n\n## 操作系统的主要功能\n\n- **进程管理**：包括进程控制、进程同步、进程通信和进程调度\n- **内存管理**：包括内存分配、内存保护、地址映射和内存扩充\n- **设备管理**：负责管理各类外围设备（简称：外设），包括分配、启动和故障处理等\n  - 完成用户的IO请求\n  - 为用户进程分配IO设备\n  - 提高IO设备利用率\n  - 提高IO速度\n  - 方便IO的使用\n\n- **文件管理**：管理系统文件和用户文件，方便使用同时保证安全性\n  - 磁盘存储空间管理\n  - 目录管理\n  - 文件读写管理\n  - 文件共享和保护\n- **作业管理**：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制（根据用户的需要控制作业运行的步骤）\n\n## 进程的状态与转换\n\n![进程状态转换图](/images/进程状态转换图.jpg)\n\n- **新建**： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息\n- **运行**：当一个进程在处理机上运行时，则称该进程处于运行状态\n  - 处于此状态的进程的数目小于等于处理器的数目\n  - 对于单处理机系统，处于运行状态的进程只有一个\n  - 在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。\n- **就绪**：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个<u>优先级</u>来划分队列:\n  - 当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列\n  - 当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。\n- **阻塞**：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态\n\n- **终止**：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程）\n\n## 进程与线程\n\n| 方面     | 进程                                                         | 线程                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 根本区别 | 操作系统资源分配的基本单位                                   | 任务调度和执行的基本单位                                     |\n| 开销方面 | 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销 | 线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小 |\n| 所处环境 | 操作系统中多个进程可以并发运行                               | 同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） |\n| 内存分配 | 系统在运行时会为每个进程分配不同的内存空间                   | 除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源 |\n| 包含关系 | 进程可以包含多个线程，且这些线程可以并发运行                 | 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程   |\n\n## 进程通信\n\n进程之间的信息交换。\n\n- 共享内存\n- 信息传递\n- 管道通信\n  - 管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件\n  - 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道\n  - 而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据\n  - 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在\n\n## 进程同步\n\n多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。\n\n**进程同步**的任务就是对多个相关进程在<u>执行顺序上进行协调</u>，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。\n\n同步机制需要遵循的原则：\n\n1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请\n2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问\n3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等\n4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，以免陷入忙等\n\n经典的进程同步问题：\n\n- 生产者-消费者问题\n- 哲学家进餐问题\n- 读者-写者问题\n\n同步的解决方案：\n\n- 管程\n- 信号量\n\n## 用户态和内核态\n\n![img](https://user-gold-cdn.xitu.io/2017/5/22/08d8fe2bdd546e97085f4f1d69281c9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n运行在**用户态**下的程序**不能**直接访问操作系统内核数据结构和程序。\n\n**用户态切换到内核态的3种方式**\n\n1. **系统调用**：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。\n2. **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\n3. **外围设备的中断**：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\n\n## 死锁\n\n多个进程在运行过程中，因为争夺资源而造成的一种僵局。\n\n### 死锁原因\n\n1. **竞争资源**：请求同一有限资源的进程数多于可用资源数\n2. **进程推进顺序不当**：进程执行中，请求和释放资源顺序不合理，如资源等待链\n\n### 死锁的四个必要条件\n\n1. **互斥**:在一个时间只能有一个进程使用资源\n2. **持有并等待**：进程持有至少一个资源时，等待获取其他进程持有的额外资源\n3. **无抢占**：进程对于已经申请到的资源在使用完成之前不可以被剥夺\n4. **循环等待**：存在进程集合{P0,P1,...,PN}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，PN-1正在等待PN占用的资源，PN正在等待P0占用的资源\n\n### 死锁处理\n\n- 确保系统永远不会进入死锁状态\n- 系统可能进入死锁状态，若进入死锁状态则进行恢复\n- 忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX。\n\n\n\n1. **死锁预防**：破坏产生死锁的4个必要条件中的一个或者多个\n   1. **互斥**：不互斥可能带来不确定性问题\n   2. **持有并等待**：让一个资源在请求资源时，不持有任何其他资源。为请求资源的进程分配所有资源；仅当进程不占有资源时才可以请求资源。但是这会导致<u>资源利用率低，还可能发生饥饿</u>。\n   3. **无抢占**：抢占资源只能kill掉正在占有资源的进程，不合理\n   4. **循环等待**：对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。在<u>嵌入式系统</u>中经常这种方法，因为嵌入式系统资源比较有限\n2. **死锁避免**：额外的先行验证\n   1. 最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的**最大数目**\n   2. 限定**提供与分配**的资源数量和进程的**最大需求**\n   3. 在进程申请资源时检查资源分配状态来进行资源分配，以确保永远不会有一个环形等待状态\n   4. **银行家算法**：死锁避免的著名算法。以银行借贷系统的分配策略为基础，判断并保证系统的安全运行\n3. **死锁检测**：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大\n4. **死锁恢复**：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。\n\n## 进程调度算法\n\n- **先来先服务调度算法FCFS：**既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；\n\n- **短作业优先调度算法SJF：**作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；\n\n- **高相应比算法HRN：**响应比=(等待时间+要求服务时间)/要求服务时间；\n\n- **时间片轮转调度RR：**按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;\n\n- **多级反馈队列调度算法：**目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。\n\n## 内存连续分配\n\n动态分区分配时所采用的几种算法。\n\n动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。\n\n这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。\n\n因此系统中分区的大小和数目是可变的。\n\n- **首次适应(First Fit)算法：**空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。\n\n- **最佳适应(Best Fit)算法：**空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。\n\n- **最坏适应(Worst Fit)算法：**又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。\n\n## 基本分页储存管理方式\n\n把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。\n\n每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。\n\n因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，**因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。**\n\n由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要**两次的内存访问**(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。\n\n为了减少两次访问内存导致的效率影响，分页管理中引入了**快表机制**，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。\n\n在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用**两级页表或者多级页表的方法**，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。\n\n## 基本分段储存管理方式\n\n分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。\n\n分段内存管理当中，**地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的**。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。\n\n访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。\n\n## 分段分页方式的比较\n\n页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；\n\n段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。\n\n页的大小是固定的，由系统决定；\n\n段的大小是不确定的，由用户决定。\n\n## 段页式存储\n\n### 基本思想\n\n分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。\n\n在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。\n\n段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量\n\n程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。\n\n为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。\n\n### 地址变换的过程\n\n1. 程序执行时，从PCB（进程控制块）中取出段表始址和段表长度，装入段表寄存器。\n2. 由地址变换机构将逻辑地址自动分成段号、页号和页内地址。\n3. 将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。\n4. 将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。\n5. 取出段描述子得到该段的页表始址和页表长度。\n6. 将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。\n7. 将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。\n8. 取出页描述子得到该页的物理块号。\n9. 对该页的存取控制进行检查。\n10. 将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。\n\n## 虚拟内存\n\n如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。\n\n单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。\n\n因此可以从逻辑的角度扩充内存容量，即可解决上述两种问题。\n\n基于局部性原理，<u>在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存</u>，就可以启动程序执行。\n\n在程序执行过程中，<u>当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序</u>。\n\n另一方面，操作系统将内存中<u>暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息</u>。\n\n这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为**虚拟存储器**。\n\n**虚拟存储器**的特征：\n\n1. **多次性**：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性\n2. **对换性**：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)\n3. **虚拟性**：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上\n\n## 页面置换算法\n\n- **最佳置换算法：**只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。\n\n- **先进先出置换算法：**简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。\n\n- **最近最久未使用算法LRU：**算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。\n\n- **时钟算法clock(也被称为是最近未使用算法NRU)：**页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。\n\n- **改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。\n\n- **最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。\n\n","slug":"操作系统面试相关总结","published":1,"updated":"2018-10-10T08:48:13.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1x1003cfmagd9ijdkgc","content":"<p>参考课程：<a href=\"https://www.bilibili.com/video/av6538245?from=search&amp;seid=2726829833194936883\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">操作系统</a></p><p>参考资料：<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fc.biancheng.net%2Fcpp%2Fu%2Fxitong%2F\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">计算机操作系统教程</a></p><a id=\"more\"></a><hr><h2 id=\"操作系统的四个特性\"><a href=\"#操作系统的四个特性\" class=\"headerlink\" title=\"操作系统的四个特性\"></a>操作系统的四个特性</h2><ul><li><strong>并发</strong>：同一<u>时间段</u>内多个程序执行<ul><li>需要区别并行和并发</li><li>并行为同一<u>时刻</u>多个程序执行</li></ul></li><li><strong>共享</strong>：系统中的资源可以被内存中的多个并发执行的进线程共同使用</li><li><p><strong>虚拟</strong>：通过时分复用和空分复用技术实现把一个物理实体虚拟为多个</p><ul><li>时分复用：如分时系统，就是将提供给整个信道传输信息的事件划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用</li><li>空分复用：如虚拟内存，指让同一个频段在不同的空间内得到重复利用</li></ul></li><li><p><strong>异步</strong>：操作系统允许多个程序并发执行，<u>但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可知的速度向前推进</u></p><ul><li>这导致当操作系统运行在一种随机的环境下时，可能导致进程产生与时间有关的错误</li><li>但只要运行环境相同，操作系统必须保证多次运行进程都获得相同的结果</li></ul></li></ul><h2 id=\"操作系统的主要功能\"><a href=\"#操作系统的主要功能\" class=\"headerlink\" title=\"操作系统的主要功能\"></a>操作系统的主要功能</h2><ul><li><strong>进程管理</strong>：包括进程控制、进程同步、进程通信和进程调度</li><li><strong>内存管理</strong>：包括内存分配、内存保护、地址映射和内存扩充</li><li><p><strong>设备管理</strong>：负责管理各类外围设备（简称：外设），包括分配、启动和故障处理等</p><ul><li>完成用户的IO请求</li><li>为用户进程分配IO设备</li><li>提高IO设备利用率</li><li>提高IO速度</li><li>方便IO的使用</li></ul></li><li><p><strong>文件管理</strong>：管理系统文件和用户文件，方便使用同时保证安全性</p><ul><li>磁盘存储空间管理</li><li>目录管理</li><li>文件读写管理</li><li>文件共享和保护</li></ul></li><li><strong>作业管理</strong>：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制（根据用户的需要控制作业运行的步骤）</li></ul><h2 id=\"进程的状态与转换\"><a href=\"#进程的状态与转换\" class=\"headerlink\" title=\"进程的状态与转换\"></a>进程的状态与转换</h2><p><img src=\"/images/进程状态转换图.jpg\" alt=\"进程状态转换图\"></p><ul><li><strong>新建</strong>： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息</li><li><strong>运行</strong>：当一个进程在处理机上运行时，则称该进程处于运行状态<ul><li>处于此状态的进程的数目小于等于处理器的数目</li><li>对于单处理机系统，处于运行状态的进程只有一个</li><li>在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</li></ul></li><li><strong>就绪</strong>：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个<u>优先级</u>来划分队列:<ul><li>当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列</li><li>当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。</li></ul></li><li><p><strong>阻塞</strong>：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态</p></li><li><p><strong>终止</strong>：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程）</p></li></ul><h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><table><thead><tr><th>方面</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>操作系统资源分配的基本单位</td><td>任务调度和执行的基本单位</td></tr><tr><td>开销方面</td><td>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销</td><td>线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小</td></tr><tr><td>所处环境</td><td>操作系统中多个进程可以并发运行</td><td>同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</td></tr><tr><td>内存分配</td><td>系统在运行时会为每个进程分配不同的内存空间</td><td>除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源</td></tr><tr><td>包含关系</td><td>进程可以包含多个线程，且这些线程可以并发运行</td><td>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</td></tr></tbody></table><h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>进程之间的信息交换。</p><ul><li>共享内存</li><li>信息传递</li><li>管道通信<ul><li>管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件</li><li>向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道</li><li>而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据</li><li>为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在</li></ul></li></ul><h2 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h2><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。</p><p><strong>进程同步</strong>的任务就是对多个相关进程在<u>执行顺序上进行协调</u>，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。</p><p>同步机制需要遵循的原则：</p><ol><li>空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</li><li>忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</li><li>有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</li><li>让权等待：当进程无法进入临界区的时候，需要释放处理机，以免陷入忙等</li></ol><p>经典的进程同步问题：</p><ul><li>生产者-消费者问题</li><li>哲学家进餐问题</li><li>读者-写者问题</li></ul><p>同步的解决方案：</p><ul><li>管程</li><li>信号量</li></ul><h2 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h2><p><img src=\"https://user-gold-cdn.xitu.io/2017/5/22/08d8fe2bdd546e97085f4f1d69281c9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\"></p><p>运行在<strong>用户态</strong>下的程序<strong>不能</strong>直接访问操作系统内核数据结构和程序。</p><p><strong>用户态切换到内核态的3种方式</strong></p><ol><li><strong>系统调用</strong>：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ol><h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>多个进程在运行过程中，因为争夺资源而造成的一种僵局。</p><h3 id=\"死锁原因\"><a href=\"#死锁原因\" class=\"headerlink\" title=\"死锁原因\"></a>死锁原因</h3><ol><li><strong>竞争资源</strong>：请求同一有限资源的进程数多于可用资源数</li><li><strong>进程推进顺序不当</strong>：进程执行中，请求和释放资源顺序不合理，如资源等待链</li></ol><h3 id=\"死锁的四个必要条件\"><a href=\"#死锁的四个必要条件\" class=\"headerlink\" title=\"死锁的四个必要条件\"></a>死锁的四个必要条件</h3><ol><li><strong>互斥</strong>:在一个时间只能有一个进程使用资源</li><li><strong>持有并等待</strong>：进程持有至少一个资源时，等待获取其他进程持有的额外资源</li><li><strong>无抢占</strong>：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li><li><strong>循环等待</strong>：存在进程集合{P0,P1,…,PN}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，PN-1正在等待PN占用的资源，PN正在等待P0占用的资源</li></ol><h3 id=\"死锁处理\"><a href=\"#死锁处理\" class=\"headerlink\" title=\"死锁处理\"></a>死锁处理</h3><ul><li>确保系统永远不会进入死锁状态</li><li>系统可能进入死锁状态，若进入死锁状态则进行恢复</li><li>忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX。</li></ul><ol><li><strong>死锁预防</strong>：破坏产生死锁的4个必要条件中的一个或者多个<ol><li><strong>互斥</strong>：不互斥可能带来不确定性问题</li><li><strong>持有并等待</strong>：让一个资源在请求资源时，不持有任何其他资源。为请求资源的进程分配所有资源；仅当进程不占有资源时才可以请求资源。但是这会导致<u>资源利用率低，还可能发生饥饿</u>。</li><li><strong>无抢占</strong>：抢占资源只能kill掉正在占有资源的进程，不合理</li><li><strong>循环等待</strong>：对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。在<u>嵌入式系统</u>中经常这种方法，因为嵌入式系统资源比较有限</li></ol></li><li><strong>死锁避免</strong>：额外的先行验证<ol><li>最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的<strong>最大数目</strong></li><li>限定<strong>提供与分配</strong>的资源数量和进程的<strong>最大需求</strong></li><li>在进程申请资源时检查资源分配状态来进行资源分配，以确保永远不会有一个环形等待状态</li><li><strong>银行家算法</strong>：死锁避免的著名算法。以银行借贷系统的分配策略为基础，判断并保证系统的安全运行</li></ol></li><li><strong>死锁检测</strong>：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大</li><li><strong>死锁恢复</strong>：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。</li></ol><h2 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h2><ul><li><p><strong>先来先服务调度算法FCFS：</strong>既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</p></li><li><p><strong>短作业优先调度算法SJF：</strong>作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p></li><li><p><strong>高相应比算法HRN：</strong>响应比=(等待时间+要求服务时间)/要求服务时间；</p></li><li><p><strong>时间片轮转调度RR：</strong>按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</p></li><li><p><strong>多级反馈队列调度算法：</strong>目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。</p></li></ul><h2 id=\"内存连续分配\"><a href=\"#内存连续分配\" class=\"headerlink\" title=\"内存连续分配\"></a>内存连续分配</h2><p>动态分区分配时所采用的几种算法。</p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。</p><p>这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</p><p>因此系统中分区的大小和数目是可变的。</p><ul><li><p><strong>首次适应(First Fit)算法：</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</p></li><li><p><strong>最佳适应(Best Fit)算法：</strong>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</p></li><li><p><strong>最坏适应(Worst Fit)算法：</strong>又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</p></li></ul><h2 id=\"基本分页储存管理方式\"><a href=\"#基本分页储存管理方式\" class=\"headerlink\" title=\"基本分页储存管理方式\"></a>基本分页储存管理方式</h2><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。</p><p>每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。</strong></p><p>由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要<strong>两次的内存访问</strong>(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><p>为了减少两次访问内存导致的效率影响，分页管理中引入了<strong>快表机制</strong>，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。</p><p>在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用<strong>两级页表或者多级页表的方法</strong>，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。</p><h2 id=\"基本分段储存管理方式\"><a href=\"#基本分段储存管理方式\" class=\"headerlink\" title=\"基本分段储存管理方式\"></a>基本分段储存管理方式</h2><p>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。</p><p>访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。</p><h2 id=\"分段分页方式的比较\"><a href=\"#分段分页方式的比较\" class=\"headerlink\" title=\"分段分页方式的比较\"></a>分段分页方式的比较</h2><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；</p><p>段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。</p><p>页的大小是固定的，由系统决定；</p><p>段的大小是不确定的，由用户决定。</p><h2 id=\"段页式存储\"><a href=\"#段页式存储\" class=\"headerlink\" title=\"段页式存储\"></a>段页式存储</h2><h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。</p><p>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。</p><p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p><p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p><p>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。</p><h3 id=\"地址变换的过程\"><a href=\"#地址变换的过程\" class=\"headerlink\" title=\"地址变换的过程\"></a>地址变换的过程</h3><ol><li>程序执行时，从PCB（进程控制块）中取出段表始址和段表长度，装入段表寄存器。</li><li>由地址变换机构将逻辑地址自动分成段号、页号和页内地址。</li><li>将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。</li><li>将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。</li><li>取出段描述子得到该段的页表始址和页表长度。</li><li>将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。</li><li>将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。</li><li>取出页描述子得到该页的物理块号。</li><li>对该页的存取控制进行检查。</li><li>将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。</li></ol><h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。</p><p>单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。</p><p>因此可以从逻辑的角度扩充内存容量，即可解决上述两种问题。</p><p>基于局部性原理，<u>在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存</u>，就可以启动程序执行。</p><p>在程序执行过程中，<u>当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序</u>。</p><p>另一方面，操作系统将内存中<u>暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息</u>。</p><p>这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>。</p><p><strong>虚拟存储器</strong>的特征：</p><ol><li><strong>多次性</strong>：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性</li><li><strong>对换性</strong>：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)</li><li><strong>虚拟性</strong>：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上</li></ol><h2 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h2><ul><li><p><strong>最佳置换算法：</strong>只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p></li><li><p><strong>先进先出置换算法：</strong>简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p></li><li><p><strong>最近最久未使用算法LRU：</strong>算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p></li><li><p><strong>时钟算法clock(也被称为是最近未使用算法NRU)：</strong>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p></li><li><p><strong>改进型Clock算法：</strong>在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p></li><li><p><strong>最少使用算法LFU：</strong>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p></li></ul>","site":{"data":{}},"excerpt":"<p>参考课程：<a href=\"https://www.bilibili.com/video/av6538245?from=search&amp;seid=2726829833194936883\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">操作系统</a></p><p>参考资料：<a href=\"https://link.juejin.im/?target=http%3A%2F%2Fc.biancheng.net%2Fcpp%2Fu%2Fxitong%2F\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">计算机操作系统教程</a></p>","more":"<hr><h2 id=\"操作系统的四个特性\"><a href=\"#操作系统的四个特性\" class=\"headerlink\" title=\"操作系统的四个特性\"></a>操作系统的四个特性</h2><ul><li><strong>并发</strong>：同一<u>时间段</u>内多个程序执行<ul><li>需要区别并行和并发</li><li>并行为同一<u>时刻</u>多个程序执行</li></ul></li><li><strong>共享</strong>：系统中的资源可以被内存中的多个并发执行的进线程共同使用</li><li><p><strong>虚拟</strong>：通过时分复用和空分复用技术实现把一个物理实体虚拟为多个</p><ul><li>时分复用：如分时系统，就是将提供给整个信道传输信息的事件划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用</li><li>空分复用：如虚拟内存，指让同一个频段在不同的空间内得到重复利用</li></ul></li><li><p><strong>异步</strong>：操作系统允许多个程序并发执行，<u>但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可知的速度向前推进</u></p><ul><li>这导致当操作系统运行在一种随机的环境下时，可能导致进程产生与时间有关的错误</li><li>但只要运行环境相同，操作系统必须保证多次运行进程都获得相同的结果</li></ul></li></ul><h2 id=\"操作系统的主要功能\"><a href=\"#操作系统的主要功能\" class=\"headerlink\" title=\"操作系统的主要功能\"></a>操作系统的主要功能</h2><ul><li><strong>进程管理</strong>：包括进程控制、进程同步、进程通信和进程调度</li><li><strong>内存管理</strong>：包括内存分配、内存保护、地址映射和内存扩充</li><li><p><strong>设备管理</strong>：负责管理各类外围设备（简称：外设），包括分配、启动和故障处理等</p><ul><li>完成用户的IO请求</li><li>为用户进程分配IO设备</li><li>提高IO设备利用率</li><li>提高IO速度</li><li>方便IO的使用</li></ul></li><li><p><strong>文件管理</strong>：管理系统文件和用户文件，方便使用同时保证安全性</p><ul><li>磁盘存储空间管理</li><li>目录管理</li><li>文件读写管理</li><li>文件共享和保护</li></ul></li><li><strong>作业管理</strong>：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制（根据用户的需要控制作业运行的步骤）</li></ul><h2 id=\"进程的状态与转换\"><a href=\"#进程的状态与转换\" class=\"headerlink\" title=\"进程的状态与转换\"></a>进程的状态与转换</h2><p><img src=\"/images/进程状态转换图.jpg\" alt=\"进程状态转换图\"></p><ul><li><strong>新建</strong>： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息</li><li><strong>运行</strong>：当一个进程在处理机上运行时，则称该进程处于运行状态<ul><li>处于此状态的进程的数目小于等于处理器的数目</li><li>对于单处理机系统，处于运行状态的进程只有一个</li><li>在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</li></ul></li><li><strong>就绪</strong>：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个<u>优先级</u>来划分队列:<ul><li>当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列</li><li>当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。</li></ul></li><li><p><strong>阻塞</strong>：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态</p></li><li><p><strong>终止</strong>：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程）</p></li></ul><h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><table><thead><tr><th>方面</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>操作系统资源分配的基本单位</td><td>任务调度和执行的基本单位</td></tr><tr><td>开销方面</td><td>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销</td><td>线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小</td></tr><tr><td>所处环境</td><td>操作系统中多个进程可以并发运行</td><td>同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</td></tr><tr><td>内存分配</td><td>系统在运行时会为每个进程分配不同的内存空间</td><td>除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源</td></tr><tr><td>包含关系</td><td>进程可以包含多个线程，且这些线程可以并发运行</td><td>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</td></tr></tbody></table><h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>进程之间的信息交换。</p><ul><li>共享内存</li><li>信息传递</li><li>管道通信<ul><li>管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件</li><li>向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道</li><li>而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据</li><li>为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在</li></ul></li></ul><h2 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h2><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。</p><p><strong>进程同步</strong>的任务就是对多个相关进程在<u>执行顺序上进行协调</u>，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。</p><p>同步机制需要遵循的原则：</p><ol><li>空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</li><li>忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</li><li>有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</li><li>让权等待：当进程无法进入临界区的时候，需要释放处理机，以免陷入忙等</li></ol><p>经典的进程同步问题：</p><ul><li>生产者-消费者问题</li><li>哲学家进餐问题</li><li>读者-写者问题</li></ul><p>同步的解决方案：</p><ul><li>管程</li><li>信号量</li></ul><h2 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h2><p><img src=\"https://user-gold-cdn.xitu.io/2017/5/22/08d8fe2bdd546e97085f4f1d69281c9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\"></p><p>运行在<strong>用户态</strong>下的程序<strong>不能</strong>直接访问操作系统内核数据结构和程序。</p><p><strong>用户态切换到内核态的3种方式</strong></p><ol><li><strong>系统调用</strong>：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ol><h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>多个进程在运行过程中，因为争夺资源而造成的一种僵局。</p><h3 id=\"死锁原因\"><a href=\"#死锁原因\" class=\"headerlink\" title=\"死锁原因\"></a>死锁原因</h3><ol><li><strong>竞争资源</strong>：请求同一有限资源的进程数多于可用资源数</li><li><strong>进程推进顺序不当</strong>：进程执行中，请求和释放资源顺序不合理，如资源等待链</li></ol><h3 id=\"死锁的四个必要条件\"><a href=\"#死锁的四个必要条件\" class=\"headerlink\" title=\"死锁的四个必要条件\"></a>死锁的四个必要条件</h3><ol><li><strong>互斥</strong>:在一个时间只能有一个进程使用资源</li><li><strong>持有并等待</strong>：进程持有至少一个资源时，等待获取其他进程持有的额外资源</li><li><strong>无抢占</strong>：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li><li><strong>循环等待</strong>：存在进程集合{P0,P1,…,PN}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，PN-1正在等待PN占用的资源，PN正在等待P0占用的资源</li></ol><h3 id=\"死锁处理\"><a href=\"#死锁处理\" class=\"headerlink\" title=\"死锁处理\"></a>死锁处理</h3><ul><li>确保系统永远不会进入死锁状态</li><li>系统可能进入死锁状态，若进入死锁状态则进行恢复</li><li>忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX。</li></ul><ol><li><strong>死锁预防</strong>：破坏产生死锁的4个必要条件中的一个或者多个<ol><li><strong>互斥</strong>：不互斥可能带来不确定性问题</li><li><strong>持有并等待</strong>：让一个资源在请求资源时，不持有任何其他资源。为请求资源的进程分配所有资源；仅当进程不占有资源时才可以请求资源。但是这会导致<u>资源利用率低，还可能发生饥饿</u>。</li><li><strong>无抢占</strong>：抢占资源只能kill掉正在占有资源的进程，不合理</li><li><strong>循环等待</strong>：对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。在<u>嵌入式系统</u>中经常这种方法，因为嵌入式系统资源比较有限</li></ol></li><li><strong>死锁避免</strong>：额外的先行验证<ol><li>最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的<strong>最大数目</strong></li><li>限定<strong>提供与分配</strong>的资源数量和进程的<strong>最大需求</strong></li><li>在进程申请资源时检查资源分配状态来进行资源分配，以确保永远不会有一个环形等待状态</li><li><strong>银行家算法</strong>：死锁避免的著名算法。以银行借贷系统的分配策略为基础，判断并保证系统的安全运行</li></ol></li><li><strong>死锁检测</strong>：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大</li><li><strong>死锁恢复</strong>：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。</li></ol><h2 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h2><ul><li><p><strong>先来先服务调度算法FCFS：</strong>既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</p></li><li><p><strong>短作业优先调度算法SJF：</strong>作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p></li><li><p><strong>高相应比算法HRN：</strong>响应比=(等待时间+要求服务时间)/要求服务时间；</p></li><li><p><strong>时间片轮转调度RR：</strong>按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</p></li><li><p><strong>多级反馈队列调度算法：</strong>目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。</p></li></ul><h2 id=\"内存连续分配\"><a href=\"#内存连续分配\" class=\"headerlink\" title=\"内存连续分配\"></a>内存连续分配</h2><p>动态分区分配时所采用的几种算法。</p><p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。</p><p>这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</p><p>因此系统中分区的大小和数目是可变的。</p><ul><li><p><strong>首次适应(First Fit)算法：</strong>空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</p></li><li><p><strong>最佳适应(Best Fit)算法：</strong>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</p></li><li><p><strong>最坏适应(Worst Fit)算法：</strong>又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</p></li></ul><h2 id=\"基本分页储存管理方式\"><a href=\"#基本分页储存管理方式\" class=\"headerlink\" title=\"基本分页储存管理方式\"></a>基本分页储存管理方式</h2><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。</p><p>每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。</strong></p><p>由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要<strong>两次的内存访问</strong>(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><p>为了减少两次访问内存导致的效率影响，分页管理中引入了<strong>快表机制</strong>，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。</p><p>在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用<strong>两级页表或者多级页表的方法</strong>，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。</p><h2 id=\"基本分段储存管理方式\"><a href=\"#基本分段储存管理方式\" class=\"headerlink\" title=\"基本分段储存管理方式\"></a>基本分段储存管理方式</h2><p>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。</p><p>访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。</p><h2 id=\"分段分页方式的比较\"><a href=\"#分段分页方式的比较\" class=\"headerlink\" title=\"分段分页方式的比较\"></a>分段分页方式的比较</h2><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；</p><p>段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。</p><p>页的大小是固定的，由系统决定；</p><p>段的大小是不确定的，由用户决定。</p><h2 id=\"段页式存储\"><a href=\"#段页式存储\" class=\"headerlink\" title=\"段页式存储\"></a>段页式存储</h2><h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。</p><p>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。</p><p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p><p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p><p>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。</p><h3 id=\"地址变换的过程\"><a href=\"#地址变换的过程\" class=\"headerlink\" title=\"地址变换的过程\"></a>地址变换的过程</h3><ol><li>程序执行时，从PCB（进程控制块）中取出段表始址和段表长度，装入段表寄存器。</li><li>由地址变换机构将逻辑地址自动分成段号、页号和页内地址。</li><li>将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。</li><li>将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。</li><li>取出段描述子得到该段的页表始址和页表长度。</li><li>将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。</li><li>将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。</li><li>取出页描述子得到该页的物理块号。</li><li>对该页的存取控制进行检查。</li><li>将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。</li></ol><h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。</p><p>单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。</p><p>因此可以从逻辑的角度扩充内存容量，即可解决上述两种问题。</p><p>基于局部性原理，<u>在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存</u>，就可以启动程序执行。</p><p>在程序执行过程中，<u>当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序</u>。</p><p>另一方面，操作系统将内存中<u>暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息</u>。</p><p>这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为<strong>虚拟存储器</strong>。</p><p><strong>虚拟存储器</strong>的特征：</p><ol><li><strong>多次性</strong>：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性</li><li><strong>对换性</strong>：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)</li><li><strong>虚拟性</strong>：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上</li></ol><h2 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h2><ul><li><p><strong>最佳置换算法：</strong>只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p></li><li><p><strong>先进先出置换算法：</strong>简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p></li><li><p><strong>最近最久未使用算法LRU：</strong>算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p></li><li><p><strong>时钟算法clock(也被称为是最近未使用算法NRU)：</strong>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p></li><li><p><strong>改进型Clock算法：</strong>在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p></li><li><p><strong>最少使用算法LFU：</strong>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p></li></ul>"},{"title":"数据库基础知识","toc":true,"date":"2018-09-29T00:36:52.000Z","_content":"\n## 数据库系统\n\n### 数据库系统的组成\n\n数据库系统是由数据库、数据库管理系统、支持数据库运行的软硬件环境、数据库应用软件和数据库管理员组成的。\n\n<!-- more -->\n\n- **数据库**：长期储存在计算机内、有组织的、可共享的大量数据的集合。\n- **数据库管理系统**：DBMS，管理数据库的软件，是用户和数据库之间的接口，负责完成各项数据处理操作：数据定义、数据操纵、数据库运行管理、数据库的建立和维护。\n- **支持数据库运行的软硬件环境**：有足够大的内存来保障数据库系统的运行，操作系统要提供对数据管理系统的支持等。\n- **数据库应用软件**：由用户或第三方软件公司设计的有特殊用途的应用软件，实现用户和数据库管理系统之间的沟通和交流。例如图书管理系统等。\n- **数据库管理员**：Database Administrator，DBA，负责建立、管理和维护数据的人员。主要职责包括：定义并存储数据库的内容、监督并控制数据库的使用、负责数据库的日常维护、必要时重组和改进数据库。\n\n### 数据库的体系结构\n\n#### 数据库三级模式结构\n\n模式是对数据库中全部数据的逻辑结构和特征的描述，仅仅涉及到“型”的描述，不涉及具体的值。\n\n数据库由内模式、模式、外模式三级组成。\n\n![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538195145278&di=af84260b9188b3ec9fa0aa220645c240&imgtype=0&src=http%3A%2F%2Fp.ananas.chaoxing.com%2Fstar3%2Forigin%2F56e827f5e4b0b07fe6cf4581.gif)\n\n- **内模式**：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。\n- **模式**：又称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n- **外模式**：通常是模式的一个子集，又称为子模式。外模式面向的是用户，是用户眼中的数据库，所以外模式又称为用户视图。\n\n#### 三级模式之间的映射\n\n- **外模式/模式间的映射**：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对于同一个模式，可以有任意个外模式。对于每个外模式，数据库系统都有一个外模式/模式之间的映射。\n- **模式/内模式间的映射**：数据库只有唯一的模式和内模式，因此它们之间的映射也是唯一的，这个映射定义了数据库全局逻辑结构和存储结构之间的对应关系。\n\n### 数据模型\n\n#### 概念\n\n数据模型是一种模型，是现实世界数据特征的抽象。\n\n数据模型通常包括数据结构、数据操作和完整性约束三部分。\n\n- **数据结构**：是所研究对象的集合，描述的是数据库结构的组成、特性和其互相之间的联系。数据库系统通常按数据结构的类型来命名数据模型，如关系结构的模型命名为关系模型。\n- **数据操作**：数据库中各种对象的实例允许执行的操作的集合。主要包括检索和维护两大类。\n- **完整性约束**：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。\n\n#### 实体与关系\n\n- **实体**：客观存在并可相互区分的事物，一个实体可以用若干属性来描述。具有相同属性的实体集合称为实体集。\n- **关系**：有一对一、一对多、多对多三种。\n\n#### 常见的数据模型\n\n- **层次模型**：数据结构是一颗有向树，特征是：\n  - 有且仅有一个结点没有父结点，即根结点\n  - 除了根结点，其他结点有且只有一个父结点\n- **网状模型**：结点间可以任意发生关系，特征是：\n  - 可以有一个以上的结点没有父结点\n  - 允许结点有多于一个的父结点\n- **关系模型**：用二维表结构表示实体与实体之间的联系。E-R方法（实体-关系方法）是表示实体与关系的最常用的方法。在E-R图中：\n  - 长方形表示实体\n  - 椭圆表示属性\n  - 菱形表示关系\n  - 关系与实体间用实线连接，并注明关系的类型\n\n![层次模型](http://www.educity.cn/ncre/ncrefx/images/20136256439.png)\n\n![网状模型](http://www.zgdwzp.com/uploadfile/2017/0601/20170601073737760.png)\n\n![关系模型](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538199232122&di=5193ce315374bb598c4c79c6c2f7f53b&imgtype=0&src=http%3A%2F%2Fupload.idcquan.com%2F2015%2F0818%2F1439864300593.jpg)\n\n#### 关系数据库的规范化\n\n为了使数据库设计更加优化，提出了规范化理论。\n\n关系数据库必须满足一定的要求，即满足不同的范式。\n\n在第一范式（1NF）的基础上进一步满足更多要求的称为第二范式（2NF），以此类推。一般来说，数据库只要满足第三范式（3NF）即可。\n\n- **第一范式（1NF）**：无重复的列，**同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性**。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成。\n- **第二范式（2NF）**：先满足1NF，同时要求**属性完全依赖于主键**。\n- **第三范式（3NF）**：先满足2NF，同时要求**不存在传递依赖关系**。","source":"_posts/数据库基础知识.md","raw":"---\ntitle: 数据库基础知识\ntoc: true\ndate: 2018-09-29 08:36:52\ncategories:\n- Web\ntags:\n- 数据库\n---\n\n## 数据库系统\n\n### 数据库系统的组成\n\n数据库系统是由数据库、数据库管理系统、支持数据库运行的软硬件环境、数据库应用软件和数据库管理员组成的。\n\n<!-- more -->\n\n- **数据库**：长期储存在计算机内、有组织的、可共享的大量数据的集合。\n- **数据库管理系统**：DBMS，管理数据库的软件，是用户和数据库之间的接口，负责完成各项数据处理操作：数据定义、数据操纵、数据库运行管理、数据库的建立和维护。\n- **支持数据库运行的软硬件环境**：有足够大的内存来保障数据库系统的运行，操作系统要提供对数据管理系统的支持等。\n- **数据库应用软件**：由用户或第三方软件公司设计的有特殊用途的应用软件，实现用户和数据库管理系统之间的沟通和交流。例如图书管理系统等。\n- **数据库管理员**：Database Administrator，DBA，负责建立、管理和维护数据的人员。主要职责包括：定义并存储数据库的内容、监督并控制数据库的使用、负责数据库的日常维护、必要时重组和改进数据库。\n\n### 数据库的体系结构\n\n#### 数据库三级模式结构\n\n模式是对数据库中全部数据的逻辑结构和特征的描述，仅仅涉及到“型”的描述，不涉及具体的值。\n\n数据库由内模式、模式、外模式三级组成。\n\n![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538195145278&di=af84260b9188b3ec9fa0aa220645c240&imgtype=0&src=http%3A%2F%2Fp.ananas.chaoxing.com%2Fstar3%2Forigin%2F56e827f5e4b0b07fe6cf4581.gif)\n\n- **内模式**：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。\n- **模式**：又称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n- **外模式**：通常是模式的一个子集，又称为子模式。外模式面向的是用户，是用户眼中的数据库，所以外模式又称为用户视图。\n\n#### 三级模式之间的映射\n\n- **外模式/模式间的映射**：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对于同一个模式，可以有任意个外模式。对于每个外模式，数据库系统都有一个外模式/模式之间的映射。\n- **模式/内模式间的映射**：数据库只有唯一的模式和内模式，因此它们之间的映射也是唯一的，这个映射定义了数据库全局逻辑结构和存储结构之间的对应关系。\n\n### 数据模型\n\n#### 概念\n\n数据模型是一种模型，是现实世界数据特征的抽象。\n\n数据模型通常包括数据结构、数据操作和完整性约束三部分。\n\n- **数据结构**：是所研究对象的集合，描述的是数据库结构的组成、特性和其互相之间的联系。数据库系统通常按数据结构的类型来命名数据模型，如关系结构的模型命名为关系模型。\n- **数据操作**：数据库中各种对象的实例允许执行的操作的集合。主要包括检索和维护两大类。\n- **完整性约束**：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。\n\n#### 实体与关系\n\n- **实体**：客观存在并可相互区分的事物，一个实体可以用若干属性来描述。具有相同属性的实体集合称为实体集。\n- **关系**：有一对一、一对多、多对多三种。\n\n#### 常见的数据模型\n\n- **层次模型**：数据结构是一颗有向树，特征是：\n  - 有且仅有一个结点没有父结点，即根结点\n  - 除了根结点，其他结点有且只有一个父结点\n- **网状模型**：结点间可以任意发生关系，特征是：\n  - 可以有一个以上的结点没有父结点\n  - 允许结点有多于一个的父结点\n- **关系模型**：用二维表结构表示实体与实体之间的联系。E-R方法（实体-关系方法）是表示实体与关系的最常用的方法。在E-R图中：\n  - 长方形表示实体\n  - 椭圆表示属性\n  - 菱形表示关系\n  - 关系与实体间用实线连接，并注明关系的类型\n\n![层次模型](http://www.educity.cn/ncre/ncrefx/images/20136256439.png)\n\n![网状模型](http://www.zgdwzp.com/uploadfile/2017/0601/20170601073737760.png)\n\n![关系模型](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1538199232122&di=5193ce315374bb598c4c79c6c2f7f53b&imgtype=0&src=http%3A%2F%2Fupload.idcquan.com%2F2015%2F0818%2F1439864300593.jpg)\n\n#### 关系数据库的规范化\n\n为了使数据库设计更加优化，提出了规范化理论。\n\n关系数据库必须满足一定的要求，即满足不同的范式。\n\n在第一范式（1NF）的基础上进一步满足更多要求的称为第二范式（2NF），以此类推。一般来说，数据库只要满足第三范式（3NF）即可。\n\n- **第一范式（1NF）**：无重复的列，**同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性**。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成。\n- **第二范式（2NF）**：先满足1NF，同时要求**属性完全依赖于主键**。\n- **第三范式（3NF）**：先满足2NF，同时要求**不存在传递依赖关系**。","slug":"数据库基础知识","published":1,"updated":"2018-10-10T08:48:08.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1x3003efmagmfhs1kz3","content":"<h2 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h2><h3 id=\"数据库系统的组成\"><a href=\"#数据库系统的组成\" class=\"headerlink\" title=\"数据库系统的组成\"></a>数据库系统的组成</h3><p>数据库系统是由数据库、数据库管理系统、支持数据库运行的软硬件环境、数据库应用软件和数据库管理员组成的。</p><a id=\"more\"></a><ul><li><strong>数据库</strong>：长期储存在计算机内、有组织的、可共享的大量数据的集合。</li><li><strong>数据库管理系统</strong>：DBMS，管理数据库的软件，是用户和数据库之间的接口，负责完成各项数据处理操作：数据定义、数据操纵、数据库运行管理、数据库的建立和维护。</li><li><strong>支持数据库运行的软硬件环境</strong>：有足够大的内存来保障数据库系统的运行，操作系统要提供对数据管理系统的支持等。</li><li><strong>数据库应用软件</strong>：由用户或第三方软件公司设计的有特殊用途的应用软件，实现用户和数据库管理系统之间的沟通和交流。例如图书管理系统等。</li><li><strong>数据库管理员</strong>：Database Administrator，DBA，负责建立、管理和维护数据的人员。主要职责包括：定义并存储数据库的内容、监督并控制数据库的使用、负责数据库的日常维护、必要时重组和改进数据库。</li></ul><h3 id=\"数据库的体系结构\"><a href=\"#数据库的体系结构\" class=\"headerlink\" title=\"数据库的体系结构\"></a>数据库的体系结构</h3><h4 id=\"数据库三级模式结构\"><a href=\"#数据库三级模式结构\" class=\"headerlink\" title=\"数据库三级模式结构\"></a>数据库三级模式结构</h4><p>模式是对数据库中全部数据的逻辑结构和特征的描述，仅仅涉及到“型”的描述，不涉及具体的值。</p><p>数据库由内模式、模式、外模式三级组成。</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1538195145278&amp;di=af84260b9188b3ec9fa0aa220645c240&amp;imgtype=0&amp;src=http%3A%2F%2Fp.ananas.chaoxing.com%2Fstar3%2Forigin%2F56e827f5e4b0b07fe6cf4581.gif\" alt=\"img\"></p><ul><li><strong>内模式</strong>：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。</li><li><strong>模式</strong>：又称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li><strong>外模式</strong>：通常是模式的一个子集，又称为子模式。外模式面向的是用户，是用户眼中的数据库，所以外模式又称为用户视图。</li></ul><h4 id=\"三级模式之间的映射\"><a href=\"#三级模式之间的映射\" class=\"headerlink\" title=\"三级模式之间的映射\"></a>三级模式之间的映射</h4><ul><li><strong>外模式/模式间的映射</strong>：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对于同一个模式，可以有任意个外模式。对于每个外模式，数据库系统都有一个外模式/模式之间的映射。</li><li><strong>模式/内模式间的映射</strong>：数据库只有唯一的模式和内模式，因此它们之间的映射也是唯一的，这个映射定义了数据库全局逻辑结构和存储结构之间的对应关系。</li></ul><h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>数据模型是一种模型，是现实世界数据特征的抽象。</p><p>数据模型通常包括数据结构、数据操作和完整性约束三部分。</p><ul><li><strong>数据结构</strong>：是所研究对象的集合，描述的是数据库结构的组成、特性和其互相之间的联系。数据库系统通常按数据结构的类型来命名数据模型，如关系结构的模型命名为关系模型。</li><li><strong>数据操作</strong>：数据库中各种对象的实例允许执行的操作的集合。主要包括检索和维护两大类。</li><li><strong>完整性约束</strong>：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。</li></ul><h4 id=\"实体与关系\"><a href=\"#实体与关系\" class=\"headerlink\" title=\"实体与关系\"></a>实体与关系</h4><ul><li><strong>实体</strong>：客观存在并可相互区分的事物，一个实体可以用若干属性来描述。具有相同属性的实体集合称为实体集。</li><li><strong>关系</strong>：有一对一、一对多、多对多三种。</li></ul><h4 id=\"常见的数据模型\"><a href=\"#常见的数据模型\" class=\"headerlink\" title=\"常见的数据模型\"></a>常见的数据模型</h4><ul><li><strong>层次模型</strong>：数据结构是一颗有向树，特征是：<ul><li>有且仅有一个结点没有父结点，即根结点</li><li>除了根结点，其他结点有且只有一个父结点</li></ul></li><li><strong>网状模型</strong>：结点间可以任意发生关系，特征是：<ul><li>可以有一个以上的结点没有父结点</li><li>允许结点有多于一个的父结点</li></ul></li><li><strong>关系模型</strong>：用二维表结构表示实体与实体之间的联系。E-R方法（实体-关系方法）是表示实体与关系的最常用的方法。在E-R图中：<ul><li>长方形表示实体</li><li>椭圆表示属性</li><li>菱形表示关系</li><li>关系与实体间用实线连接，并注明关系的类型</li></ul></li></ul><p><img src=\"http://www.educity.cn/ncre/ncrefx/images/20136256439.png\" alt=\"层次模型\"></p><p><img src=\"http://www.zgdwzp.com/uploadfile/2017/0601/20170601073737760.png\" alt=\"网状模型\"></p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1538199232122&amp;di=5193ce315374bb598c4c79c6c2f7f53b&amp;imgtype=0&amp;src=http%3A%2F%2Fupload.idcquan.com%2F2015%2F0818%2F1439864300593.jpg\" alt=\"关系模型\"></p><h4 id=\"关系数据库的规范化\"><a href=\"#关系数据库的规范化\" class=\"headerlink\" title=\"关系数据库的规范化\"></a>关系数据库的规范化</h4><p>为了使数据库设计更加优化，提出了规范化理论。</p><p>关系数据库必须满足一定的要求，即满足不同的范式。</p><p>在第一范式（1NF）的基础上进一步满足更多要求的称为第二范式（2NF），以此类推。一般来说，数据库只要满足第三范式（3NF）即可。</p><ul><li><strong>第一范式（1NF）</strong>：无重复的列，<strong>同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成。</li><li><strong>第二范式（2NF）</strong>：先满足1NF，同时要求<strong>属性完全依赖于主键</strong>。</li><li><strong>第三范式（3NF）</strong>：先满足2NF，同时要求<strong>不存在传递依赖关系</strong>。</li></ul>","site":{"data":{}},"excerpt":"<h2 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h2><h3 id=\"数据库系统的组成\"><a href=\"#数据库系统的组成\" class=\"headerlink\" title=\"数据库系统的组成\"></a>数据库系统的组成</h3><p>数据库系统是由数据库、数据库管理系统、支持数据库运行的软硬件环境、数据库应用软件和数据库管理员组成的。</p>","more":"<ul><li><strong>数据库</strong>：长期储存在计算机内、有组织的、可共享的大量数据的集合。</li><li><strong>数据库管理系统</strong>：DBMS，管理数据库的软件，是用户和数据库之间的接口，负责完成各项数据处理操作：数据定义、数据操纵、数据库运行管理、数据库的建立和维护。</li><li><strong>支持数据库运行的软硬件环境</strong>：有足够大的内存来保障数据库系统的运行，操作系统要提供对数据管理系统的支持等。</li><li><strong>数据库应用软件</strong>：由用户或第三方软件公司设计的有特殊用途的应用软件，实现用户和数据库管理系统之间的沟通和交流。例如图书管理系统等。</li><li><strong>数据库管理员</strong>：Database Administrator，DBA，负责建立、管理和维护数据的人员。主要职责包括：定义并存储数据库的内容、监督并控制数据库的使用、负责数据库的日常维护、必要时重组和改进数据库。</li></ul><h3 id=\"数据库的体系结构\"><a href=\"#数据库的体系结构\" class=\"headerlink\" title=\"数据库的体系结构\"></a>数据库的体系结构</h3><h4 id=\"数据库三级模式结构\"><a href=\"#数据库三级模式结构\" class=\"headerlink\" title=\"数据库三级模式结构\"></a>数据库三级模式结构</h4><p>模式是对数据库中全部数据的逻辑结构和特征的描述，仅仅涉及到“型”的描述，不涉及具体的值。</p><p>数据库由内模式、模式、外模式三级组成。</p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1538195145278&amp;di=af84260b9188b3ec9fa0aa220645c240&amp;imgtype=0&amp;src=http%3A%2F%2Fp.ananas.chaoxing.com%2Fstar3%2Forigin%2F56e827f5e4b0b07fe6cf4581.gif\" alt=\"img\"></p><ul><li><strong>内模式</strong>：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。</li><li><strong>模式</strong>：又称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li><strong>外模式</strong>：通常是模式的一个子集，又称为子模式。外模式面向的是用户，是用户眼中的数据库，所以外模式又称为用户视图。</li></ul><h4 id=\"三级模式之间的映射\"><a href=\"#三级模式之间的映射\" class=\"headerlink\" title=\"三级模式之间的映射\"></a>三级模式之间的映射</h4><ul><li><strong>外模式/模式间的映射</strong>：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对于同一个模式，可以有任意个外模式。对于每个外模式，数据库系统都有一个外模式/模式之间的映射。</li><li><strong>模式/内模式间的映射</strong>：数据库只有唯一的模式和内模式，因此它们之间的映射也是唯一的，这个映射定义了数据库全局逻辑结构和存储结构之间的对应关系。</li></ul><h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>数据模型是一种模型，是现实世界数据特征的抽象。</p><p>数据模型通常包括数据结构、数据操作和完整性约束三部分。</p><ul><li><strong>数据结构</strong>：是所研究对象的集合，描述的是数据库结构的组成、特性和其互相之间的联系。数据库系统通常按数据结构的类型来命名数据模型，如关系结构的模型命名为关系模型。</li><li><strong>数据操作</strong>：数据库中各种对象的实例允许执行的操作的集合。主要包括检索和维护两大类。</li><li><strong>完整性约束</strong>：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。</li></ul><h4 id=\"实体与关系\"><a href=\"#实体与关系\" class=\"headerlink\" title=\"实体与关系\"></a>实体与关系</h4><ul><li><strong>实体</strong>：客观存在并可相互区分的事物，一个实体可以用若干属性来描述。具有相同属性的实体集合称为实体集。</li><li><strong>关系</strong>：有一对一、一对多、多对多三种。</li></ul><h4 id=\"常见的数据模型\"><a href=\"#常见的数据模型\" class=\"headerlink\" title=\"常见的数据模型\"></a>常见的数据模型</h4><ul><li><strong>层次模型</strong>：数据结构是一颗有向树，特征是：<ul><li>有且仅有一个结点没有父结点，即根结点</li><li>除了根结点，其他结点有且只有一个父结点</li></ul></li><li><strong>网状模型</strong>：结点间可以任意发生关系，特征是：<ul><li>可以有一个以上的结点没有父结点</li><li>允许结点有多于一个的父结点</li></ul></li><li><strong>关系模型</strong>：用二维表结构表示实体与实体之间的联系。E-R方法（实体-关系方法）是表示实体与关系的最常用的方法。在E-R图中：<ul><li>长方形表示实体</li><li>椭圆表示属性</li><li>菱形表示关系</li><li>关系与实体间用实线连接，并注明关系的类型</li></ul></li></ul><p><img src=\"http://www.educity.cn/ncre/ncrefx/images/20136256439.png\" alt=\"层次模型\"></p><p><img src=\"http://www.zgdwzp.com/uploadfile/2017/0601/20170601073737760.png\" alt=\"网状模型\"></p><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1538199232122&amp;di=5193ce315374bb598c4c79c6c2f7f53b&amp;imgtype=0&amp;src=http%3A%2F%2Fupload.idcquan.com%2F2015%2F0818%2F1439864300593.jpg\" alt=\"关系模型\"></p><h4 id=\"关系数据库的规范化\"><a href=\"#关系数据库的规范化\" class=\"headerlink\" title=\"关系数据库的规范化\"></a>关系数据库的规范化</h4><p>为了使数据库设计更加优化，提出了规范化理论。</p><p>关系数据库必须满足一定的要求，即满足不同的范式。</p><p>在第一范式（1NF）的基础上进一步满足更多要求的称为第二范式（2NF），以此类推。一般来说，数据库只要满足第三范式（3NF）即可。</p><ul><li><strong>第一范式（1NF）</strong>：无重复的列，<strong>同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成。</li><li><strong>第二范式（2NF）</strong>：先满足1NF，同时要求<strong>属性完全依赖于主键</strong>。</li><li><strong>第三范式（3NF）</strong>：先满足2NF，同时要求<strong>不存在传递依赖关系</strong>。</li></ul>"},{"title":"智能指针","date":"2018-04-02T07:21:32.000Z","_content":"\n\n\n## 为什么使用动态指针？\n\n在C++中，动态内存的管理是通过一对运算符来完成的：\n\n<!-- more -->\n\n- new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。\n- delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。\n\n这样动态内存的使用就很容易出现问题：\n\n- 忘记释放内存（delete）就会产生内存泄漏的问题。\n- 过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。\n\n为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。\n\n## 什么是智能指针？\n\n智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。\n\n## 智能指针的原理是什么？\n\n资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。\n\n定义一个类来封装资源的分配和释放，在构造函数完成资源的分配\n和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。\n\n在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。\n\n## 常见的智能指针？\n\nC++11提供的两个智能指针为**shared_ptr**和**unique_ptr**，还定义了一个伴随类**weak_ptr**，这三个类都定义在**memory**头文件中。以及C++98引入的使用起来到处是坑的**auto_ptr**。\n\n### shared_ptr（[官方文档](http://en.cppreference.com/w/cpp/memory/shared_ptr)）\n\n>  shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。\n>\n> 每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。\n>\n> shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。\n>\n> 不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。\n\n### unique_ptr\n\n> unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。\n>\n> 相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。\n>\n> unique_ptr指针本身的生命周期：\n>\n> - 从unique_ptr指针创建时开始，直到离开作用域。\n> - 离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。\n>\n> unique_ptr指针与其所指对象的关系：\n>\n> 在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。\n\n### weak_ptr\n\n> weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它**不具有普通指针的行为，没有重载operator*和->**,它的最大作用在于协助shared_ptr工作，**像旁观者那样观测资源的使用情况**。\n>\n> weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。\n>\n> 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。\n>\n> weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。\n\n## 循环引用问题\n\n首先看下面的代码理解什么是循环引用：\n\n```c++\nclass B;\nclass A\n{\npublic:\n　　shared_ptr<B> m_b;\n};\n \nclass B\n{\npublic:\n　　shared_ptr<A> m_a;\n};\n \nvoid test()\n{\n　　shared_ptr<A> a(new A); //new出来的A的引用计数此时为1\n　　shared_ptr<B> b(new B); //new出来的B的引用计数此时为1\n　　a->m_b = b; //B的引用计数增加为2\n　　b->m_a = a; //A的引用计数增加为2\n \n　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放\n　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放\n}\n```\n\n因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）：\n\n```c++\nclass B;\nclass A\n{\npublic:\n　　weak_ptr<B> m_b;\n};\n \nclass B\n{\npublic:\n　　weak_ptr<A> m_a;\n};\n \nvoid test()\n{\n　　shared_ptr<A> a(new A);\n　　shared_ptr<B> b(new B);\n　　a->m_b = b;\n　　b->m_a = a;\n}\n```\n\n### auto_ptr\n\n缺陷：（[参考链接](https://www.zhihu.com/question/37351146/answer/83379043)，来源：知乎，作者：Sen Zhang）\n\n> auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。\n>\n> 例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。\n>\n> 而现在C++11的对move语义的支持，使得这样的资源转移**通常**只会在**必要的场合**发生，例如转移一个临时变量（右值）给某个named variable（左值）\n>\n> 这也就是用unique_ptr代替auto_ptr的原因，\n>\n> 本质上来说，就是unique_ptr禁用了copy，而用move替代。\n\n```c++\nstd::unique_ptr<bar> b0(new bar());\nstd::unique_ptr<bar> b1(std::move(b0));\n```\n\n## 智能指针的实现\n\n```c++\ntemplate <typename T>\nclass SmartPointer {\npublic:\n    //构造函数\n    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){\n        if(p)\n            *_reference_count = 1; \n        else\n            *_reference_count = 0; \n    }\n    //拷贝构造函数\n    SmartPointer(const SmartPointer& src) {\n        if(this!=&src) {\n            _ptr = src._ptr;\n            _reference_count = src._reference_count;\n            (*_reference_count)++;\n        }\n    }\n    //重载赋值操作符\n    SmartPointer& operator=(const SmartPointer& src) {\n        if(_ptr==src._ptr) {\n            return *this;\n        }\n        releaseCount();\n        _ptr = src._ptr;\n        _reference_count = src._reference_count;\n        (*_reference_count)++;\n        return *this;\n    }\n\n    //重载操作符\n    T& operator*() {\n        if(ptr) {\n            return *_ptr;\n        }\n        //throw exception\n    }\n    //重载操作符\n    T* operator->() {\n        if(_ptr) {\n            return _ptr;\n        }\n        //throw exception\n    }\n    //析构函数\n    ~SmartPointer() {\n        if (--(*_reference_count) == 0) {\n            delete _ptr;\n            delete _reference_count;\n        }\n    }\nprivate:\n    T *_ptr;\n    size_t *_reference_count;\n    void releaseCount() {\n        if(_ptr) {\n            (*_reference_count)--;\n            if((*_reference_count)==0) {\n                delete _ptr;\n                delete _reference_count;\n            }    \n        }\n    }\n};\n\nint main() \n{\n    SmartPointer<char> cp1(new char('a'));\n    SmartPointer<char> cp2(cp1);\n    SmartPointer<char> cp3;\n    cp3 = cp2;\n    cp3 = cp1;\n    cp3 = cp3;\n    SmartPointer<char> cp4(new char('b'));\n    cp3 = cp4;\n}\n```\n\n","source":"_posts/智能指针.md","raw":"---\ntitle: 智能指针\ndate: 2018-04-02 15:21:32\ncategories: \n- C/C++\ntags:\n- 指针\n---\n\n\n\n## 为什么使用动态指针？\n\n在C++中，动态内存的管理是通过一对运算符来完成的：\n\n<!-- more -->\n\n- new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。\n- delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。\n\n这样动态内存的使用就很容易出现问题：\n\n- 忘记释放内存（delete）就会产生内存泄漏的问题。\n- 过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。\n\n为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。\n\n## 什么是智能指针？\n\n智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。\n\n## 智能指针的原理是什么？\n\n资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。\n\n定义一个类来封装资源的分配和释放，在构造函数完成资源的分配\n和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。\n\n在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。\n\n## 常见的智能指针？\n\nC++11提供的两个智能指针为**shared_ptr**和**unique_ptr**，还定义了一个伴随类**weak_ptr**，这三个类都定义在**memory**头文件中。以及C++98引入的使用起来到处是坑的**auto_ptr**。\n\n### shared_ptr（[官方文档](http://en.cppreference.com/w/cpp/memory/shared_ptr)）\n\n>  shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。\n>\n> 每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。\n>\n> shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。\n>\n> 不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。\n\n### unique_ptr\n\n> unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。\n>\n> 相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。\n>\n> unique_ptr指针本身的生命周期：\n>\n> - 从unique_ptr指针创建时开始，直到离开作用域。\n> - 离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。\n>\n> unique_ptr指针与其所指对象的关系：\n>\n> 在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。\n\n### weak_ptr\n\n> weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它**不具有普通指针的行为，没有重载operator*和->**,它的最大作用在于协助shared_ptr工作，**像旁观者那样观测资源的使用情况**。\n>\n> weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。\n>\n> 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。\n>\n> weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。\n\n## 循环引用问题\n\n首先看下面的代码理解什么是循环引用：\n\n```c++\nclass B;\nclass A\n{\npublic:\n　　shared_ptr<B> m_b;\n};\n \nclass B\n{\npublic:\n　　shared_ptr<A> m_a;\n};\n \nvoid test()\n{\n　　shared_ptr<A> a(new A); //new出来的A的引用计数此时为1\n　　shared_ptr<B> b(new B); //new出来的B的引用计数此时为1\n　　a->m_b = b; //B的引用计数增加为2\n　　b->m_a = a; //A的引用计数增加为2\n \n　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放\n　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放\n}\n```\n\n因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）：\n\n```c++\nclass B;\nclass A\n{\npublic:\n　　weak_ptr<B> m_b;\n};\n \nclass B\n{\npublic:\n　　weak_ptr<A> m_a;\n};\n \nvoid test()\n{\n　　shared_ptr<A> a(new A);\n　　shared_ptr<B> b(new B);\n　　a->m_b = b;\n　　b->m_a = a;\n}\n```\n\n### auto_ptr\n\n缺陷：（[参考链接](https://www.zhihu.com/question/37351146/answer/83379043)，来源：知乎，作者：Sen Zhang）\n\n> auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。\n>\n> 例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。\n>\n> 而现在C++11的对move语义的支持，使得这样的资源转移**通常**只会在**必要的场合**发生，例如转移一个临时变量（右值）给某个named variable（左值）\n>\n> 这也就是用unique_ptr代替auto_ptr的原因，\n>\n> 本质上来说，就是unique_ptr禁用了copy，而用move替代。\n\n```c++\nstd::unique_ptr<bar> b0(new bar());\nstd::unique_ptr<bar> b1(std::move(b0));\n```\n\n## 智能指针的实现\n\n```c++\ntemplate <typename T>\nclass SmartPointer {\npublic:\n    //构造函数\n    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){\n        if(p)\n            *_reference_count = 1; \n        else\n            *_reference_count = 0; \n    }\n    //拷贝构造函数\n    SmartPointer(const SmartPointer& src) {\n        if(this!=&src) {\n            _ptr = src._ptr;\n            _reference_count = src._reference_count;\n            (*_reference_count)++;\n        }\n    }\n    //重载赋值操作符\n    SmartPointer& operator=(const SmartPointer& src) {\n        if(_ptr==src._ptr) {\n            return *this;\n        }\n        releaseCount();\n        _ptr = src._ptr;\n        _reference_count = src._reference_count;\n        (*_reference_count)++;\n        return *this;\n    }\n\n    //重载操作符\n    T& operator*() {\n        if(ptr) {\n            return *_ptr;\n        }\n        //throw exception\n    }\n    //重载操作符\n    T* operator->() {\n        if(_ptr) {\n            return _ptr;\n        }\n        //throw exception\n    }\n    //析构函数\n    ~SmartPointer() {\n        if (--(*_reference_count) == 0) {\n            delete _ptr;\n            delete _reference_count;\n        }\n    }\nprivate:\n    T *_ptr;\n    size_t *_reference_count;\n    void releaseCount() {\n        if(_ptr) {\n            (*_reference_count)--;\n            if((*_reference_count)==0) {\n                delete _ptr;\n                delete _reference_count;\n            }    \n        }\n    }\n};\n\nint main() \n{\n    SmartPointer<char> cp1(new char('a'));\n    SmartPointer<char> cp2(cp1);\n    SmartPointer<char> cp3;\n    cp3 = cp2;\n    cp3 = cp1;\n    cp3 = cp3;\n    SmartPointer<char> cp4(new char('b'));\n    cp3 = cp4;\n}\n```\n\n","slug":"智能指针","published":1,"updated":"2018-10-10T08:48:03.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1x5003hfmagwo31wlzq","content":"<h2 id=\"为什么使用动态指针？\"><a href=\"#为什么使用动态指针？\" class=\"headerlink\" title=\"为什么使用动态指针？\"></a>为什么使用动态指针？</h2><p>在C++中，动态内存的管理是通过一对运算符来完成的：</p><a id=\"more\"></a><ul><li>new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。</li><li>delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</li></ul><p>这样动态内存的使用就很容易出现问题：</p><ul><li>忘记释放内存（delete）就会产生内存泄漏的问题。</li><li>过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。</li></ul><p>为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。</p><h2 id=\"什么是智能指针？\"><a href=\"#什么是智能指针？\" class=\"headerlink\" title=\"什么是智能指针？\"></a>什么是智能指针？</h2><p>智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。</p><h2 id=\"智能指针的原理是什么？\"><a href=\"#智能指针的原理是什么？\" class=\"headerlink\" title=\"智能指针的原理是什么？\"></a>智能指针的原理是什么？</h2><p>资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。</p><p>定义一个类来封装资源的分配和释放，在构造函数完成资源的分配<br>和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。</p><p>在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。</p><h2 id=\"常见的智能指针？\"><a href=\"#常见的智能指针？\" class=\"headerlink\" title=\"常见的智能指针？\"></a>常见的智能指针？</h2><p>C++11提供的两个智能指针为<strong>shared_ptr</strong>和<strong>unique_ptr</strong>，还定义了一个伴随类<strong>weak_ptr</strong>，这三个类都定义在<strong>memory</strong>头文件中。以及C++98引入的使用起来到处是坑的<strong>auto_ptr</strong>。</p><h3 id=\"shared-ptr（官方文档）\"><a href=\"#shared-ptr（官方文档）\" class=\"headerlink\" title=\"shared_ptr（官方文档）\"></a>shared_ptr（<a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方文档</a>）</h3><blockquote><p>shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。</p><p>每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。</p><p>shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><p>不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。</p></blockquote><h3 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h3><blockquote><p>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p>相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。</p><p>unique_ptr指针本身的生命周期：</p><ul><li>从unique_ptr指针创建时开始，直到离开作用域。</li><li>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</li></ul><p>unique_ptr指针与其所指对象的关系：</p><p>在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p></blockquote><h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><blockquote><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它<strong>不具有普通指针的行为，没有重载operator*和-&gt;</strong>,它的最大作用在于协助shared_ptr工作，<strong>像旁观者那样观测资源的使用情况</strong>。</p><p>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p><p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p></blockquote><h2 id=\"循环引用问题\"><a href=\"#循环引用问题\" class=\"headerlink\" title=\"循环引用问题\"></a>循环引用问题</h2><p>首先看下面的代码理解什么是循环引用：</p><pre class=\" language-c++\"><code class=\"language-c++\">class B;\nclass A\n{\npublic:\n　　shared_ptr<B> m_b;\n};\n\nclass B\n{\npublic:\n　　shared_ptr<A> m_a;\n};\n\nvoid test()\n{\n　　shared_ptr<A> a(new A); //new出来的A的引用计数此时为1\n　　shared_ptr<B> b(new B); //new出来的B的引用计数此时为1\n　　a->m_b = b; //B的引用计数增加为2\n　　b->m_a = a; //A的引用计数增加为2\n\n　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放\n　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放\n}\n</code></pre><p>因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）：</p><pre class=\" language-c++\"><code class=\"language-c++\">class B;\nclass A\n{\npublic:\n　　weak_ptr<B> m_b;\n};\n\nclass B\n{\npublic:\n　　weak_ptr<A> m_a;\n};\n\nvoid test()\n{\n　　shared_ptr<A> a(new A);\n　　shared_ptr<B> b(new B);\n　　a->m_b = b;\n　　b->m_a = a;\n}\n</code></pre><h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><p>缺陷：（<a href=\"https://www.zhihu.com/question/37351146/answer/83379043\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>，来源：知乎，作者：Sen Zhang）</p><blockquote><p>auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。</p><p>例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。</p><p>而现在C++11的对move语义的支持，使得这样的资源转移<strong>通常</strong>只会在<strong>必要的场合</strong>发生，例如转移一个临时变量（右值）给某个named variable（左值）</p><p>这也就是用unique_ptr代替auto_ptr的原因，</p><p>本质上来说，就是unique_ptr禁用了copy，而用move替代。</p></blockquote><pre class=\" language-c++\"><code class=\"language-c++\">std::unique_ptr<bar> b0(new bar());\nstd::unique_ptr<bar> b1(std::move(b0));\n</code></pre><h2 id=\"智能指针的实现\"><a href=\"#智能指针的实现\" class=\"headerlink\" title=\"智能指针的实现\"></a>智能指针的实现</h2><pre class=\" language-c++\"><code class=\"language-c++\">template <typename T>\nclass SmartPointer {\npublic:\n    //构造函数\n    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){\n        if(p)\n            *_reference_count = 1; \n        else\n            *_reference_count = 0; \n    }\n    //拷贝构造函数\n    SmartPointer(const SmartPointer& src) {\n        if(this!=&src) {\n            _ptr = src._ptr;\n            _reference_count = src._reference_count;\n            (*_reference_count)++;\n        }\n    }\n    //重载赋值操作符\n    SmartPointer& operator=(const SmartPointer& src) {\n        if(_ptr==src._ptr) {\n            return *this;\n        }\n        releaseCount();\n        _ptr = src._ptr;\n        _reference_count = src._reference_count;\n        (*_reference_count)++;\n        return *this;\n    }\n\n    //重载操作符\n    T& operator*() {\n        if(ptr) {\n            return *_ptr;\n        }\n        //throw exception\n    }\n    //重载操作符\n    T* operator->() {\n        if(_ptr) {\n            return _ptr;\n        }\n        //throw exception\n    }\n    //析构函数\n    ~SmartPointer() {\n        if (--(*_reference_count) == 0) {\n            delete _ptr;\n            delete _reference_count;\n        }\n    }\nprivate:\n    T *_ptr;\n    size_t *_reference_count;\n    void releaseCount() {\n        if(_ptr) {\n            (*_reference_count)--;\n            if((*_reference_count)==0) {\n                delete _ptr;\n                delete _reference_count;\n            }    \n        }\n    }\n};\n\nint main() \n{\n    SmartPointer<char> cp1(new char('a'));\n    SmartPointer<char> cp2(cp1);\n    SmartPointer<char> cp3;\n    cp3 = cp2;\n    cp3 = cp1;\n    cp3 = cp3;\n    SmartPointer<char> cp4(new char('b'));\n    cp3 = cp4;\n}\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"为什么使用动态指针？\"><a href=\"#为什么使用动态指针？\" class=\"headerlink\" title=\"为什么使用动态指针？\"></a>为什么使用动态指针？</h2><p>在C++中，动态内存的管理是通过一对运算符来完成的：</p>","more":"<ul><li>new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。</li><li>delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</li></ul><p>这样动态内存的使用就很容易出现问题：</p><ul><li>忘记释放内存（delete）就会产生内存泄漏的问题。</li><li>过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。</li></ul><p>为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。</p><h2 id=\"什么是智能指针？\"><a href=\"#什么是智能指针？\" class=\"headerlink\" title=\"什么是智能指针？\"></a>什么是智能指针？</h2><p>智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。</p><h2 id=\"智能指针的原理是什么？\"><a href=\"#智能指针的原理是什么？\" class=\"headerlink\" title=\"智能指针的原理是什么？\"></a>智能指针的原理是什么？</h2><p>资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。</p><p>定义一个类来封装资源的分配和释放，在构造函数完成资源的分配<br>和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。</p><p>在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。</p><h2 id=\"常见的智能指针？\"><a href=\"#常见的智能指针？\" class=\"headerlink\" title=\"常见的智能指针？\"></a>常见的智能指针？</h2><p>C++11提供的两个智能指针为<strong>shared_ptr</strong>和<strong>unique_ptr</strong>，还定义了一个伴随类<strong>weak_ptr</strong>，这三个类都定义在<strong>memory</strong>头文件中。以及C++98引入的使用起来到处是坑的<strong>auto_ptr</strong>。</p><h3 id=\"shared-ptr（官方文档）\"><a href=\"#shared-ptr（官方文档）\" class=\"headerlink\" title=\"shared_ptr（官方文档）\"></a>shared_ptr（<a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方文档</a>）</h3><blockquote><p>shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。</p><p>每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。</p><p>shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><p>不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。</p></blockquote><h3 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h3><blockquote><p>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p>相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。</p><p>unique_ptr指针本身的生命周期：</p><ul><li>从unique_ptr指针创建时开始，直到离开作用域。</li><li>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</li></ul><p>unique_ptr指针与其所指对象的关系：</p><p>在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p></blockquote><h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><blockquote><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它<strong>不具有普通指针的行为，没有重载operator*和-&gt;</strong>,它的最大作用在于协助shared_ptr工作，<strong>像旁观者那样观测资源的使用情况</strong>。</p><p>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p><p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p></blockquote><h2 id=\"循环引用问题\"><a href=\"#循环引用问题\" class=\"headerlink\" title=\"循环引用问题\"></a>循环引用问题</h2><p>首先看下面的代码理解什么是循环引用：</p><pre><code class=\"c++\">class B;\nclass A\n{\npublic:\n　　shared_ptr&lt;B&gt; m_b;\n};\n\nclass B\n{\npublic:\n　　shared_ptr&lt;A&gt; m_a;\n};\n\nvoid test()\n{\n　　shared_ptr&lt;A&gt; a(new A); //new出来的A的引用计数此时为1\n　　shared_ptr&lt;B&gt; b(new B); //new出来的B的引用计数此时为1\n　　a-&gt;m_b = b; //B的引用计数增加为2\n　　b-&gt;m_a = a; //A的引用计数增加为2\n\n　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放\n　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放\n}\n</code></pre><p>因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）：</p><pre><code class=\"c++\">class B;\nclass A\n{\npublic:\n　　weak_ptr&lt;B&gt; m_b;\n};\n\nclass B\n{\npublic:\n　　weak_ptr&lt;A&gt; m_a;\n};\n\nvoid test()\n{\n　　shared_ptr&lt;A&gt; a(new A);\n　　shared_ptr&lt;B&gt; b(new B);\n　　a-&gt;m_b = b;\n　　b-&gt;m_a = a;\n}\n</code></pre><h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><p>缺陷：（<a href=\"https://www.zhihu.com/question/37351146/answer/83379043\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>，来源：知乎，作者：Sen Zhang）</p><blockquote><p>auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。</p><p>例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。</p><p>而现在C++11的对move语义的支持，使得这样的资源转移<strong>通常</strong>只会在<strong>必要的场合</strong>发生，例如转移一个临时变量（右值）给某个named variable（左值）</p><p>这也就是用unique_ptr代替auto_ptr的原因，</p><p>本质上来说，就是unique_ptr禁用了copy，而用move替代。</p></blockquote><pre><code class=\"c++\">std::unique_ptr&lt;bar&gt; b0(new bar());\nstd::unique_ptr&lt;bar&gt; b1(std::move(b0));\n</code></pre><h2 id=\"智能指针的实现\"><a href=\"#智能指针的实现\" class=\"headerlink\" title=\"智能指针的实现\"></a>智能指针的实现</h2><pre><code class=\"c++\">template &lt;typename T&gt;\nclass SmartPointer {\npublic:\n    //构造函数\n    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){\n        if(p)\n            *_reference_count = 1; \n        else\n            *_reference_count = 0; \n    }\n    //拷贝构造函数\n    SmartPointer(const SmartPointer&amp; src) {\n        if(this!=&amp;src) {\n            _ptr = src._ptr;\n            _reference_count = src._reference_count;\n            (*_reference_count)++;\n        }\n    }\n    //重载赋值操作符\n    SmartPointer&amp; operator=(const SmartPointer&amp; src) {\n        if(_ptr==src._ptr) {\n            return *this;\n        }\n        releaseCount();\n        _ptr = src._ptr;\n        _reference_count = src._reference_count;\n        (*_reference_count)++;\n        return *this;\n    }\n\n    //重载操作符\n    T&amp; operator*() {\n        if(ptr) {\n            return *_ptr;\n        }\n        //throw exception\n    }\n    //重载操作符\n    T* operator-&gt;() {\n        if(_ptr) {\n            return _ptr;\n        }\n        //throw exception\n    }\n    //析构函数\n    ~SmartPointer() {\n        if (--(*_reference_count) == 0) {\n            delete _ptr;\n            delete _reference_count;\n        }\n    }\nprivate:\n    T *_ptr;\n    size_t *_reference_count;\n    void releaseCount() {\n        if(_ptr) {\n            (*_reference_count)--;\n            if((*_reference_count)==0) {\n                delete _ptr;\n                delete _reference_count;\n            }    \n        }\n    }\n};\n\nint main() \n{\n    SmartPointer&lt;char&gt; cp1(new char(&#39;a&#39;));\n    SmartPointer&lt;char&gt; cp2(cp1);\n    SmartPointer&lt;char&gt; cp3;\n    cp3 = cp2;\n    cp3 = cp1;\n    cp3 = cp3;\n    SmartPointer&lt;char&gt; cp4(new char(&#39;b&#39;));\n    cp3 = cp4;\n}\n</code></pre>"},{"title":"求包含每个有序数组(共k个)至少一个元素的最小区间","toc":false,"date":"2018-09-22T13:03:22.000Z","_content":"\n> 给定k个**有序**数组, 每个数组有个N个元素，找出一个最小的闭区间，使其包含每个数组中的至少一个元素。 \n>\n> 关于最小区间——\n>\n> 给定两个区间[a,b], [c,d]： \n>\n> 如果 b-a < d-c，则认为[a, b]是更小的区间；\n>\n> 如果 b-a == d-c，且a < c，则认为[a, b]是更小的区间。\n\n不妨设k为3，分别为a,b,c数组且a1<=b1<=c1，当前最小区间长度为INT_MAX\n\n假设三个数组所有元素排序后为：\n\na1,...,b1,...,c1,.....\n\n我们考虑最小的a1，若最小区间包含的a数组的元素为a1，则若[a1,c1]的长度小于当前最小区间长度，更新最小区间长度为c1-a1，\n\n然后我们丢弃a1，因为若最小区间包含的a数组元素为a1，则最小区间一定为[a1,c1]，而我们已经更新了这个长度；若不是a1,则丢弃a1也无关紧要，不影响最后结果。\n\n那么现在我们一直的最小区间长度为c1-a1，三个数组剩下所有元素排序后可能为\n\na2,..,b1,..,c1,...或\n\nb1,..,a2,..c1,...或\n\nb1,..,c1,..a2...\n\n第一种情况就类似于上边讨论的情况，更新最小区间长度为c1-a2，然后丢弃a2。\n\n对于后两种情况，我们考虑最小的b1：\n\n若最小区间包含的b数组的元素为b1，则最小区间包含的一定为b1,c1,a2，我们更新最小区间长度，然后丢弃b1，\n\n若不是b1，则丢弃b1;\n\n这样不断循环地考虑最小值，直到丢弃完了某一个数组的所有值，这样我们的当前最小区间长度就是所求结果。\n\n下边是代码：\n\n```c++\n#include <iostream>\n#include <limits.h>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int k, n;\n    cin>>k>>n;\n    if (k <= 0 || n <= 0) return 0;\n    vector<vector<int> > nums;\n    vector<int> pos;\n    for (int i = 0; i < k; i++) {\n        vector<int> arrayI;\n        int tmp;\n        for (int j = 0; j < n; j++) {\n            cin>>tmp;\n            arrayI.push_back(tmp);\n        }\n        nums.push_back(arrayI);\n        pos.push_back(0);\n    }\n    int minLength = INT_MAX;\n    int realMin, realMax;\n    while (true) {\n        int arrayOfLeastNum = -1;\n        int tmpMin = INT_MAX;\n        int tmpMax = INT_MIN;\n        for (int i = 0; i < k; i++) {\n            if (nums[i][pos[i]] < tmpMin) {\n                tmpMin = nums[i][pos[i]];\n                arrayOfLeastNum = i;\n            }\n            if (nums[i][pos[i]] > tmpMax) {\n                tmpMax = nums[i][pos[i]];\n            }\n        }\n        if (tmpMax - tmpMin < minLength) {\n            minLength = tmpMax - tmpMin;\n            realMin = tmpMin, realMax = tmpMax;\n        }\n        if (++pos[arrayOfLeastNum] >= n) break;\n    }\n    cout<<realMin<<' '<<realMax;\n    return 0;\n}\n```\n\n但是，这个只能过90%:\n\n> 运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。\n> case通过率为90.00%\n\n看了一下题下的讨论，可以用一个优先队列（priority_queue，一个STL）或自己实现一个最小堆来维护“当前最小区间队列”，这样查找当前的最大值和最小值就是O(logn)而不是O(n)\n\n下边帖一下别人的代码：\n\n```c++\n链接：https://www.nowcoder.com/questionTerminal/0399d363fb594970bae7ad8a3978f86a\n来源：牛客网\n\n//思路2，用优先队列去实现多路归并\n \n#include<bits/stdc++.h>\nusing namespace std;\nstruct pt{\n    int x;\n    int pos;\n    pt(int a,int b):x(a),pos(b){}\n};\nstruct cmp{        //重写比较函数\n    bool operator()(const pt a,const pt b){\n        return a.x>b.x;\n    }\n};\nint main(){\n    int k,n;\n    while(cin>>k>>n){\n        vector<vector<pt>>all;\n        vector<int> vec;\n        for(int i = 0;i<k;i++){\n            vector<pt>temp;\n            for(int j = 0;j<n;j++){\n                int x;\n                cin>>x;\n                pt p(x,i);\n                temp.push_back(p);\n            }\n            all.push_back(temp);\n            vec.push_back(0);\n        }\n        vector<pt> sort;\n        priority_queue<pt,vector<pt>,cmp> qu; //优先队列\n        for(int i = 0;i<k;i++)\n            qu.push(all[i][0]);\n        while(!qu.empty()){\n            pt temp = qu.top();\n            qu.pop();\n            sort.push_back(temp);\n            vec[temp.pos]++;\n            if(vec[temp.pos]<=n-1){\n                qu.push(all[temp.pos][vec[temp.pos]]);\n            }\n        }\n        for(int i = 0;i<vec.size();i++)\n            vec[i] = 0;\n        int begin = 0;\n        int end = 0;\n        int start = 0;\n        int final = 0;\n        int length = INT_MAX;\n        bool flg = false;\n        vec[sort[0].pos]++;\n        while(begin<sort.size()-1||end<sort.size()-1){\n            bool flgg = true;\n            for(int i = 0;i<k;i++)\n                flgg = flgg&&(vec[i]>=1);\n            if(!flgg&&end<sort.size()){\n                if(end<sort.size()-1)\n                    end++;\n                vec[sort[end].pos]++;\n            }\n            if(!flgg&&end==sort.size()-1)\n                break;\n            if(flgg&&begin<sort.size()){\n                int x = sort[end].x-sort[begin].x;\n                if(x<length){\n                    start = sort[begin].x;\n                    final = sort[end].x;\n                    length = x;\n                }\n                vec[sort[begin].pos]--;\n                if(begin<sort.size()-1)\n                    begin++;\n            }\n            int a = 1;\n        }\n        cout<<start<<\" \"<<final<<endl;\n    }\n    system(\"pause\");\n    return 0;\n}\n```","source":"_posts/求包含每个有序数组-共k个-至少一个元素的最小区间.md","raw":"---\ntitle: 求包含每个有序数组(共k个)至少一个元素的最小区间\ntoc: false\ndate: 2018-09-22 21:03:22\ncategories:\n- OJ\ntags:\n- 归并\n---\n\n> 给定k个**有序**数组, 每个数组有个N个元素，找出一个最小的闭区间，使其包含每个数组中的至少一个元素。 \n>\n> 关于最小区间——\n>\n> 给定两个区间[a,b], [c,d]： \n>\n> 如果 b-a < d-c，则认为[a, b]是更小的区间；\n>\n> 如果 b-a == d-c，且a < c，则认为[a, b]是更小的区间。\n\n不妨设k为3，分别为a,b,c数组且a1<=b1<=c1，当前最小区间长度为INT_MAX\n\n假设三个数组所有元素排序后为：\n\na1,...,b1,...,c1,.....\n\n我们考虑最小的a1，若最小区间包含的a数组的元素为a1，则若[a1,c1]的长度小于当前最小区间长度，更新最小区间长度为c1-a1，\n\n然后我们丢弃a1，因为若最小区间包含的a数组元素为a1，则最小区间一定为[a1,c1]，而我们已经更新了这个长度；若不是a1,则丢弃a1也无关紧要，不影响最后结果。\n\n那么现在我们一直的最小区间长度为c1-a1，三个数组剩下所有元素排序后可能为\n\na2,..,b1,..,c1,...或\n\nb1,..,a2,..c1,...或\n\nb1,..,c1,..a2...\n\n第一种情况就类似于上边讨论的情况，更新最小区间长度为c1-a2，然后丢弃a2。\n\n对于后两种情况，我们考虑最小的b1：\n\n若最小区间包含的b数组的元素为b1，则最小区间包含的一定为b1,c1,a2，我们更新最小区间长度，然后丢弃b1，\n\n若不是b1，则丢弃b1;\n\n这样不断循环地考虑最小值，直到丢弃完了某一个数组的所有值，这样我们的当前最小区间长度就是所求结果。\n\n下边是代码：\n\n```c++\n#include <iostream>\n#include <limits.h>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int k, n;\n    cin>>k>>n;\n    if (k <= 0 || n <= 0) return 0;\n    vector<vector<int> > nums;\n    vector<int> pos;\n    for (int i = 0; i < k; i++) {\n        vector<int> arrayI;\n        int tmp;\n        for (int j = 0; j < n; j++) {\n            cin>>tmp;\n            arrayI.push_back(tmp);\n        }\n        nums.push_back(arrayI);\n        pos.push_back(0);\n    }\n    int minLength = INT_MAX;\n    int realMin, realMax;\n    while (true) {\n        int arrayOfLeastNum = -1;\n        int tmpMin = INT_MAX;\n        int tmpMax = INT_MIN;\n        for (int i = 0; i < k; i++) {\n            if (nums[i][pos[i]] < tmpMin) {\n                tmpMin = nums[i][pos[i]];\n                arrayOfLeastNum = i;\n            }\n            if (nums[i][pos[i]] > tmpMax) {\n                tmpMax = nums[i][pos[i]];\n            }\n        }\n        if (tmpMax - tmpMin < minLength) {\n            minLength = tmpMax - tmpMin;\n            realMin = tmpMin, realMax = tmpMax;\n        }\n        if (++pos[arrayOfLeastNum] >= n) break;\n    }\n    cout<<realMin<<' '<<realMax;\n    return 0;\n}\n```\n\n但是，这个只能过90%:\n\n> 运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。\n> case通过率为90.00%\n\n看了一下题下的讨论，可以用一个优先队列（priority_queue，一个STL）或自己实现一个最小堆来维护“当前最小区间队列”，这样查找当前的最大值和最小值就是O(logn)而不是O(n)\n\n下边帖一下别人的代码：\n\n```c++\n链接：https://www.nowcoder.com/questionTerminal/0399d363fb594970bae7ad8a3978f86a\n来源：牛客网\n\n//思路2，用优先队列去实现多路归并\n \n#include<bits/stdc++.h>\nusing namespace std;\nstruct pt{\n    int x;\n    int pos;\n    pt(int a,int b):x(a),pos(b){}\n};\nstruct cmp{        //重写比较函数\n    bool operator()(const pt a,const pt b){\n        return a.x>b.x;\n    }\n};\nint main(){\n    int k,n;\n    while(cin>>k>>n){\n        vector<vector<pt>>all;\n        vector<int> vec;\n        for(int i = 0;i<k;i++){\n            vector<pt>temp;\n            for(int j = 0;j<n;j++){\n                int x;\n                cin>>x;\n                pt p(x,i);\n                temp.push_back(p);\n            }\n            all.push_back(temp);\n            vec.push_back(0);\n        }\n        vector<pt> sort;\n        priority_queue<pt,vector<pt>,cmp> qu; //优先队列\n        for(int i = 0;i<k;i++)\n            qu.push(all[i][0]);\n        while(!qu.empty()){\n            pt temp = qu.top();\n            qu.pop();\n            sort.push_back(temp);\n            vec[temp.pos]++;\n            if(vec[temp.pos]<=n-1){\n                qu.push(all[temp.pos][vec[temp.pos]]);\n            }\n        }\n        for(int i = 0;i<vec.size();i++)\n            vec[i] = 0;\n        int begin = 0;\n        int end = 0;\n        int start = 0;\n        int final = 0;\n        int length = INT_MAX;\n        bool flg = false;\n        vec[sort[0].pos]++;\n        while(begin<sort.size()-1||end<sort.size()-1){\n            bool flgg = true;\n            for(int i = 0;i<k;i++)\n                flgg = flgg&&(vec[i]>=1);\n            if(!flgg&&end<sort.size()){\n                if(end<sort.size()-1)\n                    end++;\n                vec[sort[end].pos]++;\n            }\n            if(!flgg&&end==sort.size()-1)\n                break;\n            if(flgg&&begin<sort.size()){\n                int x = sort[end].x-sort[begin].x;\n                if(x<length){\n                    start = sort[begin].x;\n                    final = sort[end].x;\n                    length = x;\n                }\n                vec[sort[begin].pos]--;\n                if(begin<sort.size()-1)\n                    begin++;\n            }\n            int a = 1;\n        }\n        cout<<start<<\" \"<<final<<endl;\n    }\n    system(\"pause\");\n    return 0;\n}\n```","slug":"求包含每个有序数组-共k个-至少一个元素的最小区间","published":1,"updated":"2018-10-10T08:47:40.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1x6003kfmag1gsj0r59","content":"<blockquote><p>给定k个<strong>有序</strong>数组, 每个数组有个N个元素，找出一个最小的闭区间，使其包含每个数组中的至少一个元素。</p><p>关于最小区间——</p><p>给定两个区间[a,b], [c,d]：</p><p>如果 b-a &lt; d-c，则认为[a, b]是更小的区间；</p><p>如果 b-a == d-c，且a &lt; c，则认为[a, b]是更小的区间。</p></blockquote><p>不妨设k为3，分别为a,b,c数组且a1&lt;=b1&lt;=c1，当前最小区间长度为INT_MAX</p><p>假设三个数组所有元素排序后为：</p><p>a1,…,b1,…,c1,…..</p><p>我们考虑最小的a1，若最小区间包含的a数组的元素为a1，则若[a1,c1]的长度小于当前最小区间长度，更新最小区间长度为c1-a1，</p><p>然后我们丢弃a1，因为若最小区间包含的a数组元素为a1，则最小区间一定为[a1,c1]，而我们已经更新了这个长度；若不是a1,则丢弃a1也无关紧要，不影响最后结果。</p><p>那么现在我们一直的最小区间长度为c1-a1，三个数组剩下所有元素排序后可能为</p><p>a2,..,b1,..,c1,…或</p><p>b1,..,a2,..c1,…或</p><p>b1,..,c1,..a2…</p><p>第一种情况就类似于上边讨论的情况，更新最小区间长度为c1-a2，然后丢弃a2。</p><p>对于后两种情况，我们考虑最小的b1：</p><p>若最小区间包含的b数组的元素为b1，则最小区间包含的一定为b1,c1,a2，我们更新最小区间长度，然后丢弃b1，</p><p>若不是b1，则丢弃b1;</p><p>这样不断循环地考虑最小值，直到丢弃完了某一个数组的所有值，这样我们的当前最小区间长度就是所求结果。</p><p>下边是代码：</p><pre class=\" language-c++\"><code class=\"language-c++\">#include <iostream>\n#include <limits.h>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int k, n;\n    cin>>k>>n;\n    if (k <= 0 || n <= 0) return 0;\n    vector<vector<int> > nums;\n    vector<int> pos;\n    for (int i = 0; i < k; i++) {\n        vector<int> arrayI;\n        int tmp;\n        for (int j = 0; j < n; j++) {\n            cin>>tmp;\n            arrayI.push_back(tmp);\n        }\n        nums.push_back(arrayI);\n        pos.push_back(0);\n    }\n    int minLength = INT_MAX;\n    int realMin, realMax;\n    while (true) {\n        int arrayOfLeastNum = -1;\n        int tmpMin = INT_MAX;\n        int tmpMax = INT_MIN;\n        for (int i = 0; i < k; i++) {\n            if (nums[i][pos[i]] < tmpMin) {\n                tmpMin = nums[i][pos[i]];\n                arrayOfLeastNum = i;\n            }\n            if (nums[i][pos[i]] > tmpMax) {\n                tmpMax = nums[i][pos[i]];\n            }\n        }\n        if (tmpMax - tmpMin < minLength) {\n            minLength = tmpMax - tmpMin;\n            realMin = tmpMin, realMax = tmpMax;\n        }\n        if (++pos[arrayOfLeastNum] >= n) break;\n    }\n    cout<<realMin<<' '<<realMax;\n    return 0;\n}\n</code></pre><p>但是，这个只能过90%:</p><blockquote><p>运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。<br>case通过率为90.00%</p></blockquote><p>看了一下题下的讨论，可以用一个优先队列（priority_queue，一个STL）或自己实现一个最小堆来维护“当前最小区间队列”，这样查找当前的最大值和最小值就是O(logn)而不是O(n)</p><p>下边帖一下别人的代码：</p><pre class=\" language-c++\"><code class=\"language-c++\">链接：https://www.nowcoder.com/questionTerminal/0399d363fb594970bae7ad8a3978f86a\n来源：牛客网\n\n//思路2，用优先队列去实现多路归并\n\n#include<bits/stdc++.h>\nusing namespace std;\nstruct pt{\n    int x;\n    int pos;\n    pt(int a,int b):x(a),pos(b){}\n};\nstruct cmp{        //重写比较函数\n    bool operator()(const pt a,const pt b){\n        return a.x>b.x;\n    }\n};\nint main(){\n    int k,n;\n    while(cin>>k>>n){\n        vector<vector<pt>>all;\n        vector<int> vec;\n        for(int i = 0;i<k;i++){\n            vector<pt>temp;\n            for(int j = 0;j<n;j++){\n                int x;\n                cin>>x;\n                pt p(x,i);\n                temp.push_back(p);\n            }\n            all.push_back(temp);\n            vec.push_back(0);\n        }\n        vector<pt> sort;\n        priority_queue<pt,vector<pt>,cmp> qu; //优先队列\n        for(int i = 0;i<k;i++)\n            qu.push(all[i][0]);\n        while(!qu.empty()){\n            pt temp = qu.top();\n            qu.pop();\n            sort.push_back(temp);\n            vec[temp.pos]++;\n            if(vec[temp.pos]<=n-1){\n                qu.push(all[temp.pos][vec[temp.pos]]);\n            }\n        }\n        for(int i = 0;i<vec.size();i++)\n            vec[i] = 0;\n        int begin = 0;\n        int end = 0;\n        int start = 0;\n        int final = 0;\n        int length = INT_MAX;\n        bool flg = false;\n        vec[sort[0].pos]++;\n        while(begin<sort.size()-1||end<sort.size()-1){\n            bool flgg = true;\n            for(int i = 0;i<k;i++)\n                flgg = flgg&&(vec[i]>=1);\n            if(!flgg&&end<sort.size()){\n                if(end<sort.size()-1)\n                    end++;\n                vec[sort[end].pos]++;\n            }\n            if(!flgg&&end==sort.size()-1)\n                break;\n            if(flgg&&begin<sort.size()){\n                int x = sort[end].x-sort[begin].x;\n                if(x<length){\n                    start = sort[begin].x;\n                    final = sort[end].x;\n                    length = x;\n                }\n                vec[sort[begin].pos]--;\n                if(begin<sort.size()-1)\n                    begin++;\n            }\n            int a = 1;\n        }\n        cout<<start<<\" \"<<final<<endl;\n    }\n    system(\"pause\");\n    return 0;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote><p>给定k个<strong>有序</strong>数组, 每个数组有个N个元素，找出一个最小的闭区间，使其包含每个数组中的至少一个元素。</p><p>关于最小区间——</p><p>给定两个区间[a,b], [c,d]：</p><p>如果 b-a &lt; d-c，则认为[a, b]是更小的区间；</p><p>如果 b-a == d-c，且a &lt; c，则认为[a, b]是更小的区间。</p></blockquote><p>不妨设k为3，分别为a,b,c数组且a1&lt;=b1&lt;=c1，当前最小区间长度为INT_MAX</p><p>假设三个数组所有元素排序后为：</p><p>a1,…,b1,…,c1,…..</p><p>我们考虑最小的a1，若最小区间包含的a数组的元素为a1，则若[a1,c1]的长度小于当前最小区间长度，更新最小区间长度为c1-a1，</p><p>然后我们丢弃a1，因为若最小区间包含的a数组元素为a1，则最小区间一定为[a1,c1]，而我们已经更新了这个长度；若不是a1,则丢弃a1也无关紧要，不影响最后结果。</p><p>那么现在我们一直的最小区间长度为c1-a1，三个数组剩下所有元素排序后可能为</p><p>a2,..,b1,..,c1,…或</p><p>b1,..,a2,..c1,…或</p><p>b1,..,c1,..a2…</p><p>第一种情况就类似于上边讨论的情况，更新最小区间长度为c1-a2，然后丢弃a2。</p><p>对于后两种情况，我们考虑最小的b1：</p><p>若最小区间包含的b数组的元素为b1，则最小区间包含的一定为b1,c1,a2，我们更新最小区间长度，然后丢弃b1，</p><p>若不是b1，则丢弃b1;</p><p>这样不断循环地考虑最小值，直到丢弃完了某一个数组的所有值，这样我们的当前最小区间长度就是所求结果。</p><p>下边是代码：</p><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;limits.h&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int k, n;\n    cin&gt;&gt;k&gt;&gt;n;\n    if (k &lt;= 0 || n &lt;= 0) return 0;\n    vector&lt;vector&lt;int&gt; &gt; nums;\n    vector&lt;int&gt; pos;\n    for (int i = 0; i &lt; k; i++) {\n        vector&lt;int&gt; arrayI;\n        int tmp;\n        for (int j = 0; j &lt; n; j++) {\n            cin&gt;&gt;tmp;\n            arrayI.push_back(tmp);\n        }\n        nums.push_back(arrayI);\n        pos.push_back(0);\n    }\n    int minLength = INT_MAX;\n    int realMin, realMax;\n    while (true) {\n        int arrayOfLeastNum = -1;\n        int tmpMin = INT_MAX;\n        int tmpMax = INT_MIN;\n        for (int i = 0; i &lt; k; i++) {\n            if (nums[i][pos[i]] &lt; tmpMin) {\n                tmpMin = nums[i][pos[i]];\n                arrayOfLeastNum = i;\n            }\n            if (nums[i][pos[i]] &gt; tmpMax) {\n                tmpMax = nums[i][pos[i]];\n            }\n        }\n        if (tmpMax - tmpMin &lt; minLength) {\n            minLength = tmpMax - tmpMin;\n            realMin = tmpMin, realMax = tmpMax;\n        }\n        if (++pos[arrayOfLeastNum] &gt;= n) break;\n    }\n    cout&lt;&lt;realMin&lt;&lt;&#39; &#39;&lt;&lt;realMax;\n    return 0;\n}\n</code></pre><p>但是，这个只能过90%:</p><blockquote><p>运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。<br>case通过率为90.00%</p></blockquote><p>看了一下题下的讨论，可以用一个优先队列（priority_queue，一个STL）或自己实现一个最小堆来维护“当前最小区间队列”，这样查找当前的最大值和最小值就是O(logn)而不是O(n)</p><p>下边帖一下别人的代码：</p><pre><code class=\"c++\">链接：https://www.nowcoder.com/questionTerminal/0399d363fb594970bae7ad8a3978f86a\n来源：牛客网\n\n//思路2，用优先队列去实现多路归并\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct pt{\n    int x;\n    int pos;\n    pt(int a,int b):x(a),pos(b){}\n};\nstruct cmp{        //重写比较函数\n    bool operator()(const pt a,const pt b){\n        return a.x&gt;b.x;\n    }\n};\nint main(){\n    int k,n;\n    while(cin&gt;&gt;k&gt;&gt;n){\n        vector&lt;vector&lt;pt&gt;&gt;all;\n        vector&lt;int&gt; vec;\n        for(int i = 0;i&lt;k;i++){\n            vector&lt;pt&gt;temp;\n            for(int j = 0;j&lt;n;j++){\n                int x;\n                cin&gt;&gt;x;\n                pt p(x,i);\n                temp.push_back(p);\n            }\n            all.push_back(temp);\n            vec.push_back(0);\n        }\n        vector&lt;pt&gt; sort;\n        priority_queue&lt;pt,vector&lt;pt&gt;,cmp&gt; qu; //优先队列\n        for(int i = 0;i&lt;k;i++)\n            qu.push(all[i][0]);\n        while(!qu.empty()){\n            pt temp = qu.top();\n            qu.pop();\n            sort.push_back(temp);\n            vec[temp.pos]++;\n            if(vec[temp.pos]&lt;=n-1){\n                qu.push(all[temp.pos][vec[temp.pos]]);\n            }\n        }\n        for(int i = 0;i&lt;vec.size();i++)\n            vec[i] = 0;\n        int begin = 0;\n        int end = 0;\n        int start = 0;\n        int final = 0;\n        int length = INT_MAX;\n        bool flg = false;\n        vec[sort[0].pos]++;\n        while(begin&lt;sort.size()-1||end&lt;sort.size()-1){\n            bool flgg = true;\n            for(int i = 0;i&lt;k;i++)\n                flgg = flgg&amp;&amp;(vec[i]&gt;=1);\n            if(!flgg&amp;&amp;end&lt;sort.size()){\n                if(end&lt;sort.size()-1)\n                    end++;\n                vec[sort[end].pos]++;\n            }\n            if(!flgg&amp;&amp;end==sort.size()-1)\n                break;\n            if(flgg&amp;&amp;begin&lt;sort.size()){\n                int x = sort[end].x-sort[begin].x;\n                if(x&lt;length){\n                    start = sort[begin].x;\n                    final = sort[end].x;\n                    length = x;\n                }\n                vec[sort[begin].pos]--;\n                if(begin&lt;sort.size()-1)\n                    begin++;\n            }\n            int a = 1;\n        }\n        cout&lt;&lt;start&lt;&lt;&quot; &quot;&lt;&lt;final&lt;&lt;endl;\n    }\n    system(&quot;pause&quot;);\n    return 0;\n}\n</code></pre>"},{"title":"深度学习周报week01&week02","date":"2018-03-30T14:16:12.000Z","toc":true,"_content":"\n\n\n# Week1\n\n## 配置Cuda、Cudnn和Tensorflow\n\n要注意**版本对应**\n\n<!-- more -->\n\n## 学习基础知识\n\n### [神经网络基本原理](http://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n\n#### 感知器\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071202.png)\n一个圆圈表示一个感知器，x1、x2、x3...为输入，output为对应的输出。为了简化问题，output只取0或1.\n\n#### 权重和阈值\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071203.png)\nthreshold为阈值，xi为输入，wi为对应的权重，表示输入的重要性。\n\n#### 矢量化\n\n- 将输入x1,x2,x3,...写为矢量**x**: < x1,x2,x3,... >\n- 将权重w1,w2,w3,...写为矢量**w**: < w1,w2,w3,... >\n- 则 **w·x** = ∑ wx\n- 设 b 等于负的阈值 b = -threshold\n  ![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071206.png)\n\n#### 实际的决策模型\n\n多个感知器组成的多层网络：\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png)\n\n#### 神经网络的运作过程\n\n- 确定输入和输出\n- 找到一种或多种算法，可以从输入得到输出（决定决策模型）\n- 找到一组已知答案的数据集，用来训练模型，估算w和b\n  **估算w和b：试错法**\n  首先获取一组随机的**w**和**x**，将**w**（或**b**）进行微小变动，记作**Δw**（或**Δb**），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组**w**和**b**，就是我们要的值。这个过程称为**模型的训练**。\n- 一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正\n\n#### 输出的连续性\n\n为了保证能观察到**w**和**b**的微小变化对结果造成的影响，必须将\"输出\"改造成一个连续性函数。一般使用**sigmoid**函数。\n\n- 将output记为z：`z = wx + b` \n- 则结果的sigmoid函数为σ(z)：`σ(z) = 1 / (1 + e^(-z))`\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071209.png)\n实际上，Δσ满足下面的公式：\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png)\n即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。\n\n### 反向传播（BP）\n\n- 即估算**w**和**b**的**试错法**的具体实现。\n- 反向传播算法主要由两个过程（**激励传播、权重更新**）反复循环迭代，直到结果误差在可容忍的限度结束。\n\n#### 激励传播\n\n每次迭代中的传播环节包含两步：\n\n1. 前向传播阶段——按照当前**w**和**b**计算**output（激励响应）**；\n2. 反向传播阶段——将**output**和目标输出求差，从而获得隐层和输出层的**响应误差**。\n\n#### 权重更新\n\n对于每个权重 **wi **，按照以下步骤进行更新：\n\n1. 将**输入激励**和**响应误差**相乘，从而获得权重的**梯度**；\n2. 将这个梯度乘上一个比例并取反后加到权重上。\n3. 这个比例将会影响到训练过程的速度和效果，因此称为“**训练因子**”。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。\n\n<u>关于算法推导（**梯度下降+链式求导**），网上的博客质量良莠不齐，因此打算等买的书到了之后再研究一下，这里就不再列出。</u>\n\n### 卷积神经网络（CNN）\n\n- **卷积神经网络**由三部分构成：\n  - 第一部分是输入层。\n  - 第二部分由n个卷积层和池化层的组合组成。\n  - 第三部分由一个全连结的多层感知机分类器构成。\n- **卷积神经网络**与**普通神经网络**的区别在于，卷积神经网络包含了一个特征抽取器（即第二部分）。\n- **卷积神经网络**的卷积层中，一个神经元只和部分邻层神经元连接。\n- 在每一个**卷积层**中，通常包含若干个**特征平面(feature map)，**每个特征平面由一些**矩形排列**的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是**卷积核**。\n- **卷积核**一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将通过学习得到合理的权值（**反向传播**）。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接（**减少参数**），同时又降低了**过拟合**（参数过多导致）的风险。\n- **子采样**也叫做池化（pooling），也可以认为是下采样，通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。\n\n<u>与**普通的神经网络**相比，包含**卷积和子采样**的**卷积神经网络**大大**简化了模型复杂度，减少了模型的参数**。</u>\n\n#### **局部连接**\n\n假设一张图大小为n1\\*n2，一个卷积核的大小为m1\\*m2，对于卷积后生成的每一个数据xi，它都是原图中对应位置的m1\\*m2矩阵和这个卷积核对应点相乘求和得到的。\n\n也就是说xi只和原图中对应的m1\\*m2的那个矩阵中的元素连接，而不是和整张图的n1\\*n2个元素连接。\n\n因此局部连接使得参数数量变为全连接的（m1\\*m2）/（n1\\*n2）。\n\n#### 权值共享\n\n即对于一个卷积核遍历原数据矩阵，生成的一个新的数据矩阵的每一个元素来说，它们的权值都为这个卷积核。\n\n这样就导致了权值数几乎变为了不权值共享时的数据量分之一。\n\n#### 多卷积核\n\n用一个卷积核对整张图卷积可以看作是提取了原图的一个特征。\n\n使用一个卷积核只提取了一个特征，因此为了充分的提取特征，要使用多个卷积核，得到多个特征平面。\n\n#### 下采样（池化）\n\n当输入数据过多时，参数的量就不可避免的变得很多，为了防止参数过多导致过拟合，需要下采样。\n\n## 常见网络结构了解\n\n### LeNet\n\n\n![LeNet](https://upload-images.jianshu.io/upload_images/3352522-2ef0a2bbb096ced0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n1. **Input Layer**：1\\*32\\*32图像\n2. **Conv1 Layer**：包含6个卷积核，kernal size：5\\*5，parameters:（5\\*5+1）\\*6=156个\n3. **Subsampling Layer**：average pooling，size：2\\*2, Activation Function：sigmoid\n4. **Conv3 Layer**：包含16个卷积核，kernal size：5\\*5\n5. **Subsampling Layer**：average pooling，size：2\\*2\n6. **Conv5 Layer**：包含120个卷积核，kernal size：5\\*5\n7. **Fully Connected Layer**：Activation Function：sigmoid\n8. **Output Layer**：Gaussian connection\n\n### AlexNet\n\n#### AlexNet结构图\n\n![ImageNet](https://www.52ml.net/wp-content/uploads/2016/08/alexnet.png)\n\n#### AlexNet结构精简版\n\n![ImageNet](https://www.52ml.net/wp-content/uploads/2016/08/alexnet2.png)\n\n对比一下即可理解精简版中**符号的含义**（以第一层为例）：\n\n卷积核大小为11\\*11，共有96个卷积核，步长为4，下采样矩阵大小为2\\*2。\n\nfc：full connect，全连接。\n\n激活函数变为ReLU：斜坡函数 f(x) = max(0, x)及其变种。\n\n### VGG\n\n#### VGG结构图\n\n![VGG](https://www.52ml.net/wp-content/uploads/2016/08/vgg.png)\n\n#### VGG-19网络结构精简版\n\n![VGG-19](https://www.52ml.net/wp-content/uploads/2016/08/vgg19.png)\n\n### GoogLeNet\n\n[讲解链接](https://blog.csdn.net/shuzfan/article/details/50738394)\n\n主要特征是**重新启用全连接**以及提出了**网中网**的结构。\n\n网上的博客写的都比较粗略，有时间看一下相关资料或者论文。\n\n### ResNet\n\n#### 残差网络模型\n\n主要的创新为残差网络，本质上是要解决层次比较深时无法训练的问题：\n\n![residual](https://www.52ml.net/wp-content/uploads/2016/08/residual.png)\n\n#### ResNet网络结构\n\n![resnet](https://www.52ml.net/wp-content/uploads/2016/08/resnet.png)\n\n### DenseNet\n\n#### DenseNet网络结构\n\n![DenseNet](https://tse4.mm.bing.net/th?id=OIP.m8LpfrnNS-bVUC8gil9eVwHaBD&pid=Api)\n\n#### Dense Block结构\n\n![Dense Block](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1522436431455&di=3f3b62ddecf7accdb6b2b756f942cf89&imgtype=0&src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201802%2F20180217134048130090.png)\n\n还是只看懂了大概，需要后续学习。\n\n## 利用LeNet5网络模型实现MNIST手写数字识别\n\n主要的关键点是熟悉TensorFlow相关变量和含义\n\n完成TensorFlow官方MINIST识别教程。\n\n使用[国内网站](http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_pros.html)来更方便的浏览。\n\n------\n\n# Week2\n\n## 利用VGG16实现CIFAR-10动物分类\n\n[教程页链接](http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/deep_cnn.html)\n\n## 学习使用[TensorBoard](https://github.com/jikexueyuanwiki/tensorflow-zh/blob/master/SOURCE/how_tos/summaries_and_tensorboard/index.md)\n\n## 了解Batch Normalization(BN)批标准化\n\n文献链接：[Batch Normalization: Accelerating Deep Network Training by Reducing  Internal Covariate Shift](https://arxiv.org/pdf/1502.03167.pdf)\n\n\n\n> 在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。\n\n","source":"_posts/深度学习周报week01-week02.md","raw":"---\ntitle: 深度学习周报week01&week02\ndate: 2018-03-30 22:16:12\ncategories:\n- deep learning\ntags:\n- TensorFlow\ntoc: true\n---\n\n\n\n# Week1\n\n## 配置Cuda、Cudnn和Tensorflow\n\n要注意**版本对应**\n\n<!-- more -->\n\n## 学习基础知识\n\n### [神经网络基本原理](http://www.ruanyifeng.com/blog/2017/07/neural-network.html)\n\n#### 感知器\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071202.png)\n一个圆圈表示一个感知器，x1、x2、x3...为输入，output为对应的输出。为了简化问题，output只取0或1.\n\n#### 权重和阈值\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071203.png)\nthreshold为阈值，xi为输入，wi为对应的权重，表示输入的重要性。\n\n#### 矢量化\n\n- 将输入x1,x2,x3,...写为矢量**x**: < x1,x2,x3,... >\n- 将权重w1,w2,w3,...写为矢量**w**: < w1,w2,w3,... >\n- 则 **w·x** = ∑ wx\n- 设 b 等于负的阈值 b = -threshold\n  ![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071206.png)\n\n#### 实际的决策模型\n\n多个感知器组成的多层网络：\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png)\n\n#### 神经网络的运作过程\n\n- 确定输入和输出\n- 找到一种或多种算法，可以从输入得到输出（决定决策模型）\n- 找到一组已知答案的数据集，用来训练模型，估算w和b\n  **估算w和b：试错法**\n  首先获取一组随机的**w**和**x**，将**w**（或**b**）进行微小变动，记作**Δw**（或**Δb**），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组**w**和**b**，就是我们要的值。这个过程称为**模型的训练**。\n- 一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正\n\n#### 输出的连续性\n\n为了保证能观察到**w**和**b**的微小变化对结果造成的影响，必须将\"输出\"改造成一个连续性函数。一般使用**sigmoid**函数。\n\n- 将output记为z：`z = wx + b` \n- 则结果的sigmoid函数为σ(z)：`σ(z) = 1 / (1 + e^(-z))`\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071209.png)\n实际上，Δσ满足下面的公式：\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png)\n即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。\n\n### 反向传播（BP）\n\n- 即估算**w**和**b**的**试错法**的具体实现。\n- 反向传播算法主要由两个过程（**激励传播、权重更新**）反复循环迭代，直到结果误差在可容忍的限度结束。\n\n#### 激励传播\n\n每次迭代中的传播环节包含两步：\n\n1. 前向传播阶段——按照当前**w**和**b**计算**output（激励响应）**；\n2. 反向传播阶段——将**output**和目标输出求差，从而获得隐层和输出层的**响应误差**。\n\n#### 权重更新\n\n对于每个权重 **wi **，按照以下步骤进行更新：\n\n1. 将**输入激励**和**响应误差**相乘，从而获得权重的**梯度**；\n2. 将这个梯度乘上一个比例并取反后加到权重上。\n3. 这个比例将会影响到训练过程的速度和效果，因此称为“**训练因子**”。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。\n\n<u>关于算法推导（**梯度下降+链式求导**），网上的博客质量良莠不齐，因此打算等买的书到了之后再研究一下，这里就不再列出。</u>\n\n### 卷积神经网络（CNN）\n\n- **卷积神经网络**由三部分构成：\n  - 第一部分是输入层。\n  - 第二部分由n个卷积层和池化层的组合组成。\n  - 第三部分由一个全连结的多层感知机分类器构成。\n- **卷积神经网络**与**普通神经网络**的区别在于，卷积神经网络包含了一个特征抽取器（即第二部分）。\n- **卷积神经网络**的卷积层中，一个神经元只和部分邻层神经元连接。\n- 在每一个**卷积层**中，通常包含若干个**特征平面(feature map)，**每个特征平面由一些**矩形排列**的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是**卷积核**。\n- **卷积核**一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将通过学习得到合理的权值（**反向传播**）。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接（**减少参数**），同时又降低了**过拟合**（参数过多导致）的风险。\n- **子采样**也叫做池化（pooling），也可以认为是下采样，通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。\n\n<u>与**普通的神经网络**相比，包含**卷积和子采样**的**卷积神经网络**大大**简化了模型复杂度，减少了模型的参数**。</u>\n\n#### **局部连接**\n\n假设一张图大小为n1\\*n2，一个卷积核的大小为m1\\*m2，对于卷积后生成的每一个数据xi，它都是原图中对应位置的m1\\*m2矩阵和这个卷积核对应点相乘求和得到的。\n\n也就是说xi只和原图中对应的m1\\*m2的那个矩阵中的元素连接，而不是和整张图的n1\\*n2个元素连接。\n\n因此局部连接使得参数数量变为全连接的（m1\\*m2）/（n1\\*n2）。\n\n#### 权值共享\n\n即对于一个卷积核遍历原数据矩阵，生成的一个新的数据矩阵的每一个元素来说，它们的权值都为这个卷积核。\n\n这样就导致了权值数几乎变为了不权值共享时的数据量分之一。\n\n#### 多卷积核\n\n用一个卷积核对整张图卷积可以看作是提取了原图的一个特征。\n\n使用一个卷积核只提取了一个特征，因此为了充分的提取特征，要使用多个卷积核，得到多个特征平面。\n\n#### 下采样（池化）\n\n当输入数据过多时，参数的量就不可避免的变得很多，为了防止参数过多导致过拟合，需要下采样。\n\n## 常见网络结构了解\n\n### LeNet\n\n\n![LeNet](https://upload-images.jianshu.io/upload_images/3352522-2ef0a2bbb096ced0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n1. **Input Layer**：1\\*32\\*32图像\n2. **Conv1 Layer**：包含6个卷积核，kernal size：5\\*5，parameters:（5\\*5+1）\\*6=156个\n3. **Subsampling Layer**：average pooling，size：2\\*2, Activation Function：sigmoid\n4. **Conv3 Layer**：包含16个卷积核，kernal size：5\\*5\n5. **Subsampling Layer**：average pooling，size：2\\*2\n6. **Conv5 Layer**：包含120个卷积核，kernal size：5\\*5\n7. **Fully Connected Layer**：Activation Function：sigmoid\n8. **Output Layer**：Gaussian connection\n\n### AlexNet\n\n#### AlexNet结构图\n\n![ImageNet](https://www.52ml.net/wp-content/uploads/2016/08/alexnet.png)\n\n#### AlexNet结构精简版\n\n![ImageNet](https://www.52ml.net/wp-content/uploads/2016/08/alexnet2.png)\n\n对比一下即可理解精简版中**符号的含义**（以第一层为例）：\n\n卷积核大小为11\\*11，共有96个卷积核，步长为4，下采样矩阵大小为2\\*2。\n\nfc：full connect，全连接。\n\n激活函数变为ReLU：斜坡函数 f(x) = max(0, x)及其变种。\n\n### VGG\n\n#### VGG结构图\n\n![VGG](https://www.52ml.net/wp-content/uploads/2016/08/vgg.png)\n\n#### VGG-19网络结构精简版\n\n![VGG-19](https://www.52ml.net/wp-content/uploads/2016/08/vgg19.png)\n\n### GoogLeNet\n\n[讲解链接](https://blog.csdn.net/shuzfan/article/details/50738394)\n\n主要特征是**重新启用全连接**以及提出了**网中网**的结构。\n\n网上的博客写的都比较粗略，有时间看一下相关资料或者论文。\n\n### ResNet\n\n#### 残差网络模型\n\n主要的创新为残差网络，本质上是要解决层次比较深时无法训练的问题：\n\n![residual](https://www.52ml.net/wp-content/uploads/2016/08/residual.png)\n\n#### ResNet网络结构\n\n![resnet](https://www.52ml.net/wp-content/uploads/2016/08/resnet.png)\n\n### DenseNet\n\n#### DenseNet网络结构\n\n![DenseNet](https://tse4.mm.bing.net/th?id=OIP.m8LpfrnNS-bVUC8gil9eVwHaBD&pid=Api)\n\n#### Dense Block结构\n\n![Dense Block](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1522436431455&di=3f3b62ddecf7accdb6b2b756f942cf89&imgtype=0&src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201802%2F20180217134048130090.png)\n\n还是只看懂了大概，需要后续学习。\n\n## 利用LeNet5网络模型实现MNIST手写数字识别\n\n主要的关键点是熟悉TensorFlow相关变量和含义\n\n完成TensorFlow官方MINIST识别教程。\n\n使用[国内网站](http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_pros.html)来更方便的浏览。\n\n------\n\n# Week2\n\n## 利用VGG16实现CIFAR-10动物分类\n\n[教程页链接](http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/deep_cnn.html)\n\n## 学习使用[TensorBoard](https://github.com/jikexueyuanwiki/tensorflow-zh/blob/master/SOURCE/how_tos/summaries_and_tensorboard/index.md)\n\n## 了解Batch Normalization(BN)批标准化\n\n文献链接：[Batch Normalization: Accelerating Deep Network Training by Reducing  Internal Covariate Shift](https://arxiv.org/pdf/1502.03167.pdf)\n\n\n\n> 在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。\n\n","slug":"深度学习周报week01-week02","published":1,"updated":"2018-10-10T08:47:08.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xa003ofmagc71hjdhv","content":"<h1 id=\"Week1\"><a href=\"#Week1\" class=\"headerlink\" title=\"Week1\"></a>Week1</h1><h2 id=\"配置Cuda、Cudnn和Tensorflow\"><a href=\"#配置Cuda、Cudnn和Tensorflow\" class=\"headerlink\" title=\"配置Cuda、Cudnn和Tensorflow\"></a>配置Cuda、Cudnn和Tensorflow</h2><p>要注意<strong>版本对应</strong></p><a id=\"more\"></a><h2 id=\"学习基础知识\"><a href=\"#学习基础知识\" class=\"headerlink\" title=\"学习基础知识\"></a>学习基础知识</h2><h3 id=\"神经网络基本原理\"><a href=\"#神经网络基本原理\" class=\"headerlink\" title=\"神经网络基本原理\"></a><a href=\"http://www.ruanyifeng.com/blog/2017/07/neural-network.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">神经网络基本原理</a></h3><h4 id=\"感知器\"><a href=\"#感知器\" class=\"headerlink\" title=\"感知器\"></a>感知器</h4><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071202.png\" alt=\"\"><br>一个圆圈表示一个感知器，x1、x2、x3…为输入，output为对应的输出。为了简化问题，output只取0或1.</p><h4 id=\"权重和阈值\"><a href=\"#权重和阈值\" class=\"headerlink\" title=\"权重和阈值\"></a>权重和阈值</h4><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071203.png\" alt=\"\"><br>threshold为阈值，xi为输入，wi为对应的权重，表示输入的重要性。</p><h4 id=\"矢量化\"><a href=\"#矢量化\" class=\"headerlink\" title=\"矢量化\"></a>矢量化</h4><ul><li>将输入x1,x2,x3,…写为矢量<strong>x</strong>: &lt; x1,x2,x3,… &gt;</li><li>将权重w1,w2,w3,…写为矢量<strong>w</strong>: &lt; w1,w2,w3,… &gt;</li><li>则 <strong>w·x</strong> = ∑ wx</li><li>设 b 等于负的阈值 b = -threshold<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071206.png\" alt=\"\"></li></ul><h4 id=\"实际的决策模型\"><a href=\"#实际的决策模型\" class=\"headerlink\" title=\"实际的决策模型\"></a>实际的决策模型</h4><p>多个感知器组成的多层网络：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png\" alt=\"\"></p><h4 id=\"神经网络的运作过程\"><a href=\"#神经网络的运作过程\" class=\"headerlink\" title=\"神经网络的运作过程\"></a>神经网络的运作过程</h4><ul><li>确定输入和输出</li><li>找到一种或多种算法，可以从输入得到输出（决定决策模型）</li><li>找到一组已知答案的数据集，用来训练模型，估算w和b<br><strong>估算w和b：试错法</strong><br>首先获取一组随机的<strong>w</strong>和<strong>x</strong>，将<strong>w</strong>（或<strong>b</strong>）进行微小变动，记作<strong>Δw</strong>（或<strong>Δb</strong>），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组<strong>w</strong>和<strong>b</strong>，就是我们要的值。这个过程称为<strong>模型的训练</strong>。</li><li>一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正</li></ul><h4 id=\"输出的连续性\"><a href=\"#输出的连续性\" class=\"headerlink\" title=\"输出的连续性\"></a>输出的连续性</h4><p>为了保证能观察到<strong>w</strong>和<strong>b</strong>的微小变化对结果造成的影响，必须将”输出”改造成一个连续性函数。一般使用<strong>sigmoid</strong>函数。</p><ul><li>将output记为z：<code>z = wx + b</code></li><li>则结果的sigmoid函数为σ(z)：<code>σ(z) = 1 / (1 + e^(-z))</code></li></ul><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071209.png\" alt=\"\"><br>实际上，Δσ满足下面的公式：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png\" alt=\"\"><br>即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。</p><h3 id=\"反向传播（BP）\"><a href=\"#反向传播（BP）\" class=\"headerlink\" title=\"反向传播（BP）\"></a>反向传播（BP）</h3><ul><li>即估算<strong>w</strong>和<strong>b</strong>的<strong>试错法</strong>的具体实现。</li><li>反向传播算法主要由两个过程（<strong>激励传播、权重更新</strong>）反复循环迭代，直到结果误差在可容忍的限度结束。</li></ul><h4 id=\"激励传播\"><a href=\"#激励传播\" class=\"headerlink\" title=\"激励传播\"></a>激励传播</h4><p>每次迭代中的传播环节包含两步：</p><ol><li>前向传播阶段——按照当前<strong>w</strong>和<strong>b</strong>计算<strong>output（激励响应）</strong>；</li><li>反向传播阶段——将<strong>output</strong>和目标输出求差，从而获得隐层和输出层的<strong>响应误差</strong>。</li></ol><h4 id=\"权重更新\"><a href=\"#权重更新\" class=\"headerlink\" title=\"权重更新\"></a>权重更新</h4><p>对于每个权重 <strong>wi </strong>，按照以下步骤进行更新：</p><ol><li>将<strong>输入激励</strong>和<strong>响应误差</strong>相乘，从而获得权重的<strong>梯度</strong>；</li><li>将这个梯度乘上一个比例并取反后加到权重上。</li><li>这个比例将会影响到训练过程的速度和效果，因此称为“<strong>训练因子</strong>”。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。</li></ol><p><u>关于算法推导（<strong>梯度下降+链式求导</strong>），网上的博客质量良莠不齐，因此打算等买的书到了之后再研究一下，这里就不再列出。</u></p><h3 id=\"卷积神经网络（CNN）\"><a href=\"#卷积神经网络（CNN）\" class=\"headerlink\" title=\"卷积神经网络（CNN）\"></a>卷积神经网络（CNN）</h3><ul><li><strong>卷积神经网络</strong>由三部分构成：<ul><li>第一部分是输入层。</li><li>第二部分由n个卷积层和池化层的组合组成。</li><li>第三部分由一个全连结的多层感知机分类器构成。</li></ul></li><li><strong>卷积神经网络</strong>与<strong>普通神经网络</strong>的区别在于，卷积神经网络包含了一个特征抽取器（即第二部分）。</li><li><strong>卷积神经网络</strong>的卷积层中，一个神经元只和部分邻层神经元连接。</li><li>在每一个<strong>卷积层</strong>中，通常包含若干个<strong>特征平面(feature map)，</strong>每个特征平面由一些<strong>矩形排列</strong>的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是<strong>卷积核</strong>。</li><li><strong>卷积核</strong>一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将通过学习得到合理的权值（<strong>反向传播</strong>）。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接（<strong>减少参数</strong>），同时又降低了<strong>过拟合</strong>（参数过多导致）的风险。</li><li><strong>子采样</strong>也叫做池化（pooling），也可以认为是下采样，通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。</li></ul><p><u>与<strong>普通的神经网络</strong>相比，包含<strong>卷积和子采样</strong>的<strong>卷积神经网络</strong>大大<strong>简化了模型复杂度，减少了模型的参数</strong>。</u></p><h4 id=\"局部连接\"><a href=\"#局部连接\" class=\"headerlink\" title=\"局部连接\"></a><strong>局部连接</strong></h4><p>假设一张图大小为n1*n2，一个卷积核的大小为m1*m2，对于卷积后生成的每一个数据xi，它都是原图中对应位置的m1*m2矩阵和这个卷积核对应点相乘求和得到的。</p><p>也就是说xi只和原图中对应的m1*m2的那个矩阵中的元素连接，而不是和整张图的n1*n2个元素连接。</p><p>因此局部连接使得参数数量变为全连接的（m1*m2）/（n1*n2）。</p><h4 id=\"权值共享\"><a href=\"#权值共享\" class=\"headerlink\" title=\"权值共享\"></a>权值共享</h4><p>即对于一个卷积核遍历原数据矩阵，生成的一个新的数据矩阵的每一个元素来说，它们的权值都为这个卷积核。</p><p>这样就导致了权值数几乎变为了不权值共享时的数据量分之一。</p><h4 id=\"多卷积核\"><a href=\"#多卷积核\" class=\"headerlink\" title=\"多卷积核\"></a>多卷积核</h4><p>用一个卷积核对整张图卷积可以看作是提取了原图的一个特征。</p><p>使用一个卷积核只提取了一个特征，因此为了充分的提取特征，要使用多个卷积核，得到多个特征平面。</p><h4 id=\"下采样（池化）\"><a href=\"#下采样（池化）\" class=\"headerlink\" title=\"下采样（池化）\"></a>下采样（池化）</h4><p>当输入数据过多时，参数的量就不可避免的变得很多，为了防止参数过多导致过拟合，需要下采样。</p><h2 id=\"常见网络结构了解\"><a href=\"#常见网络结构了解\" class=\"headerlink\" title=\"常见网络结构了解\"></a>常见网络结构了解</h2><h3 id=\"LeNet\"><a href=\"#LeNet\" class=\"headerlink\" title=\"LeNet\"></a>LeNet</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/3352522-2ef0a2bbb096ced0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"LeNet\"></p><ol><li><strong>Input Layer</strong>：1*32*32图像</li><li><strong>Conv1 Layer</strong>：包含6个卷积核，kernal size：5*5，parameters:（5*5+1）*6=156个</li><li><strong>Subsampling Layer</strong>：average pooling，size：2*2, Activation Function：sigmoid</li><li><strong>Conv3 Layer</strong>：包含16个卷积核，kernal size：5*5</li><li><strong>Subsampling Layer</strong>：average pooling，size：2*2</li><li><strong>Conv5 Layer</strong>：包含120个卷积核，kernal size：5*5</li><li><strong>Fully Connected Layer</strong>：Activation Function：sigmoid</li><li><strong>Output Layer</strong>：Gaussian connection</li></ol><h3 id=\"AlexNet\"><a href=\"#AlexNet\" class=\"headerlink\" title=\"AlexNet\"></a>AlexNet</h3><h4 id=\"AlexNet结构图\"><a href=\"#AlexNet结构图\" class=\"headerlink\" title=\"AlexNet结构图\"></a>AlexNet结构图</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/alexnet.png\" alt=\"ImageNet\"></p><h4 id=\"AlexNet结构精简版\"><a href=\"#AlexNet结构精简版\" class=\"headerlink\" title=\"AlexNet结构精简版\"></a>AlexNet结构精简版</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/alexnet2.png\" alt=\"ImageNet\"></p><p>对比一下即可理解精简版中<strong>符号的含义</strong>（以第一层为例）：</p><p>卷积核大小为11*11，共有96个卷积核，步长为4，下采样矩阵大小为2*2。</p><p>fc：full connect，全连接。</p><p>激活函数变为ReLU：斜坡函数 f(x) = max(0, x)及其变种。</p><h3 id=\"VGG\"><a href=\"#VGG\" class=\"headerlink\" title=\"VGG\"></a>VGG</h3><h4 id=\"VGG结构图\"><a href=\"#VGG结构图\" class=\"headerlink\" title=\"VGG结构图\"></a>VGG结构图</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/vgg.png\" alt=\"VGG\"></p><h4 id=\"VGG-19网络结构精简版\"><a href=\"#VGG-19网络结构精简版\" class=\"headerlink\" title=\"VGG-19网络结构精简版\"></a>VGG-19网络结构精简版</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/vgg19.png\" alt=\"VGG-19\"></p><h3 id=\"GoogLeNet\"><a href=\"#GoogLeNet\" class=\"headerlink\" title=\"GoogLeNet\"></a>GoogLeNet</h3><p><a href=\"https://blog.csdn.net/shuzfan/article/details/50738394\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">讲解链接</a></p><p>主要特征是<strong>重新启用全连接</strong>以及提出了<strong>网中网</strong>的结构。</p><p>网上的博客写的都比较粗略，有时间看一下相关资料或者论文。</p><h3 id=\"ResNet\"><a href=\"#ResNet\" class=\"headerlink\" title=\"ResNet\"></a>ResNet</h3><h4 id=\"残差网络模型\"><a href=\"#残差网络模型\" class=\"headerlink\" title=\"残差网络模型\"></a>残差网络模型</h4><p>主要的创新为残差网络，本质上是要解决层次比较深时无法训练的问题：</p><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/residual.png\" alt=\"residual\"></p><h4 id=\"ResNet网络结构\"><a href=\"#ResNet网络结构\" class=\"headerlink\" title=\"ResNet网络结构\"></a>ResNet网络结构</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/resnet.png\" alt=\"resnet\"></p><h3 id=\"DenseNet\"><a href=\"#DenseNet\" class=\"headerlink\" title=\"DenseNet\"></a>DenseNet</h3><h4 id=\"DenseNet网络结构\"><a href=\"#DenseNet网络结构\" class=\"headerlink\" title=\"DenseNet网络结构\"></a>DenseNet网络结构</h4><p><img src=\"https://tse4.mm.bing.net/th?id=OIP.m8LpfrnNS-bVUC8gil9eVwHaBD&amp;pid=Api\" alt=\"DenseNet\"></p><h4 id=\"Dense-Block结构\"><a href=\"#Dense-Block结构\" class=\"headerlink\" title=\"Dense Block结构\"></a>Dense Block结构</h4><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522436431455&amp;di=3f3b62ddecf7accdb6b2b756f942cf89&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201802%2F20180217134048130090.png\" alt=\"Dense Block\"></p><p>还是只看懂了大概，需要后续学习。</p><h2 id=\"利用LeNet5网络模型实现MNIST手写数字识别\"><a href=\"#利用LeNet5网络模型实现MNIST手写数字识别\" class=\"headerlink\" title=\"利用LeNet5网络模型实现MNIST手写数字识别\"></a>利用LeNet5网络模型实现MNIST手写数字识别</h2><p>主要的关键点是熟悉TensorFlow相关变量和含义</p><p>完成TensorFlow官方MINIST识别教程。</p><p>使用<a href=\"http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_pros.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">国内网站</a>来更方便的浏览。</p><hr><h1 id=\"Week2\"><a href=\"#Week2\" class=\"headerlink\" title=\"Week2\"></a>Week2</h1><h2 id=\"利用VGG16实现CIFAR-10动物分类\"><a href=\"#利用VGG16实现CIFAR-10动物分类\" class=\"headerlink\" title=\"利用VGG16实现CIFAR-10动物分类\"></a>利用VGG16实现CIFAR-10动物分类</h2><p><a href=\"http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/deep_cnn.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">教程页链接</a></p><h2 id=\"学习使用TensorBoard\"><a href=\"#学习使用TensorBoard\" class=\"headerlink\" title=\"学习使用TensorBoard\"></a>学习使用<a href=\"https://github.com/jikexueyuanwiki/tensorflow-zh/blob/master/SOURCE/how_tos/summaries_and_tensorboard/index.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TensorBoard</a></h2><h2 id=\"了解Batch-Normalization-BN-批标准化\"><a href=\"#了解Batch-Normalization-BN-批标准化\" class=\"headerlink\" title=\"了解Batch Normalization(BN)批标准化\"></a>了解Batch Normalization(BN)批标准化</h2><p>文献链接：<a href=\"https://arxiv.org/pdf/1502.03167.pdf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><blockquote><p>在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。</p></blockquote>","site":{"data":{}},"excerpt":"<h1 id=\"Week1\"><a href=\"#Week1\" class=\"headerlink\" title=\"Week1\"></a>Week1</h1><h2 id=\"配置Cuda、Cudnn和Tensorflow\"><a href=\"#配置Cuda、Cudnn和Tensorflow\" class=\"headerlink\" title=\"配置Cuda、Cudnn和Tensorflow\"></a>配置Cuda、Cudnn和Tensorflow</h2><p>要注意<strong>版本对应</strong></p>","more":"<h2 id=\"学习基础知识\"><a href=\"#学习基础知识\" class=\"headerlink\" title=\"学习基础知识\"></a>学习基础知识</h2><h3 id=\"神经网络基本原理\"><a href=\"#神经网络基本原理\" class=\"headerlink\" title=\"神经网络基本原理\"></a><a href=\"http://www.ruanyifeng.com/blog/2017/07/neural-network.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">神经网络基本原理</a></h3><h4 id=\"感知器\"><a href=\"#感知器\" class=\"headerlink\" title=\"感知器\"></a>感知器</h4><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071202.png\" alt=\"\"><br>一个圆圈表示一个感知器，x1、x2、x3…为输入，output为对应的输出。为了简化问题，output只取0或1.</p><h4 id=\"权重和阈值\"><a href=\"#权重和阈值\" class=\"headerlink\" title=\"权重和阈值\"></a>权重和阈值</h4><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071203.png\" alt=\"\"><br>threshold为阈值，xi为输入，wi为对应的权重，表示输入的重要性。</p><h4 id=\"矢量化\"><a href=\"#矢量化\" class=\"headerlink\" title=\"矢量化\"></a>矢量化</h4><ul><li>将输入x1,x2,x3,…写为矢量<strong>x</strong>: &lt; x1,x2,x3,… &gt;</li><li>将权重w1,w2,w3,…写为矢量<strong>w</strong>: &lt; w1,w2,w3,… &gt;</li><li>则 <strong>w·x</strong> = ∑ wx</li><li>设 b 等于负的阈值 b = -threshold<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071206.png\" alt=\"\"></li></ul><h4 id=\"实际的决策模型\"><a href=\"#实际的决策模型\" class=\"headerlink\" title=\"实际的决策模型\"></a>实际的决策模型</h4><p>多个感知器组成的多层网络：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png\" alt=\"\"></p><h4 id=\"神经网络的运作过程\"><a href=\"#神经网络的运作过程\" class=\"headerlink\" title=\"神经网络的运作过程\"></a>神经网络的运作过程</h4><ul><li>确定输入和输出</li><li>找到一种或多种算法，可以从输入得到输出（决定决策模型）</li><li>找到一组已知答案的数据集，用来训练模型，估算w和b<br><strong>估算w和b：试错法</strong><br>首先获取一组随机的<strong>w</strong>和<strong>x</strong>，将<strong>w</strong>（或<strong>b</strong>）进行微小变动，记作<strong>Δw</strong>（或<strong>Δb</strong>），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组<strong>w</strong>和<strong>b</strong>，就是我们要的值。这个过程称为<strong>模型的训练</strong>。</li><li>一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正</li></ul><h4 id=\"输出的连续性\"><a href=\"#输出的连续性\" class=\"headerlink\" title=\"输出的连续性\"></a>输出的连续性</h4><p>为了保证能观察到<strong>w</strong>和<strong>b</strong>的微小变化对结果造成的影响，必须将”输出”改造成一个连续性函数。一般使用<strong>sigmoid</strong>函数。</p><ul><li>将output记为z：<code>z = wx + b</code></li><li>则结果的sigmoid函数为σ(z)：<code>σ(z) = 1 / (1 + e^(-z))</code></li></ul><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071209.png\" alt=\"\"><br>实际上，Δσ满足下面的公式：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png\" alt=\"\"><br>即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。</p><h3 id=\"反向传播（BP）\"><a href=\"#反向传播（BP）\" class=\"headerlink\" title=\"反向传播（BP）\"></a>反向传播（BP）</h3><ul><li>即估算<strong>w</strong>和<strong>b</strong>的<strong>试错法</strong>的具体实现。</li><li>反向传播算法主要由两个过程（<strong>激励传播、权重更新</strong>）反复循环迭代，直到结果误差在可容忍的限度结束。</li></ul><h4 id=\"激励传播\"><a href=\"#激励传播\" class=\"headerlink\" title=\"激励传播\"></a>激励传播</h4><p>每次迭代中的传播环节包含两步：</p><ol><li>前向传播阶段——按照当前<strong>w</strong>和<strong>b</strong>计算<strong>output（激励响应）</strong>；</li><li>反向传播阶段——将<strong>output</strong>和目标输出求差，从而获得隐层和输出层的<strong>响应误差</strong>。</li></ol><h4 id=\"权重更新\"><a href=\"#权重更新\" class=\"headerlink\" title=\"权重更新\"></a>权重更新</h4><p>对于每个权重 <strong>wi </strong>，按照以下步骤进行更新：</p><ol><li>将<strong>输入激励</strong>和<strong>响应误差</strong>相乘，从而获得权重的<strong>梯度</strong>；</li><li>将这个梯度乘上一个比例并取反后加到权重上。</li><li>这个比例将会影响到训练过程的速度和效果，因此称为“<strong>训练因子</strong>”。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。</li></ol><p><u>关于算法推导（<strong>梯度下降+链式求导</strong>），网上的博客质量良莠不齐，因此打算等买的书到了之后再研究一下，这里就不再列出。</u></p><h3 id=\"卷积神经网络（CNN）\"><a href=\"#卷积神经网络（CNN）\" class=\"headerlink\" title=\"卷积神经网络（CNN）\"></a>卷积神经网络（CNN）</h3><ul><li><strong>卷积神经网络</strong>由三部分构成：<ul><li>第一部分是输入层。</li><li>第二部分由n个卷积层和池化层的组合组成。</li><li>第三部分由一个全连结的多层感知机分类器构成。</li></ul></li><li><strong>卷积神经网络</strong>与<strong>普通神经网络</strong>的区别在于，卷积神经网络包含了一个特征抽取器（即第二部分）。</li><li><strong>卷积神经网络</strong>的卷积层中，一个神经元只和部分邻层神经元连接。</li><li>在每一个<strong>卷积层</strong>中，通常包含若干个<strong>特征平面(feature map)，</strong>每个特征平面由一些<strong>矩形排列</strong>的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是<strong>卷积核</strong>。</li><li><strong>卷积核</strong>一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将通过学习得到合理的权值（<strong>反向传播</strong>）。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接（<strong>减少参数</strong>），同时又降低了<strong>过拟合</strong>（参数过多导致）的风险。</li><li><strong>子采样</strong>也叫做池化（pooling），也可以认为是下采样，通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。</li></ul><p><u>与<strong>普通的神经网络</strong>相比，包含<strong>卷积和子采样</strong>的<strong>卷积神经网络</strong>大大<strong>简化了模型复杂度，减少了模型的参数</strong>。</u></p><h4 id=\"局部连接\"><a href=\"#局部连接\" class=\"headerlink\" title=\"局部连接\"></a><strong>局部连接</strong></h4><p>假设一张图大小为n1*n2，一个卷积核的大小为m1*m2，对于卷积后生成的每一个数据xi，它都是原图中对应位置的m1*m2矩阵和这个卷积核对应点相乘求和得到的。</p><p>也就是说xi只和原图中对应的m1*m2的那个矩阵中的元素连接，而不是和整张图的n1*n2个元素连接。</p><p>因此局部连接使得参数数量变为全连接的（m1*m2）/（n1*n2）。</p><h4 id=\"权值共享\"><a href=\"#权值共享\" class=\"headerlink\" title=\"权值共享\"></a>权值共享</h4><p>即对于一个卷积核遍历原数据矩阵，生成的一个新的数据矩阵的每一个元素来说，它们的权值都为这个卷积核。</p><p>这样就导致了权值数几乎变为了不权值共享时的数据量分之一。</p><h4 id=\"多卷积核\"><a href=\"#多卷积核\" class=\"headerlink\" title=\"多卷积核\"></a>多卷积核</h4><p>用一个卷积核对整张图卷积可以看作是提取了原图的一个特征。</p><p>使用一个卷积核只提取了一个特征，因此为了充分的提取特征，要使用多个卷积核，得到多个特征平面。</p><h4 id=\"下采样（池化）\"><a href=\"#下采样（池化）\" class=\"headerlink\" title=\"下采样（池化）\"></a>下采样（池化）</h4><p>当输入数据过多时，参数的量就不可避免的变得很多，为了防止参数过多导致过拟合，需要下采样。</p><h2 id=\"常见网络结构了解\"><a href=\"#常见网络结构了解\" class=\"headerlink\" title=\"常见网络结构了解\"></a>常见网络结构了解</h2><h3 id=\"LeNet\"><a href=\"#LeNet\" class=\"headerlink\" title=\"LeNet\"></a>LeNet</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/3352522-2ef0a2bbb096ced0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"LeNet\"></p><ol><li><strong>Input Layer</strong>：1*32*32图像</li><li><strong>Conv1 Layer</strong>：包含6个卷积核，kernal size：5*5，parameters:（5*5+1）*6=156个</li><li><strong>Subsampling Layer</strong>：average pooling，size：2*2, Activation Function：sigmoid</li><li><strong>Conv3 Layer</strong>：包含16个卷积核，kernal size：5*5</li><li><strong>Subsampling Layer</strong>：average pooling，size：2*2</li><li><strong>Conv5 Layer</strong>：包含120个卷积核，kernal size：5*5</li><li><strong>Fully Connected Layer</strong>：Activation Function：sigmoid</li><li><strong>Output Layer</strong>：Gaussian connection</li></ol><h3 id=\"AlexNet\"><a href=\"#AlexNet\" class=\"headerlink\" title=\"AlexNet\"></a>AlexNet</h3><h4 id=\"AlexNet结构图\"><a href=\"#AlexNet结构图\" class=\"headerlink\" title=\"AlexNet结构图\"></a>AlexNet结构图</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/alexnet.png\" alt=\"ImageNet\"></p><h4 id=\"AlexNet结构精简版\"><a href=\"#AlexNet结构精简版\" class=\"headerlink\" title=\"AlexNet结构精简版\"></a>AlexNet结构精简版</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/alexnet2.png\" alt=\"ImageNet\"></p><p>对比一下即可理解精简版中<strong>符号的含义</strong>（以第一层为例）：</p><p>卷积核大小为11*11，共有96个卷积核，步长为4，下采样矩阵大小为2*2。</p><p>fc：full connect，全连接。</p><p>激活函数变为ReLU：斜坡函数 f(x) = max(0, x)及其变种。</p><h3 id=\"VGG\"><a href=\"#VGG\" class=\"headerlink\" title=\"VGG\"></a>VGG</h3><h4 id=\"VGG结构图\"><a href=\"#VGG结构图\" class=\"headerlink\" title=\"VGG结构图\"></a>VGG结构图</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/vgg.png\" alt=\"VGG\"></p><h4 id=\"VGG-19网络结构精简版\"><a href=\"#VGG-19网络结构精简版\" class=\"headerlink\" title=\"VGG-19网络结构精简版\"></a>VGG-19网络结构精简版</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/vgg19.png\" alt=\"VGG-19\"></p><h3 id=\"GoogLeNet\"><a href=\"#GoogLeNet\" class=\"headerlink\" title=\"GoogLeNet\"></a>GoogLeNet</h3><p><a href=\"https://blog.csdn.net/shuzfan/article/details/50738394\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">讲解链接</a></p><p>主要特征是<strong>重新启用全连接</strong>以及提出了<strong>网中网</strong>的结构。</p><p>网上的博客写的都比较粗略，有时间看一下相关资料或者论文。</p><h3 id=\"ResNet\"><a href=\"#ResNet\" class=\"headerlink\" title=\"ResNet\"></a>ResNet</h3><h4 id=\"残差网络模型\"><a href=\"#残差网络模型\" class=\"headerlink\" title=\"残差网络模型\"></a>残差网络模型</h4><p>主要的创新为残差网络，本质上是要解决层次比较深时无法训练的问题：</p><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/residual.png\" alt=\"residual\"></p><h4 id=\"ResNet网络结构\"><a href=\"#ResNet网络结构\" class=\"headerlink\" title=\"ResNet网络结构\"></a>ResNet网络结构</h4><p><img src=\"https://www.52ml.net/wp-content/uploads/2016/08/resnet.png\" alt=\"resnet\"></p><h3 id=\"DenseNet\"><a href=\"#DenseNet\" class=\"headerlink\" title=\"DenseNet\"></a>DenseNet</h3><h4 id=\"DenseNet网络结构\"><a href=\"#DenseNet网络结构\" class=\"headerlink\" title=\"DenseNet网络结构\"></a>DenseNet网络结构</h4><p><img src=\"https://tse4.mm.bing.net/th?id=OIP.m8LpfrnNS-bVUC8gil9eVwHaBD&amp;pid=Api\" alt=\"DenseNet\"></p><h4 id=\"Dense-Block结构\"><a href=\"#Dense-Block结构\" class=\"headerlink\" title=\"Dense Block结构\"></a>Dense Block结构</h4><p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1522436431455&amp;di=3f3b62ddecf7accdb6b2b756f942cf89&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201802%2F20180217134048130090.png\" alt=\"Dense Block\"></p><p>还是只看懂了大概，需要后续学习。</p><h2 id=\"利用LeNet5网络模型实现MNIST手写数字识别\"><a href=\"#利用LeNet5网络模型实现MNIST手写数字识别\" class=\"headerlink\" title=\"利用LeNet5网络模型实现MNIST手写数字识别\"></a>利用LeNet5网络模型实现MNIST手写数字识别</h2><p>主要的关键点是熟悉TensorFlow相关变量和含义</p><p>完成TensorFlow官方MINIST识别教程。</p><p>使用<a href=\"http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_pros.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">国内网站</a>来更方便的浏览。</p><hr><h1 id=\"Week2\"><a href=\"#Week2\" class=\"headerlink\" title=\"Week2\"></a>Week2</h1><h2 id=\"利用VGG16实现CIFAR-10动物分类\"><a href=\"#利用VGG16实现CIFAR-10动物分类\" class=\"headerlink\" title=\"利用VGG16实现CIFAR-10动物分类\"></a>利用VGG16实现CIFAR-10动物分类</h2><p><a href=\"http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/deep_cnn.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">教程页链接</a></p><h2 id=\"学习使用TensorBoard\"><a href=\"#学习使用TensorBoard\" class=\"headerlink\" title=\"学习使用TensorBoard\"></a>学习使用<a href=\"https://github.com/jikexueyuanwiki/tensorflow-zh/blob/master/SOURCE/how_tos/summaries_and_tensorboard/index.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TensorBoard</a></h2><h2 id=\"了解Batch-Normalization-BN-批标准化\"><a href=\"#了解Batch-Normalization-BN-批标准化\" class=\"headerlink\" title=\"了解Batch Normalization(BN)批标准化\"></a>了解Batch Normalization(BN)批标准化</h2><p>文献链接：<a href=\"https://arxiv.org/pdf/1502.03167.pdf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></p><blockquote><p>在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。</p></blockquote>"},{"title":"深度学习周报week03-week04","toc":true,"date":"2018-05-12T01:20:23.000Z","_content":"\n## Tmux ：终端分割\n\n> tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。\n\n<!-- more -->\n\n### 常用快捷键\n\n`Ctrl+b ：激活控制台；此时以下按键生效`\n\n#### 系统操作\n\n| ?      | 列出所有快捷键；按q返回                                      |\n| ------ | ------------------------------------------------------------ |\n| d      | 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 |\n| D      | 选择要脱离的会话；在同时开启了多个会话时使用                 |\n| Ctrl+z | 挂起当前会话                                                 |\n| r      | 强制重绘未脱离的会话                                         |\n| s      | 选择并切换会话；在同时开启了多个会话时使用                   |\n| :      | 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 |\n| [      | 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出          |\n| ~      | 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息       |\n\n#### 窗口操作\n\n| c      | 创建新窗口                           |\n| ------ | ------------------------------------ |\n| &      | 关闭当前窗口                         |\n| 数字键 | 切换至指定窗口                       |\n| p      | 切换至上一窗口                       |\n| n      | 切换至下一窗口                       |\n| l      | 在前后两个窗口间互相切换             |\n| w      | 通过窗口列表切换窗口                 |\n| ,      | 重命名当前窗口；这样便于识别         |\n| .      | 修改当前窗口编号；相当于窗口重新排序 |\n| f      | 在所有窗口中查找指定文本             |\n\n#### 面板操作\n\n| ”           | 将当前面板平分为上下两块                                     |\n| ----------- | ------------------------------------------------------------ |\n| %           | 将当前面板平分为左右两块                                     |\n| x           | 关闭当前面板                                                 |\n| !           | 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板     |\n| Ctrl+方向键 | 以1个单元格为单位移动边缘以调整当前面板大小                  |\n| Alt+方向键  | 以5个单元格为单位移动边缘以调整当前面板大小                  |\n| Space       | 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled |\n| q           | 显示面板编号                                                 |\n| o           | 在当前窗口中选择下一面板                                     |\n| 方向键      | 移动光标以选择面板                                           |\n| {           | 向前置换当前面板                                             |\n| }           | 向后置换当前面板                                             |\n| Alt+o       | 逆时针旋转当前窗口的面板                                     |\n| Ctrl+o      | 顺时针旋转当前窗口的面板                                     |\n\n> Ctrl-b s\t\t\t在 Tmux 的会话间切换\n>\n> Ctrl-b %\t\t\t上下分屏\n>\n> Ctrl-b \"\t\t\t左右分屏\n>\n> Ctrl-b +方向键\t进入对应的窗格\n>\n> Ctrl-b c\t\t\t创建窗口\n>\n> Ctrl-b +数字\t\t切换窗口 \n>\n> Ctrl-b &\t\t\t离开一个会话[exited]\n>\n> Ctrl-b d\t\t\t从一个会话中脱离[dettached]\n\n## ssh\n\n下载MobaXterm来在windows下使用ssh\n\n连接命令：\n\n```shell\nssh username@xxx.xxx.xxx.xxx\npassword\n```\n\n## 监控显卡\n\n```shell\nnvidia smi\n```\n\n[GPU使用表的具体含义](https://blog.csdn.net/bruce_0712/article/details/63683787)：\n\n> 第一张表格中： \n>\n> 第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。\n>\n>\n> 第二栏的Temp：是温度，单位摄氏度。 \n>\n> 第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。 \n>\n> 第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。\n>\n>\n> 第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function \n>\n> 第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。 \n>\n> 第五第六栏下方的Memory Usage是显存使用率。 \n>\n> 第七栏是浮动的GPU利用率。 \n>\n> 第八栏上方是关于ECC的东西。 \n>\n> 第八栏下方Compute M是计算模式。 \n>\n> 第二张表示每个进程占用的显存使用情况。\n\n### 使用watch命令实时监测显卡\n\nwatch的基本用法：\n\n```shell\nwatch [options]  command\n```\n\n最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。\n\n例如：设置每 10s 显示一次显存的情况\n\n```shell\nwatch -n 10 nvidia-smi\n```\n\n## cifar10\n\n继续调整网络结构和参数来增加准确率。","source":"_posts/深度学习周报week03-week04.md","raw":"---\ntitle: 深度学习周报week03-week04\ntoc: true\ndate: 2018-05-12 09:20:23\ncategories:\n- deep learning\ntags:\n- Tmux\n---\n\n## Tmux ：终端分割\n\n> tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。\n\n<!-- more -->\n\n### 常用快捷键\n\n`Ctrl+b ：激活控制台；此时以下按键生效`\n\n#### 系统操作\n\n| ?      | 列出所有快捷键；按q返回                                      |\n| ------ | ------------------------------------------------------------ |\n| d      | 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 |\n| D      | 选择要脱离的会话；在同时开启了多个会话时使用                 |\n| Ctrl+z | 挂起当前会话                                                 |\n| r      | 强制重绘未脱离的会话                                         |\n| s      | 选择并切换会话；在同时开启了多个会话时使用                   |\n| :      | 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 |\n| [      | 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出          |\n| ~      | 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息       |\n\n#### 窗口操作\n\n| c      | 创建新窗口                           |\n| ------ | ------------------------------------ |\n| &      | 关闭当前窗口                         |\n| 数字键 | 切换至指定窗口                       |\n| p      | 切换至上一窗口                       |\n| n      | 切换至下一窗口                       |\n| l      | 在前后两个窗口间互相切换             |\n| w      | 通过窗口列表切换窗口                 |\n| ,      | 重命名当前窗口；这样便于识别         |\n| .      | 修改当前窗口编号；相当于窗口重新排序 |\n| f      | 在所有窗口中查找指定文本             |\n\n#### 面板操作\n\n| ”           | 将当前面板平分为上下两块                                     |\n| ----------- | ------------------------------------------------------------ |\n| %           | 将当前面板平分为左右两块                                     |\n| x           | 关闭当前面板                                                 |\n| !           | 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板     |\n| Ctrl+方向键 | 以1个单元格为单位移动边缘以调整当前面板大小                  |\n| Alt+方向键  | 以5个单元格为单位移动边缘以调整当前面板大小                  |\n| Space       | 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled |\n| q           | 显示面板编号                                                 |\n| o           | 在当前窗口中选择下一面板                                     |\n| 方向键      | 移动光标以选择面板                                           |\n| {           | 向前置换当前面板                                             |\n| }           | 向后置换当前面板                                             |\n| Alt+o       | 逆时针旋转当前窗口的面板                                     |\n| Ctrl+o      | 顺时针旋转当前窗口的面板                                     |\n\n> Ctrl-b s\t\t\t在 Tmux 的会话间切换\n>\n> Ctrl-b %\t\t\t上下分屏\n>\n> Ctrl-b \"\t\t\t左右分屏\n>\n> Ctrl-b +方向键\t进入对应的窗格\n>\n> Ctrl-b c\t\t\t创建窗口\n>\n> Ctrl-b +数字\t\t切换窗口 \n>\n> Ctrl-b &\t\t\t离开一个会话[exited]\n>\n> Ctrl-b d\t\t\t从一个会话中脱离[dettached]\n\n## ssh\n\n下载MobaXterm来在windows下使用ssh\n\n连接命令：\n\n```shell\nssh username@xxx.xxx.xxx.xxx\npassword\n```\n\n## 监控显卡\n\n```shell\nnvidia smi\n```\n\n[GPU使用表的具体含义](https://blog.csdn.net/bruce_0712/article/details/63683787)：\n\n> 第一张表格中： \n>\n> 第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。\n>\n>\n> 第二栏的Temp：是温度，单位摄氏度。 \n>\n> 第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。 \n>\n> 第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。\n>\n>\n> 第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function \n>\n> 第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。 \n>\n> 第五第六栏下方的Memory Usage是显存使用率。 \n>\n> 第七栏是浮动的GPU利用率。 \n>\n> 第八栏上方是关于ECC的东西。 \n>\n> 第八栏下方Compute M是计算模式。 \n>\n> 第二张表示每个进程占用的显存使用情况。\n\n### 使用watch命令实时监测显卡\n\nwatch的基本用法：\n\n```shell\nwatch [options]  command\n```\n\n最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。\n\n例如：设置每 10s 显示一次显存的情况\n\n```shell\nwatch -n 10 nvidia-smi\n```\n\n## cifar10\n\n继续调整网络结构和参数来增加准确率。","slug":"深度学习周报week03-week04","published":1,"updated":"2018-10-10T08:46:59.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xb003qfmagou6fa3e4","content":"<h2 id=\"Tmux-：终端分割\"><a href=\"#Tmux-：终端分割\" class=\"headerlink\" title=\"Tmux ：终端分割\"></a>Tmux ：终端分割</h2><blockquote><p>tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。</p></blockquote><a id=\"more\"></a><h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p><code>Ctrl+b ：激活控制台；此时以下按键生效</code></p><h4 id=\"系统操作\"><a href=\"#系统操作\" class=\"headerlink\" title=\"系统操作\"></a>系统操作</h4><table><thead><tr><th>?</th><th>列出所有快捷键；按q返回</th></tr></thead><tbody><tr><td>d</td><td>脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</td></tr><tr><td>D</td><td>选择要脱离的会话；在同时开启了多个会话时使用</td></tr><tr><td>Ctrl+z</td><td>挂起当前会话</td></tr><tr><td>r</td><td>强制重绘未脱离的会话</td></tr><tr><td>s</td><td>选择并切换会话；在同时开启了多个会话时使用</td></tr><tr><td>:</td><td>进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</td></tr><tr><td>[</td><td>进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出</td></tr><tr><td>~</td><td>列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td></tr></tbody></table><h4 id=\"窗口操作\"><a href=\"#窗口操作\" class=\"headerlink\" title=\"窗口操作\"></a>窗口操作</h4><table><thead><tr><th>c</th><th>创建新窗口</th></tr></thead><tbody><tr><td>&amp;</td><td>关闭当前窗口</td></tr><tr><td>数字键</td><td>切换至指定窗口</td></tr><tr><td>p</td><td>切换至上一窗口</td></tr><tr><td>n</td><td>切换至下一窗口</td></tr><tr><td>l</td><td>在前后两个窗口间互相切换</td></tr><tr><td>w</td><td>通过窗口列表切换窗口</td></tr><tr><td>,</td><td>重命名当前窗口；这样便于识别</td></tr><tr><td>.</td><td>修改当前窗口编号；相当于窗口重新排序</td></tr><tr><td>f</td><td>在所有窗口中查找指定文本</td></tr></tbody></table><h4 id=\"面板操作\"><a href=\"#面板操作\" class=\"headerlink\" title=\"面板操作\"></a>面板操作</h4><table><thead><tr><th>”</th><th>将当前面板平分为上下两块</th></tr></thead><tbody><tr><td>%</td><td>将当前面板平分为左右两块</td></tr><tr><td>x</td><td>关闭当前面板</td></tr><tr><td>!</td><td>将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板</td></tr><tr><td>Ctrl+方向键</td><td>以1个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Alt+方向键</td><td>以5个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Space</td><td>在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</td></tr><tr><td>q</td><td>显示面板编号</td></tr><tr><td>o</td><td>在当前窗口中选择下一面板</td></tr><tr><td>方向键</td><td>移动光标以选择面板</td></tr><tr><td>{</td><td>向前置换当前面板</td></tr><tr><td>}</td><td>向后置换当前面板</td></tr><tr><td>Alt+o</td><td>逆时针旋转当前窗口的面板</td></tr><tr><td>Ctrl+o</td><td>顺时针旋转当前窗口的面板</td></tr></tbody></table><blockquote><p>Ctrl-b s 在 Tmux 的会话间切换</p><p>Ctrl-b % 上下分屏</p><p>Ctrl-b “ 左右分屏</p><p>Ctrl-b +方向键 进入对应的窗格</p><p>Ctrl-b c 创建窗口</p><p>Ctrl-b +数字 切换窗口</p><p>Ctrl-b &amp; 离开一个会话[exited]</p><p>Ctrl-b d 从一个会话中脱离[dettached]</p></blockquote><h2 id=\"ssh\"><a href=\"#ssh\" class=\"headerlink\" title=\"ssh\"></a>ssh</h2><p>下载MobaXterm来在windows下使用ssh</p><p>连接命令：</p><pre class=\" language-shell\"><code class=\"language-shell\">ssh username@xxx.xxx.xxx.xxx\npassword\n</code></pre><h2 id=\"监控显卡\"><a href=\"#监控显卡\" class=\"headerlink\" title=\"监控显卡\"></a>监控显卡</h2><pre class=\" language-shell\"><code class=\"language-shell\">nvidia smi\n</code></pre><p><a href=\"https://blog.csdn.net/bruce_0712/article/details/63683787\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">GPU使用表的具体含义</a>：</p><blockquote><p>第一张表格中：</p><p>第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。</p><p>第二栏的Temp：是温度，单位摄氏度。</p><p>第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。</p><p>第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。</p><p>第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function</p><p>第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。</p><p>第五第六栏下方的Memory Usage是显存使用率。</p><p>第七栏是浮动的GPU利用率。</p><p>第八栏上方是关于ECC的东西。</p><p>第八栏下方Compute M是计算模式。</p><p>第二张表示每个进程占用的显存使用情况。</p></blockquote><h3 id=\"使用watch命令实时监测显卡\"><a href=\"#使用watch命令实时监测显卡\" class=\"headerlink\" title=\"使用watch命令实时监测显卡\"></a>使用watch命令实时监测显卡</h3><p>watch的基本用法：</p><pre class=\" language-shell\"><code class=\"language-shell\">watch [options]  command\n</code></pre><p>最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。</p><p>例如：设置每 10s 显示一次显存的情况</p><pre class=\" language-shell\"><code class=\"language-shell\">watch -n 10 nvidia-smi\n</code></pre><h2 id=\"cifar10\"><a href=\"#cifar10\" class=\"headerlink\" title=\"cifar10\"></a>cifar10</h2><p>继续调整网络结构和参数来增加准确率。</p>","site":{"data":{}},"excerpt":"<h2 id=\"Tmux-：终端分割\"><a href=\"#Tmux-：终端分割\" class=\"headerlink\" title=\"Tmux ：终端分割\"></a>Tmux ：终端分割</h2><blockquote><p>tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。</p></blockquote>","more":"<h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p><code>Ctrl+b ：激活控制台；此时以下按键生效</code></p><h4 id=\"系统操作\"><a href=\"#系统操作\" class=\"headerlink\" title=\"系统操作\"></a>系统操作</h4><table><thead><tr><th>?</th><th>列出所有快捷键；按q返回</th></tr></thead><tbody><tr><td>d</td><td>脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</td></tr><tr><td>D</td><td>选择要脱离的会话；在同时开启了多个会话时使用</td></tr><tr><td>Ctrl+z</td><td>挂起当前会话</td></tr><tr><td>r</td><td>强制重绘未脱离的会话</td></tr><tr><td>s</td><td>选择并切换会话；在同时开启了多个会话时使用</td></tr><tr><td>:</td><td>进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</td></tr><tr><td>[</td><td>进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出</td></tr><tr><td>~</td><td>列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td></tr></tbody></table><h4 id=\"窗口操作\"><a href=\"#窗口操作\" class=\"headerlink\" title=\"窗口操作\"></a>窗口操作</h4><table><thead><tr><th>c</th><th>创建新窗口</th></tr></thead><tbody><tr><td>&amp;</td><td>关闭当前窗口</td></tr><tr><td>数字键</td><td>切换至指定窗口</td></tr><tr><td>p</td><td>切换至上一窗口</td></tr><tr><td>n</td><td>切换至下一窗口</td></tr><tr><td>l</td><td>在前后两个窗口间互相切换</td></tr><tr><td>w</td><td>通过窗口列表切换窗口</td></tr><tr><td>,</td><td>重命名当前窗口；这样便于识别</td></tr><tr><td>.</td><td>修改当前窗口编号；相当于窗口重新排序</td></tr><tr><td>f</td><td>在所有窗口中查找指定文本</td></tr></tbody></table><h4 id=\"面板操作\"><a href=\"#面板操作\" class=\"headerlink\" title=\"面板操作\"></a>面板操作</h4><table><thead><tr><th>”</th><th>将当前面板平分为上下两块</th></tr></thead><tbody><tr><td>%</td><td>将当前面板平分为左右两块</td></tr><tr><td>x</td><td>关闭当前面板</td></tr><tr><td>!</td><td>将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板</td></tr><tr><td>Ctrl+方向键</td><td>以1个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Alt+方向键</td><td>以5个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>Space</td><td>在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</td></tr><tr><td>q</td><td>显示面板编号</td></tr><tr><td>o</td><td>在当前窗口中选择下一面板</td></tr><tr><td>方向键</td><td>移动光标以选择面板</td></tr><tr><td>{</td><td>向前置换当前面板</td></tr><tr><td>}</td><td>向后置换当前面板</td></tr><tr><td>Alt+o</td><td>逆时针旋转当前窗口的面板</td></tr><tr><td>Ctrl+o</td><td>顺时针旋转当前窗口的面板</td></tr></tbody></table><blockquote><p>Ctrl-b s 在 Tmux 的会话间切换</p><p>Ctrl-b % 上下分屏</p><p>Ctrl-b “ 左右分屏</p><p>Ctrl-b +方向键 进入对应的窗格</p><p>Ctrl-b c 创建窗口</p><p>Ctrl-b +数字 切换窗口</p><p>Ctrl-b &amp; 离开一个会话[exited]</p><p>Ctrl-b d 从一个会话中脱离[dettached]</p></blockquote><h2 id=\"ssh\"><a href=\"#ssh\" class=\"headerlink\" title=\"ssh\"></a>ssh</h2><p>下载MobaXterm来在windows下使用ssh</p><p>连接命令：</p><pre><code class=\"shell\">ssh username@xxx.xxx.xxx.xxx\npassword\n</code></pre><h2 id=\"监控显卡\"><a href=\"#监控显卡\" class=\"headerlink\" title=\"监控显卡\"></a>监控显卡</h2><pre><code class=\"shell\">nvidia smi\n</code></pre><p><a href=\"https://blog.csdn.net/bruce_0712/article/details/63683787\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">GPU使用表的具体含义</a>：</p><blockquote><p>第一张表格中：</p><p>第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。</p><p>第二栏的Temp：是温度，单位摄氏度。</p><p>第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。</p><p>第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。</p><p>第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function</p><p>第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。</p><p>第五第六栏下方的Memory Usage是显存使用率。</p><p>第七栏是浮动的GPU利用率。</p><p>第八栏上方是关于ECC的东西。</p><p>第八栏下方Compute M是计算模式。</p><p>第二张表示每个进程占用的显存使用情况。</p></blockquote><h3 id=\"使用watch命令实时监测显卡\"><a href=\"#使用watch命令实时监测显卡\" class=\"headerlink\" title=\"使用watch命令实时监测显卡\"></a>使用watch命令实时监测显卡</h3><p>watch的基本用法：</p><pre><code class=\"shell\">watch [options]  command\n</code></pre><p>最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。</p><p>例如：设置每 10s 显示一次显存的情况</p><pre><code class=\"shell\">watch -n 10 nvidia-smi\n</code></pre><h2 id=\"cifar10\"><a href=\"#cifar10\" class=\"headerlink\" title=\"cifar10\"></a>cifar10</h2><p>继续调整网络结构和参数来增加准确率。</p>"},{"title":"深度学习周报week05-week06","toc":true,"date":"2018-05-12T02:22:12.000Z","_content":"\n## 过拟合\n\n过拟合，就是拟合函数由于顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。\n\n<!-- more -->\n\n## 正则化\n\n[参考链接](https://blog.csdn.net/u012162613/article/details/44261657)\n\n当训练数据不够多或训练过度时，常常会导致过拟合。正则化就是避免过拟合的一个办法。\n\n<u>正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</u>\n\n### L2正则化（权重衰减）\n\nL2正则化就是在代价函数后面再加上一个正则化项：\n\n![](/images/L2.jpg)\n\n### L1正则化\n\nL1正则化就是在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n：\n\n![](/images/L1.jpg)\n\n## Batch Normalization(BN)\n\n在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。\n\n![](/images/BN.png)\n\n训练过程中采用batch 随机梯度下降，其中E(xk)指的是每一批训练数据神经元xk的平均值；分母指的是每一批数据神经元xk激活度的一个标准差。\n\n引入了可学习参数γ、β：\n\n![](/images/BN_y.png)\n\n因此Batch Normalization网络层的前向传导过程公式为：\n\n![](/images/BN_back.png)\n\n其中m为mini-batch size。\n\n### 在CNN中的使用\n\n由于BN是对单个神经元的运算，因此为了避免参数过多的情况，使用类似权值共享的策略，把一整张特征图当作一个神经元处理。\n\n## cifar 10\n\n继续调整网络结构和参数。\n\n## 项目准备\n\n了解频谱图以及音频采样。\n\n","source":"_posts/深度学习周报week05-week06.md","raw":"---\ntitle: 深度学习周报week05-week06\ntoc: true\ndate: 2018-05-12 10:22:12\ncategories:\n- deep learning\ntags:\n- BN\n---\n\n## 过拟合\n\n过拟合，就是拟合函数由于顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。\n\n<!-- more -->\n\n## 正则化\n\n[参考链接](https://blog.csdn.net/u012162613/article/details/44261657)\n\n当训练数据不够多或训练过度时，常常会导致过拟合。正则化就是避免过拟合的一个办法。\n\n<u>正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</u>\n\n### L2正则化（权重衰减）\n\nL2正则化就是在代价函数后面再加上一个正则化项：\n\n![](/images/L2.jpg)\n\n### L1正则化\n\nL1正则化就是在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n：\n\n![](/images/L1.jpg)\n\n## Batch Normalization(BN)\n\n在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。\n\n![](/images/BN.png)\n\n训练过程中采用batch 随机梯度下降，其中E(xk)指的是每一批训练数据神经元xk的平均值；分母指的是每一批数据神经元xk激活度的一个标准差。\n\n引入了可学习参数γ、β：\n\n![](/images/BN_y.png)\n\n因此Batch Normalization网络层的前向传导过程公式为：\n\n![](/images/BN_back.png)\n\n其中m为mini-batch size。\n\n### 在CNN中的使用\n\n由于BN是对单个神经元的运算，因此为了避免参数过多的情况，使用类似权值共享的策略，把一整张特征图当作一个神经元处理。\n\n## cifar 10\n\n继续调整网络结构和参数。\n\n## 项目准备\n\n了解频谱图以及音频采样。\n\n","slug":"深度学习周报week05-week06","published":1,"updated":"2018-10-10T08:46:48.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xe003ufmag51188ac7","content":"<h2 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h2><p>过拟合，就是拟合函数由于顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</p><a id=\"more\"></a><h2 id=\"正则化\"><a href=\"#正则化\" class=\"headerlink\" title=\"正则化\"></a>正则化</h2><p><a href=\"https://blog.csdn.net/u012162613/article/details/44261657\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>当训练数据不够多或训练过度时，常常会导致过拟合。正则化就是避免过拟合的一个办法。</p><p><u>正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</u></p><h3 id=\"L2正则化（权重衰减）\"><a href=\"#L2正则化（权重衰减）\" class=\"headerlink\" title=\"L2正则化（权重衰减）\"></a>L2正则化（权重衰减）</h3><p>L2正则化就是在代价函数后面再加上一个正则化项：</p><p><img src=\"/images/L2.jpg\" alt=\"\"></p><h3 id=\"L1正则化\"><a href=\"#L1正则化\" class=\"headerlink\" title=\"L1正则化\"></a>L1正则化</h3><p>L1正则化就是在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n：</p><p><img src=\"/images/L1.jpg\" alt=\"\"></p><h2 id=\"Batch-Normalization-BN\"><a href=\"#Batch-Normalization-BN\" class=\"headerlink\" title=\"Batch Normalization(BN)\"></a>Batch Normalization(BN)</h2><p>在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。</p><p><img src=\"/images/BN.png\" alt=\"\"></p><p>训练过程中采用batch 随机梯度下降，其中E(xk)指的是每一批训练数据神经元xk的平均值；分母指的是每一批数据神经元xk激活度的一个标准差。</p><p>引入了可学习参数γ、β：</p><p><img src=\"/images/BN_y.png\" alt=\"\"></p><p>因此Batch Normalization网络层的前向传导过程公式为：</p><p><img src=\"/images/BN_back.png\" alt=\"\"></p><p>其中m为mini-batch size。</p><h3 id=\"在CNN中的使用\"><a href=\"#在CNN中的使用\" class=\"headerlink\" title=\"在CNN中的使用\"></a>在CNN中的使用</h3><p>由于BN是对单个神经元的运算，因此为了避免参数过多的情况，使用类似权值共享的策略，把一整张特征图当作一个神经元处理。</p><h2 id=\"cifar-10\"><a href=\"#cifar-10\" class=\"headerlink\" title=\"cifar 10\"></a>cifar 10</h2><p>继续调整网络结构和参数。</p><h2 id=\"项目准备\"><a href=\"#项目准备\" class=\"headerlink\" title=\"项目准备\"></a>项目准备</h2><p>了解频谱图以及音频采样。</p>","site":{"data":{}},"excerpt":"<h2 id=\"过拟合\"><a href=\"#过拟合\" class=\"headerlink\" title=\"过拟合\"></a>过拟合</h2><p>过拟合，就是拟合函数由于顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</p>","more":"<h2 id=\"正则化\"><a href=\"#正则化\" class=\"headerlink\" title=\"正则化\"></a>正则化</h2><p><a href=\"https://blog.csdn.net/u012162613/article/details/44261657\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>当训练数据不够多或训练过度时，常常会导致过拟合。正则化就是避免过拟合的一个办法。</p><p><u>正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。</u></p><h3 id=\"L2正则化（权重衰减）\"><a href=\"#L2正则化（权重衰减）\" class=\"headerlink\" title=\"L2正则化（权重衰减）\"></a>L2正则化（权重衰减）</h3><p>L2正则化就是在代价函数后面再加上一个正则化项：</p><p><img src=\"/images/L2.jpg\" alt=\"\"></p><h3 id=\"L1正则化\"><a href=\"#L1正则化\" class=\"headerlink\" title=\"L1正则化\"></a>L1正则化</h3><p>L1正则化就是在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n：</p><p><img src=\"/images/L1.jpg\" alt=\"\"></p><h2 id=\"Batch-Normalization-BN\"><a href=\"#Batch-Normalization-BN\" class=\"headerlink\" title=\"Batch Normalization(BN)\"></a>Batch Normalization(BN)</h2><p>在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。</p><p><img src=\"/images/BN.png\" alt=\"\"></p><p>训练过程中采用batch 随机梯度下降，其中E(xk)指的是每一批训练数据神经元xk的平均值；分母指的是每一批数据神经元xk激活度的一个标准差。</p><p>引入了可学习参数γ、β：</p><p><img src=\"/images/BN_y.png\" alt=\"\"></p><p>因此Batch Normalization网络层的前向传导过程公式为：</p><p><img src=\"/images/BN_back.png\" alt=\"\"></p><p>其中m为mini-batch size。</p><h3 id=\"在CNN中的使用\"><a href=\"#在CNN中的使用\" class=\"headerlink\" title=\"在CNN中的使用\"></a>在CNN中的使用</h3><p>由于BN是对单个神经元的运算，因此为了避免参数过多的情况，使用类似权值共享的策略，把一整张特征图当作一个神经元处理。</p><h2 id=\"cifar-10\"><a href=\"#cifar-10\" class=\"headerlink\" title=\"cifar 10\"></a>cifar 10</h2><p>继续调整网络结构和参数。</p><h2 id=\"项目准备\"><a href=\"#项目准备\" class=\"headerlink\" title=\"项目准备\"></a>项目准备</h2><p>了解频谱图以及音频采样。</p>"},{"title":"深度学习周报week07-week08","toc":true,"date":"2018-05-19T01:49:31.000Z","_content":"\n## 音频分类\n\n将1000个音频分别放入对应文件夹中：\n\n![](/images/classification.PNG)\n\n`filename.txt` 存储文件对应位置。\n\n<!-- more -->\n\n以上所有存储在`classification`文件夹中。\n\n建立`filename.py`来生成`filename.txt`：\n\n```python\nimport os\n\ntextname = 'filename.txt'\nwith open(textname, 'w') as f:\n    for root, dirs, afiles in os.walk('./classification'):\n        for subdir in dirs:\n            for subroot, subdirs, subfiles in os.walk('./classification/'+subdir):\n                for filename in subfiles:\n                    apath = os.path.join(subdir, filename)\n                    f.write(apath)\n                    f.write('\\n')\n```\n\n生成的`filename.txt`为：\n\n![](/images/filename_txt.PNG)\n\n## MFCC\n\n[学习链接](https://blog.csdn.net/fengzhonghen/article/details/51722555)\n\n**MFCC**(Mel-frequency cepstral coefficients)：梅尔频率倒谱系数。\n\n梅尔频率是基于人耳听觉特性提出的概念， 它与Hz频率成非线性对应关系。\n\nMFCC则是利用它们之间的这种关系，计算得到的Hz频谱特征，<u>主要用于语音数据特征提取和降低运算维度</u>。\n\n<u>主要用于语音数据特征提取和降低运算维度。</u>\n\n例如：对于一帧有512维(采样点)数据，经过MFCC后可以提取出最重要的40维(一般而言)数据同时也达到了将维的目的。\n\nMFCC的步骤为：\n\n- 预加重\n- 分帧\n- 加窗\n- **快速傅里叶变换(FFT)**\n- **梅尔滤波器组**\n- 离散余弦变换(DCT)\n\n其中最重要的就是FFT和梅尔滤波器组，这两个进行了主要的降维操作。\n\n## 了解相关库和函数\n\n- scipy.io.wavfile\n- python_speech_features\n- librosa\n- pydub\n- tf.sparse_tensor_to_dense\n- tf.edit_distance\n- tf.nn.ctc_loss","source":"_posts/深度学习周报week07-week08.md","raw":"---\ntitle: 深度学习周报week07-week08\ntoc: true\ndate: 2018-05-19 09:49:31\ncategories:\n- deep learning\ntags:\n---\n\n## 音频分类\n\n将1000个音频分别放入对应文件夹中：\n\n![](/images/classification.PNG)\n\n`filename.txt` 存储文件对应位置。\n\n<!-- more -->\n\n以上所有存储在`classification`文件夹中。\n\n建立`filename.py`来生成`filename.txt`：\n\n```python\nimport os\n\ntextname = 'filename.txt'\nwith open(textname, 'w') as f:\n    for root, dirs, afiles in os.walk('./classification'):\n        for subdir in dirs:\n            for subroot, subdirs, subfiles in os.walk('./classification/'+subdir):\n                for filename in subfiles:\n                    apath = os.path.join(subdir, filename)\n                    f.write(apath)\n                    f.write('\\n')\n```\n\n生成的`filename.txt`为：\n\n![](/images/filename_txt.PNG)\n\n## MFCC\n\n[学习链接](https://blog.csdn.net/fengzhonghen/article/details/51722555)\n\n**MFCC**(Mel-frequency cepstral coefficients)：梅尔频率倒谱系数。\n\n梅尔频率是基于人耳听觉特性提出的概念， 它与Hz频率成非线性对应关系。\n\nMFCC则是利用它们之间的这种关系，计算得到的Hz频谱特征，<u>主要用于语音数据特征提取和降低运算维度</u>。\n\n<u>主要用于语音数据特征提取和降低运算维度。</u>\n\n例如：对于一帧有512维(采样点)数据，经过MFCC后可以提取出最重要的40维(一般而言)数据同时也达到了将维的目的。\n\nMFCC的步骤为：\n\n- 预加重\n- 分帧\n- 加窗\n- **快速傅里叶变换(FFT)**\n- **梅尔滤波器组**\n- 离散余弦变换(DCT)\n\n其中最重要的就是FFT和梅尔滤波器组，这两个进行了主要的降维操作。\n\n## 了解相关库和函数\n\n- scipy.io.wavfile\n- python_speech_features\n- librosa\n- pydub\n- tf.sparse_tensor_to_dense\n- tf.edit_distance\n- tf.nn.ctc_loss","slug":"深度学习周报week07-week08","published":1,"updated":"2018-10-10T08:46:32.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xg003xfmagg5b3pru1","content":"<h2 id=\"音频分类\"><a href=\"#音频分类\" class=\"headerlink\" title=\"音频分类\"></a>音频分类</h2><p>将1000个音频分别放入对应文件夹中：</p><p><img src=\"/images/classification.PNG\" alt=\"\"></p><p><code>filename.txt</code> 存储文件对应位置。</p><a id=\"more\"></a><p>以上所有存储在<code>classification</code>文件夹中。</p><p>建立<code>filename.py</code>来生成<code>filename.txt</code>：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n\ntextname <span class=\"token operator\">=</span> <span class=\"token string\">'filename.txt'</span>\n<span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span>textname<span class=\"token punctuation\">,</span> <span class=\"token string\">'w'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> f<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> root<span class=\"token punctuation\">,</span> dirs<span class=\"token punctuation\">,</span> afiles <span class=\"token keyword\">in</span> os<span class=\"token punctuation\">.</span>walk<span class=\"token punctuation\">(</span><span class=\"token string\">'./classification'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> subdir <span class=\"token keyword\">in</span> dirs<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> subroot<span class=\"token punctuation\">,</span> subdirs<span class=\"token punctuation\">,</span> subfiles <span class=\"token keyword\">in</span> os<span class=\"token punctuation\">.</span>walk<span class=\"token punctuation\">(</span><span class=\"token string\">'./classification/'</span><span class=\"token operator\">+</span>subdir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">for</span> filename <span class=\"token keyword\">in</span> subfiles<span class=\"token punctuation\">:</span>\n                    apath <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>subdir<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span>\n                    f<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>apath<span class=\"token punctuation\">)</span>\n                    f<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span>\n</code></pre><p>生成的<code>filename.txt</code>为：</p><p><img src=\"/images/filename_txt.PNG\" alt=\"\"></p><h2 id=\"MFCC\"><a href=\"#MFCC\" class=\"headerlink\" title=\"MFCC\"></a>MFCC</h2><p><a href=\"https://blog.csdn.net/fengzhonghen/article/details/51722555\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">学习链接</a></p><p><strong>MFCC</strong>(Mel-frequency cepstral coefficients)：梅尔频率倒谱系数。</p><p>梅尔频率是基于人耳听觉特性提出的概念， 它与Hz频率成非线性对应关系。</p><p>MFCC则是利用它们之间的这种关系，计算得到的Hz频谱特征，<u>主要用于语音数据特征提取和降低运算维度</u>。</p><p><u>主要用于语音数据特征提取和降低运算维度。</u></p><p>例如：对于一帧有512维(采样点)数据，经过MFCC后可以提取出最重要的40维(一般而言)数据同时也达到了将维的目的。</p><p>MFCC的步骤为：</p><ul><li>预加重</li><li>分帧</li><li>加窗</li><li><strong>快速傅里叶变换(FFT)</strong></li><li><strong>梅尔滤波器组</strong></li><li>离散余弦变换(DCT)</li></ul><p>其中最重要的就是FFT和梅尔滤波器组，这两个进行了主要的降维操作。</p><h2 id=\"了解相关库和函数\"><a href=\"#了解相关库和函数\" class=\"headerlink\" title=\"了解相关库和函数\"></a>了解相关库和函数</h2><ul><li>scipy.io.wavfile</li><li>python_speech_features</li><li>librosa</li><li>pydub</li><li>tf.sparse_tensor_to_dense</li><li>tf.edit_distance</li><li>tf.nn.ctc_loss</li></ul>","site":{"data":{}},"excerpt":"<h2 id=\"音频分类\"><a href=\"#音频分类\" class=\"headerlink\" title=\"音频分类\"></a>音频分类</h2><p>将1000个音频分别放入对应文件夹中：</p><p><img src=\"/images/classification.PNG\" alt=\"\"></p><p><code>filename.txt</code> 存储文件对应位置。</p>","more":"<p>以上所有存储在<code>classification</code>文件夹中。</p><p>建立<code>filename.py</code>来生成<code>filename.txt</code>：</p><pre><code class=\"python\">import os\n\ntextname = &#39;filename.txt&#39;\nwith open(textname, &#39;w&#39;) as f:\n    for root, dirs, afiles in os.walk(&#39;./classification&#39;):\n        for subdir in dirs:\n            for subroot, subdirs, subfiles in os.walk(&#39;./classification/&#39;+subdir):\n                for filename in subfiles:\n                    apath = os.path.join(subdir, filename)\n                    f.write(apath)\n                    f.write(&#39;\\n&#39;)\n</code></pre><p>生成的<code>filename.txt</code>为：</p><p><img src=\"/images/filename_txt.PNG\" alt=\"\"></p><h2 id=\"MFCC\"><a href=\"#MFCC\" class=\"headerlink\" title=\"MFCC\"></a>MFCC</h2><p><a href=\"https://blog.csdn.net/fengzhonghen/article/details/51722555\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">学习链接</a></p><p><strong>MFCC</strong>(Mel-frequency cepstral coefficients)：梅尔频率倒谱系数。</p><p>梅尔频率是基于人耳听觉特性提出的概念， 它与Hz频率成非线性对应关系。</p><p>MFCC则是利用它们之间的这种关系，计算得到的Hz频谱特征，<u>主要用于语音数据特征提取和降低运算维度</u>。</p><p><u>主要用于语音数据特征提取和降低运算维度。</u></p><p>例如：对于一帧有512维(采样点)数据，经过MFCC后可以提取出最重要的40维(一般而言)数据同时也达到了将维的目的。</p><p>MFCC的步骤为：</p><ul><li>预加重</li><li>分帧</li><li>加窗</li><li><strong>快速傅里叶变换(FFT)</strong></li><li><strong>梅尔滤波器组</strong></li><li>离散余弦变换(DCT)</li></ul><p>其中最重要的就是FFT和梅尔滤波器组，这两个进行了主要的降维操作。</p><h2 id=\"了解相关库和函数\"><a href=\"#了解相关库和函数\" class=\"headerlink\" title=\"了解相关库和函数\"></a>了解相关库和函数</h2><ul><li>scipy.io.wavfile</li><li>python_speech_features</li><li>librosa</li><li>pydub</li><li>tf.sparse_tensor_to_dense</li><li>tf.edit_distance</li><li>tf.nn.ctc_loss</li></ul>"},{"title":"深度学习周报week09-week10","toc":true,"date":"2018-06-27T12:06:00.000Z","_content":"\n## 项目实现\n\n- 分类后的音频作为训练集\n\n\n- 读入训练集后对语音进行初始化和特征提取\n- 定义参数\n- 实现网络结构（七层卷积三次下采样）\n- 训练模型并进行检验（对单词识别）\n\n\n## 优化\n\n根据准确率和Tensor flow Board不断调整参数和网络结构。","source":"_posts/深度学习周报week09-week10.md","raw":"---\ntitle: 深度学习周报week09-week10\ntoc: true\ndate: 2018-06-27 20:06:00\ncategories:\n- deep learning\ntags:\n---\n\n## 项目实现\n\n- 分类后的音频作为训练集\n\n\n- 读入训练集后对语音进行初始化和特征提取\n- 定义参数\n- 实现网络结构（七层卷积三次下采样）\n- 训练模型并进行检验（对单词识别）\n\n\n## 优化\n\n根据准确率和Tensor flow Board不断调整参数和网络结构。","slug":"深度学习周报week09-week10","published":1,"updated":"2018-09-11T05:46:12.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xi0040fmaggzsalgpe","content":"<h2 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h2><ul><li>分类后的音频作为训练集</li></ul><ul><li>读入训练集后对语音进行初始化和特征提取</li><li>定义参数</li><li>实现网络结构（七层卷积三次下采样）</li><li>训练模型并进行检验（对单词识别）</li></ul><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>根据准确率和Tensor flow Board不断调整参数和网络结构。</p>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"项目实现\"><a href=\"#项目实现\" class=\"headerlink\" title=\"项目实现\"></a>项目实现</h2><ul><li>分类后的音频作为训练集</li></ul><ul><li>读入训练集后对语音进行初始化和特征提取</li><li>定义参数</li><li>实现网络结构（七层卷积三次下采样）</li><li>训练模型并进行检验（对单词识别）</li></ul><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>根据准确率和Tensor flow Board不断调整参数和网络结构。</p>"},{"title":"深度学习周报week11-week12","toc":true,"date":"2018-06-27T12:22:11.000Z","_content":"\n## 实现本地服务器\n\n## Tornado\n\n利用tornado框架搭建本地服务器。\n\n<!-- more -->\n\n主要学习以下内容：\n\n- define\n- Future\n- RequestHandler\n- 协程装饰器\n- http相关\n- json相关\n- 正则表达式匹配url\n\n\n## 优化\n\n继续调整参数和网络进行优化\n\n## 整合\n\n将训练模型单独整合为一个函数，server单独为一个文件，运行server，在开启本地服务器时，调用此函数训练模型，选定一个测试数据后直接进行预测。","source":"_posts/深度学习周报week11-week12.md","raw":"---\ntitle: 深度学习周报week11-week12\ntoc: true\ndate: 2018-06-27 20:22:11\ncategories:\n- deep learning\ntags:\n---\n\n## 实现本地服务器\n\n## Tornado\n\n利用tornado框架搭建本地服务器。\n\n<!-- more -->\n\n主要学习以下内容：\n\n- define\n- Future\n- RequestHandler\n- 协程装饰器\n- http相关\n- json相关\n- 正则表达式匹配url\n\n\n## 优化\n\n继续调整参数和网络进行优化\n\n## 整合\n\n将训练模型单独整合为一个函数，server单独为一个文件，运行server，在开启本地服务器时，调用此函数训练模型，选定一个测试数据后直接进行预测。","slug":"深度学习周报week11-week12","published":1,"updated":"2018-10-10T08:46:05.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xk0044fmagzgd7bsl3","content":"<h2 id=\"实现本地服务器\"><a href=\"#实现本地服务器\" class=\"headerlink\" title=\"实现本地服务器\"></a>实现本地服务器</h2><h2 id=\"Tornado\"><a href=\"#Tornado\" class=\"headerlink\" title=\"Tornado\"></a>Tornado</h2><p>利用tornado框架搭建本地服务器。</p><a id=\"more\"></a><p>主要学习以下内容：</p><ul><li>define</li><li>Future</li><li>RequestHandler</li><li>协程装饰器</li><li>http相关</li><li>json相关</li><li>正则表达式匹配url</li></ul><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>继续调整参数和网络进行优化</p><h2 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h2><p>将训练模型单独整合为一个函数，server单独为一个文件，运行server，在开启本地服务器时，调用此函数训练模型，选定一个测试数据后直接进行预测。</p>","site":{"data":{}},"excerpt":"<h2 id=\"实现本地服务器\"><a href=\"#实现本地服务器\" class=\"headerlink\" title=\"实现本地服务器\"></a>实现本地服务器</h2><h2 id=\"Tornado\"><a href=\"#Tornado\" class=\"headerlink\" title=\"Tornado\"></a>Tornado</h2><p>利用tornado框架搭建本地服务器。</p>","more":"<p>主要学习以下内容：</p><ul><li>define</li><li>Future</li><li>RequestHandler</li><li>协程装饰器</li><li>http相关</li><li>json相关</li><li>正则表达式匹配url</li></ul><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>继续调整参数和网络进行优化</p><h2 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h2><p>将训练模型单独整合为一个函数，server单独为一个文件，运行server，在开启本地服务器时，调用此函数训练模型，选定一个测试数据后直接进行预测。</p>"},{"title":"牛客网前端挑战编程题解","toc":true,"date":"2018-09-20T06:33:15.000Z","_content":"\nOJ链接：https://www.nowcoder.com/ta/front-end\n\n注意：在牛客不能用ES6的东西！\n\n<!-- more -->\n\n## 修改this指向\n\n>  封装函数 f，使 f 的 this 指向指定的对象\n\n代码\n\n```js\nfunction bindThis(f, oTarget) {\n  // 考虑浏览器兼容\n  if (f.bind) {\n    return f.bind(oTarget);\n  } else {\n    // apply()为立即执行函数，因此需要放在一个函数里，到需要使用的时候再立即执行\n    return function() {\n      // arguments不能省略，在执行f时可能会传入参数\n      return f.apply(oTarget, arguments);\n    }\n  }\n}\n```\n\n## 获取url参数\n\n> 获取 url 中的参数\n> 1. 指定参数名称，返回该参数的值 或者 空字符串\n> 2. 不指定参数名称，返回全部的参数对象 或者 {}\n> 3. 如果存在多个同名参数，则返回数组\n\n输入\n\n```\nhttp://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe\n```\n\n输出\n\n```\n[1, 2, 3]\n```\n\n代码\n\n```js\nfunction getUrlParam(sUrl, sKey) {\n  var result = {};\n  // 先取?和#之间的字符串，然后按照&分割\n  var querys = ((sUrl.split('?')[1]).split('#')[0]).split('&');\n  for (var i = 0; i < querys.length; i++) {\n    var key = querys[i].split('=')[0];\n    var value = querys[i].split('=')[1];\n    // 如果result[key]未定义，则创建一个含有value的数组\n    if (result[key] == undefined) result[key] = [value];\n    else result[key].push(value);\n  }\n  // 不指定参数名称，返回全部的参数对象\n  if (sKey == undefined) return result;\n  if (result[sKey] == undefined) return \"\";\n  else if (result[sKey].length == 1) return result[sKey][0];\n  else return result[sKey];\n}\n```\n\n还有大神的正则的方法...直接贴出来吧：\n\n```js\n// 链接：https://www.nowcoder.com/questionTerminal/a3ded747e3884a3c86d09d88d1652e10\n// 来源：牛客网\n\nfunction getUrlParam(sUrl, sKey) {\n    var obj = {};\n    var reg = /[?&](\\w+)=(\\w+)/g;\n    while(reg.exec(sUrl))\n        obj[RegExp.$1] ? obj[RegExp.$1]=[].concat(obj[RegExp.$1],RegExp.$2) : obj[RegExp.$1]=RegExp.$2;\n    return sKey ? obj[sKey]||\"\" : obj;\n}\n```\n\n## dom节点查找\n\n> 查找两个节点的最近的一个共同父节点，可以包括节点自身\n\n输入描述\n\n```\noNode1 和 oNode2 在同一文档中，且不会为相同的节点\n```\n\n代码\n\n```js\nfunction commonParentNode(oNode1, oNode2) {\n    for (;oNode1;oNode1 = oNode1.parentNode) {\n        if (oNode1.contains(oNode2)) {\n            return oNode1;\n        }\n    }\n}\n```\n\n还是对DOM的相关属性啊什么的不了解。。红宝书刚看到DOM。。。要加油鸭\n\n## 根据包名，在指定空间中创建对象\n\n输入描述\n\n```\nnamespace({a: {test: 1, b: 2}}, 'a.b.c.d')\n```\n\n输出描述\n\n```\n{a: {test: 1, b: {c: {d: {}}}}}\n```\n\n代码\n\n```js\nfunction namespace(oNamespace, sPackage) {\n    var tmpPoint = oNamespace;\n    var keys = sPackage.split('.');\n    for (var i = 0; i < keys.length; i++) {\n        if (tmpPoint[keys[i]] == undefined) tmpPoint[keys[i]] = {};\n        tmpPoint = tmpPoint[keys[i]];\n    }\n    return oNamespace;\n}\n```\n\n记住，对象名就像是指针一样。\n\n## 数组去重\n\n> 为 Array 对象添加一个去除重复项的方法\n\n输入\n\n```\n[false, true, undefined, null, NaN, 0, 1, {}, {}, 'a', 'a', NaN]\n```\n\n输出\n\n```\n[false, true, undefined, null, NaN, 0, 1, {}, {}, 'a']\n```\n\n代码\n\n```js\nArray.prototype.uniq = function () {\n    var hasNaN = false;\n    for (var i = 0; i < this.length; i++) {\n        if ((hasNaN === false) && (this[i] != this[i])) {\n            hasNaN = true;\n            continue;\n        }\n        if (this.indexOf(this[i]) < i) this.splice(i--,1);\n    }\n    return this;\n}\n```\n\n关于NaN的问题调试了好几次。。\n\n使用`this.indexOf(this[i]) < i`判断的时候，\n\n因为NaN和任何值都不相等，因此index是-1，因此在这里一定会被删掉，\n\n因此需要先判断是不是已经遇到过NaN了，遇到过的话再次遇到就直接删掉，没有遇到的话遇到时就把hasNaN设为true，然后continue来跳过splice。\n\n## 斐波那契数列\n\n> 用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等\n\nemmmmm，不知道为什么会有斐波那契这种题。。。。\n\n```js\n// 暴力递归\nfunction fibonacci(n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n// 本来想用callee，结果严格模式不让用。。。红宝书一直说callee多么多么好。。。搞得我不用好难受\n```\n\n```js\n// 循环\nfunction fibonacci(n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    var a = 0, b = 1, c = 1;\n    for (var i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n## 时间格式化输出\n\n> 按所给的时间格式输出指定的时间\n> 格式说明\n> 对于 2014.09.05 13:14:20\n> yyyy: 年份，2014\n> yy: 年份，14\n> MM: 月份，补满两位，09\n> M: 月份, 9\n> dd: 日期，补满两位，05\n> d: 日期, 5\n> HH: 24制小时，补满两位，13\n> H: 24制小时，13\n> hh: 12制小时，补满两位，01\n> h: 12制小时，1\n> mm: 分钟，补满两位，14\n> m: 分钟，14\n> ss: 秒，补满两位，20\n> s: 秒，20\n> w: 星期，为 ['日', '一', '二', '三', '四', '五', '六'] 中的某一个，本 demo 结果为 五\n\n输入\n\n```\nformatDate(new Date(1409894060000), 'yyyy-MM-dd HH:mm:ss 星期w')\n```\n\n输出\n\n```\n2014-09-05 13:14:20 星期五\n```\n\n代码\n\n```js\nfunction formatDate(date, format) {\n    var myDate = {\n        yyyy: date.getFullYear(),\n        yy: date.getFullYear()%100,\n        MM: (\"0\" + (date.getMonth()+1)).slice(-2),\n        M: date.getMonth()+1,\n        dd: (\"0\" + (date.getDate())).slice(-2),\n        d: date.getDate(),\n        HH: (\"0\" + date.getHours()).slice(-2),\n        H: date.getHours(),\n        hh: (\"0\" + (date.getHours() % 12)).slice(-2),\n        h: date.getHours() % 12,\n        mm: (\"0\" + date.getMinutes()).slice(-2),\n        m: date.getMinutes(),\n        ss: (\"0\" + date.getSeconds()).slice(-2),\n        s: date.getSeconds(),\n        w: ['日', '一', '二', '三', '四', '五', '六'][date.getDay()]\n    }\n    return format.replace(/([a-z]+)/ig,function($1){return myDate[$1];});\n}\n```\n\n参考了大神的代码。。。自己差点就十几个if了。。。\n\n关于代码说明几点：\n\n`getFullYear()`为年份四位表示\n\n`getMonth()`为月份0-11\n\n`getDate()`为日期1-31\n\n`getHours()`为小时0-23\n\n`getMinutes()`为分钟0-59\n\n`getSeconds()`为秒数0-59\n\n`getDay()`为0-6表示['日', '一', '二', '三', '四', '五', '六']\n\n`RegExp.$1...RegExp.$9`表示用于存储第一、……第九个匹配的捕获组，至于什么是捕获组可以看下边这个例子：\n\n```js\nvar text = \"this has been a short summer\";\nvar pattern = /(..)or(.)/g;\n\nif (pattern.exec(text)) {\n  alert(RegExp.$1); // \"sh\"\n  alert(RegExp.$2); // \"t\"\n}\n```\n\n## 获取字符串长度\n\n> 如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1\n> 否则如果字符 Unicode 编码 > 255 则长度为 2\n\n输入\n\n```\n'hello world, 牛客', false\n```\n\n输出\n\n```\n17\n```\n\n代码\n\n```js\nfunction strLength(s, bUnicode255For1) {\n    if (bUnicode255For1 === true) {\n        return s.length;\n    } else {\n        var result = 0;\n        for (var i = 0; i < s.length; i++) {\n            if (s.charCodeAt(i) > 255) result+=2;\n            else result+=1;\n        }\n        return result;\n    }\n}\n```\n\n刚开始一直没看懂题。。。这道题应该有点问题，js默认utf-16编码，所以不是所有字符都长度为1，有的字符是长度为2的。。。忽略这个写这个题吧。。。\n\n## 邮箱字符串判断\n\n输入描述\n\n```\n邮箱字符串\n```\n\n输出描述\n\n```\ntrue表示格式正确\n```\n\n代码\n\n```js\nfunction isAvailableEmail(sEmail) {\n    var reg = /^[\\w\\.]+@[\\w\\.]+\\.[\\w\\.]+$/i;\n    return reg.test(sEmail);\n}\n```\n\n> - \\w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。\n>\n> - \\s 匹配任意的空白符\n>\n> - \\d 匹配数字\n>\n> - \\b 匹配单词的开始或结束\n>\n> - ^ 匹配字符串的开始\n>\n> - $ 匹配字符串的结束\n>\n> - \\w能不能匹配汉字要视你的操作系统和你的应用环境而定\n\n## 颜色字符串转换\n\n> 将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff\n> 1. rgb 中每个 , 后面的空格数量不固定\n> 2. 十六进制表达式使用六位小写字母\n> 3. 如果输入不符合 rgb 格式，返回原始输入\n\n输入\n\n```\n'rgb(255, 255, 255)'\n```\n\n输出\n\n```\n#ffffff\n```\n\n代码\n\n```js\nfunction rgb2hex(sRGB) {\n    if(sRGB.slice(0,4)!=='rgb(' || sRGB.slice(-1)!==')') return sRGB;\n    var tmp = (sRGB.split('(')[1]).split(')')[0];\n    var colors = tmp.split(',');\n    if (colors.length != 3) return sRGB;\n    var re = \"#\";\n    for (var i = 0; i < colors.length; i++) {\n        var value =  parseInt(colors[i].substring(colors[i].lastIndexOf(' ')));\n        if (value < 0 || value > 255) return sRGB;\n        re += (\"0\" + (value).toString(16)).slice(-2);\n    }\n    return re;\n}\n```\n\n又使用了最水的办法。。。\n\n看一下大佬的正则的方法：\n\n```js\n//链接：https://www.nowcoder.com/questionTerminal/80b08802a833419f9c4ccc6e042c1cca\n//来源：牛客网\n\nfunction rgb2hex(sRGB) {\n   return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n       return '#' + hex(r) + hex(g) + hex(b);\n   });\n}\nfunction hex(n){\n    return n < 16 ? '0' + (+n).toString(16) : (+n).toString(16);\n}\n\n```\n\na代表正则匹配的整个字符串,  r ,g, b代表红绿蓝三个通道, 分别是正则中的三个括号匹配的字符串.  通常用的$0, $1, $2, $3。\n\n但是吧，可能是用例不全，这个方法并没有判断是不是超出0-255也能AC。。\n\n可以在hex函数里加个判断，如果规范才返回字符串，然后在replace里的那个函数里加个判断hex(r)、hex(g)、hex(b)是否为undefined，像这样：\n\n```js\nfunction rgb2hex(sRGB) {\n  return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n    if (hex(r) == undefined || hex(g) == undefined || hex(b) == undefined) return sRGB;\n    return '#' + hex(r) + hex(g) + hex(b);\n  });\n}\nfunction hex(n){\n  if (n > -1 && n < 256) {\n    return n < 16 ? '0' + (+n).toString(16) : (+n).toString(16);\n  }\n}\n```\n\n这样就可以啦！\n\n## 将字符串转换为驼峰模式\n\n> css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能\n> 1. 以 - 为分隔符，将第二个起的非空单词首字母转为大写\n> 2. -webkit-border-image 转换后的结果为 webkitBorderImage\n\n输入\n\n```\n'font-size'\n```\n\n输出\n\n```\nfontSize\n```\n\n代码\n\n```js\nfunction cssStyle2DomStyle(sName) {\n    if (sName[0] == \"-\") sName = sName.slice(1);\n    var words = sName.split('-');\n    var re = words[0];\n    for (var i = 1; i < words.length; i++) {\n        re = re + words[i][0].toUpperCase() + words[i].slice(1);\n    }\n    return re;\n}\n```\n\n大神的代码：\n\n```js\n// 链接：https://www.nowcoder.com/questionTerminal/2ded24e34ec34325a62d42d0c8479bae\n// 来源：牛客网\n\nreturn sName.replace(/\\-[a-z]/g , function(a, b){\n \n    return b == 0 ? a.replace('-','') : a.replace('-','').toUpperCase();\n \n});\n```\n\n其中b是offset。\n\nreplace第二个参数函数的参数表：\n\n| 变量名       | 代表的值                                                     |\n| ------------ | ------------------------------------------------------------ |\n| match        | 匹配的子串。（对应于上述的$&。）                             |\n| `p1,p2, ...` | 假如replace()方法的第一个参数是一个[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） |\n| `offset`     | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） |\n| string       | 被匹配的原字符串。                                           |\n\n## 字符串字符统计\n\n> 统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率\n> 1. 不限制 key 的顺序\n> 2. 输入的字符串参数不会为空\n> 3. 忽略空白字符\n\n输入\n\n```\n'hello world'\n```\n\n输出\n\n```\n{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}\n```\n\n大神的代码：\n\n```js\nfunction count(str) {\n    var obj = {};\n    str.replace(/\\S/g,function(s){\n        !obj[s]?obj[s]=1:obj[s]++;\n    })\n    return obj;\n}\n```\n\n\\S匹配非空字符串，function(s)里的s代表匹配到的每一项。\n\n\n\n---\n\n哎总结一句就是我好菜。。对JS了解还是太少。。。","source":"_posts/牛客网前端挑战编程题解.md","raw":"---\ntitle: 牛客网前端挑战编程题解\ntoc: true\ndate: 2018-09-20 14:33:15\ncategories:\n- Web\ntags:\n- JavaScript\n---\n\nOJ链接：https://www.nowcoder.com/ta/front-end\n\n注意：在牛客不能用ES6的东西！\n\n<!-- more -->\n\n## 修改this指向\n\n>  封装函数 f，使 f 的 this 指向指定的对象\n\n代码\n\n```js\nfunction bindThis(f, oTarget) {\n  // 考虑浏览器兼容\n  if (f.bind) {\n    return f.bind(oTarget);\n  } else {\n    // apply()为立即执行函数，因此需要放在一个函数里，到需要使用的时候再立即执行\n    return function() {\n      // arguments不能省略，在执行f时可能会传入参数\n      return f.apply(oTarget, arguments);\n    }\n  }\n}\n```\n\n## 获取url参数\n\n> 获取 url 中的参数\n> 1. 指定参数名称，返回该参数的值 或者 空字符串\n> 2. 不指定参数名称，返回全部的参数对象 或者 {}\n> 3. 如果存在多个同名参数，则返回数组\n\n输入\n\n```\nhttp://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe\n```\n\n输出\n\n```\n[1, 2, 3]\n```\n\n代码\n\n```js\nfunction getUrlParam(sUrl, sKey) {\n  var result = {};\n  // 先取?和#之间的字符串，然后按照&分割\n  var querys = ((sUrl.split('?')[1]).split('#')[0]).split('&');\n  for (var i = 0; i < querys.length; i++) {\n    var key = querys[i].split('=')[0];\n    var value = querys[i].split('=')[1];\n    // 如果result[key]未定义，则创建一个含有value的数组\n    if (result[key] == undefined) result[key] = [value];\n    else result[key].push(value);\n  }\n  // 不指定参数名称，返回全部的参数对象\n  if (sKey == undefined) return result;\n  if (result[sKey] == undefined) return \"\";\n  else if (result[sKey].length == 1) return result[sKey][0];\n  else return result[sKey];\n}\n```\n\n还有大神的正则的方法...直接贴出来吧：\n\n```js\n// 链接：https://www.nowcoder.com/questionTerminal/a3ded747e3884a3c86d09d88d1652e10\n// 来源：牛客网\n\nfunction getUrlParam(sUrl, sKey) {\n    var obj = {};\n    var reg = /[?&](\\w+)=(\\w+)/g;\n    while(reg.exec(sUrl))\n        obj[RegExp.$1] ? obj[RegExp.$1]=[].concat(obj[RegExp.$1],RegExp.$2) : obj[RegExp.$1]=RegExp.$2;\n    return sKey ? obj[sKey]||\"\" : obj;\n}\n```\n\n## dom节点查找\n\n> 查找两个节点的最近的一个共同父节点，可以包括节点自身\n\n输入描述\n\n```\noNode1 和 oNode2 在同一文档中，且不会为相同的节点\n```\n\n代码\n\n```js\nfunction commonParentNode(oNode1, oNode2) {\n    for (;oNode1;oNode1 = oNode1.parentNode) {\n        if (oNode1.contains(oNode2)) {\n            return oNode1;\n        }\n    }\n}\n```\n\n还是对DOM的相关属性啊什么的不了解。。红宝书刚看到DOM。。。要加油鸭\n\n## 根据包名，在指定空间中创建对象\n\n输入描述\n\n```\nnamespace({a: {test: 1, b: 2}}, 'a.b.c.d')\n```\n\n输出描述\n\n```\n{a: {test: 1, b: {c: {d: {}}}}}\n```\n\n代码\n\n```js\nfunction namespace(oNamespace, sPackage) {\n    var tmpPoint = oNamespace;\n    var keys = sPackage.split('.');\n    for (var i = 0; i < keys.length; i++) {\n        if (tmpPoint[keys[i]] == undefined) tmpPoint[keys[i]] = {};\n        tmpPoint = tmpPoint[keys[i]];\n    }\n    return oNamespace;\n}\n```\n\n记住，对象名就像是指针一样。\n\n## 数组去重\n\n> 为 Array 对象添加一个去除重复项的方法\n\n输入\n\n```\n[false, true, undefined, null, NaN, 0, 1, {}, {}, 'a', 'a', NaN]\n```\n\n输出\n\n```\n[false, true, undefined, null, NaN, 0, 1, {}, {}, 'a']\n```\n\n代码\n\n```js\nArray.prototype.uniq = function () {\n    var hasNaN = false;\n    for (var i = 0; i < this.length; i++) {\n        if ((hasNaN === false) && (this[i] != this[i])) {\n            hasNaN = true;\n            continue;\n        }\n        if (this.indexOf(this[i]) < i) this.splice(i--,1);\n    }\n    return this;\n}\n```\n\n关于NaN的问题调试了好几次。。\n\n使用`this.indexOf(this[i]) < i`判断的时候，\n\n因为NaN和任何值都不相等，因此index是-1，因此在这里一定会被删掉，\n\n因此需要先判断是不是已经遇到过NaN了，遇到过的话再次遇到就直接删掉，没有遇到的话遇到时就把hasNaN设为true，然后continue来跳过splice。\n\n## 斐波那契数列\n\n> 用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等\n\nemmmmm，不知道为什么会有斐波那契这种题。。。。\n\n```js\n// 暴力递归\nfunction fibonacci(n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n// 本来想用callee，结果严格模式不让用。。。红宝书一直说callee多么多么好。。。搞得我不用好难受\n```\n\n```js\n// 循环\nfunction fibonacci(n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    var a = 0, b = 1, c = 1;\n    for (var i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n## 时间格式化输出\n\n> 按所给的时间格式输出指定的时间\n> 格式说明\n> 对于 2014.09.05 13:14:20\n> yyyy: 年份，2014\n> yy: 年份，14\n> MM: 月份，补满两位，09\n> M: 月份, 9\n> dd: 日期，补满两位，05\n> d: 日期, 5\n> HH: 24制小时，补满两位，13\n> H: 24制小时，13\n> hh: 12制小时，补满两位，01\n> h: 12制小时，1\n> mm: 分钟，补满两位，14\n> m: 分钟，14\n> ss: 秒，补满两位，20\n> s: 秒，20\n> w: 星期，为 ['日', '一', '二', '三', '四', '五', '六'] 中的某一个，本 demo 结果为 五\n\n输入\n\n```\nformatDate(new Date(1409894060000), 'yyyy-MM-dd HH:mm:ss 星期w')\n```\n\n输出\n\n```\n2014-09-05 13:14:20 星期五\n```\n\n代码\n\n```js\nfunction formatDate(date, format) {\n    var myDate = {\n        yyyy: date.getFullYear(),\n        yy: date.getFullYear()%100,\n        MM: (\"0\" + (date.getMonth()+1)).slice(-2),\n        M: date.getMonth()+1,\n        dd: (\"0\" + (date.getDate())).slice(-2),\n        d: date.getDate(),\n        HH: (\"0\" + date.getHours()).slice(-2),\n        H: date.getHours(),\n        hh: (\"0\" + (date.getHours() % 12)).slice(-2),\n        h: date.getHours() % 12,\n        mm: (\"0\" + date.getMinutes()).slice(-2),\n        m: date.getMinutes(),\n        ss: (\"0\" + date.getSeconds()).slice(-2),\n        s: date.getSeconds(),\n        w: ['日', '一', '二', '三', '四', '五', '六'][date.getDay()]\n    }\n    return format.replace(/([a-z]+)/ig,function($1){return myDate[$1];});\n}\n```\n\n参考了大神的代码。。。自己差点就十几个if了。。。\n\n关于代码说明几点：\n\n`getFullYear()`为年份四位表示\n\n`getMonth()`为月份0-11\n\n`getDate()`为日期1-31\n\n`getHours()`为小时0-23\n\n`getMinutes()`为分钟0-59\n\n`getSeconds()`为秒数0-59\n\n`getDay()`为0-6表示['日', '一', '二', '三', '四', '五', '六']\n\n`RegExp.$1...RegExp.$9`表示用于存储第一、……第九个匹配的捕获组，至于什么是捕获组可以看下边这个例子：\n\n```js\nvar text = \"this has been a short summer\";\nvar pattern = /(..)or(.)/g;\n\nif (pattern.exec(text)) {\n  alert(RegExp.$1); // \"sh\"\n  alert(RegExp.$2); // \"t\"\n}\n```\n\n## 获取字符串长度\n\n> 如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1\n> 否则如果字符 Unicode 编码 > 255 则长度为 2\n\n输入\n\n```\n'hello world, 牛客', false\n```\n\n输出\n\n```\n17\n```\n\n代码\n\n```js\nfunction strLength(s, bUnicode255For1) {\n    if (bUnicode255For1 === true) {\n        return s.length;\n    } else {\n        var result = 0;\n        for (var i = 0; i < s.length; i++) {\n            if (s.charCodeAt(i) > 255) result+=2;\n            else result+=1;\n        }\n        return result;\n    }\n}\n```\n\n刚开始一直没看懂题。。。这道题应该有点问题，js默认utf-16编码，所以不是所有字符都长度为1，有的字符是长度为2的。。。忽略这个写这个题吧。。。\n\n## 邮箱字符串判断\n\n输入描述\n\n```\n邮箱字符串\n```\n\n输出描述\n\n```\ntrue表示格式正确\n```\n\n代码\n\n```js\nfunction isAvailableEmail(sEmail) {\n    var reg = /^[\\w\\.]+@[\\w\\.]+\\.[\\w\\.]+$/i;\n    return reg.test(sEmail);\n}\n```\n\n> - \\w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。\n>\n> - \\s 匹配任意的空白符\n>\n> - \\d 匹配数字\n>\n> - \\b 匹配单词的开始或结束\n>\n> - ^ 匹配字符串的开始\n>\n> - $ 匹配字符串的结束\n>\n> - \\w能不能匹配汉字要视你的操作系统和你的应用环境而定\n\n## 颜色字符串转换\n\n> 将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff\n> 1. rgb 中每个 , 后面的空格数量不固定\n> 2. 十六进制表达式使用六位小写字母\n> 3. 如果输入不符合 rgb 格式，返回原始输入\n\n输入\n\n```\n'rgb(255, 255, 255)'\n```\n\n输出\n\n```\n#ffffff\n```\n\n代码\n\n```js\nfunction rgb2hex(sRGB) {\n    if(sRGB.slice(0,4)!=='rgb(' || sRGB.slice(-1)!==')') return sRGB;\n    var tmp = (sRGB.split('(')[1]).split(')')[0];\n    var colors = tmp.split(',');\n    if (colors.length != 3) return sRGB;\n    var re = \"#\";\n    for (var i = 0; i < colors.length; i++) {\n        var value =  parseInt(colors[i].substring(colors[i].lastIndexOf(' ')));\n        if (value < 0 || value > 255) return sRGB;\n        re += (\"0\" + (value).toString(16)).slice(-2);\n    }\n    return re;\n}\n```\n\n又使用了最水的办法。。。\n\n看一下大佬的正则的方法：\n\n```js\n//链接：https://www.nowcoder.com/questionTerminal/80b08802a833419f9c4ccc6e042c1cca\n//来源：牛客网\n\nfunction rgb2hex(sRGB) {\n   return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n       return '#' + hex(r) + hex(g) + hex(b);\n   });\n}\nfunction hex(n){\n    return n < 16 ? '0' + (+n).toString(16) : (+n).toString(16);\n}\n\n```\n\na代表正则匹配的整个字符串,  r ,g, b代表红绿蓝三个通道, 分别是正则中的三个括号匹配的字符串.  通常用的$0, $1, $2, $3。\n\n但是吧，可能是用例不全，这个方法并没有判断是不是超出0-255也能AC。。\n\n可以在hex函数里加个判断，如果规范才返回字符串，然后在replace里的那个函数里加个判断hex(r)、hex(g)、hex(b)是否为undefined，像这样：\n\n```js\nfunction rgb2hex(sRGB) {\n  return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n    if (hex(r) == undefined || hex(g) == undefined || hex(b) == undefined) return sRGB;\n    return '#' + hex(r) + hex(g) + hex(b);\n  });\n}\nfunction hex(n){\n  if (n > -1 && n < 256) {\n    return n < 16 ? '0' + (+n).toString(16) : (+n).toString(16);\n  }\n}\n```\n\n这样就可以啦！\n\n## 将字符串转换为驼峰模式\n\n> css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能\n> 1. 以 - 为分隔符，将第二个起的非空单词首字母转为大写\n> 2. -webkit-border-image 转换后的结果为 webkitBorderImage\n\n输入\n\n```\n'font-size'\n```\n\n输出\n\n```\nfontSize\n```\n\n代码\n\n```js\nfunction cssStyle2DomStyle(sName) {\n    if (sName[0] == \"-\") sName = sName.slice(1);\n    var words = sName.split('-');\n    var re = words[0];\n    for (var i = 1; i < words.length; i++) {\n        re = re + words[i][0].toUpperCase() + words[i].slice(1);\n    }\n    return re;\n}\n```\n\n大神的代码：\n\n```js\n// 链接：https://www.nowcoder.com/questionTerminal/2ded24e34ec34325a62d42d0c8479bae\n// 来源：牛客网\n\nreturn sName.replace(/\\-[a-z]/g , function(a, b){\n \n    return b == 0 ? a.replace('-','') : a.replace('-','').toUpperCase();\n \n});\n```\n\n其中b是offset。\n\nreplace第二个参数函数的参数表：\n\n| 变量名       | 代表的值                                                     |\n| ------------ | ------------------------------------------------------------ |\n| match        | 匹配的子串。（对应于上述的$&。）                             |\n| `p1,p2, ...` | 假如replace()方法的第一个参数是一个[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） |\n| `offset`     | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） |\n| string       | 被匹配的原字符串。                                           |\n\n## 字符串字符统计\n\n> 统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率\n> 1. 不限制 key 的顺序\n> 2. 输入的字符串参数不会为空\n> 3. 忽略空白字符\n\n输入\n\n```\n'hello world'\n```\n\n输出\n\n```\n{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}\n```\n\n大神的代码：\n\n```js\nfunction count(str) {\n    var obj = {};\n    str.replace(/\\S/g,function(s){\n        !obj[s]?obj[s]=1:obj[s]++;\n    })\n    return obj;\n}\n```\n\n\\S匹配非空字符串，function(s)里的s代表匹配到的每一项。\n\n\n\n---\n\n哎总结一句就是我好菜。。对JS了解还是太少。。。","slug":"牛客网前端挑战编程题解","published":1,"updated":"2018-10-10T08:46:00.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xm0046fmagqx3k985v","content":"<p>OJ链接：<a href=\"https://www.nowcoder.com/ta/front-end\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.nowcoder.com/ta/front-end</a></p><p>注意：在牛客不能用ES6的东西！</p><a id=\"more\"></a><h2 id=\"修改this指向\"><a href=\"#修改this指向\" class=\"headerlink\" title=\"修改this指向\"></a>修改this指向</h2><blockquote><p>封装函数 f，使 f 的 this 指向指定的对象</p></blockquote><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bindThis</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> oTarget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 考虑浏览器兼容</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>oTarget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// apply()为立即执行函数，因此需要放在一个函数里，到需要使用的时候再立即执行</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// arguments不能省略，在执行f时可能会传入参数</span>\n      <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>oTarget<span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"获取url参数\"><a href=\"#获取url参数\" class=\"headerlink\" title=\"获取url参数\"></a>获取url参数</h2><blockquote><p>获取 url 中的参数</p><ol><li>指定参数名称，返回该参数的值 或者 空字符串</li><li>不指定参数名称，返回全部的参数对象 或者 {}</li><li>如果存在多个同名参数，则返回数组</li></ol></blockquote><p>输入</p><pre><code>http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe\n</code></pre><p>输出</p><pre><code>[1, 2, 3]\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUrlParam</span><span class=\"token punctuation\">(</span>sUrl<span class=\"token punctuation\">,</span> sKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 先取?和#之间的字符串，然后按照&amp;分割</span>\n  <span class=\"token keyword\">var</span> querys <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sUrl<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> querys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> key <span class=\"token operator\">=</span> querys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span> querys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果result[key]未定义，则创建一个含有value的数组</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> undefined<span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> result<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 不指定参数名称，返回全部的参数对象</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sKey <span class=\"token operator\">==</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span>sKey<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span>sKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">[</span>sKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">[</span>sKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>还有大神的正则的方法…直接贴出来吧：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 链接：https://www.nowcoder.com/questionTerminal/a3ded747e3884a3c86d09d88d1652e10</span>\n<span class=\"token comment\" spellcheck=\"true\">// 来源：牛客网</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUrlParam</span><span class=\"token punctuation\">(</span>sUrl<span class=\"token punctuation\">,</span> sKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> reg <span class=\"token operator\">=</span> <span class=\"token regex\">/[?&amp;](\\w+)=(\\w+)/g</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>reg<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>sUrl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        obj<span class=\"token punctuation\">[</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> obj<span class=\"token punctuation\">[</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">[</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> obj<span class=\"token punctuation\">[</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> sKey <span class=\"token operator\">?</span> obj<span class=\"token punctuation\">[</span>sKey<span class=\"token punctuation\">]</span><span class=\"token operator\">||</span><span class=\"token string\">\"\"</span> <span class=\"token punctuation\">:</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"dom节点查找\"><a href=\"#dom节点查找\" class=\"headerlink\" title=\"dom节点查找\"></a>dom节点查找</h2><blockquote><p>查找两个节点的最近的一个共同父节点，可以包括节点自身</p></blockquote><p>输入描述</p><pre><code>oNode1 和 oNode2 在同一文档中，且不会为相同的节点\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">commonParentNode</span><span class=\"token punctuation\">(</span>oNode1<span class=\"token punctuation\">,</span> oNode2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>oNode1<span class=\"token punctuation\">;</span>oNode1 <span class=\"token operator\">=</span> oNode1<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oNode1<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>oNode2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> oNode1<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>还是对DOM的相关属性啊什么的不了解。。红宝书刚看到DOM。。。要加油鸭</p><h2 id=\"根据包名，在指定空间中创建对象\"><a href=\"#根据包名，在指定空间中创建对象\" class=\"headerlink\" title=\"根据包名，在指定空间中创建对象\"></a>根据包名，在指定空间中创建对象</h2><p>输入描述</p><pre><code>namespace({a: {test: 1, b: 2}}, &#39;a.b.c.d&#39;)\n</code></pre><p>输出描述</p><pre><code>{a: {test: 1, b: {c: {d: {}}}}}\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">namespace</span><span class=\"token punctuation\">(</span>oNamespace<span class=\"token punctuation\">,</span> sPackage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> tmpPoint <span class=\"token operator\">=</span> oNamespace<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> keys <span class=\"token operator\">=</span> sPackage<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> keys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmpPoint<span class=\"token punctuation\">[</span>keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> undefined<span class=\"token punctuation\">)</span> tmpPoint<span class=\"token punctuation\">[</span>keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        tmpPoint <span class=\"token operator\">=</span> tmpPoint<span class=\"token punctuation\">[</span>keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> oNamespace<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>记住，对象名就像是指针一样。</p><h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><blockquote><p>为 Array 对象添加一个去除重复项的方法</p></blockquote><p>输入</p><pre><code>[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;, &#39;a&#39;, NaN]\n</code></pre><p>输出</p><pre><code>[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;]\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\">Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>uniq <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> hasNaN <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>hasNaN <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            hasNaN <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">)</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>关于NaN的问题调试了好几次。。</p><p>使用<code>this.indexOf(this[i]) &lt; i</code>判断的时候，</p><p>因为NaN和任何值都不相等，因此index是-1，因此在这里一定会被删掉，</p><p>因此需要先判断是不是已经遇到过NaN了，遇到过的话再次遇到就直接删掉，没有遇到的话遇到时就把hasNaN设为true，然后continue来跳过splice。</p><h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><blockquote><p>用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等</p></blockquote><p>emmmmm，不知道为什么会有斐波那契这种题。。。。</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 暴力递归</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token number\">-2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 本来想用callee，结果严格模式不让用。。。红宝书一直说callee多么多么好。。。搞得我不用好难受</span>\n</code></pre><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 循环</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        c <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"时间格式化输出\"><a href=\"#时间格式化输出\" class=\"headerlink\" title=\"时间格式化输出\"></a>时间格式化输出</h2><blockquote><p>按所给的时间格式输出指定的时间<br>格式说明<br>对于 2014.09.05 13:14:20<br>yyyy: 年份，2014<br>yy: 年份，14<br>MM: 月份，补满两位，09<br>M: 月份, 9<br>dd: 日期，补满两位，05<br>d: 日期, 5<br>HH: 24制小时，补满两位，13<br>H: 24制小时，13<br>hh: 12制小时，补满两位，01<br>h: 12制小时，1<br>mm: 分钟，补满两位，14<br>m: 分钟，14<br>ss: 秒，补满两位，20<br>s: 秒，20<br>w: 星期，为 [‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’] 中的某一个，本 demo 结果为 五</p></blockquote><p>输入</p><pre><code>formatDate(new Date(1409894060000), &#39;yyyy-MM-dd HH:mm:ss 星期w&#39;)\n</code></pre><p>输出</p><pre><code>2014-09-05 13:14:20 星期五\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">formatDate</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">,</span> format<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> myDate <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        yyyy<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getFullYear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        yy<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getFullYear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n        MM<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">getMonth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        M<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getMonth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        dd<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">getDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        d<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        HH<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getHours</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        H<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getHours</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        hh<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">getHours</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        h<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getHours</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span>\n        mm<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getMinutes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        m<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getMinutes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        ss<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        s<span class=\"token punctuation\">:</span> date<span class=\"token punctuation\">.</span><span class=\"token function\">getSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        w<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'日'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'一'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'二'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'三'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'四'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'五'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'六'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">getDay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> format<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/([a-z]+)/ig</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> myDate<span class=\"token punctuation\">[</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>参考了大神的代码。。。自己差点就十几个if了。。。</p><p>关于代码说明几点：</p><p><code>getFullYear()</code>为年份四位表示</p><p><code>getMonth()</code>为月份0-11</p><p><code>getDate()</code>为日期1-31</p><p><code>getHours()</code>为小时0-23</p><p><code>getMinutes()</code>为分钟0-59</p><p><code>getSeconds()</code>为秒数0-59</p><p><code>getDay()</code>为0-6表示[‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’]</p><p><code>RegExp.$1...RegExp.$9</code>表示用于存储第一、……第九个匹配的捕获组，至于什么是捕获组可以看下边这个例子：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> text <span class=\"token operator\">=</span> <span class=\"token string\">\"this has been a short summer\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> pattern <span class=\"token operator\">=</span> <span class=\"token regex\">/(..)or(.)/g</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"sh\"</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>RegExp<span class=\"token punctuation\">.</span>$<span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"t\"</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h2 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h2><blockquote><p>如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1<br>否则如果字符 Unicode 编码 &gt; 255 则长度为 2</p></blockquote><p>输入</p><pre><code>&#39;hello world, 牛客&#39;, false\n</code></pre><p>输出</p><pre><code>17\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">strLength</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> bUnicode255For1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bUnicode255For1 <span class=\"token operator\">===</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">255</span><span class=\"token punctuation\">)</span> result<span class=\"token operator\">+</span><span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> result<span class=\"token operator\">+</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>刚开始一直没看懂题。。。这道题应该有点问题，js默认utf-16编码，所以不是所有字符都长度为1，有的字符是长度为2的。。。忽略这个写这个题吧。。。</p><h2 id=\"邮箱字符串判断\"><a href=\"#邮箱字符串判断\" class=\"headerlink\" title=\"邮箱字符串判断\"></a>邮箱字符串判断</h2><p>输入描述</p><pre><code>邮箱字符串\n</code></pre><p>输出描述</p><pre><code>true表示格式正确\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">isAvailableEmail</span><span class=\"token punctuation\">(</span>sEmail<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> reg <span class=\"token operator\">=</span> <span class=\"token regex\">/^[\\w\\.]+@[\\w\\.]+\\.[\\w\\.]+$/i</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> reg<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>sEmail<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><blockquote><ul><li><p>\\w 匹配字母或数字或下划线或汉字 等价于 ‘[^A-Za-z0-9_]’。</p></li><li><p>\\s 匹配任意的空白符</p></li><li><p>\\d 匹配数字</p></li><li><p>\\b 匹配单词的开始或结束</p></li><li><p>^ 匹配字符串的开始</p></li><li><p>$ 匹配字符串的结束</p></li><li><p>\\w能不能匹配汉字要视你的操作系统和你的应用环境而定</p></li></ul></blockquote><h2 id=\"颜色字符串转换\"><a href=\"#颜色字符串转换\" class=\"headerlink\" title=\"颜色字符串转换\"></a>颜色字符串转换</h2><blockquote><p>将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff</p><ol><li>rgb 中每个 , 后面的空格数量不固定</li><li>十六进制表达式使用六位小写字母</li><li>如果输入不符合 rgb 格式，返回原始输入</li></ol></blockquote><p>输入</p><pre><code>&#39;rgb(255, 255, 255)&#39;\n</code></pre><p>输出</p><pre><code>#ffffff\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">rgb2hex</span><span class=\"token punctuation\">(</span>sRGB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sRGB<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!==</span><span class=\"token string\">'rgb('</span> <span class=\"token operator\">||</span> sRGB<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!==</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>sRGB<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'('</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> colors <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>colors<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> re <span class=\"token operator\">=</span> <span class=\"token string\">\"#\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> colors<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span>  <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>colors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>colors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">lastIndexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> value <span class=\"token operator\">></span> <span class=\"token number\">255</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">;</span>\n        re <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> re<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>又使用了最水的办法。。。</p><p>看一下大佬的正则的方法：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//链接：https://www.nowcoder.com/questionTerminal/80b08802a833419f9c4ccc6e042c1cca</span>\n<span class=\"token comment\" spellcheck=\"true\">//来源：牛客网</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">rgb2hex</span><span class=\"token punctuation\">(</span>sRGB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token string\">'#'</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">16</span> <span class=\"token operator\">?</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre><p>a代表正则匹配的整个字符串, r ,g, b代表红绿蓝三个通道, 分别是正则中的三个括号匹配的字符串. 通常用的$0, $1, $2, $3。</p><p>但是吧，可能是用例不全，这个方法并没有判断是不是超出0-255也能AC。。</p><p>可以在hex函数里加个判断，如果规范才返回字符串，然后在replace里的那个函数里加个判断hex(r)、hex(g)、hex(b)是否为undefined，像这样：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">rgb2hex</span><span class=\"token punctuation\">(</span>sRGB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> undefined <span class=\"token operator\">||</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> undefined <span class=\"token operator\">||</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> sRGB<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'#'</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">16</span> <span class=\"token operator\">?</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>这样就可以啦！</p><h2 id=\"将字符串转换为驼峰模式\"><a href=\"#将字符串转换为驼峰模式\" class=\"headerlink\" title=\"将字符串转换为驼峰模式\"></a>将字符串转换为驼峰模式</h2><blockquote><p>css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能</p><ol><li>以 - 为分隔符，将第二个起的非空单词首字母转为大写</li><li>-webkit-border-image 转换后的结果为 webkitBorderImage</li></ol></blockquote><p>输入</p><pre><code>&#39;font-size&#39;\n</code></pre><p>输出</p><pre><code>fontSize\n</code></pre><p>代码</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">cssStyle2DomStyle</span><span class=\"token punctuation\">(</span>sName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sName<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">)</span> sName <span class=\"token operator\">=</span> sName<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> words <span class=\"token operator\">=</span> sName<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> re <span class=\"token operator\">=</span> words<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> words<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        re <span class=\"token operator\">=</span> re <span class=\"token operator\">+</span> words<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> words<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> re<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>大神的代码：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 链接：https://www.nowcoder.com/questionTerminal/2ded24e34ec34325a62d42d0c8479bae</span>\n<span class=\"token comment\" spellcheck=\"true\">// 来源：牛客网</span>\n\n<span class=\"token keyword\">return</span> sName<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\-[a-z]/g</span> <span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">return</span> b <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">,</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">,</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><p>其中b是offset。</p><p>replace第二个参数函数的参数表：</p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的$&amp;。）</td></tr><tr><td><code>p1,p2, ...</code></td><td>假如replace()方法的第一个参数是一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RegExp</code></a> 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）</td></tr><tr><td><code>offset</code></td><td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr></tbody></table><h2 id=\"字符串字符统计\"><a href=\"#字符串字符统计\" class=\"headerlink\" title=\"字符串字符统计\"></a>字符串字符统计</h2><blockquote><p>统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率</p><ol><li>不限制 key 的顺序</li><li>输入的字符串参数不会为空</li><li>忽略空白字符</li></ol></blockquote><p>输入</p><pre><code>&#39;hello world&#39;\n</code></pre><p>输出</p><pre><code>{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}\n</code></pre><p>大神的代码：</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\S/g</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">!</span>obj<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">]</span><span class=\"token operator\">?</span>obj<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>obj<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><p>\\S匹配非空字符串，function(s)里的s代表匹配到的每一项。</p><hr><p>哎总结一句就是我好菜。。对JS了解还是太少。。。</p>","site":{"data":{}},"excerpt":"<p>OJ链接：<a href=\"https://www.nowcoder.com/ta/front-end\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.nowcoder.com/ta/front-end</a></p><p>注意：在牛客不能用ES6的东西！</p>","more":"<h2 id=\"修改this指向\"><a href=\"#修改this指向\" class=\"headerlink\" title=\"修改this指向\"></a>修改this指向</h2><blockquote><p>封装函数 f，使 f 的 this 指向指定的对象</p></blockquote><p>代码</p><pre><code class=\"js\">function bindThis(f, oTarget) {\n  // 考虑浏览器兼容\n  if (f.bind) {\n    return f.bind(oTarget);\n  } else {\n    // apply()为立即执行函数，因此需要放在一个函数里，到需要使用的时候再立即执行\n    return function() {\n      // arguments不能省略，在执行f时可能会传入参数\n      return f.apply(oTarget, arguments);\n    }\n  }\n}\n</code></pre><h2 id=\"获取url参数\"><a href=\"#获取url参数\" class=\"headerlink\" title=\"获取url参数\"></a>获取url参数</h2><blockquote><p>获取 url 中的参数</p><ol><li>指定参数名称，返回该参数的值 或者 空字符串</li><li>不指定参数名称，返回全部的参数对象 或者 {}</li><li>如果存在多个同名参数，则返回数组</li></ol></blockquote><p>输入</p><pre><code>http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe\n</code></pre><p>输出</p><pre><code>[1, 2, 3]\n</code></pre><p>代码</p><pre><code class=\"js\">function getUrlParam(sUrl, sKey) {\n  var result = {};\n  // 先取?和#之间的字符串，然后按照&amp;分割\n  var querys = ((sUrl.split(&#39;?&#39;)[1]).split(&#39;#&#39;)[0]).split(&#39;&amp;&#39;);\n  for (var i = 0; i &lt; querys.length; i++) {\n    var key = querys[i].split(&#39;=&#39;)[0];\n    var value = querys[i].split(&#39;=&#39;)[1];\n    // 如果result[key]未定义，则创建一个含有value的数组\n    if (result[key] == undefined) result[key] = [value];\n    else result[key].push(value);\n  }\n  // 不指定参数名称，返回全部的参数对象\n  if (sKey == undefined) return result;\n  if (result[sKey] == undefined) return &quot;&quot;;\n  else if (result[sKey].length == 1) return result[sKey][0];\n  else return result[sKey];\n}\n</code></pre><p>还有大神的正则的方法…直接贴出来吧：</p><pre><code class=\"js\">// 链接：https://www.nowcoder.com/questionTerminal/a3ded747e3884a3c86d09d88d1652e10\n// 来源：牛客网\n\nfunction getUrlParam(sUrl, sKey) {\n    var obj = {};\n    var reg = /[?&amp;](\\w+)=(\\w+)/g;\n    while(reg.exec(sUrl))\n        obj[RegExp.$1] ? obj[RegExp.$1]=[].concat(obj[RegExp.$1],RegExp.$2) : obj[RegExp.$1]=RegExp.$2;\n    return sKey ? obj[sKey]||&quot;&quot; : obj;\n}\n</code></pre><h2 id=\"dom节点查找\"><a href=\"#dom节点查找\" class=\"headerlink\" title=\"dom节点查找\"></a>dom节点查找</h2><blockquote><p>查找两个节点的最近的一个共同父节点，可以包括节点自身</p></blockquote><p>输入描述</p><pre><code>oNode1 和 oNode2 在同一文档中，且不会为相同的节点\n</code></pre><p>代码</p><pre><code class=\"js\">function commonParentNode(oNode1, oNode2) {\n    for (;oNode1;oNode1 = oNode1.parentNode) {\n        if (oNode1.contains(oNode2)) {\n            return oNode1;\n        }\n    }\n}\n</code></pre><p>还是对DOM的相关属性啊什么的不了解。。红宝书刚看到DOM。。。要加油鸭</p><h2 id=\"根据包名，在指定空间中创建对象\"><a href=\"#根据包名，在指定空间中创建对象\" class=\"headerlink\" title=\"根据包名，在指定空间中创建对象\"></a>根据包名，在指定空间中创建对象</h2><p>输入描述</p><pre><code>namespace({a: {test: 1, b: 2}}, &#39;a.b.c.d&#39;)\n</code></pre><p>输出描述</p><pre><code>{a: {test: 1, b: {c: {d: {}}}}}\n</code></pre><p>代码</p><pre><code class=\"js\">function namespace(oNamespace, sPackage) {\n    var tmpPoint = oNamespace;\n    var keys = sPackage.split(&#39;.&#39;);\n    for (var i = 0; i &lt; keys.length; i++) {\n        if (tmpPoint[keys[i]] == undefined) tmpPoint[keys[i]] = {};\n        tmpPoint = tmpPoint[keys[i]];\n    }\n    return oNamespace;\n}\n</code></pre><p>记住，对象名就像是指针一样。</p><h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><blockquote><p>为 Array 对象添加一个去除重复项的方法</p></blockquote><p>输入</p><pre><code>[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;, &#39;a&#39;, NaN]\n</code></pre><p>输出</p><pre><code>[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;]\n</code></pre><p>代码</p><pre><code class=\"js\">Array.prototype.uniq = function () {\n    var hasNaN = false;\n    for (var i = 0; i &lt; this.length; i++) {\n        if ((hasNaN === false) &amp;&amp; (this[i] != this[i])) {\n            hasNaN = true;\n            continue;\n        }\n        if (this.indexOf(this[i]) &lt; i) this.splice(i--,1);\n    }\n    return this;\n}\n</code></pre><p>关于NaN的问题调试了好几次。。</p><p>使用<code>this.indexOf(this[i]) &lt; i</code>判断的时候，</p><p>因为NaN和任何值都不相等，因此index是-1，因此在这里一定会被删掉，</p><p>因此需要先判断是不是已经遇到过NaN了，遇到过的话再次遇到就直接删掉，没有遇到的话遇到时就把hasNaN设为true，然后continue来跳过splice。</p><h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><blockquote><p>用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等</p></blockquote><p>emmmmm，不知道为什么会有斐波那契这种题。。。。</p><pre><code class=\"js\">// 暴力递归\nfunction fibonacci(n) {\n    if (n &lt;= 0) return 0;\n    if (n == 1) return 1;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n// 本来想用callee，结果严格模式不让用。。。红宝书一直说callee多么多么好。。。搞得我不用好难受\n</code></pre><pre><code class=\"js\">// 循环\nfunction fibonacci(n) {\n    if (n &lt;= 0) return 0;\n    if (n == 1) return 1;\n    var a = 0, b = 1, c = 1;\n    for (var i = 2; i &lt;= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n</code></pre><h2 id=\"时间格式化输出\"><a href=\"#时间格式化输出\" class=\"headerlink\" title=\"时间格式化输出\"></a>时间格式化输出</h2><blockquote><p>按所给的时间格式输出指定的时间<br>格式说明<br>对于 2014.09.05 13:14:20<br>yyyy: 年份，2014<br>yy: 年份，14<br>MM: 月份，补满两位，09<br>M: 月份, 9<br>dd: 日期，补满两位，05<br>d: 日期, 5<br>HH: 24制小时，补满两位，13<br>H: 24制小时，13<br>hh: 12制小时，补满两位，01<br>h: 12制小时，1<br>mm: 分钟，补满两位，14<br>m: 分钟，14<br>ss: 秒，补满两位，20<br>s: 秒，20<br>w: 星期，为 [‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’] 中的某一个，本 demo 结果为 五</p></blockquote><p>输入</p><pre><code>formatDate(new Date(1409894060000), &#39;yyyy-MM-dd HH:mm:ss 星期w&#39;)\n</code></pre><p>输出</p><pre><code>2014-09-05 13:14:20 星期五\n</code></pre><p>代码</p><pre><code class=\"js\">function formatDate(date, format) {\n    var myDate = {\n        yyyy: date.getFullYear(),\n        yy: date.getFullYear()%100,\n        MM: (&quot;0&quot; + (date.getMonth()+1)).slice(-2),\n        M: date.getMonth()+1,\n        dd: (&quot;0&quot; + (date.getDate())).slice(-2),\n        d: date.getDate(),\n        HH: (&quot;0&quot; + date.getHours()).slice(-2),\n        H: date.getHours(),\n        hh: (&quot;0&quot; + (date.getHours() % 12)).slice(-2),\n        h: date.getHours() % 12,\n        mm: (&quot;0&quot; + date.getMinutes()).slice(-2),\n        m: date.getMinutes(),\n        ss: (&quot;0&quot; + date.getSeconds()).slice(-2),\n        s: date.getSeconds(),\n        w: [&#39;日&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;][date.getDay()]\n    }\n    return format.replace(/([a-z]+)/ig,function($1){return myDate[$1];});\n}\n</code></pre><p>参考了大神的代码。。。自己差点就十几个if了。。。</p><p>关于代码说明几点：</p><p><code>getFullYear()</code>为年份四位表示</p><p><code>getMonth()</code>为月份0-11</p><p><code>getDate()</code>为日期1-31</p><p><code>getHours()</code>为小时0-23</p><p><code>getMinutes()</code>为分钟0-59</p><p><code>getSeconds()</code>为秒数0-59</p><p><code>getDay()</code>为0-6表示[‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’]</p><p><code>RegExp.$1...RegExp.$9</code>表示用于存储第一、……第九个匹配的捕获组，至于什么是捕获组可以看下边这个例子：</p><pre><code class=\"js\">var text = &quot;this has been a short summer&quot;;\nvar pattern = /(..)or(.)/g;\n\nif (pattern.exec(text)) {\n  alert(RegExp.$1); // &quot;sh&quot;\n  alert(RegExp.$2); // &quot;t&quot;\n}\n</code></pre><h2 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h2><blockquote><p>如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1<br>否则如果字符 Unicode 编码 &gt; 255 则长度为 2</p></blockquote><p>输入</p><pre><code>&#39;hello world, 牛客&#39;, false\n</code></pre><p>输出</p><pre><code>17\n</code></pre><p>代码</p><pre><code class=\"js\">function strLength(s, bUnicode255For1) {\n    if (bUnicode255For1 === true) {\n        return s.length;\n    } else {\n        var result = 0;\n        for (var i = 0; i &lt; s.length; i++) {\n            if (s.charCodeAt(i) &gt; 255) result+=2;\n            else result+=1;\n        }\n        return result;\n    }\n}\n</code></pre><p>刚开始一直没看懂题。。。这道题应该有点问题，js默认utf-16编码，所以不是所有字符都长度为1，有的字符是长度为2的。。。忽略这个写这个题吧。。。</p><h2 id=\"邮箱字符串判断\"><a href=\"#邮箱字符串判断\" class=\"headerlink\" title=\"邮箱字符串判断\"></a>邮箱字符串判断</h2><p>输入描述</p><pre><code>邮箱字符串\n</code></pre><p>输出描述</p><pre><code>true表示格式正确\n</code></pre><p>代码</p><pre><code class=\"js\">function isAvailableEmail(sEmail) {\n    var reg = /^[\\w\\.]+@[\\w\\.]+\\.[\\w\\.]+$/i;\n    return reg.test(sEmail);\n}\n</code></pre><blockquote><ul><li><p>\\w 匹配字母或数字或下划线或汉字 等价于 ‘[^A-Za-z0-9_]’。</p></li><li><p>\\s 匹配任意的空白符</p></li><li><p>\\d 匹配数字</p></li><li><p>\\b 匹配单词的开始或结束</p></li><li><p>^ 匹配字符串的开始</p></li><li><p>$ 匹配字符串的结束</p></li><li><p>\\w能不能匹配汉字要视你的操作系统和你的应用环境而定</p></li></ul></blockquote><h2 id=\"颜色字符串转换\"><a href=\"#颜色字符串转换\" class=\"headerlink\" title=\"颜色字符串转换\"></a>颜色字符串转换</h2><blockquote><p>将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff</p><ol><li>rgb 中每个 , 后面的空格数量不固定</li><li>十六进制表达式使用六位小写字母</li><li>如果输入不符合 rgb 格式，返回原始输入</li></ol></blockquote><p>输入</p><pre><code>&#39;rgb(255, 255, 255)&#39;\n</code></pre><p>输出</p><pre><code>#ffffff\n</code></pre><p>代码</p><pre><code class=\"js\">function rgb2hex(sRGB) {\n    if(sRGB.slice(0,4)!==&#39;rgb(&#39; || sRGB.slice(-1)!==&#39;)&#39;) return sRGB;\n    var tmp = (sRGB.split(&#39;(&#39;)[1]).split(&#39;)&#39;)[0];\n    var colors = tmp.split(&#39;,&#39;);\n    if (colors.length != 3) return sRGB;\n    var re = &quot;#&quot;;\n    for (var i = 0; i &lt; colors.length; i++) {\n        var value =  parseInt(colors[i].substring(colors[i].lastIndexOf(&#39; &#39;)));\n        if (value &lt; 0 || value &gt; 255) return sRGB;\n        re += (&quot;0&quot; + (value).toString(16)).slice(-2);\n    }\n    return re;\n}\n</code></pre><p>又使用了最水的办法。。。</p><p>看一下大佬的正则的方法：</p><pre><code class=\"js\">//链接：https://www.nowcoder.com/questionTerminal/80b08802a833419f9c4ccc6e042c1cca\n//来源：牛客网\n\nfunction rgb2hex(sRGB) {\n   return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n       return &#39;#&#39; + hex(r) + hex(g) + hex(b);\n   });\n}\nfunction hex(n){\n    return n &lt; 16 ? &#39;0&#39; + (+n).toString(16) : (+n).toString(16);\n}\n\n</code></pre><p>a代表正则匹配的整个字符串, r ,g, b代表红绿蓝三个通道, 分别是正则中的三个括号匹配的字符串. 通常用的$0, $1, $2, $3。</p><p>但是吧，可能是用例不全，这个方法并没有判断是不是超出0-255也能AC。。</p><p>可以在hex函数里加个判断，如果规范才返回字符串，然后在replace里的那个函数里加个判断hex(r)、hex(g)、hex(b)是否为undefined，像这样：</p><pre><code class=\"js\">function rgb2hex(sRGB) {\n  return sRGB.replace(/^rgb\\((\\d+)\\s*\\,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\)$/g, function(a, r, g, b){\n    if (hex(r) == undefined || hex(g) == undefined || hex(b) == undefined) return sRGB;\n    return &#39;#&#39; + hex(r) + hex(g) + hex(b);\n  });\n}\nfunction hex(n){\n  if (n &gt; -1 &amp;&amp; n &lt; 256) {\n    return n &lt; 16 ? &#39;0&#39; + (+n).toString(16) : (+n).toString(16);\n  }\n}\n</code></pre><p>这样就可以啦！</p><h2 id=\"将字符串转换为驼峰模式\"><a href=\"#将字符串转换为驼峰模式\" class=\"headerlink\" title=\"将字符串转换为驼峰模式\"></a>将字符串转换为驼峰模式</h2><blockquote><p>css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能</p><ol><li>以 - 为分隔符，将第二个起的非空单词首字母转为大写</li><li>-webkit-border-image 转换后的结果为 webkitBorderImage</li></ol></blockquote><p>输入</p><pre><code>&#39;font-size&#39;\n</code></pre><p>输出</p><pre><code>fontSize\n</code></pre><p>代码</p><pre><code class=\"js\">function cssStyle2DomStyle(sName) {\n    if (sName[0] == &quot;-&quot;) sName = sName.slice(1);\n    var words = sName.split(&#39;-&#39;);\n    var re = words[0];\n    for (var i = 1; i &lt; words.length; i++) {\n        re = re + words[i][0].toUpperCase() + words[i].slice(1);\n    }\n    return re;\n}\n</code></pre><p>大神的代码：</p><pre><code class=\"js\">// 链接：https://www.nowcoder.com/questionTerminal/2ded24e34ec34325a62d42d0c8479bae\n// 来源：牛客网\n\nreturn sName.replace(/\\-[a-z]/g , function(a, b){\n\n    return b == 0 ? a.replace(&#39;-&#39;,&#39;&#39;) : a.replace(&#39;-&#39;,&#39;&#39;).toUpperCase();\n\n});\n</code></pre><p>其中b是offset。</p><p>replace第二个参数函数的参数表：</p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的$&amp;。）</td></tr><tr><td><code>p1,p2, ...</code></td><td>假如replace()方法的第一个参数是一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>RegExp</code></a> 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）</td></tr><tr><td><code>offset</code></td><td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr></tbody></table><h2 id=\"字符串字符统计\"><a href=\"#字符串字符统计\" class=\"headerlink\" title=\"字符串字符统计\"></a>字符串字符统计</h2><blockquote><p>统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率</p><ol><li>不限制 key 的顺序</li><li>输入的字符串参数不会为空</li><li>忽略空白字符</li></ol></blockquote><p>输入</p><pre><code>&#39;hello world&#39;\n</code></pre><p>输出</p><pre><code>{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}\n</code></pre><p>大神的代码：</p><pre><code class=\"js\">function count(str) {\n    var obj = {};\n    str.replace(/\\S/g,function(s){\n        !obj[s]?obj[s]=1:obj[s]++;\n    })\n    return obj;\n}\n</code></pre><p>\\S匹配非空字符串，function(s)里的s代表匹配到的每一项。</p><hr><p>哎总结一句就是我好菜。。对JS了解还是太少。。。</p>"},{"title":"猫眼电影加密数字破解（爬取评分票房票价）","toc":true,"date":"2018-07-01T14:05:27.000Z","_content":"\n## 背景\n\n在爬取猫眼电影相关数据时发现爬取下来的评分、票房、票价不是具体的数字而是一串类似于`\\uf5fb`的码，需要解密。\n\n而这些密码是每次访问时随机生成的，和0-9的映射关系也是随机的。\n\n<!-- more -->\n\n## 解密办法\n\n下载动态字体文件，解析映射关系。\n\n## 解密思路\n\n首先找到动态字体文件的地址（head标签内的style标签内）：\n\n```html\n<style>\n    @font-face {\n      font-family: stonefont;\n      src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot');\n      src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot?#iefix') format('embedded-opentype'),\n           url('//vfile.meituan.net/colorstone/8f497cdb4e39d1f3dcbafa28a486aea42076.woff') format('woff');\n    }\n\n    .stonefont {\n      font-family: stonefont;\n    }\n  </style>\n```\n\n其中的.woff文件是我们需要的。\n\n爬取代码如下（利用**scrapy**）：\n\n```python\n#下载字体文件\nfont_url = sel.xpath('/html/head/style/text()').extract()[0]\nfont_url = 'http:'+font_url[font_url.rfind('url')+5:font_url.find('woff')+4]\nprint(font_url)\nwoff_path = 'tmp.woff'\nf = urllib.request.urlopen(font_url)\ndata = f.read()\nwith open(woff_path, \"wb\") as code:\n    code.write(data)\n```\n\n利用`TTFont`将`woff`文件转换为`xml`文件：\n\n```python\nfont1 = TTFont('tmp.woff')\nfont1.saveXML('tmp.xml')\n```\n\n查看xml文件会发现一个映射关系：\n\n```xml\n<GlyphOrder>\n    <!-- The 'id' attribute is only for humans; it is ignored when parsed. -->\n    <GlyphID id=\"0\" name=\"glyph00000\"/>\n    <GlyphID id=\"1\" name=\"x\"/>\n    <GlyphID id=\"2\" name=\"uniF753\"/>\n    <GlyphID id=\"3\" name=\"uniEA72\"/>\n    <GlyphID id=\"4\" name=\"uniEE4E\"/>\n    <GlyphID id=\"5\" name=\"uniECE6\"/>\n    <GlyphID id=\"6\" name=\"uniE140\"/>\n    <GlyphID id=\"7\" name=\"uniF4B0\"/>\n    <GlyphID id=\"8\" name=\"uniE1B7\"/>\n    <GlyphID id=\"9\" name=\"uniF245\"/>\n    <GlyphID id=\"10\" name=\"uniE488\"/>\n    <GlyphID id=\"11\" name=\"uniE6DA\"/>\n</GlyphOrder>\n```\n\n但是使用这个映射关系解码发现解密出来的数字不对，因此GlyphOrder并不是我们需要的映射关系。\n\nxml文件往下翻，发现了字体数据：\n\n```xml\n<TTGlyph name=\"uniF245\" xMin=\"0\" yMin=\"0\" xMax=\"508\" yMax=\"716\">\n  <contour>\n    <pt x=\"323\" y=\"0\" on=\"1\"/>\n    <pt x=\"323\" y=\"171\" on=\"1\"/>\n    <pt x=\"13\" y=\"171\" on=\"1\"/>\n    <pt x=\"13\" y=\"252\" on=\"1\"/>\n    <pt x=\"339\" y=\"716\" on=\"1\"/>\n    <pt x=\"411\" y=\"716\" on=\"1\"/>\n    <pt x=\"411\" y=\"252\" on=\"1\"/>\n    <pt x=\"508\" y=\"252\" on=\"1\"/>\n    <pt x=\"508\" y=\"171\" on=\"1\"/>\n    <pt x=\"411\" y=\"171\" on=\"1\"/>\n    <pt x=\"411\" y=\"0\" on=\"1\"/>\n  </contour>\n  <contour>\n    <pt x=\"323\" y=\"252\" on=\"1\"/>\n    <pt x=\"323\" y=\"575\" on=\"1\"/>\n    <pt x=\"99\" y=\"252\" on=\"1\"/>\n  </contour>\n  <instructions/>\n</TTGlyph>\n```\n\n看到这里突然想到，无论unicode码怎么变，数字渲染出来的样子是不会变的，因此可以从字体数据入手：\n\n**0-9每一个数字都有对应的一个`TTGlyph`数据，首先对一个已知映射关系的字体文件进行分析，获取0-9的字体数据，然后对于每次下载的动态字体文件，将其字体信息与0-9的字体数据进行对比就可以知道其映射关系了。**\n\n首先需要一份已知映射关系的xml文件作为映射关系对比文件，将其命名为`data.xml`，然后使用[百度字体编辑器](http://fontstore.baidu.com/static/editor/index.html)分析其对应的`woff`获取其映射关系(由于我的`data.xml`对应的`woff`文件删掉了，因此这里截图的是一个随机的`woff`文件对应的映射关系，可能与后边的代码内的映射关系不同，特此说明)：\n\n![](/images/woff_decode.PNG)\n\n创建`data.xml`对应的映射关系的字典：\n\n```python\ndata_dict = {\"uniE184\":\"4\",\"uniE80B\":\"3\",\"uniF22E\":\"8\",\"uniE14C\":\"0\",\n\t\t\"uniF5FB\":\"6\",\"uniEE59\":\"5\",\"uniEBD3\":\"1\",\"uniED85\":\"7\",\"uniECB8\":\"2\",\"uniE96A\":\"9\"}\n```\n\n要对比字体数据就要对xml文件进行分析，因此创建相关xml分析函数：\n\n获取某节点指定属性的值：\n\n```python\ndef getValue(node, attribute):\n\treturn node.attributes[attribute].value\n```\n\n字体数据的标签为`TTGlyph`，创建获取一个`xml`文件中所有的文字信息节点的函数：\n\n```python\ndef getTTGlyphList(xml_path):\n\tdataXmlfilepath = os.path.abspath(xml_path)\n\tdataDomObj = xmldom.parse(dataXmlfilepath)\n\tdataElementObj = dataDomObj.documentElement\n\tdataTTGlyphList = dataElementObj.getElementsByTagName('TTGlyph')\n\treturn dataTTGlyphList\n```\n\n判断两个`TTGlyph`节点数据是否相同的函数：\n\n```python\ndef isEqual(ttglyph_a, ttglyph_b):\n\ta_pt_list = ttglyph_a.getElementsByTagName('pt')\n\tb_pt_list = ttglyph_b.getElementsByTagName('pt')\n\ta_len = len(a_pt_list)\n\tb_len = len(b_pt_list)\n\tif a_len != b_len:\n\t\treturn False\n\tfor i in range(a_len):\n\t\tif getValue(a_pt_list[i], 'x') != getValue(b_pt_list[i], 'x')  or getValue(a_pt_list[i], 'y') != getValue(b_pt_list[i], 'y') or getValue(a_pt_list[i], 'on') != getValue(b_pt_list[i], 'on'):\n\t\t\treturn False\n\treturn True\n```\n\n===============================================\n\n相关函数建好后可以继续分析：\n\n由于每次的unicode码是随机生成的，因此还需要知道新的0-9对应的unicode码是多少，为了方便直接使用函数获取了上边提到过的映射关系不对的`GlyphOrder`，是一个`key`为unicode，`value`为数字的字典：\n\n```python\ndecode_dict = dict(enumerate(font1.getGlyphOrder()[2:]))\ndecode_dict = dict(zip(decode_dict.values(),decode_dict.keys()))\t\n```\n\n获取已知映射关系的`data.xml`的字体数据节点和新的动态字体文件的数据节点：\n\n```python\ndataTTGlyphList = getTTGlyphList(\"data.xml\")\ntmpTTGlyphList = getTTGlyphList(\"tmp.xml\")\n```\n\n利用字体数据更新映射字典：\n\n```python\ndecode_dict = refresh(decode_dict,tmpTTGlyphList,dataTTGlyphList)\n```\n\n更新函数的具体实现如下：\n\n```python\ndef refresh(dict, ttGlyphList_a, ttGlyphList_data):\n\tdata_dict = {\"uniE184\":\"4\",\"uniE80B\":\"3\",\"uniF22E\":\"8\",\"uniE14C\":\"0\",\n\t\t\"uniF5FB\":\"6\",\"uniEE59\":\"5\",\"uniEBD3\":\"1\",\"uniED85\":\"7\",\"uniECB8\":\"2\",\"uniE96A\":\"9\"}\n\tdata_keys = data_dict.keys()\n\tfor ttglyph_data in ttGlyphList_data:\n\t\tif \tgetValue(ttglyph_data,'name') in data_keys:\n\t\t\tfor ttglyph_a in ttGlyphList_a:\n\t\t\t\tif isEqual(ttglyph_a, ttglyph_data):\n\t\t\t\t\tdict[getValue(ttglyph_a,'name')] = data_dict[getValue(ttglyph_data,'name')]\n\t\t\t\t\tbreak\n\treturn dict\n```\n\n考虑到小数的情况，加入小数点映射：\n\n```python\ndecode_dict['.'] = '.'\n```\n\n实现解码函数（输入映射字典和一个需要解密的数值，输出解密后的结果如15.6）：\n\n```python\ndef decode(decode_dict, code):\n\t_lst_uincode = []\n\tfor item in code.__repr__().split(\"\\\\u\"):\n\t\t_lst_uincode.append(\"uni\" + item[:4].upper())\n\t\tif item[4:]:\n\t\t\t_lst_uincode.append(item[4:])\n\t_lst_uincode = _lst_uincode[1:-1]\n\tresult = \"\".join([str(decode_dict[i]) for i in _lst_uincode])\n\treturn result\n```\n\n\n\n==================================================\n\n[具体代码链接](https://github.com/SoftwareSAD/Spider/blob/master/rowpiece/rowpiece/spiders/RowpieceSpider.py)","source":"_posts/猫眼电影加密数字破解（爬取评分票房票价）.md","raw":"---\ntitle: 猫眼电影加密数字破解（爬取评分票房票价）\ntoc: true\ndate: 2018-07-01 22:05:27\ncategories:\n- methods\ntags:\n- 爬虫\n- Python\n---\n\n## 背景\n\n在爬取猫眼电影相关数据时发现爬取下来的评分、票房、票价不是具体的数字而是一串类似于`\\uf5fb`的码，需要解密。\n\n而这些密码是每次访问时随机生成的，和0-9的映射关系也是随机的。\n\n<!-- more -->\n\n## 解密办法\n\n下载动态字体文件，解析映射关系。\n\n## 解密思路\n\n首先找到动态字体文件的地址（head标签内的style标签内）：\n\n```html\n<style>\n    @font-face {\n      font-family: stonefont;\n      src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot');\n      src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot?#iefix') format('embedded-opentype'),\n           url('//vfile.meituan.net/colorstone/8f497cdb4e39d1f3dcbafa28a486aea42076.woff') format('woff');\n    }\n\n    .stonefont {\n      font-family: stonefont;\n    }\n  </style>\n```\n\n其中的.woff文件是我们需要的。\n\n爬取代码如下（利用**scrapy**）：\n\n```python\n#下载字体文件\nfont_url = sel.xpath('/html/head/style/text()').extract()[0]\nfont_url = 'http:'+font_url[font_url.rfind('url')+5:font_url.find('woff')+4]\nprint(font_url)\nwoff_path = 'tmp.woff'\nf = urllib.request.urlopen(font_url)\ndata = f.read()\nwith open(woff_path, \"wb\") as code:\n    code.write(data)\n```\n\n利用`TTFont`将`woff`文件转换为`xml`文件：\n\n```python\nfont1 = TTFont('tmp.woff')\nfont1.saveXML('tmp.xml')\n```\n\n查看xml文件会发现一个映射关系：\n\n```xml\n<GlyphOrder>\n    <!-- The 'id' attribute is only for humans; it is ignored when parsed. -->\n    <GlyphID id=\"0\" name=\"glyph00000\"/>\n    <GlyphID id=\"1\" name=\"x\"/>\n    <GlyphID id=\"2\" name=\"uniF753\"/>\n    <GlyphID id=\"3\" name=\"uniEA72\"/>\n    <GlyphID id=\"4\" name=\"uniEE4E\"/>\n    <GlyphID id=\"5\" name=\"uniECE6\"/>\n    <GlyphID id=\"6\" name=\"uniE140\"/>\n    <GlyphID id=\"7\" name=\"uniF4B0\"/>\n    <GlyphID id=\"8\" name=\"uniE1B7\"/>\n    <GlyphID id=\"9\" name=\"uniF245\"/>\n    <GlyphID id=\"10\" name=\"uniE488\"/>\n    <GlyphID id=\"11\" name=\"uniE6DA\"/>\n</GlyphOrder>\n```\n\n但是使用这个映射关系解码发现解密出来的数字不对，因此GlyphOrder并不是我们需要的映射关系。\n\nxml文件往下翻，发现了字体数据：\n\n```xml\n<TTGlyph name=\"uniF245\" xMin=\"0\" yMin=\"0\" xMax=\"508\" yMax=\"716\">\n  <contour>\n    <pt x=\"323\" y=\"0\" on=\"1\"/>\n    <pt x=\"323\" y=\"171\" on=\"1\"/>\n    <pt x=\"13\" y=\"171\" on=\"1\"/>\n    <pt x=\"13\" y=\"252\" on=\"1\"/>\n    <pt x=\"339\" y=\"716\" on=\"1\"/>\n    <pt x=\"411\" y=\"716\" on=\"1\"/>\n    <pt x=\"411\" y=\"252\" on=\"1\"/>\n    <pt x=\"508\" y=\"252\" on=\"1\"/>\n    <pt x=\"508\" y=\"171\" on=\"1\"/>\n    <pt x=\"411\" y=\"171\" on=\"1\"/>\n    <pt x=\"411\" y=\"0\" on=\"1\"/>\n  </contour>\n  <contour>\n    <pt x=\"323\" y=\"252\" on=\"1\"/>\n    <pt x=\"323\" y=\"575\" on=\"1\"/>\n    <pt x=\"99\" y=\"252\" on=\"1\"/>\n  </contour>\n  <instructions/>\n</TTGlyph>\n```\n\n看到这里突然想到，无论unicode码怎么变，数字渲染出来的样子是不会变的，因此可以从字体数据入手：\n\n**0-9每一个数字都有对应的一个`TTGlyph`数据，首先对一个已知映射关系的字体文件进行分析，获取0-9的字体数据，然后对于每次下载的动态字体文件，将其字体信息与0-9的字体数据进行对比就可以知道其映射关系了。**\n\n首先需要一份已知映射关系的xml文件作为映射关系对比文件，将其命名为`data.xml`，然后使用[百度字体编辑器](http://fontstore.baidu.com/static/editor/index.html)分析其对应的`woff`获取其映射关系(由于我的`data.xml`对应的`woff`文件删掉了，因此这里截图的是一个随机的`woff`文件对应的映射关系，可能与后边的代码内的映射关系不同，特此说明)：\n\n![](/images/woff_decode.PNG)\n\n创建`data.xml`对应的映射关系的字典：\n\n```python\ndata_dict = {\"uniE184\":\"4\",\"uniE80B\":\"3\",\"uniF22E\":\"8\",\"uniE14C\":\"0\",\n\t\t\"uniF5FB\":\"6\",\"uniEE59\":\"5\",\"uniEBD3\":\"1\",\"uniED85\":\"7\",\"uniECB8\":\"2\",\"uniE96A\":\"9\"}\n```\n\n要对比字体数据就要对xml文件进行分析，因此创建相关xml分析函数：\n\n获取某节点指定属性的值：\n\n```python\ndef getValue(node, attribute):\n\treturn node.attributes[attribute].value\n```\n\n字体数据的标签为`TTGlyph`，创建获取一个`xml`文件中所有的文字信息节点的函数：\n\n```python\ndef getTTGlyphList(xml_path):\n\tdataXmlfilepath = os.path.abspath(xml_path)\n\tdataDomObj = xmldom.parse(dataXmlfilepath)\n\tdataElementObj = dataDomObj.documentElement\n\tdataTTGlyphList = dataElementObj.getElementsByTagName('TTGlyph')\n\treturn dataTTGlyphList\n```\n\n判断两个`TTGlyph`节点数据是否相同的函数：\n\n```python\ndef isEqual(ttglyph_a, ttglyph_b):\n\ta_pt_list = ttglyph_a.getElementsByTagName('pt')\n\tb_pt_list = ttglyph_b.getElementsByTagName('pt')\n\ta_len = len(a_pt_list)\n\tb_len = len(b_pt_list)\n\tif a_len != b_len:\n\t\treturn False\n\tfor i in range(a_len):\n\t\tif getValue(a_pt_list[i], 'x') != getValue(b_pt_list[i], 'x')  or getValue(a_pt_list[i], 'y') != getValue(b_pt_list[i], 'y') or getValue(a_pt_list[i], 'on') != getValue(b_pt_list[i], 'on'):\n\t\t\treturn False\n\treturn True\n```\n\n===============================================\n\n相关函数建好后可以继续分析：\n\n由于每次的unicode码是随机生成的，因此还需要知道新的0-9对应的unicode码是多少，为了方便直接使用函数获取了上边提到过的映射关系不对的`GlyphOrder`，是一个`key`为unicode，`value`为数字的字典：\n\n```python\ndecode_dict = dict(enumerate(font1.getGlyphOrder()[2:]))\ndecode_dict = dict(zip(decode_dict.values(),decode_dict.keys()))\t\n```\n\n获取已知映射关系的`data.xml`的字体数据节点和新的动态字体文件的数据节点：\n\n```python\ndataTTGlyphList = getTTGlyphList(\"data.xml\")\ntmpTTGlyphList = getTTGlyphList(\"tmp.xml\")\n```\n\n利用字体数据更新映射字典：\n\n```python\ndecode_dict = refresh(decode_dict,tmpTTGlyphList,dataTTGlyphList)\n```\n\n更新函数的具体实现如下：\n\n```python\ndef refresh(dict, ttGlyphList_a, ttGlyphList_data):\n\tdata_dict = {\"uniE184\":\"4\",\"uniE80B\":\"3\",\"uniF22E\":\"8\",\"uniE14C\":\"0\",\n\t\t\"uniF5FB\":\"6\",\"uniEE59\":\"5\",\"uniEBD3\":\"1\",\"uniED85\":\"7\",\"uniECB8\":\"2\",\"uniE96A\":\"9\"}\n\tdata_keys = data_dict.keys()\n\tfor ttglyph_data in ttGlyphList_data:\n\t\tif \tgetValue(ttglyph_data,'name') in data_keys:\n\t\t\tfor ttglyph_a in ttGlyphList_a:\n\t\t\t\tif isEqual(ttglyph_a, ttglyph_data):\n\t\t\t\t\tdict[getValue(ttglyph_a,'name')] = data_dict[getValue(ttglyph_data,'name')]\n\t\t\t\t\tbreak\n\treturn dict\n```\n\n考虑到小数的情况，加入小数点映射：\n\n```python\ndecode_dict['.'] = '.'\n```\n\n实现解码函数（输入映射字典和一个需要解密的数值，输出解密后的结果如15.6）：\n\n```python\ndef decode(decode_dict, code):\n\t_lst_uincode = []\n\tfor item in code.__repr__().split(\"\\\\u\"):\n\t\t_lst_uincode.append(\"uni\" + item[:4].upper())\n\t\tif item[4:]:\n\t\t\t_lst_uincode.append(item[4:])\n\t_lst_uincode = _lst_uincode[1:-1]\n\tresult = \"\".join([str(decode_dict[i]) for i in _lst_uincode])\n\treturn result\n```\n\n\n\n==================================================\n\n[具体代码链接](https://github.com/SoftwareSAD/Spider/blob/master/rowpiece/rowpiece/spiders/RowpieceSpider.py)","slug":"猫眼电影加密数字破解（爬取评分票房票价）","published":1,"updated":"2018-10-10T08:45:54.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xo0049fmagvapgznp6","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在爬取猫眼电影相关数据时发现爬取下来的评分、票房、票价不是具体的数字而是一串类似于<code>\\uf5fb</code>的码，需要解密。</p><p>而这些密码是每次访问时随机生成的，和0-9的映射关系也是随机的。</p><a id=\"more\"></a><h2 id=\"解密办法\"><a href=\"#解密办法\" class=\"headerlink\" title=\"解密办法\"></a>解密办法</h2><p>下载动态字体文件，解析映射关系。</p><h2 id=\"解密思路\"><a href=\"#解密思路\" class=\"headerlink\" title=\"解密思路\"></a>解密思路</h2><p>首先找到动态字体文件的地址（head标签内的style标签内）：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token atrule\"><span class=\"token rule\">@font-face</span></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span> stonefont<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">src</span><span class=\"token punctuation\">:</span> <span class=\"token url\">url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot')</span><span class=\"token punctuation\">;</span>\n      <span class=\"token property\">src</span><span class=\"token punctuation\">:</span> <span class=\"token url\">url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot?#iefix')</span> <span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">'embedded-opentype'</span><span class=\"token punctuation\">)</span>,\n           <span class=\"token url\">url('//vfile.meituan.net/colorstone/8f497cdb4e39d1f3dcbafa28a486aea42076.woff')</span> <span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">'woff'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token selector\"><span class=\"token class\">.stonefont</span> </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span> stonefont<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>其中的.woff文件是我们需要的。</p><p>爬取代码如下（利用<strong>scrapy</strong>）：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\">#下载字体文件</span>\nfont_url <span class=\"token operator\">=</span> sel<span class=\"token punctuation\">.</span>xpath<span class=\"token punctuation\">(</span><span class=\"token string\">'/html/head/style/text()'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>extract<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\nfont_url <span class=\"token operator\">=</span> <span class=\"token string\">'http:'</span><span class=\"token operator\">+</span>font_url<span class=\"token punctuation\">[</span>font_url<span class=\"token punctuation\">.</span>rfind<span class=\"token punctuation\">(</span><span class=\"token string\">'url'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span>font_url<span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span><span class=\"token string\">'woff'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>font_url<span class=\"token punctuation\">)</span>\nwoff_path <span class=\"token operator\">=</span> <span class=\"token string\">'tmp.woff'</span>\nf <span class=\"token operator\">=</span> urllib<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">.</span>urlopen<span class=\"token punctuation\">(</span>font_url<span class=\"token punctuation\">)</span>\ndata <span class=\"token operator\">=</span> f<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span>woff_path<span class=\"token punctuation\">,</span> <span class=\"token string\">\"wb\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> code<span class=\"token punctuation\">:</span>\n    code<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n</code></pre><p>利用<code>TTFont</code>将<code>woff</code>文件转换为<code>xml</code>文件：</p><pre class=\" language-python\"><code class=\"language-python\">font1 <span class=\"token operator\">=</span> TTFont<span class=\"token punctuation\">(</span><span class=\"token string\">'tmp.woff'</span><span class=\"token punctuation\">)</span>\nfont1<span class=\"token punctuation\">.</span>saveXML<span class=\"token punctuation\">(</span><span class=\"token string\">'tmp.xml'</span><span class=\"token punctuation\">)</span>\n</code></pre><p>查看xml文件会发现一个映射关系：</p><pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphOrder</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- The 'id' attribute is only for humans; it is ignored when parsed. --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>glyph00000<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>x<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniF753<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>3<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniEA72<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>4<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniEE4E<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>5<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniECE6<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>6<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniE140<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>7<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniF4B0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>8<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniE1B7<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>9<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniF245<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>10<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniE488<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>GlyphID</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>11<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniE6DA<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>GlyphOrder</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>但是使用这个映射关系解码发现解密出来的数字不对，因此GlyphOrder并不是我们需要的映射关系。</p><p>xml文件往下翻，发现了字体数据：</p><pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TTGlyph</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>uniF245<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">xMin</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">yMin</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">xMax</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>508<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">yMax</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>716<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>contour</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>323<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>323<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>171<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>13<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>171<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>13<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>252<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>339<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>716<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>411<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>716<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>411<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>252<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>508<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>252<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>508<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>171<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>411<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>171<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>411<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>contour</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>contour</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>323<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>252<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>323<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>575<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>pt</span> <span class=\"token attr-name\">x</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>99<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">y</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>252<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">on</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>contour</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>instructions</span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>TTGlyph</span><span class=\"token punctuation\">></span></span>\n</code></pre><p>看到这里突然想到，无论unicode码怎么变，数字渲染出来的样子是不会变的，因此可以从字体数据入手：</p><p><strong>0-9每一个数字都有对应的一个<code>TTGlyph</code>数据，首先对一个已知映射关系的字体文件进行分析，获取0-9的字体数据，然后对于每次下载的动态字体文件，将其字体信息与0-9的字体数据进行对比就可以知道其映射关系了。</strong></p><p>首先需要一份已知映射关系的xml文件作为映射关系对比文件，将其命名为<code>data.xml</code>，然后使用<a href=\"http://fontstore.baidu.com/static/editor/index.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">百度字体编辑器</a>分析其对应的<code>woff</code>获取其映射关系(由于我的<code>data.xml</code>对应的<code>woff</code>文件删掉了，因此这里截图的是一个随机的<code>woff</code>文件对应的映射关系，可能与后边的代码内的映射关系不同，特此说明)：</p><p><img src=\"/images/woff_decode.PNG\" alt=\"\"></p><p>创建<code>data.xml</code>对应的映射关系的字典：</p><pre class=\" language-python\"><code class=\"language-python\">data_dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"uniE184\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE80B\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniF22E\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"8\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE14C\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"uniF5FB\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"6\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniEE59\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniEBD3\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniED85\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"7\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniECB8\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE96A\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"9\"</span><span class=\"token punctuation\">}</span>\n</code></pre><p>要对比字体数据就要对xml文件进行分析，因此创建相关xml分析函数：</p><p>获取某节点指定属性的值：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> attribute<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>attributes<span class=\"token punctuation\">[</span>attribute<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value\n</code></pre><p>字体数据的标签为<code>TTGlyph</code>，创建获取一个<code>xml</code>文件中所有的文字信息节点的函数：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">getTTGlyphList</span><span class=\"token punctuation\">(</span>xml_path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    dataXmlfilepath <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>abspath<span class=\"token punctuation\">(</span>xml_path<span class=\"token punctuation\">)</span>\n    dataDomObj <span class=\"token operator\">=</span> xmldom<span class=\"token punctuation\">.</span>parse<span class=\"token punctuation\">(</span>dataXmlfilepath<span class=\"token punctuation\">)</span>\n    dataElementObj <span class=\"token operator\">=</span> dataDomObj<span class=\"token punctuation\">.</span>documentElement\n    dataTTGlyphList <span class=\"token operator\">=</span> dataElementObj<span class=\"token punctuation\">.</span>getElementsByTagName<span class=\"token punctuation\">(</span><span class=\"token string\">'TTGlyph'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> dataTTGlyphList\n</code></pre><p>判断两个<code>TTGlyph</code>节点数据是否相同的函数：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">isEqual</span><span class=\"token punctuation\">(</span>ttglyph_a<span class=\"token punctuation\">,</span> ttglyph_b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a_pt_list <span class=\"token operator\">=</span> ttglyph_a<span class=\"token punctuation\">.</span>getElementsByTagName<span class=\"token punctuation\">(</span><span class=\"token string\">'pt'</span><span class=\"token punctuation\">)</span>\n    b_pt_list <span class=\"token operator\">=</span> ttglyph_b<span class=\"token punctuation\">.</span>getElementsByTagName<span class=\"token punctuation\">(</span><span class=\"token string\">'pt'</span><span class=\"token punctuation\">)</span>\n    a_len <span class=\"token operator\">=</span> len<span class=\"token punctuation\">(</span>a_pt_list<span class=\"token punctuation\">)</span>\n    b_len <span class=\"token operator\">=</span> len<span class=\"token punctuation\">(</span>b_pt_list<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a_len <span class=\"token operator\">!=</span> b_len<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>a_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> getValue<span class=\"token punctuation\">(</span>a_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> getValue<span class=\"token punctuation\">(</span>b_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">or</span> getValue<span class=\"token punctuation\">(</span>a_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> getValue<span class=\"token punctuation\">(</span>b_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> getValue<span class=\"token punctuation\">(</span>a_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'on'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> getValue<span class=\"token punctuation\">(</span>b_pt_list<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'on'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n</code></pre><p>===============================================</p><p>相关函数建好后可以继续分析：</p><p>由于每次的unicode码是随机生成的，因此还需要知道新的0-9对应的unicode码是多少，为了方便直接使用函数获取了上边提到过的映射关系不对的<code>GlyphOrder</code>，是一个<code>key</code>为unicode，<code>value</code>为数字的字典：</p><pre class=\" language-python\"><code class=\"language-python\">decode_dict <span class=\"token operator\">=</span> dict<span class=\"token punctuation\">(</span>enumerate<span class=\"token punctuation\">(</span>font1<span class=\"token punctuation\">.</span>getGlyphOrder<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ndecode_dict <span class=\"token operator\">=</span> dict<span class=\"token punctuation\">(</span>zip<span class=\"token punctuation\">(</span>decode_dict<span class=\"token punctuation\">.</span>values<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>decode_dict<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    \n</code></pre><p>获取已知映射关系的<code>data.xml</code>的字体数据节点和新的动态字体文件的数据节点：</p><pre class=\" language-python\"><code class=\"language-python\">dataTTGlyphList <span class=\"token operator\">=</span> getTTGlyphList<span class=\"token punctuation\">(</span><span class=\"token string\">\"data.xml\"</span><span class=\"token punctuation\">)</span>\ntmpTTGlyphList <span class=\"token operator\">=</span> getTTGlyphList<span class=\"token punctuation\">(</span><span class=\"token string\">\"tmp.xml\"</span><span class=\"token punctuation\">)</span>\n</code></pre><p>利用字体数据更新映射字典：</p><pre class=\" language-python\"><code class=\"language-python\">decode_dict <span class=\"token operator\">=</span> refresh<span class=\"token punctuation\">(</span>decode_dict<span class=\"token punctuation\">,</span>tmpTTGlyphList<span class=\"token punctuation\">,</span>dataTTGlyphList<span class=\"token punctuation\">)</span>\n</code></pre><p>更新函数的具体实现如下：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">refresh</span><span class=\"token punctuation\">(</span>dict<span class=\"token punctuation\">,</span> ttGlyphList_a<span class=\"token punctuation\">,</span> ttGlyphList_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    data_dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"uniE184\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE80B\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniF22E\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"8\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE14C\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"uniF5FB\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"6\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniEE59\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"5\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniEBD3\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniED85\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"7\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniECB8\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"uniE96A\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"9\"</span><span class=\"token punctuation\">}</span>\n    data_keys <span class=\"token operator\">=</span> data_dict<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> ttglyph_data <span class=\"token keyword\">in</span> ttGlyphList_data<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span>     getValue<span class=\"token punctuation\">(</span>ttglyph_data<span class=\"token punctuation\">,</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> data_keys<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> ttglyph_a <span class=\"token keyword\">in</span> ttGlyphList_a<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> isEqual<span class=\"token punctuation\">(</span>ttglyph_a<span class=\"token punctuation\">,</span> ttglyph_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    dict<span class=\"token punctuation\">[</span>getValue<span class=\"token punctuation\">(</span>ttglyph_a<span class=\"token punctuation\">,</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data_dict<span class=\"token punctuation\">[</span>getValue<span class=\"token punctuation\">(</span>ttglyph_data<span class=\"token punctuation\">,</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n                    <span class=\"token keyword\">break</span>\n    <span class=\"token keyword\">return</span> dict\n</code></pre><p>考虑到小数的情况，加入小数点映射：</p><pre class=\" language-python\"><code class=\"language-python\">decode_dict<span class=\"token punctuation\">[</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'.'</span>\n</code></pre><p>实现解码函数（输入映射字典和一个需要解密的数值，输出解密后的结果如15.6）：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>decode_dict<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    _lst_uincode <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> code<span class=\"token punctuation\">.</span>__repr__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\u\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        _lst_uincode<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">\"uni\"</span> <span class=\"token operator\">+</span> item<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>upper<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> item<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            _lst_uincode<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    _lst_uincode <span class=\"token operator\">=</span> _lst_uincode<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    result <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>str<span class=\"token punctuation\">(</span>decode_dict<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> _lst_uincode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n</code></pre><p>==================================================</p><p><a href=\"https://github.com/SoftwareSAD/Spider/blob/master/rowpiece/rowpiece/spiders/RowpieceSpider.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">具体代码链接</a></p>","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在爬取猫眼电影相关数据时发现爬取下来的评分、票房、票价不是具体的数字而是一串类似于<code>\\uf5fb</code>的码，需要解密。</p><p>而这些密码是每次访问时随机生成的，和0-9的映射关系也是随机的。</p>","more":"<h2 id=\"解密办法\"><a href=\"#解密办法\" class=\"headerlink\" title=\"解密办法\"></a>解密办法</h2><p>下载动态字体文件，解析映射关系。</p><h2 id=\"解密思路\"><a href=\"#解密思路\" class=\"headerlink\" title=\"解密思路\"></a>解密思路</h2><p>首先找到动态字体文件的地址（head标签内的style标签内）：</p><pre><code class=\"html\">&lt;style&gt;\n    @font-face {\n      font-family: stonefont;\n      src: url(&#39;//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot&#39;);\n      src: url(&#39;//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),\n           url(&#39;//vfile.meituan.net/colorstone/8f497cdb4e39d1f3dcbafa28a486aea42076.woff&#39;) format(&#39;woff&#39;);\n    }\n\n    .stonefont {\n      font-family: stonefont;\n    }\n  &lt;/style&gt;\n</code></pre><p>其中的.woff文件是我们需要的。</p><p>爬取代码如下（利用<strong>scrapy</strong>）：</p><pre><code class=\"python\">#下载字体文件\nfont_url = sel.xpath(&#39;/html/head/style/text()&#39;).extract()[0]\nfont_url = &#39;http:&#39;+font_url[font_url.rfind(&#39;url&#39;)+5:font_url.find(&#39;woff&#39;)+4]\nprint(font_url)\nwoff_path = &#39;tmp.woff&#39;\nf = urllib.request.urlopen(font_url)\ndata = f.read()\nwith open(woff_path, &quot;wb&quot;) as code:\n    code.write(data)\n</code></pre><p>利用<code>TTFont</code>将<code>woff</code>文件转换为<code>xml</code>文件：</p><pre><code class=\"python\">font1 = TTFont(&#39;tmp.woff&#39;)\nfont1.saveXML(&#39;tmp.xml&#39;)\n</code></pre><p>查看xml文件会发现一个映射关系：</p><pre><code class=\"xml\">&lt;GlyphOrder&gt;\n    &lt;!-- The &#39;id&#39; attribute is only for humans; it is ignored when parsed. --&gt;\n    &lt;GlyphID id=&quot;0&quot; name=&quot;glyph00000&quot;/&gt;\n    &lt;GlyphID id=&quot;1&quot; name=&quot;x&quot;/&gt;\n    &lt;GlyphID id=&quot;2&quot; name=&quot;uniF753&quot;/&gt;\n    &lt;GlyphID id=&quot;3&quot; name=&quot;uniEA72&quot;/&gt;\n    &lt;GlyphID id=&quot;4&quot; name=&quot;uniEE4E&quot;/&gt;\n    &lt;GlyphID id=&quot;5&quot; name=&quot;uniECE6&quot;/&gt;\n    &lt;GlyphID id=&quot;6&quot; name=&quot;uniE140&quot;/&gt;\n    &lt;GlyphID id=&quot;7&quot; name=&quot;uniF4B0&quot;/&gt;\n    &lt;GlyphID id=&quot;8&quot; name=&quot;uniE1B7&quot;/&gt;\n    &lt;GlyphID id=&quot;9&quot; name=&quot;uniF245&quot;/&gt;\n    &lt;GlyphID id=&quot;10&quot; name=&quot;uniE488&quot;/&gt;\n    &lt;GlyphID id=&quot;11&quot; name=&quot;uniE6DA&quot;/&gt;\n&lt;/GlyphOrder&gt;\n</code></pre><p>但是使用这个映射关系解码发现解密出来的数字不对，因此GlyphOrder并不是我们需要的映射关系。</p><p>xml文件往下翻，发现了字体数据：</p><pre><code class=\"xml\">&lt;TTGlyph name=&quot;uniF245&quot; xMin=&quot;0&quot; yMin=&quot;0&quot; xMax=&quot;508&quot; yMax=&quot;716&quot;&gt;\n  &lt;contour&gt;\n    &lt;pt x=&quot;323&quot; y=&quot;0&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;323&quot; y=&quot;171&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;13&quot; y=&quot;171&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;13&quot; y=&quot;252&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;339&quot; y=&quot;716&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;411&quot; y=&quot;716&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;411&quot; y=&quot;252&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;508&quot; y=&quot;252&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;508&quot; y=&quot;171&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;411&quot; y=&quot;171&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;411&quot; y=&quot;0&quot; on=&quot;1&quot;/&gt;\n  &lt;/contour&gt;\n  &lt;contour&gt;\n    &lt;pt x=&quot;323&quot; y=&quot;252&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;323&quot; y=&quot;575&quot; on=&quot;1&quot;/&gt;\n    &lt;pt x=&quot;99&quot; y=&quot;252&quot; on=&quot;1&quot;/&gt;\n  &lt;/contour&gt;\n  &lt;instructions/&gt;\n&lt;/TTGlyph&gt;\n</code></pre><p>看到这里突然想到，无论unicode码怎么变，数字渲染出来的样子是不会变的，因此可以从字体数据入手：</p><p><strong>0-9每一个数字都有对应的一个<code>TTGlyph</code>数据，首先对一个已知映射关系的字体文件进行分析，获取0-9的字体数据，然后对于每次下载的动态字体文件，将其字体信息与0-9的字体数据进行对比就可以知道其映射关系了。</strong></p><p>首先需要一份已知映射关系的xml文件作为映射关系对比文件，将其命名为<code>data.xml</code>，然后使用<a href=\"http://fontstore.baidu.com/static/editor/index.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">百度字体编辑器</a>分析其对应的<code>woff</code>获取其映射关系(由于我的<code>data.xml</code>对应的<code>woff</code>文件删掉了，因此这里截图的是一个随机的<code>woff</code>文件对应的映射关系，可能与后边的代码内的映射关系不同，特此说明)：</p><p><img src=\"/images/woff_decode.PNG\" alt=\"\"></p><p>创建<code>data.xml</code>对应的映射关系的字典：</p><pre><code class=\"python\">data_dict = {&quot;uniE184&quot;:&quot;4&quot;,&quot;uniE80B&quot;:&quot;3&quot;,&quot;uniF22E&quot;:&quot;8&quot;,&quot;uniE14C&quot;:&quot;0&quot;,\n        &quot;uniF5FB&quot;:&quot;6&quot;,&quot;uniEE59&quot;:&quot;5&quot;,&quot;uniEBD3&quot;:&quot;1&quot;,&quot;uniED85&quot;:&quot;7&quot;,&quot;uniECB8&quot;:&quot;2&quot;,&quot;uniE96A&quot;:&quot;9&quot;}\n</code></pre><p>要对比字体数据就要对xml文件进行分析，因此创建相关xml分析函数：</p><p>获取某节点指定属性的值：</p><pre><code class=\"python\">def getValue(node, attribute):\n    return node.attributes[attribute].value\n</code></pre><p>字体数据的标签为<code>TTGlyph</code>，创建获取一个<code>xml</code>文件中所有的文字信息节点的函数：</p><pre><code class=\"python\">def getTTGlyphList(xml_path):\n    dataXmlfilepath = os.path.abspath(xml_path)\n    dataDomObj = xmldom.parse(dataXmlfilepath)\n    dataElementObj = dataDomObj.documentElement\n    dataTTGlyphList = dataElementObj.getElementsByTagName(&#39;TTGlyph&#39;)\n    return dataTTGlyphList\n</code></pre><p>判断两个<code>TTGlyph</code>节点数据是否相同的函数：</p><pre><code class=\"python\">def isEqual(ttglyph_a, ttglyph_b):\n    a_pt_list = ttglyph_a.getElementsByTagName(&#39;pt&#39;)\n    b_pt_list = ttglyph_b.getElementsByTagName(&#39;pt&#39;)\n    a_len = len(a_pt_list)\n    b_len = len(b_pt_list)\n    if a_len != b_len:\n        return False\n    for i in range(a_len):\n        if getValue(a_pt_list[i], &#39;x&#39;) != getValue(b_pt_list[i], &#39;x&#39;)  or getValue(a_pt_list[i], &#39;y&#39;) != getValue(b_pt_list[i], &#39;y&#39;) or getValue(a_pt_list[i], &#39;on&#39;) != getValue(b_pt_list[i], &#39;on&#39;):\n            return False\n    return True\n</code></pre><p>===============================================</p><p>相关函数建好后可以继续分析：</p><p>由于每次的unicode码是随机生成的，因此还需要知道新的0-9对应的unicode码是多少，为了方便直接使用函数获取了上边提到过的映射关系不对的<code>GlyphOrder</code>，是一个<code>key</code>为unicode，<code>value</code>为数字的字典：</p><pre><code class=\"python\">decode_dict = dict(enumerate(font1.getGlyphOrder()[2:]))\ndecode_dict = dict(zip(decode_dict.values(),decode_dict.keys()))    \n</code></pre><p>获取已知映射关系的<code>data.xml</code>的字体数据节点和新的动态字体文件的数据节点：</p><pre><code class=\"python\">dataTTGlyphList = getTTGlyphList(&quot;data.xml&quot;)\ntmpTTGlyphList = getTTGlyphList(&quot;tmp.xml&quot;)\n</code></pre><p>利用字体数据更新映射字典：</p><pre><code class=\"python\">decode_dict = refresh(decode_dict,tmpTTGlyphList,dataTTGlyphList)\n</code></pre><p>更新函数的具体实现如下：</p><pre><code class=\"python\">def refresh(dict, ttGlyphList_a, ttGlyphList_data):\n    data_dict = {&quot;uniE184&quot;:&quot;4&quot;,&quot;uniE80B&quot;:&quot;3&quot;,&quot;uniF22E&quot;:&quot;8&quot;,&quot;uniE14C&quot;:&quot;0&quot;,\n        &quot;uniF5FB&quot;:&quot;6&quot;,&quot;uniEE59&quot;:&quot;5&quot;,&quot;uniEBD3&quot;:&quot;1&quot;,&quot;uniED85&quot;:&quot;7&quot;,&quot;uniECB8&quot;:&quot;2&quot;,&quot;uniE96A&quot;:&quot;9&quot;}\n    data_keys = data_dict.keys()\n    for ttglyph_data in ttGlyphList_data:\n        if     getValue(ttglyph_data,&#39;name&#39;) in data_keys:\n            for ttglyph_a in ttGlyphList_a:\n                if isEqual(ttglyph_a, ttglyph_data):\n                    dict[getValue(ttglyph_a,&#39;name&#39;)] = data_dict[getValue(ttglyph_data,&#39;name&#39;)]\n                    break\n    return dict\n</code></pre><p>考虑到小数的情况，加入小数点映射：</p><pre><code class=\"python\">decode_dict[&#39;.&#39;] = &#39;.&#39;\n</code></pre><p>实现解码函数（输入映射字典和一个需要解密的数值，输出解密后的结果如15.6）：</p><pre><code class=\"python\">def decode(decode_dict, code):\n    _lst_uincode = []\n    for item in code.__repr__().split(&quot;\\\\u&quot;):\n        _lst_uincode.append(&quot;uni&quot; + item[:4].upper())\n        if item[4:]:\n            _lst_uincode.append(item[4:])\n    _lst_uincode = _lst_uincode[1:-1]\n    result = &quot;&quot;.join([str(decode_dict[i]) for i in _lst_uincode])\n    return result\n</code></pre><p>==================================================</p><p><a href=\"https://github.com/SoftwareSAD/Spider/blob/master/rowpiece/rowpiece/spiders/RowpieceSpider.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">具体代码链接</a></p>"},{"title":"系统分析与设计作业FinalReport","toc":true,"date":"2018-06-30T11:27:39.000Z","_content":"\n## 简短的课程学习自我总结（400字以内）\n\n<!-- more -->\n\n> 请不用讲述与分析、设计、开发、管理无关的话题\n>\n> 可以包括对同学帮助的致谢（同学姓名请用 github 昵称表示，不许出现真实姓名）\n>\n> 0 ~ 400字，即没有这段也没关系\n\n感谢所有队友（[Eileen101    ](https://github.com/orgs/SoftwareSAD/people/Eileen101)、[hanxu1997    ](https://github.com/orgs/SoftwareSAD/people/hanxu1997)、[heygrandpa    ](https://github.com/orgs/SoftwareSAD/people/heygrandpa)、[Lisa-bao    ](https://github.com/orgs/SoftwareSAD/people/Lisa-bao)、[samayuki    ](https://github.com/orgs/SoftwareSAD/people/samayuki)、[Mars_i    ](https://github.com/orgs/SoftwareSAD/people/SusieChang)）在这次作业中所做的所有贡献。\n\n跟着这次课程和队友们一起感受了开发一个项目大概的过程：需求分析、Product Backing、UI设计、迭代等等。同时参与到项目开发中更加了解了前端后端 的联系、熟悉了爬虫技术等。\n\n## PSP 2.1 统计表\n\n| PSP2.1                                | Time(%) |\n| ------------------------------------- | ------- |\n| **Planning**                          | **5**   |\n| Estimate                              | 5       |\n| **Development**                       | **85**  |\n| Analysis                              | 20      |\n| Design Spec                           | 5       |\n| Design Review                         | 5       |\n| Coding Standard                       | 3       |\n| Design                                | 8       |\n| Coding                                | 20      |\n| Code Review                           | 4       |\n| Test                                  | 20      |\n| **Reporting**                         | **10**  |\n| Test Report                           | 3       |\n| Size Measurement                      | 3       |\n| Postmortem & Process Improvement Plan | 4       |\n\n\n\n## 个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图\n\n![](/images/analysis_final_1.PNG)\n\n![](/images/analysis_final_2.PNG)\n\n![](/images/analysis_final_3.PNG)\n\n![](/images/analysis_final_4.PNG)\n\n![](/images/analysis_final_5.PNG)\n\n## 自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）\n\n解决动态字体反爬虫\n\n说明：猫眼电影网站的评分票房和票价为了反爬虫使用动态字体，利用字体形状不变进行解密。\n\n## 个人的技术类、项目管理类博客清单（只需要名称与 url ）\n\n[猫眼电影加密数字破解（爬取评分票房票价）](https://blog.zmj97.top/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%A0%B4%E8%A7%A3%EF%BC%88%E7%88%AC%E5%8F%96%E8%AF%84%E5%88%86%E7%A5%A8%E6%88%BF%E7%A5%A8%E4%BB%B7%EF%BC%89.html)","source":"_posts/系统分析与设计作业FinalReport.md","raw":"---\ntitle: 系统分析与设计作业FinalReport\ntoc: true\ndate: 2018-06-30 19:27:39\ncategories:\n- 系统分析与设计\ntags:\n---\n\n## 简短的课程学习自我总结（400字以内）\n\n<!-- more -->\n\n> 请不用讲述与分析、设计、开发、管理无关的话题\n>\n> 可以包括对同学帮助的致谢（同学姓名请用 github 昵称表示，不许出现真实姓名）\n>\n> 0 ~ 400字，即没有这段也没关系\n\n感谢所有队友（[Eileen101    ](https://github.com/orgs/SoftwareSAD/people/Eileen101)、[hanxu1997    ](https://github.com/orgs/SoftwareSAD/people/hanxu1997)、[heygrandpa    ](https://github.com/orgs/SoftwareSAD/people/heygrandpa)、[Lisa-bao    ](https://github.com/orgs/SoftwareSAD/people/Lisa-bao)、[samayuki    ](https://github.com/orgs/SoftwareSAD/people/samayuki)、[Mars_i    ](https://github.com/orgs/SoftwareSAD/people/SusieChang)）在这次作业中所做的所有贡献。\n\n跟着这次课程和队友们一起感受了开发一个项目大概的过程：需求分析、Product Backing、UI设计、迭代等等。同时参与到项目开发中更加了解了前端后端 的联系、熟悉了爬虫技术等。\n\n## PSP 2.1 统计表\n\n| PSP2.1                                | Time(%) |\n| ------------------------------------- | ------- |\n| **Planning**                          | **5**   |\n| Estimate                              | 5       |\n| **Development**                       | **85**  |\n| Analysis                              | 20      |\n| Design Spec                           | 5       |\n| Design Review                         | 5       |\n| Coding Standard                       | 3       |\n| Design                                | 8       |\n| Coding                                | 20      |\n| Code Review                           | 4       |\n| Test                                  | 20      |\n| **Reporting**                         | **10**  |\n| Test Report                           | 3       |\n| Size Measurement                      | 3       |\n| Postmortem & Process Improvement Plan | 4       |\n\n\n\n## 个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图\n\n![](/images/analysis_final_1.PNG)\n\n![](/images/analysis_final_2.PNG)\n\n![](/images/analysis_final_3.PNG)\n\n![](/images/analysis_final_4.PNG)\n\n![](/images/analysis_final_5.PNG)\n\n## 自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）\n\n解决动态字体反爬虫\n\n说明：猫眼电影网站的评分票房和票价为了反爬虫使用动态字体，利用字体形状不变进行解密。\n\n## 个人的技术类、项目管理类博客清单（只需要名称与 url ）\n\n[猫眼电影加密数字破解（爬取评分票房票价）](https://blog.zmj97.top/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%A0%B4%E8%A7%A3%EF%BC%88%E7%88%AC%E5%8F%96%E8%AF%84%E5%88%86%E7%A5%A8%E6%88%BF%E7%A5%A8%E4%BB%B7%EF%BC%89.html)","slug":"系统分析与设计作业FinalReport","published":1,"updated":"2018-10-10T08:56:45.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xp004cfmagpv7c92rz","content":"<h2 id=\"简短的课程学习自我总结（400字以内）\"><a href=\"#简短的课程学习自我总结（400字以内）\" class=\"headerlink\" title=\"简短的课程学习自我总结（400字以内）\"></a>简短的课程学习自我总结（400字以内）</h2><a id=\"more\"></a><blockquote><p>请不用讲述与分析、设计、开发、管理无关的话题</p><p>可以包括对同学帮助的致谢（同学姓名请用 github 昵称表示，不许出现真实姓名）</p><p>0 ~ 400字，即没有这段也没关系</p></blockquote><p>感谢所有队友（<a href=\"https://github.com/orgs/SoftwareSAD/people/Eileen101\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Eileen101 </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/hanxu1997\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">hanxu1997 </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/heygrandpa\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">heygrandpa </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/Lisa-bao\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Lisa-bao </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/samayuki\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">samayuki </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/SusieChang\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Mars_i </a>）在这次作业中所做的所有贡献。</p><p>跟着这次课程和队友们一起感受了开发一个项目大概的过程：需求分析、Product Backing、UI设计、迭代等等。同时参与到项目开发中更加了解了前端后端 的联系、熟悉了爬虫技术等。</p><h2 id=\"PSP-2-1-统计表\"><a href=\"#PSP-2-1-统计表\" class=\"headerlink\" title=\"PSP 2.1 统计表\"></a>PSP 2.1 统计表</h2><table><thead><tr><th>PSP2.1</th><th>Time(%)</th></tr></thead><tbody><tr><td><strong>Planning</strong></td><td><strong>5</strong></td></tr><tr><td>Estimate</td><td>5</td></tr><tr><td><strong>Development</strong></td><td><strong>85</strong></td></tr><tr><td>Analysis</td><td>20</td></tr><tr><td>Design Spec</td><td>5</td></tr><tr><td>Design Review</td><td>5</td></tr><tr><td>Coding Standard</td><td>3</td></tr><tr><td>Design</td><td>8</td></tr><tr><td>Coding</td><td>20</td></tr><tr><td>Code Review</td><td>4</td></tr><tr><td>Test</td><td>20</td></tr><tr><td><strong>Reporting</strong></td><td><strong>10</strong></td></tr><tr><td>Test Report</td><td>3</td></tr><tr><td>Size Measurement</td><td>3</td></tr><tr><td>Postmortem &amp; Process Improvement Plan</td><td>4</td></tr></tbody></table><h2 id=\"个人分支的-GIT-统计报告（不需要解释原因）-仅需要提交截图\"><a href=\"#个人分支的-GIT-统计报告（不需要解释原因）-仅需要提交截图\" class=\"headerlink\" title=\"个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图\"></a>个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图</h2><p><img src=\"/images/analysis_final_1.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_2.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_3.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_4.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_5.PNG\" alt=\"\"></p><h2 id=\"自认为最得意-或有价值-或有苦劳的工作清单，含简短说明（一句话）\"><a href=\"#自认为最得意-或有价值-或有苦劳的工作清单，含简短说明（一句话）\" class=\"headerlink\" title=\"自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）\"></a>自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）</h2><p>解决动态字体反爬虫</p><p>说明：猫眼电影网站的评分票房和票价为了反爬虫使用动态字体，利用字体形状不变进行解密。</p><h2 id=\"个人的技术类、项目管理类博客清单（只需要名称与-url-）\"><a href=\"#个人的技术类、项目管理类博客清单（只需要名称与-url-）\" class=\"headerlink\" title=\"个人的技术类、项目管理类博客清单（只需要名称与 url ）\"></a>个人的技术类、项目管理类博客清单（只需要名称与 url ）</h2><p><a href=\"https://blog.zmj97.top/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%A0%B4%E8%A7%A3%EF%BC%88%E7%88%AC%E5%8F%96%E8%AF%84%E5%88%86%E7%A5%A8%E6%88%BF%E7%A5%A8%E4%BB%B7%EF%BC%89.html\" target=\"_blank\" rel=\"noopener\">猫眼电影加密数字破解（爬取评分票房票价）</a></p>","site":{"data":{}},"excerpt":"<h2 id=\"简短的课程学习自我总结（400字以内）\"><a href=\"#简短的课程学习自我总结（400字以内）\" class=\"headerlink\" title=\"简短的课程学习自我总结（400字以内）\"></a>简短的课程学习自我总结（400字以内）</h2>","more":"<blockquote><p>请不用讲述与分析、设计、开发、管理无关的话题</p><p>可以包括对同学帮助的致谢（同学姓名请用 github 昵称表示，不许出现真实姓名）</p><p>0 ~ 400字，即没有这段也没关系</p></blockquote><p>感谢所有队友（<a href=\"https://github.com/orgs/SoftwareSAD/people/Eileen101\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Eileen101 </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/hanxu1997\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">hanxu1997 </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/heygrandpa\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">heygrandpa </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/Lisa-bao\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Lisa-bao </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/samayuki\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">samayuki </a>、<a href=\"https://github.com/orgs/SoftwareSAD/people/SusieChang\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Mars_i </a>）在这次作业中所做的所有贡献。</p><p>跟着这次课程和队友们一起感受了开发一个项目大概的过程：需求分析、Product Backing、UI设计、迭代等等。同时参与到项目开发中更加了解了前端后端 的联系、熟悉了爬虫技术等。</p><h2 id=\"PSP-2-1-统计表\"><a href=\"#PSP-2-1-统计表\" class=\"headerlink\" title=\"PSP 2.1 统计表\"></a>PSP 2.1 统计表</h2><table><thead><tr><th>PSP2.1</th><th>Time(%)</th></tr></thead><tbody><tr><td><strong>Planning</strong></td><td><strong>5</strong></td></tr><tr><td>Estimate</td><td>5</td></tr><tr><td><strong>Development</strong></td><td><strong>85</strong></td></tr><tr><td>Analysis</td><td>20</td></tr><tr><td>Design Spec</td><td>5</td></tr><tr><td>Design Review</td><td>5</td></tr><tr><td>Coding Standard</td><td>3</td></tr><tr><td>Design</td><td>8</td></tr><tr><td>Coding</td><td>20</td></tr><tr><td>Code Review</td><td>4</td></tr><tr><td>Test</td><td>20</td></tr><tr><td><strong>Reporting</strong></td><td><strong>10</strong></td></tr><tr><td>Test Report</td><td>3</td></tr><tr><td>Size Measurement</td><td>3</td></tr><tr><td>Postmortem &amp; Process Improvement Plan</td><td>4</td></tr></tbody></table><h2 id=\"个人分支的-GIT-统计报告（不需要解释原因）-仅需要提交截图\"><a href=\"#个人分支的-GIT-统计报告（不需要解释原因）-仅需要提交截图\" class=\"headerlink\" title=\"个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图\"></a>个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图</h2><p><img src=\"/images/analysis_final_1.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_2.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_3.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_4.PNG\" alt=\"\"></p><p><img src=\"/images/analysis_final_5.PNG\" alt=\"\"></p><h2 id=\"自认为最得意-或有价值-或有苦劳的工作清单，含简短说明（一句话）\"><a href=\"#自认为最得意-或有价值-或有苦劳的工作清单，含简短说明（一句话）\" class=\"headerlink\" title=\"自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）\"></a>自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）</h2><p>解决动态字体反爬虫</p><p>说明：猫眼电影网站的评分票房和票价为了反爬虫使用动态字体，利用字体形状不变进行解密。</p><h2 id=\"个人的技术类、项目管理类博客清单（只需要名称与-url-）\"><a href=\"#个人的技术类、项目管理类博客清单（只需要名称与-url-）\" class=\"headerlink\" title=\"个人的技术类、项目管理类博客清单（只需要名称与 url ）\"></a>个人的技术类、项目管理类博客清单（只需要名称与 url ）</h2><p><a href=\"https://blog.zmj97.top/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%A0%B4%E8%A7%A3%EF%BC%88%E7%88%AC%E5%8F%96%E8%AF%84%E5%88%86%E7%A5%A8%E6%88%BF%E7%A5%A8%E4%BB%B7%EF%BC%89.html\" target=\"_blank\" rel=\"noopener\">猫眼电影加密数字破解（爬取评分票房票价）</a></p>"},{"title":"系统分析与设计作业七","toc":true,"date":"2018-04-29T12:14:31.000Z","_content":"\n# 领域建模\n\n## 阅读 Asg_RH 文档，按用例构建领域模型。\n\n<!-- more -->\n\n> 按 Task2 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸。\n>\n> 说明：请不要受 PCMEF 层次结构影响。你需要识别实体（E）和 中介实体（M，也称状态实体）\n>\n> - 在单页面应用（如 vue）中，E 一般与数据库构建有关， M 一般与 [store 模式](https://cn.vuejs.org/v2/guide/state-management.html) 有关\n> - 在 java web 应用中，E 一般与数据库构建有关， M 一般与 session 有关\n\n![](/images/lesson7.png)\n\n## 数据库建模(E-R 模型)\n\n>  \\- 按 Task 3 要求，给出系统的 E-R 模型（数据逻辑模型）\n>\n> \\- 建模工具 PowerDesigner（简称PD） 或开源工具 [OpenSystemArchitect](http://www.codebydesign.com/)\n>\n> \\- 不负责的链接 <http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html>\n>\n> \\- 导出 Mysql 物理数据库的脚本\n>\n> \\- 简单叙说 数据库逻辑模型 与 领域模型 的异同\n\n![](/images/lesson7_2.png)\n\n```sql\n-- +---------------------------------------------------------\n-- | MODEL       : \n-- | AUTHOR      : \n-- | GENERATED BY: Open System Architect\n-- +---------------------------------------------------------\n-- | WARNING     : Review before execution\n-- +---------------------------------------------------------\n\n-- +---------------------------------------------------------\n-- | CREATE\n-- +---------------------------------------------------------\nCREATE TABLE `CardHolder`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  phoneNumber CHAR NOT NULL\n);\n\nCREATE TABLE `CreditCard`\n(\n  type LONGTEXT NOT NULL,\n  number INTEGER NOT NULL,\n  securityCode INTEGER NOT NULL,\n  expireDate DATE NOT NULL,\n  holderDetail LONGTEXT NOT NULL,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Payment`\n(\n  price INTEGER NOT NULL,\n  isSuccessful BIT NOT NULL\n);\n\nCREATE TABLE `Customer`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  gender BIT NOT NULL,\n  email LONGTEXT NOT NULL\n);\n\nCREATE TABLE `ShoppingBasket`\n(\n  numberOfReservation INTEGER NOT NULL,\n  totalPrice INTEGER NOT NULL\n);\n\nCREATE TABLE `Reservation`\n(\n  orderDate DATE NOT NULL,\n  checkInDate DATE NOT NULL,\n  checkOutDate DATE NOT NULL,\n  details LONGTEXT,\n  roomCount INTEGER NOT NULL,\n  smokingPermission BIT NOT NULL,\n  specialRequirement LONGTEXT\n);\n\nCREATE TABLE `Room`\n(\n  number INTEGER NOT NULL,\n  type LONGTEXT NOT NULL,\n  price INTEGER NOT NULL,\n  date DATE NOT NULL,\n  numberOfAdults INTEGER,\n  numberOfChildren INTEGER,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Hotel`\n(\n  name LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  star_rating SMALLINT,\n  PRIMARY KEY (address)\n);\n\nCREATE TABLE `Destination`\n(\n  city LONGTEXT NOT NULL,\n  region LONGTEXT NOT NULL\n);\n\n\n\n```\n\n异：\n\n领域模型更注重整体，数据库逻辑模型更注重开发。\n\n同：\n\n都用于业务分析，抽象提取逻辑和实体来帮助分析业务。","source":"_posts/系统分析与设计作业七.md","raw":"---\ntitle: 系统分析与设计作业七\ntoc: true\ndate: 2018-04-29 20:14:31\ncategories:\n- 系统分析与设计\ntags:\n- UMLet\n- 用例图\n- 数据库建模\n---\n\n# 领域建模\n\n## 阅读 Asg_RH 文档，按用例构建领域模型。\n\n<!-- more -->\n\n> 按 Task2 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸。\n>\n> 说明：请不要受 PCMEF 层次结构影响。你需要识别实体（E）和 中介实体（M，也称状态实体）\n>\n> - 在单页面应用（如 vue）中，E 一般与数据库构建有关， M 一般与 [store 模式](https://cn.vuejs.org/v2/guide/state-management.html) 有关\n> - 在 java web 应用中，E 一般与数据库构建有关， M 一般与 session 有关\n\n![](/images/lesson7.png)\n\n## 数据库建模(E-R 模型)\n\n>  \\- 按 Task 3 要求，给出系统的 E-R 模型（数据逻辑模型）\n>\n> \\- 建模工具 PowerDesigner（简称PD） 或开源工具 [OpenSystemArchitect](http://www.codebydesign.com/)\n>\n> \\- 不负责的链接 <http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html>\n>\n> \\- 导出 Mysql 物理数据库的脚本\n>\n> \\- 简单叙说 数据库逻辑模型 与 领域模型 的异同\n\n![](/images/lesson7_2.png)\n\n```sql\n-- +---------------------------------------------------------\n-- | MODEL       : \n-- | AUTHOR      : \n-- | GENERATED BY: Open System Architect\n-- +---------------------------------------------------------\n-- | WARNING     : Review before execution\n-- +---------------------------------------------------------\n\n-- +---------------------------------------------------------\n-- | CREATE\n-- +---------------------------------------------------------\nCREATE TABLE `CardHolder`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  phoneNumber CHAR NOT NULL\n);\n\nCREATE TABLE `CreditCard`\n(\n  type LONGTEXT NOT NULL,\n  number INTEGER NOT NULL,\n  securityCode INTEGER NOT NULL,\n  expireDate DATE NOT NULL,\n  holderDetail LONGTEXT NOT NULL,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Payment`\n(\n  price INTEGER NOT NULL,\n  isSuccessful BIT NOT NULL\n);\n\nCREATE TABLE `Customer`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  gender BIT NOT NULL,\n  email LONGTEXT NOT NULL\n);\n\nCREATE TABLE `ShoppingBasket`\n(\n  numberOfReservation INTEGER NOT NULL,\n  totalPrice INTEGER NOT NULL\n);\n\nCREATE TABLE `Reservation`\n(\n  orderDate DATE NOT NULL,\n  checkInDate DATE NOT NULL,\n  checkOutDate DATE NOT NULL,\n  details LONGTEXT,\n  roomCount INTEGER NOT NULL,\n  smokingPermission BIT NOT NULL,\n  specialRequirement LONGTEXT\n);\n\nCREATE TABLE `Room`\n(\n  number INTEGER NOT NULL,\n  type LONGTEXT NOT NULL,\n  price INTEGER NOT NULL,\n  date DATE NOT NULL,\n  numberOfAdults INTEGER,\n  numberOfChildren INTEGER,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Hotel`\n(\n  name LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  star_rating SMALLINT,\n  PRIMARY KEY (address)\n);\n\nCREATE TABLE `Destination`\n(\n  city LONGTEXT NOT NULL,\n  region LONGTEXT NOT NULL\n);\n\n\n\n```\n\n异：\n\n领域模型更注重整体，数据库逻辑模型更注重开发。\n\n同：\n\n都用于业务分析，抽象提取逻辑和实体来帮助分析业务。","slug":"系统分析与设计作业七","published":1,"updated":"2018-10-10T08:45:38.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xq004ffmagxh71zicq","content":"<h1 id=\"领域建模\"><a href=\"#领域建模\" class=\"headerlink\" title=\"领域建模\"></a>领域建模</h1><h2 id=\"阅读-Asg-RH-文档，按用例构建领域模型。\"><a href=\"#阅读-Asg-RH-文档，按用例构建领域模型。\" class=\"headerlink\" title=\"阅读 Asg_RH 文档，按用例构建领域模型。\"></a>阅读 Asg_RH 文档，按用例构建领域模型。</h2><a id=\"more\"></a><blockquote><p>按 Task2 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸。</p><p>说明：请不要受 PCMEF 层次结构影响。你需要识别实体（E）和 中介实体（M，也称状态实体）</p><ul><li>在单页面应用（如 vue）中，E 一般与数据库构建有关， M 一般与 <a href=\"https://cn.vuejs.org/v2/guide/state-management.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">store 模式</a> 有关</li><li>在 java web 应用中，E 一般与数据库构建有关， M 一般与 session 有关</li></ul></blockquote><p><img src=\"/images/lesson7.png\" alt=\"\"></p><h2 id=\"数据库建模-E-R-模型\"><a href=\"#数据库建模-E-R-模型\" class=\"headerlink\" title=\"数据库建模(E-R 模型)\"></a>数据库建模(E-R 模型)</h2><blockquote><p>- 按 Task 3 要求，给出系统的 E-R 模型（数据逻辑模型）</p><p>- 建模工具 PowerDesigner（简称PD） 或开源工具 <a href=\"http://www.codebydesign.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">OpenSystemArchitect</a></p><p>- 不负责的链接 <a href=\"http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html</a></p><p>- 导出 Mysql 物理数据库的脚本</p><p>- 简单叙说 数据库逻辑模型 与 领域模型 的异同</p></blockquote><p><img src=\"/images/lesson7_2.png\" alt=\"\"></p><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- +---------------------------------------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">-- | MODEL       : </span>\n<span class=\"token comment\" spellcheck=\"true\">-- | AUTHOR      : </span>\n<span class=\"token comment\" spellcheck=\"true\">-- | GENERATED BY: Open System Architect</span>\n<span class=\"token comment\" spellcheck=\"true\">-- +---------------------------------------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">-- | WARNING     : Review before execution</span>\n<span class=\"token comment\" spellcheck=\"true\">-- +---------------------------------------------------------</span>\n\n<span class=\"token comment\" spellcheck=\"true\">-- +---------------------------------------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">-- | CREATE</span>\n<span class=\"token comment\" spellcheck=\"true\">-- +---------------------------------------------------------</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>CardHolder<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  firstName <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  lastName <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  address <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  phoneNumber CHAR <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>CreditCard<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">type</span> <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  number <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  securityCode <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  expireDate <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  holderDetail <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Payment<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  price <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  isSuccessful <span class=\"token keyword\">BIT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Customer<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  firstName <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  lastName <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  gender <span class=\"token keyword\">BIT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  email <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>ShoppingBasket<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  numberOfReservation <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  totalPrice <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Reservation<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  orderDate <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  checkInDate <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  checkOutDate <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  details <span class=\"token keyword\">LONGTEXT</span><span class=\"token punctuation\">,</span>\n  roomCount <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  smokingPermission <span class=\"token keyword\">BIT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  specialRequirement <span class=\"token keyword\">LONGTEXT</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Room<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  number <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">type</span> <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  price <span class=\"token keyword\">INTEGER</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">date</span> <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  numberOfAdults <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>\n  numberOfChildren <span class=\"token keyword\">INTEGER</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Hotel<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  name <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  address <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  star_rating <span class=\"token keyword\">SMALLINT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>Destination<span class=\"token punctuation\">`</span>\n<span class=\"token punctuation\">(</span>\n  city <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  region <span class=\"token keyword\">LONGTEXT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n\n</code></pre><p>异：</p><p>领域模型更注重整体，数据库逻辑模型更注重开发。</p><p>同：</p><p>都用于业务分析，抽象提取逻辑和实体来帮助分析业务。</p>","site":{"data":{}},"excerpt":"<h1 id=\"领域建模\"><a href=\"#领域建模\" class=\"headerlink\" title=\"领域建模\"></a>领域建模</h1><h2 id=\"阅读-Asg-RH-文档，按用例构建领域模型。\"><a href=\"#阅读-Asg-RH-文档，按用例构建领域模型。\" class=\"headerlink\" title=\"阅读 Asg_RH 文档，按用例构建领域模型。\"></a>阅读 Asg_RH 文档，按用例构建领域模型。</h2>","more":"<blockquote><p>按 Task2 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸。</p><p>说明：请不要受 PCMEF 层次结构影响。你需要识别实体（E）和 中介实体（M，也称状态实体）</p><ul><li>在单页面应用（如 vue）中，E 一般与数据库构建有关， M 一般与 <a href=\"https://cn.vuejs.org/v2/guide/state-management.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">store 模式</a> 有关</li><li>在 java web 应用中，E 一般与数据库构建有关， M 一般与 session 有关</li></ul></blockquote><p><img src=\"/images/lesson7.png\" alt=\"\"></p><h2 id=\"数据库建模-E-R-模型\"><a href=\"#数据库建模-E-R-模型\" class=\"headerlink\" title=\"数据库建模(E-R 模型)\"></a>数据库建模(E-R 模型)</h2><blockquote><p>- 按 Task 3 要求，给出系统的 E-R 模型（数据逻辑模型）</p><p>- 建模工具 PowerDesigner（简称PD） 或开源工具 <a href=\"http://www.codebydesign.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">OpenSystemArchitect</a></p><p>- 不负责的链接 <a href=\"http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html</a></p><p>- 导出 Mysql 物理数据库的脚本</p><p>- 简单叙说 数据库逻辑模型 与 领域模型 的异同</p></blockquote><p><img src=\"/images/lesson7_2.png\" alt=\"\"></p><pre><code class=\"sql\">-- +---------------------------------------------------------\n-- | MODEL       : \n-- | AUTHOR      : \n-- | GENERATED BY: Open System Architect\n-- +---------------------------------------------------------\n-- | WARNING     : Review before execution\n-- +---------------------------------------------------------\n\n-- +---------------------------------------------------------\n-- | CREATE\n-- +---------------------------------------------------------\nCREATE TABLE `CardHolder`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  phoneNumber CHAR NOT NULL\n);\n\nCREATE TABLE `CreditCard`\n(\n  type LONGTEXT NOT NULL,\n  number INTEGER NOT NULL,\n  securityCode INTEGER NOT NULL,\n  expireDate DATE NOT NULL,\n  holderDetail LONGTEXT NOT NULL,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Payment`\n(\n  price INTEGER NOT NULL,\n  isSuccessful BIT NOT NULL\n);\n\nCREATE TABLE `Customer`\n(\n  firstName LONGTEXT NOT NULL,\n  lastName LONGTEXT NOT NULL,\n  gender BIT NOT NULL,\n  email LONGTEXT NOT NULL\n);\n\nCREATE TABLE `ShoppingBasket`\n(\n  numberOfReservation INTEGER NOT NULL,\n  totalPrice INTEGER NOT NULL\n);\n\nCREATE TABLE `Reservation`\n(\n  orderDate DATE NOT NULL,\n  checkInDate DATE NOT NULL,\n  checkOutDate DATE NOT NULL,\n  details LONGTEXT,\n  roomCount INTEGER NOT NULL,\n  smokingPermission BIT NOT NULL,\n  specialRequirement LONGTEXT\n);\n\nCREATE TABLE `Room`\n(\n  number INTEGER NOT NULL,\n  type LONGTEXT NOT NULL,\n  price INTEGER NOT NULL,\n  date DATE NOT NULL,\n  numberOfAdults INTEGER,\n  numberOfChildren INTEGER,\n  PRIMARY KEY (number)\n);\n\nCREATE TABLE `Hotel`\n(\n  name LONGTEXT NOT NULL,\n  address LONGTEXT NOT NULL,\n  star_rating SMALLINT,\n  PRIMARY KEY (address)\n);\n\nCREATE TABLE `Destination`\n(\n  city LONGTEXT NOT NULL,\n  region LONGTEXT NOT NULL\n);\n\n\n\n</code></pre><p>异：</p><p>领域模型更注重整体，数据库逻辑模型更注重开发。</p><p>同：</p><p>都用于业务分析，抽象提取逻辑和实体来帮助分析业务。</p>"},{"title":"系统分析与设计作业九","toc":true,"date":"2018-05-13T11:12:54.000Z","_content":"\n[业务描述链接](https://github.com/Chun-Ge/modelling-practice/blob/master/problem/ofo-app-hire-business-description.md)\n\n<!-- more -->\n\n### 用例图\n\n![](/images/lesson9_1.png)\n\n### 活动图\n\n![](/images/lesson9_2.png)\n\n### 领域模型\n\n![](/images/lesson9_3.png)\n\n### 状态图\n\n![](/images/lesson9_4.png)\n\n### 系统顺序图\n\n![](/images/lesson9_5.png)","source":"_posts/系统分析与设计作业九.md","raw":"---\ntitle: 系统分析与设计作业九\ntoc: true\ndate: 2018-05-13 19:12:54\ncategories:\n- 系统分析与设计\ntags:\n- UMLet\n- 建模\n---\n\n[业务描述链接](https://github.com/Chun-Ge/modelling-practice/blob/master/problem/ofo-app-hire-business-description.md)\n\n<!-- more -->\n\n### 用例图\n\n![](/images/lesson9_1.png)\n\n### 活动图\n\n![](/images/lesson9_2.png)\n\n### 领域模型\n\n![](/images/lesson9_3.png)\n\n### 状态图\n\n![](/images/lesson9_4.png)\n\n### 系统顺序图\n\n![](/images/lesson9_5.png)","slug":"系统分析与设计作业九","published":1,"updated":"2018-10-10T08:45:32.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xr004jfmagtj8mz4wt","content":"<p><a href=\"https://github.com/Chun-Ge/modelling-practice/blob/master/problem/ofo-app-hire-business-description.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">业务描述链接</a></p><a id=\"more\"></a><h3 id=\"用例图\"><a href=\"#用例图\" class=\"headerlink\" title=\"用例图\"></a>用例图</h3><p><img src=\"/images/lesson9_1.png\" alt=\"\"></p><h3 id=\"活动图\"><a href=\"#活动图\" class=\"headerlink\" title=\"活动图\"></a>活动图</h3><p><img src=\"/images/lesson9_2.png\" alt=\"\"></p><h3 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h3><p><img src=\"/images/lesson9_3.png\" alt=\"\"></p><h3 id=\"状态图\"><a href=\"#状态图\" class=\"headerlink\" title=\"状态图\"></a>状态图</h3><p><img src=\"/images/lesson9_4.png\" alt=\"\"></p><h3 id=\"系统顺序图\"><a href=\"#系统顺序图\" class=\"headerlink\" title=\"系统顺序图\"></a>系统顺序图</h3><p><img src=\"/images/lesson9_5.png\" alt=\"\"></p>","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/Chun-Ge/modelling-practice/blob/master/problem/ofo-app-hire-business-description.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">业务描述链接</a></p>","more":"<h3 id=\"用例图\"><a href=\"#用例图\" class=\"headerlink\" title=\"用例图\"></a>用例图</h3><p><img src=\"/images/lesson9_1.png\" alt=\"\"></p><h3 id=\"活动图\"><a href=\"#活动图\" class=\"headerlink\" title=\"活动图\"></a>活动图</h3><p><img src=\"/images/lesson9_2.png\" alt=\"\"></p><h3 id=\"领域模型\"><a href=\"#领域模型\" class=\"headerlink\" title=\"领域模型\"></a>领域模型</h3><p><img src=\"/images/lesson9_3.png\" alt=\"\"></p><h3 id=\"状态图\"><a href=\"#状态图\" class=\"headerlink\" title=\"状态图\"></a>状态图</h3><p><img src=\"/images/lesson9_4.png\" alt=\"\"></p><h3 id=\"系统顺序图\"><a href=\"#系统顺序图\" class=\"headerlink\" title=\"系统顺序图\"></a>系统顺序图</h3><p><img src=\"/images/lesson9_5.png\" alt=\"\"></p>"},{"title":"系统分析与设计作业五","date":"2018-04-15T14:52:13.000Z","toc":true,"_content":"\n# 配置mongoDB\n\n参考教程：https://www.yiibai.com/mongodb/mongodb_environment.html\n\n下载需要科学上网。\n\n<!-- more -->\n\n另外：\n\n将F:\\mongodb\\bin\\添加到环境变量中。\n\n每次开启前用这个命令修改db缓存路径：\n\n> mongod -dbpath f:\\mongodb\\data\n\n然后再打开另一个cmd窗口输入mongod即可。\n\n# 了解Python+Flask后端服务实现（win10）\n\n参考资料：http://www.jb51.net/article/60738.htm\n\n## 环境配置\n\n安装pymongo、flask、Pillow：\n\n> easy_install pymongo\n>\n> easy_install flask\n>\n> easy_install Pillow\n\n## IDE\n\n使用[PyCharm](https://www.jetbrains.com/pycharm/)\n\n打开PyCharm->新建项目->选择Flask框架->修改路径->创建\n\n得到了一个最简单的hello world的项目：\n\n![first pro](/images/Untitled.png)\n\n## Flask 快速入门\n\n[参考链接](http://www.pythondoc.com/flask/quickstart.html#debug-mode)\n\n运行刚刚创建的hello world程序：\n\n![run](/images/Capture.PNG)\n\n在浏览器输入网址http://127.0.0.1:5000/：\n\n![web](/images/Capture1.PNG)\n\n### 调试模式\n\n在代码修改的时候服务器能够自动加载，\n并且如果发生错误，它会提供一个有用的调试器。\n\n使用\n\n```python\napp.debug = True\napp.run()\n```\n\n或者\n\n```python\napp.run(debug=True)\n```\n\n开启调试模式。\n\n### 路由\n\n[`route()`](http://www.pythondoc.com/flask/api.html#flask.Flask.route) 装饰器用于把一个函数绑定到一个 URL 上。\n\n#### 静态绑定\n\n```python\n@app.route('/')\ndef index():\n    return 'Index Page'\n\n@app.route('/hello')\ndef hello():\n    return 'Hello World'\n```\n\n#### 动态绑定\n\n把一些特定的字段标记成 `<variable_name>`来进行动态绑定，还可以用 `<converter:variable_name>`限制格式：\n\n```python\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return 'User %s' % username\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return 'Post %d' % post_id\n```\n\n有如下三种转换器：\n\n| int       | 接受整数                        |\n| --------- | ------------------------------- |\n| **float** | **同 int 一样，但是接受浮点数** |\n| **path**  | **和默认的相似，但也接受斜线**  |\n\n### HTTP方法\n\n默认情况下，路由只会响应 GET 请求，但是能够通过给 [`route()`](http://www.pythondoc.com/flask/api.html#flask.Flask.route) 装饰器提供 methods 参数来改变：\n\n```python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        do_the_login()\n    else:\n        show_the_login_form()\n```\n\n#### 常见HTTP方法\n\n- GET\n\n  浏览器通知服务器只 *获取* 页面上的信息并且发送回来。这可能是最常用的方法。\n\n- HEAD\n\n  浏览器告诉服务器获取信息，但是只对 *头信息* 感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。\n\n- POST\n\n  浏览器通知服务器它要在 URL 上 *提交* 一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。\n\n- PUT\n\n  同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 POST 是不可能实现的，因为它只会被触发一次。\n\n- DELETE\n\n  移除给定位置的信息。\n\n- OPTIONS\n\n  给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。\n\n### 构建url\n\n可以使用函数[`url_for()`](http://www.pythondoc.com/flask/api.html#flask.url_for) 来针对一个特定的函数构建一个 URL。\n\n它能够接受函数名作为第一参数，以及一些关键字参数，\n每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数：\n\n```python\n>>> from flask import Flask, url_for\n>>> app = Flask(__name__)\n>>> @app.route('/')\n... def index(): pass\n...\n>>> @app.route('/login')\n... def login(): pass\n...\n>>> @app.route('/user/<username>')\n... def profile(username): pass\n...\n>>> with app.test_request_context():\n...  print url_for('index')\n...  print url_for('login')\n...  print url_for('login', next='/')\n...  print url_for('profile', username='John Doe')\n...\n/\n/login\n/login?next=/\n/user/John%20Doe\n```\n\n### 渲染静态文件\n\n只要在你的包中或模块旁边创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。\n\n给静态文件生成 URL：\n\n```python\nurl_for('static', filename='style.css')\n```\n\n这个文件应该存储在 `static/style.css`，而使用PyCharm创建Flask项目时已经为你创建好了static目录：\n\n![目录](/images/Capture2.PNG)\n\n### 渲染模板\n\n由于必须自行做好 HTML 转义以保持应用程序的安全，Flask 自动配置好了 [Jinja2](http://jinja.pocoo.org/2/) 模版。\n\n可以使用方法 [`render_template()`](http://www.pythondoc.com/flask/api.html#flask.render_template) 来渲染模版：\n\n```python\nfrom flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n```\n\nFlask 将会在 templates 文件夹中寻找模版。\n\n# [后续链接]()\n\n","source":"_posts/系统分析与设计作业五.md","raw":"---\ntitle: 系统分析与设计作业五\ndate: 2018-04-15 22:52:13\ncategories: \n- 系统分析与设计\ntags:\n- mongoDB\n- Flask\ntoc: true\n---\n\n# 配置mongoDB\n\n参考教程：https://www.yiibai.com/mongodb/mongodb_environment.html\n\n下载需要科学上网。\n\n<!-- more -->\n\n另外：\n\n将F:\\mongodb\\bin\\添加到环境变量中。\n\n每次开启前用这个命令修改db缓存路径：\n\n> mongod -dbpath f:\\mongodb\\data\n\n然后再打开另一个cmd窗口输入mongod即可。\n\n# 了解Python+Flask后端服务实现（win10）\n\n参考资料：http://www.jb51.net/article/60738.htm\n\n## 环境配置\n\n安装pymongo、flask、Pillow：\n\n> easy_install pymongo\n>\n> easy_install flask\n>\n> easy_install Pillow\n\n## IDE\n\n使用[PyCharm](https://www.jetbrains.com/pycharm/)\n\n打开PyCharm->新建项目->选择Flask框架->修改路径->创建\n\n得到了一个最简单的hello world的项目：\n\n![first pro](/images/Untitled.png)\n\n## Flask 快速入门\n\n[参考链接](http://www.pythondoc.com/flask/quickstart.html#debug-mode)\n\n运行刚刚创建的hello world程序：\n\n![run](/images/Capture.PNG)\n\n在浏览器输入网址http://127.0.0.1:5000/：\n\n![web](/images/Capture1.PNG)\n\n### 调试模式\n\n在代码修改的时候服务器能够自动加载，\n并且如果发生错误，它会提供一个有用的调试器。\n\n使用\n\n```python\napp.debug = True\napp.run()\n```\n\n或者\n\n```python\napp.run(debug=True)\n```\n\n开启调试模式。\n\n### 路由\n\n[`route()`](http://www.pythondoc.com/flask/api.html#flask.Flask.route) 装饰器用于把一个函数绑定到一个 URL 上。\n\n#### 静态绑定\n\n```python\n@app.route('/')\ndef index():\n    return 'Index Page'\n\n@app.route('/hello')\ndef hello():\n    return 'Hello World'\n```\n\n#### 动态绑定\n\n把一些特定的字段标记成 `<variable_name>`来进行动态绑定，还可以用 `<converter:variable_name>`限制格式：\n\n```python\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return 'User %s' % username\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return 'Post %d' % post_id\n```\n\n有如下三种转换器：\n\n| int       | 接受整数                        |\n| --------- | ------------------------------- |\n| **float** | **同 int 一样，但是接受浮点数** |\n| **path**  | **和默认的相似，但也接受斜线**  |\n\n### HTTP方法\n\n默认情况下，路由只会响应 GET 请求，但是能够通过给 [`route()`](http://www.pythondoc.com/flask/api.html#flask.Flask.route) 装饰器提供 methods 参数来改变：\n\n```python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        do_the_login()\n    else:\n        show_the_login_form()\n```\n\n#### 常见HTTP方法\n\n- GET\n\n  浏览器通知服务器只 *获取* 页面上的信息并且发送回来。这可能是最常用的方法。\n\n- HEAD\n\n  浏览器告诉服务器获取信息，但是只对 *头信息* 感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。\n\n- POST\n\n  浏览器通知服务器它要在 URL 上 *提交* 一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。\n\n- PUT\n\n  同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 POST 是不可能实现的，因为它只会被触发一次。\n\n- DELETE\n\n  移除给定位置的信息。\n\n- OPTIONS\n\n  给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。\n\n### 构建url\n\n可以使用函数[`url_for()`](http://www.pythondoc.com/flask/api.html#flask.url_for) 来针对一个特定的函数构建一个 URL。\n\n它能够接受函数名作为第一参数，以及一些关键字参数，\n每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数：\n\n```python\n>>> from flask import Flask, url_for\n>>> app = Flask(__name__)\n>>> @app.route('/')\n... def index(): pass\n...\n>>> @app.route('/login')\n... def login(): pass\n...\n>>> @app.route('/user/<username>')\n... def profile(username): pass\n...\n>>> with app.test_request_context():\n...  print url_for('index')\n...  print url_for('login')\n...  print url_for('login', next='/')\n...  print url_for('profile', username='John Doe')\n...\n/\n/login\n/login?next=/\n/user/John%20Doe\n```\n\n### 渲染静态文件\n\n只要在你的包中或模块旁边创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。\n\n给静态文件生成 URL：\n\n```python\nurl_for('static', filename='style.css')\n```\n\n这个文件应该存储在 `static/style.css`，而使用PyCharm创建Flask项目时已经为你创建好了static目录：\n\n![目录](/images/Capture2.PNG)\n\n### 渲染模板\n\n由于必须自行做好 HTML 转义以保持应用程序的安全，Flask 自动配置好了 [Jinja2](http://jinja.pocoo.org/2/) 模版。\n\n可以使用方法 [`render_template()`](http://www.pythondoc.com/flask/api.html#flask.render_template) 来渲染模版：\n\n```python\nfrom flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n```\n\nFlask 将会在 templates 文件夹中寻找模版。\n\n# [后续链接]()\n\n","slug":"系统分析与设计作业五","published":1,"updated":"2018-10-10T08:45:25.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xt004nfmag0k4ndflc","content":"<h1 id=\"配置mongoDB\"><a href=\"#配置mongoDB\" class=\"headerlink\" title=\"配置mongoDB\"></a>配置mongoDB</h1><p>参考教程：<a href=\"https://www.yiibai.com/mongodb/mongodb_environment.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.yiibai.com/mongodb/mongodb_environment.html</a></p><p>下载需要科学上网。</p><a id=\"more\"></a><p>另外：</p><p>将F:\\mongodb\\bin\\添加到环境变量中。</p><p>每次开启前用这个命令修改db缓存路径：</p><blockquote><p>mongod -dbpath f:\\mongodb\\data</p></blockquote><p>然后再打开另一个cmd窗口输入mongod即可。</p><h1 id=\"了解Python-Flask后端服务实现（win10）\"><a href=\"#了解Python-Flask后端服务实现（win10）\" class=\"headerlink\" title=\"了解Python+Flask后端服务实现（win10）\"></a>了解Python+Flask后端服务实现（win10）</h1><p>参考资料：<a href=\"http://www.jb51.net/article/60738.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.jb51.net/article/60738.htm</a></p><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>安装pymongo、flask、Pillow：</p><blockquote><p>easy_install pymongo</p><p>easy_install flask</p><p>easy_install Pillow</p></blockquote><h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h2><p>使用<a href=\"https://www.jetbrains.com/pycharm/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">PyCharm</a></p><p>打开PyCharm-&gt;新建项目-&gt;选择Flask框架-&gt;修改路径-&gt;创建</p><p>得到了一个最简单的hello world的项目：</p><p><img src=\"/images/Untitled.png\" alt=\"first pro\"></p><h2 id=\"Flask-快速入门\"><a href=\"#Flask-快速入门\" class=\"headerlink\" title=\"Flask 快速入门\"></a>Flask 快速入门</h2><p><a href=\"http://www.pythondoc.com/flask/quickstart.html#debug-mode\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>运行刚刚创建的hello world程序：</p><p><img src=\"/images/Capture.PNG\" alt=\"run\"></p><p>在浏览器输入网址<a href=\"http://127.0.0.1:5000/：\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://127.0.0.1:5000/：</a></p><p><img src=\"/images/Capture1.PNG\" alt=\"web\"></p><h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><p>在代码修改的时候服务器能够自动加载，<br>并且如果发生错误，它会提供一个有用的调试器。</p><p>使用</p><pre class=\" language-python\"><code class=\"language-python\">app<span class=\"token punctuation\">.</span>debug <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\napp<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre><p>或者</p><pre class=\" language-python\"><code class=\"language-python\">app<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>debug<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n</code></pre><p>开启调试模式。</p><h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p><a href=\"http://www.pythondoc.com/flask/api.html#flask.Flask.route\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>route()</code></a> 装饰器用于把一个函数绑定到一个 URL 上。</p><h4 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h4><pre class=\" language-python\"><code class=\"language-python\">@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">index</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Index Page'</span>\n\n@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/hello'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello World'</span>\n</code></pre><h4 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h4><p>把一些特定的字段标记成 <code>&lt;variable_name&gt;</code>来进行动态绑定，还可以用 <code>&lt;converter:variable_name&gt;</code>限制格式：</p><pre class=\" language-python\"><code class=\"language-python\">@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/user/&lt;username>'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">show_user_profile</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># show the user profile for that user</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'User %s'</span> <span class=\"token operator\">%</span> username\n\n@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/post/&lt;int:post_id>'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">show_post</span><span class=\"token punctuation\">(</span>post_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># show the post with the given id, the id is an integer</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Post %d'</span> <span class=\"token operator\">%</span> post_id\n</code></pre><p>有如下三种转换器：</p><table><thead><tr><th>int</th><th>接受整数</th></tr></thead><tbody><tr><td><strong>float</strong></td><td><strong>同 int 一样，但是接受浮点数</strong></td></tr><tr><td><strong>path</strong></td><td><strong>和默认的相似，但也接受斜线</strong></td></tr></tbody></table><h3 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h3><p>默认情况下，路由只会响应 GET 请求，但是能够通过给 <a href=\"http://www.pythondoc.com/flask/api.html#flask.Flask.route\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>route()</code></a> 装饰器提供 methods 参数来改变：</p><pre class=\" language-python\"><code class=\"language-python\">@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/login'</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token punctuation\">:</span>\n        do_the_login<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        show_the_login_form<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre><h4 id=\"常见HTTP方法\"><a href=\"#常见HTTP方法\" class=\"headerlink\" title=\"常见HTTP方法\"></a>常见HTTP方法</h4><ul><li><p>GET</p><p>浏览器通知服务器只 <em>获取</em> 页面上的信息并且发送回来。这可能是最常用的方法。</p></li><li><p>HEAD</p><p>浏览器告诉服务器获取信息，但是只对 <em>头信息</em> 感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。</p></li><li><p>POST</p><p>浏览器通知服务器它要在 URL 上 <em>提交</em> 一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。</p></li><li><p>PUT</p><p>同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 POST 是不可能实现的，因为它只会被触发一次。</p></li><li><p>DELETE</p><p>移除给定位置的信息。</p></li><li><p>OPTIONS</p><p>给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。</p></li></ul><h3 id=\"构建url\"><a href=\"#构建url\" class=\"headerlink\" title=\"构建url\"></a>构建url</h3><p>可以使用函数<a href=\"http://www.pythondoc.com/flask/api.html#flask.url_for\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>url_for()</code></a> 来针对一个特定的函数构建一个 URL。</p><p>它能够接受函数名作为第一参数，以及一些关键字参数，<br>每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> Flask<span class=\"token punctuation\">,</span> url_for\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> app <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> @app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">def</span> <span class=\"token function\">index</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">pass</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> @app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/login'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">def</span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">pass</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> @app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/user/&lt;username>'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">def</span> <span class=\"token function\">profile</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">pass</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">with</span> app<span class=\"token punctuation\">.</span>test_request_context<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token keyword\">print</span> url_for<span class=\"token punctuation\">(</span><span class=\"token string\">'index'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token keyword\">print</span> url_for<span class=\"token punctuation\">(</span><span class=\"token string\">'login'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token keyword\">print</span> url_for<span class=\"token punctuation\">(</span><span class=\"token string\">'login'</span><span class=\"token punctuation\">,</span> next<span class=\"token operator\">=</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token keyword\">print</span> url_for<span class=\"token punctuation\">(</span><span class=\"token string\">'profile'</span><span class=\"token punctuation\">,</span> username<span class=\"token operator\">=</span><span class=\"token string\">'John Doe'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token operator\">/</span>\n<span class=\"token operator\">/</span>login\n<span class=\"token operator\">/</span>login?next<span class=\"token operator\">=</span><span class=\"token operator\">/</span>\n<span class=\"token operator\">/</span>user<span class=\"token operator\">/</span>John<span class=\"token operator\">%</span>20Doe\n</code></pre><h3 id=\"渲染静态文件\"><a href=\"#渲染静态文件\" class=\"headerlink\" title=\"渲染静态文件\"></a>渲染静态文件</h3><p>只要在你的包中或模块旁边创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。</p><p>给静态文件生成 URL：</p><pre class=\" language-python\"><code class=\"language-python\">url_for<span class=\"token punctuation\">(</span><span class=\"token string\">'static'</span><span class=\"token punctuation\">,</span> filename<span class=\"token operator\">=</span><span class=\"token string\">'style.css'</span><span class=\"token punctuation\">)</span>\n</code></pre><p>这个文件应该存储在 <code>static/style.css</code>，而使用PyCharm创建Flask项目时已经为你创建好了static目录：</p><p><img src=\"/images/Capture2.PNG\" alt=\"目录\"></p><h3 id=\"渲染模板\"><a href=\"#渲染模板\" class=\"headerlink\" title=\"渲染模板\"></a>渲染模板</h3><p>由于必须自行做好 HTML 转义以保持应用程序的安全，Flask 自动配置好了 <a href=\"http://jinja.pocoo.org/2/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Jinja2</a> 模版。</p><p>可以使用方法 <a href=\"http://www.pythondoc.com/flask/api.html#flask.render_template\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>render_template()</code></a> 来渲染模版：</p><pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> render_template\n\n@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/hello/'</span><span class=\"token punctuation\">)</span>\n@app<span class=\"token punctuation\">.</span>route<span class=\"token punctuation\">(</span><span class=\"token string\">'/hello/&lt;name>'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span>None<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> render_template<span class=\"token punctuation\">(</span><span class=\"token string\">'hello.html'</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">)</span>\n</code></pre><p>Flask 将会在 templates 文件夹中寻找模版。</p><h1 id=\"后续链接\"><a href=\"#后续链接\" class=\"headerlink\" title=\"后续链接\"></a><a href=\"\">后续链接</a></h1>","site":{"data":{}},"excerpt":"<h1 id=\"配置mongoDB\"><a href=\"#配置mongoDB\" class=\"headerlink\" title=\"配置mongoDB\"></a>配置mongoDB</h1><p>参考教程：<a href=\"https://www.yiibai.com/mongodb/mongodb_environment.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.yiibai.com/mongodb/mongodb_environment.html</a></p><p>下载需要科学上网。</p>","more":"<p>另外：</p><p>将F:\\mongodb\\bin\\添加到环境变量中。</p><p>每次开启前用这个命令修改db缓存路径：</p><blockquote><p>mongod -dbpath f:\\mongodb\\data</p></blockquote><p>然后再打开另一个cmd窗口输入mongod即可。</p><h1 id=\"了解Python-Flask后端服务实现（win10）\"><a href=\"#了解Python-Flask后端服务实现（win10）\" class=\"headerlink\" title=\"了解Python+Flask后端服务实现（win10）\"></a>了解Python+Flask后端服务实现（win10）</h1><p>参考资料：<a href=\"http://www.jb51.net/article/60738.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.jb51.net/article/60738.htm</a></p><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>安装pymongo、flask、Pillow：</p><blockquote><p>easy_install pymongo</p><p>easy_install flask</p><p>easy_install Pillow</p></blockquote><h2 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h2><p>使用<a href=\"https://www.jetbrains.com/pycharm/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">PyCharm</a></p><p>打开PyCharm-&gt;新建项目-&gt;选择Flask框架-&gt;修改路径-&gt;创建</p><p>得到了一个最简单的hello world的项目：</p><p><img src=\"/images/Untitled.png\" alt=\"first pro\"></p><h2 id=\"Flask-快速入门\"><a href=\"#Flask-快速入门\" class=\"headerlink\" title=\"Flask 快速入门\"></a>Flask 快速入门</h2><p><a href=\"http://www.pythondoc.com/flask/quickstart.html#debug-mode\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>运行刚刚创建的hello world程序：</p><p><img src=\"/images/Capture.PNG\" alt=\"run\"></p><p>在浏览器输入网址<a href=\"http://127.0.0.1:5000/：\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://127.0.0.1:5000/：</a></p><p><img src=\"/images/Capture1.PNG\" alt=\"web\"></p><h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><p>在代码修改的时候服务器能够自动加载，<br>并且如果发生错误，它会提供一个有用的调试器。</p><p>使用</p><pre><code class=\"python\">app.debug = True\napp.run()\n</code></pre><p>或者</p><pre><code class=\"python\">app.run(debug=True)\n</code></pre><p>开启调试模式。</p><h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p><a href=\"http://www.pythondoc.com/flask/api.html#flask.Flask.route\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>route()</code></a> 装饰器用于把一个函数绑定到一个 URL 上。</p><h4 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h4><pre><code class=\"python\">@app.route(&#39;/&#39;)\ndef index():\n    return &#39;Index Page&#39;\n\n@app.route(&#39;/hello&#39;)\ndef hello():\n    return &#39;Hello World&#39;\n</code></pre><h4 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h4><p>把一些特定的字段标记成 <code>&lt;variable_name&gt;</code>来进行动态绑定，还可以用 <code>&lt;converter:variable_name&gt;</code>限制格式：</p><pre><code class=\"python\">@app.route(&#39;/user/&lt;username&gt;&#39;)\ndef show_user_profile(username):\n    # show the user profile for that user\n    return &#39;User %s&#39; % username\n\n@app.route(&#39;/post/&lt;int:post_id&gt;&#39;)\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return &#39;Post %d&#39; % post_id\n</code></pre><p>有如下三种转换器：</p><table><thead><tr><th>int</th><th>接受整数</th></tr></thead><tbody><tr><td><strong>float</strong></td><td><strong>同 int 一样，但是接受浮点数</strong></td></tr><tr><td><strong>path</strong></td><td><strong>和默认的相似，但也接受斜线</strong></td></tr></tbody></table><h3 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h3><p>默认情况下，路由只会响应 GET 请求，但是能够通过给 <a href=\"http://www.pythondoc.com/flask/api.html#flask.Flask.route\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>route()</code></a> 装饰器提供 methods 参数来改变：</p><pre><code class=\"python\">@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    if request.method == &#39;POST&#39;:\n        do_the_login()\n    else:\n        show_the_login_form()\n</code></pre><h4 id=\"常见HTTP方法\"><a href=\"#常见HTTP方法\" class=\"headerlink\" title=\"常见HTTP方法\"></a>常见HTTP方法</h4><ul><li><p>GET</p><p>浏览器通知服务器只 <em>获取</em> 页面上的信息并且发送回来。这可能是最常用的方法。</p></li><li><p>HEAD</p><p>浏览器告诉服务器获取信息，但是只对 <em>头信息</em> 感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。</p></li><li><p>POST</p><p>浏览器通知服务器它要在 URL 上 <em>提交</em> 一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。</p></li><li><p>PUT</p><p>同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 POST 是不可能实现的，因为它只会被触发一次。</p></li><li><p>DELETE</p><p>移除给定位置的信息。</p></li><li><p>OPTIONS</p><p>给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。</p></li></ul><h3 id=\"构建url\"><a href=\"#构建url\" class=\"headerlink\" title=\"构建url\"></a>构建url</h3><p>可以使用函数<a href=\"http://www.pythondoc.com/flask/api.html#flask.url_for\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>url_for()</code></a> 来针对一个特定的函数构建一个 URL。</p><p>它能够接受函数名作为第一参数，以及一些关键字参数，<br>每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数：</p><pre><code class=\"python\">&gt;&gt;&gt; from flask import Flask, url_for\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt; @app.route(&#39;/&#39;)\n... def index(): pass\n...\n&gt;&gt;&gt; @app.route(&#39;/login&#39;)\n... def login(): pass\n...\n&gt;&gt;&gt; @app.route(&#39;/user/&lt;username&gt;&#39;)\n... def profile(username): pass\n...\n&gt;&gt;&gt; with app.test_request_context():\n...  print url_for(&#39;index&#39;)\n...  print url_for(&#39;login&#39;)\n...  print url_for(&#39;login&#39;, next=&#39;/&#39;)\n...  print url_for(&#39;profile&#39;, username=&#39;John Doe&#39;)\n...\n/\n/login\n/login?next=/\n/user/John%20Doe\n</code></pre><h3 id=\"渲染静态文件\"><a href=\"#渲染静态文件\" class=\"headerlink\" title=\"渲染静态文件\"></a>渲染静态文件</h3><p>只要在你的包中或模块旁边创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。</p><p>给静态文件生成 URL：</p><pre><code class=\"python\">url_for(&#39;static&#39;, filename=&#39;style.css&#39;)\n</code></pre><p>这个文件应该存储在 <code>static/style.css</code>，而使用PyCharm创建Flask项目时已经为你创建好了static目录：</p><p><img src=\"/images/Capture2.PNG\" alt=\"目录\"></p><h3 id=\"渲染模板\"><a href=\"#渲染模板\" class=\"headerlink\" title=\"渲染模板\"></a>渲染模板</h3><p>由于必须自行做好 HTML 转义以保持应用程序的安全，Flask 自动配置好了 <a href=\"http://jinja.pocoo.org/2/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Jinja2</a> 模版。</p><p>可以使用方法 <a href=\"http://www.pythondoc.com/flask/api.html#flask.render_template\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"><code>render_template()</code></a> 来渲染模版：</p><pre><code class=\"python\">from flask import render_template\n\n@app.route(&#39;/hello/&#39;)\n@app.route(&#39;/hello/&lt;name&gt;&#39;)\ndef hello(name=None):\n    return render_template(&#39;hello.html&#39;, name=name)\n</code></pre><p>Flask 将会在 templates 文件夹中寻找模版。</p><h1 id=\"后续链接\"><a href=\"#后续链接\" class=\"headerlink\" title=\"后续链接\"></a><a href=\"\">后续链接</a></h1>"},{"title":"系统分析与设计作业八","toc":true,"date":"2018-05-06T14:12:10.000Z","_content":"\n建模工具： UMLet 14.1.1 stand-alone\n\n<!-- more -->\n\n# 使用 UML State Model\n\n> - 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。\n> - 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。\n\n![](/images/lesson8.png)\n\n# 研究淘宝退货流程活动图，对退货业务对象状态建模\n\n![](/images/lesson8_2.png)","source":"_posts/系统分析与设计作业八.md","raw":"---\ntitle: 系统分析与设计作业八\ntoc: true\ndate: 2018-05-06 22:12:10\ncategories:\n- 系统分析与设计\ntags:\n- UMLet\n- 用例图\n- 建模\n---\n\n建模工具： UMLet 14.1.1 stand-alone\n\n<!-- more -->\n\n# 使用 UML State Model\n\n> - 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。\n> - 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。\n\n![](/images/lesson8.png)\n\n# 研究淘宝退货流程活动图，对退货业务对象状态建模\n\n![](/images/lesson8_2.png)","slug":"系统分析与设计作业八","published":1,"updated":"2018-10-10T08:45:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xu004pfmagwo8ijq6i","content":"<p>建模工具： UMLet 14.1.1 stand-alone</p><a id=\"more\"></a><h1 id=\"使用-UML-State-Model\"><a href=\"#使用-UML-State-Model\" class=\"headerlink\" title=\"使用 UML State Model\"></a>使用 UML State Model</h1><blockquote><ul><li>建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。</li><li>建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。</li></ul></blockquote><p><img src=\"/images/lesson8.png\" alt=\"\"></p><h1 id=\"研究淘宝退货流程活动图，对退货业务对象状态建模\"><a href=\"#研究淘宝退货流程活动图，对退货业务对象状态建模\" class=\"headerlink\" title=\"研究淘宝退货流程活动图，对退货业务对象状态建模\"></a>研究淘宝退货流程活动图，对退货业务对象状态建模</h1><p><img src=\"/images/lesson8_2.png\" alt=\"\"></p>","site":{"data":{}},"excerpt":"<p>建模工具： UMLet 14.1.1 stand-alone</p>","more":"<h1 id=\"使用-UML-State-Model\"><a href=\"#使用-UML-State-Model\" class=\"headerlink\" title=\"使用 UML State Model\"></a>使用 UML State Model</h1><blockquote><ul><li>建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。</li><li>建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。</li></ul></blockquote><p><img src=\"/images/lesson8.png\" alt=\"\"></p><h1 id=\"研究淘宝退货流程活动图，对退货业务对象状态建模\"><a href=\"#研究淘宝退货流程活动图，对退货业务对象状态建模\" class=\"headerlink\" title=\"研究淘宝退货流程活动图，对退货业务对象状态建模\"></a>研究淘宝退货流程活动图，对退货业务对象状态建模</h1><p><img src=\"/images/lesson8_2.png\" alt=\"\"></p>"},{"title":"系统分析与设计作业六","toc":true,"date":"2018-04-22T14:18:13.000Z","_content":"\n# 用例建模\n\n## 阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸\n\n<!-- more -->\n\n![](/images/lesson6.png)\n\n## 选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：\n\n> - 对比 Asg_RH 用例图，请用色彩标注出创新用例或子用例\n> - 尽可能识别外部系统，并用色彩标注新的外部系统和服务\n\n![](/images/lesson6b.png)\n\n## 对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\n\n- 在基础功能上进行延伸\n- 按照模块进行深入\n- 按照用户需求的变化\n- 按照技术的变化\n\n## 请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）\n\n| ID   | Name     | Imp  | Est  | How to demo                                          |\n| ---- | -------- | ---- | ---- | ---------------------------------------------------- |\n| 1    | 选择酒店 | 40   | 5    | 选择酒店所在城市、预定时间、酒店关键字               |\n| 2    | 预订酒店 | 45   | 6    | 选择酒店、选择房间类型、查看评价、选择时间、确认信息 |\n| 3    | 确认订单 | 25   | 3    | 查看信息                                             |\n| 4    | 支付订单 | 40   | 4    | 选择付款方式付款                                     |\n| 5    | 管理订单 | 30   | 5    | 查看订单信息、删除订单                               |\n\n# 业务建模\n\n## 在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\n\n![](/images/lesson6_3.png)\n\n## 选择你身边的银行 ATM，用活动图描绘取款业务流程\n\n![](/images/lesson6_3b.png)\n\n## 查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\n\n![](/images/lesson6_3c.png)\n\n# 用例文本编写\n\n> 在大作业基础上，分析三种用例文本的优点和缺点\n\n| 用例文本    | 优点               | 缺点               |\n| ----------- | ------------------ | ------------------ |\n| 详细用例    | 详细、深入         | 繁琐导致耗时长     |\n| casual 用例 | 较详细、编写较简便 | 细节不足，不够正式 |\n| brief用例   | 简介、编写简便     | 缺少细节           |","source":"_posts/系统分析与设计作业六.md","raw":"---\ntitle: 系统分析与设计作业六\ntoc: true\ndate: 2018-04-22 22:18:13\ncategories:\n- 系统分析与设计\ntags:\n- UMLet\n- 用例图\n- SCRUM\n---\n\n# 用例建模\n\n## 阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸\n\n<!-- more -->\n\n![](/images/lesson6.png)\n\n## 选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：\n\n> - 对比 Asg_RH 用例图，请用色彩标注出创新用例或子用例\n> - 尽可能识别外部系统，并用色彩标注新的外部系统和服务\n\n![](/images/lesson6b.png)\n\n## 对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\n\n- 在基础功能上进行延伸\n- 按照模块进行深入\n- 按照用户需求的变化\n- 按照技术的变化\n\n## 请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）\n\n| ID   | Name     | Imp  | Est  | How to demo                                          |\n| ---- | -------- | ---- | ---- | ---------------------------------------------------- |\n| 1    | 选择酒店 | 40   | 5    | 选择酒店所在城市、预定时间、酒店关键字               |\n| 2    | 预订酒店 | 45   | 6    | 选择酒店、选择房间类型、查看评价、选择时间、确认信息 |\n| 3    | 确认订单 | 25   | 3    | 查看信息                                             |\n| 4    | 支付订单 | 40   | 4    | 选择付款方式付款                                     |\n| 5    | 管理订单 | 30   | 5    | 查看订单信息、删除订单                               |\n\n# 业务建模\n\n## 在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\n\n![](/images/lesson6_3.png)\n\n## 选择你身边的银行 ATM，用活动图描绘取款业务流程\n\n![](/images/lesson6_3b.png)\n\n## 查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\n\n![](/images/lesson6_3c.png)\n\n# 用例文本编写\n\n> 在大作业基础上，分析三种用例文本的优点和缺点\n\n| 用例文本    | 优点               | 缺点               |\n| ----------- | ------------------ | ------------------ |\n| 详细用例    | 详细、深入         | 繁琐导致耗时长     |\n| casual 用例 | 较详细、编写较简便 | 细节不足，不够正式 |\n| brief用例   | 简介、编写简便     | 缺少细节           |","slug":"系统分析与设计作业六","published":1,"updated":"2018-10-10T08:45:04.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xx004sfmagsokuwmyf","content":"<h1 id=\"用例建模\"><a href=\"#用例建模\" class=\"headerlink\" title=\"用例建模\"></a>用例建模</h1><h2 id=\"阅读-Asg-RH-文档，绘制用例图。-按-Task1-要求，请使用工具-UMLet，截图格式务必是-png-并控制尺寸\"><a href=\"#阅读-Asg-RH-文档，绘制用例图。-按-Task1-要求，请使用工具-UMLet，截图格式务必是-png-并控制尺寸\" class=\"headerlink\" title=\"阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸\"></a>阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸</h2><a id=\"more\"></a><p><img src=\"/images/lesson6.png\" alt=\"\"></p><h2 id=\"选择你熟悉的定旅馆在线服务系统（或移动-APP），如绘制用例图。并满足以下要求：\"><a href=\"#选择你熟悉的定旅馆在线服务系统（或移动-APP），如绘制用例图。并满足以下要求：\" class=\"headerlink\" title=\"选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：\"></a>选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：</h2><blockquote><ul><li>对比 Asg_RH 用例图，请用色彩标注出创新用例或子用例</li><li>尽可能识别外部系统，并用色彩标注新的外部系统和服务</li></ul></blockquote><p><img src=\"/images/lesson6b.png\" alt=\"\"></p><h2 id=\"对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\"><a href=\"#对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\" class=\"headerlink\" title=\"对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\"></a>对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法</h2><ul><li>在基础功能上进行延伸</li><li>按照模块进行深入</li><li>按照用户需求的变化</li><li>按照技术的变化</li></ul><h2 id=\"请使用-SCRUM-方法，在（任务b）用例图基础上，编制某定旅馆开发的需求-（backlog）\"><a href=\"#请使用-SCRUM-方法，在（任务b）用例图基础上，编制某定旅馆开发的需求-（backlog）\" class=\"headerlink\" title=\"请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）\"></a>请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）</h2><table><thead><tr><th>ID</th><th>Name</th><th>Imp</th><th>Est</th><th>How to demo</th></tr></thead><tbody><tr><td>1</td><td>选择酒店</td><td>40</td><td>5</td><td>选择酒店所在城市、预定时间、酒店关键字</td></tr><tr><td>2</td><td>预订酒店</td><td>45</td><td>6</td><td>选择酒店、选择房间类型、查看评价、选择时间、确认信息</td></tr><tr><td>3</td><td>确认订单</td><td>25</td><td>3</td><td>查看信息</td></tr><tr><td>4</td><td>支付订单</td><td>40</td><td>4</td><td>选择付款方式付款</td></tr><tr><td>5</td><td>管理订单</td><td>30</td><td>5</td><td>查看订单信息、删除订单</td></tr></tbody></table><h1 id=\"业务建模\"><a href=\"#业务建模\" class=\"headerlink\" title=\"业务建模\"></a>业务建模</h1><h2 id=\"在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\"><a href=\"#在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\" class=\"headerlink\" title=\"在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\"></a>在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。</h2><p><img src=\"/images/lesson6_3.png\" alt=\"\"></p><h2 id=\"选择你身边的银行-ATM，用活动图描绘取款业务流程\"><a href=\"#选择你身边的银行-ATM，用活动图描绘取款业务流程\" class=\"headerlink\" title=\"选择你身边的银行 ATM，用活动图描绘取款业务流程\"></a>选择你身边的银行 ATM，用活动图描绘取款业务流程</h2><p><img src=\"/images/lesson6_3b.png\" alt=\"\"></p><h2 id=\"查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\"><a href=\"#查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\" class=\"headerlink\" title=\"查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\"></a>查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例</h2><p><img src=\"/images/lesson6_3c.png\" alt=\"\"></p><h1 id=\"用例文本编写\"><a href=\"#用例文本编写\" class=\"headerlink\" title=\"用例文本编写\"></a>用例文本编写</h1><blockquote><p>在大作业基础上，分析三种用例文本的优点和缺点</p></blockquote><table><thead><tr><th>用例文本</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>详细用例</td><td>详细、深入</td><td>繁琐导致耗时长</td></tr><tr><td>casual 用例</td><td>较详细、编写较简便</td><td>细节不足，不够正式</td></tr><tr><td>brief用例</td><td>简介、编写简便</td><td>缺少细节</td></tr></tbody></table>","site":{"data":{}},"excerpt":"<h1 id=\"用例建模\"><a href=\"#用例建模\" class=\"headerlink\" title=\"用例建模\"></a>用例建模</h1><h2 id=\"阅读-Asg-RH-文档，绘制用例图。-按-Task1-要求，请使用工具-UMLet，截图格式务必是-png-并控制尺寸\"><a href=\"#阅读-Asg-RH-文档，绘制用例图。-按-Task1-要求，请使用工具-UMLet，截图格式务必是-png-并控制尺寸\" class=\"headerlink\" title=\"阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸\"></a>阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸</h2>","more":"<p><img src=\"/images/lesson6.png\" alt=\"\"></p><h2 id=\"选择你熟悉的定旅馆在线服务系统（或移动-APP），如绘制用例图。并满足以下要求：\"><a href=\"#选择你熟悉的定旅馆在线服务系统（或移动-APP），如绘制用例图。并满足以下要求：\" class=\"headerlink\" title=\"选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：\"></a>选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求：</h2><blockquote><ul><li>对比 Asg_RH 用例图，请用色彩标注出创新用例或子用例</li><li>尽可能识别外部系统，并用色彩标注新的外部系统和服务</li></ul></blockquote><p><img src=\"/images/lesson6b.png\" alt=\"\"></p><h2 id=\"对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\"><a href=\"#对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\" class=\"headerlink\" title=\"对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法\"></a>对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法</h2><ul><li>在基础功能上进行延伸</li><li>按照模块进行深入</li><li>按照用户需求的变化</li><li>按照技术的变化</li></ul><h2 id=\"请使用-SCRUM-方法，在（任务b）用例图基础上，编制某定旅馆开发的需求-（backlog）\"><a href=\"#请使用-SCRUM-方法，在（任务b）用例图基础上，编制某定旅馆开发的需求-（backlog）\" class=\"headerlink\" title=\"请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）\"></a>请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog）</h2><table><thead><tr><th>ID</th><th>Name</th><th>Imp</th><th>Est</th><th>How to demo</th></tr></thead><tbody><tr><td>1</td><td>选择酒店</td><td>40</td><td>5</td><td>选择酒店所在城市、预定时间、酒店关键字</td></tr><tr><td>2</td><td>预订酒店</td><td>45</td><td>6</td><td>选择酒店、选择房间类型、查看评价、选择时间、确认信息</td></tr><tr><td>3</td><td>确认订单</td><td>25</td><td>3</td><td>查看信息</td></tr><tr><td>4</td><td>支付订单</td><td>40</td><td>4</td><td>选择付款方式付款</td></tr><tr><td>5</td><td>管理订单</td><td>30</td><td>5</td><td>查看订单信息、删除订单</td></tr></tbody></table><h1 id=\"业务建模\"><a href=\"#业务建模\" class=\"headerlink\" title=\"业务建模\"></a>业务建模</h1><h2 id=\"在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\"><a href=\"#在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\" class=\"headerlink\" title=\"在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。\"></a>在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。</h2><p><img src=\"/images/lesson6_3.png\" alt=\"\"></p><h2 id=\"选择你身边的银行-ATM，用活动图描绘取款业务流程\"><a href=\"#选择你身边的银行-ATM，用活动图描绘取款业务流程\" class=\"headerlink\" title=\"选择你身边的银行 ATM，用活动图描绘取款业务流程\"></a>选择你身边的银行 ATM，用活动图描绘取款业务流程</h2><p><img src=\"/images/lesson6_3b.png\" alt=\"\"></p><h2 id=\"查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\"><a href=\"#查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\" class=\"headerlink\" title=\"查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例\"></a>查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例</h2><p><img src=\"/images/lesson6_3c.png\" alt=\"\"></p><h1 id=\"用例文本编写\"><a href=\"#用例文本编写\" class=\"headerlink\" title=\"用例文本编写\"></a>用例文本编写</h1><blockquote><p>在大作业基础上，分析三种用例文本的优点和缺点</p></blockquote><table><thead><tr><th>用例文本</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>详细用例</td><td>详细、深入</td><td>繁琐导致耗时长</td></tr><tr><td>casual 用例</td><td>较详细、编写较简便</td><td>细节不足，不够正式</td></tr><tr><td>brief用例</td><td>简介、编写简便</td><td>缺少细节</td></tr></tbody></table>"},{"title":"系统分析与设计作业十三","toc":true,"date":"2018-06-06T09:16:25.000Z","_content":"\n## 描述软件架构与框架之间的区别与联系\n\n### 软件架构\n\n软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。\n\n<!-- more -->\n\n### 软件框架\n\n软件框架其实就是将代码放到一个我们看不到的容器中，规定架构。当我们使用的时候直接调用。\n\n### 区别\n\n\t框架是软件，架构不是软件。\n\n\t框架是一种特殊的软件，它并不能提供完整无缺的解决方案，而是为构建解决方案提供良好的基础。框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务可以被最终应用系统直接调用，而框架中的扩展点是供应用开发人员定制的“可变化点”\n\n\t软件架构不是软件，而是关于软件如何设计的重要决策。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件框架之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。\n\n\t我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构。\n\n### 联系\n\n\t架构是框架的抽象，框架是架构的具体实现。\n\n\t框架可能集合了一种或多种架构。\n\n## 以你的项目为案例\n\n### 绘制三层架构模型图，细致到分区\n\n![](/images/lesson13_1.png)\n\n### 结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\n\n1、开发人员可以只关注整个结构中的其中某一层；\n\n2、可以很容易的用新的实现来替换原有层次的实现；\n\n3、可以降低层与层之间的依赖；\n\n4、有利于标准化；\n\n5、利于各层逻辑的复用。\n\n6、结构更加的明确\n\n7、在后期维护的时候，极大地降低了维护成本和维护时间\n\n## 研究 VUE 与 Flux 状态管理的异同\n\n### Vuex\n\n采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n核心概念：\n\n- State：Vuex 使用**单一状态树**——用一个对象就包含了全部的应用层级状态。\n- Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n- Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。\n- Action：和Action 类似于 mutation，不同在于：\n  - Action 提交的是 mutation，而不是直接变更状态。\n  - Action 可以包含任意异步操作。\n- Module：**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n### Flux\n\n[参考链接](https://blog.csdn.net/u010644262/article/details/79443567)\n\nFlux是Facebook用于构建客户端Web应用程序的一个**系统架构**。它通过**利用单向数据流来补充React的可组合视图组件**。它更像是一种模式，而不是一个正式的框架。\nFlux将一个应用分成**四个部分**。\n\n- View： 视图层 \n- Action（动作）：视图层发出的消息（比如mouseClick） \n- Dispatcher（派发器）：用来接收Actions、执行回调函数\n- Store（数据层）：用来存放应用的状态，一旦发生变动就提醒Views要更新页面\n\n流程：\n\n1. 用户访问 View\n2. View 发出用户的 Action\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n4. Store 更新后，发出一个\"change\"事件\n5. View 收到\"change\"事件后，更新页面\n\n### 区别：\n\nVuex将action分为了异步和同步两种而Flux没有区分。\n\n### 联系：\n\nVuex是基于Flux进行改进的。","source":"_posts/系统分析与设计作业十三.md","raw":"---\ntitle: 系统分析与设计作业十三\ntoc: true\ndate: 2018-06-06 17:16:25\ncategories:\n- 系统分析与设计\ntags:\n- VUE\n- Flux\n- 三层架构\n---\n\n## 描述软件架构与框架之间的区别与联系\n\n### 软件架构\n\n软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。\n\n<!-- more -->\n\n### 软件框架\n\n软件框架其实就是将代码放到一个我们看不到的容器中，规定架构。当我们使用的时候直接调用。\n\n### 区别\n\n\t框架是软件，架构不是软件。\n\n\t框架是一种特殊的软件，它并不能提供完整无缺的解决方案，而是为构建解决方案提供良好的基础。框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务可以被最终应用系统直接调用，而框架中的扩展点是供应用开发人员定制的“可变化点”\n\n\t软件架构不是软件，而是关于软件如何设计的重要决策。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件框架之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。\n\n\t我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构。\n\n### 联系\n\n\t架构是框架的抽象，框架是架构的具体实现。\n\n\t框架可能集合了一种或多种架构。\n\n## 以你的项目为案例\n\n### 绘制三层架构模型图，细致到分区\n\n![](/images/lesson13_1.png)\n\n### 结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\n\n1、开发人员可以只关注整个结构中的其中某一层；\n\n2、可以很容易的用新的实现来替换原有层次的实现；\n\n3、可以降低层与层之间的依赖；\n\n4、有利于标准化；\n\n5、利于各层逻辑的复用。\n\n6、结构更加的明确\n\n7、在后期维护的时候，极大地降低了维护成本和维护时间\n\n## 研究 VUE 与 Flux 状态管理的异同\n\n### Vuex\n\n采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n核心概念：\n\n- State：Vuex 使用**单一状态树**——用一个对象就包含了全部的应用层级状态。\n- Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n- Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。\n- Action：和Action 类似于 mutation，不同在于：\n  - Action 提交的是 mutation，而不是直接变更状态。\n  - Action 可以包含任意异步操作。\n- Module：**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n### Flux\n\n[参考链接](https://blog.csdn.net/u010644262/article/details/79443567)\n\nFlux是Facebook用于构建客户端Web应用程序的一个**系统架构**。它通过**利用单向数据流来补充React的可组合视图组件**。它更像是一种模式，而不是一个正式的框架。\nFlux将一个应用分成**四个部分**。\n\n- View： 视图层 \n- Action（动作）：视图层发出的消息（比如mouseClick） \n- Dispatcher（派发器）：用来接收Actions、执行回调函数\n- Store（数据层）：用来存放应用的状态，一旦发生变动就提醒Views要更新页面\n\n流程：\n\n1. 用户访问 View\n2. View 发出用户的 Action\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n4. Store 更新后，发出一个\"change\"事件\n5. View 收到\"change\"事件后，更新页面\n\n### 区别：\n\nVuex将action分为了异步和同步两种而Flux没有区分。\n\n### 联系：\n\nVuex是基于Flux进行改进的。","slug":"系统分析与设计作业十三","published":1,"updated":"2018-10-10T08:44:56.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1xz004wfmagdk0f5kp6","content":"<h2 id=\"描述软件架构与框架之间的区别与联系\"><a href=\"#描述软件架构与框架之间的区别与联系\" class=\"headerlink\" title=\"描述软件架构与框架之间的区别与联系\"></a>描述软件架构与框架之间的区别与联系</h2><h3 id=\"软件架构\"><a href=\"#软件架构\" class=\"headerlink\" title=\"软件架构\"></a>软件架构</h3><p>软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。</p><a id=\"more\"></a><h3 id=\"软件框架\"><a href=\"#软件框架\" class=\"headerlink\" title=\"软件框架\"></a>软件框架</h3><p>软件框架其实就是将代码放到一个我们看不到的容器中，规定架构。当我们使用的时候直接调用。</p><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><pre><code>框架是软件，架构不是软件。\n\n框架是一种特殊的软件，它并不能提供完整无缺的解决方案，而是为构建解决方案提供良好的基础。框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务可以被最终应用系统直接调用，而框架中的扩展点是供应用开发人员定制的“可变化点”\n\n软件架构不是软件，而是关于软件如何设计的重要决策。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件框架之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。\n\n我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构。\n</code></pre><h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><pre><code>架构是框架的抽象，框架是架构的具体实现。\n\n框架可能集合了一种或多种架构。\n</code></pre><h2 id=\"以你的项目为案例\"><a href=\"#以你的项目为案例\" class=\"headerlink\" title=\"以你的项目为案例\"></a>以你的项目为案例</h2><h3 id=\"绘制三层架构模型图，细致到分区\"><a href=\"#绘制三层架构模型图，细致到分区\" class=\"headerlink\" title=\"绘制三层架构模型图，细致到分区\"></a>绘制三层架构模型图，细致到分区</h3><p><img src=\"/images/lesson13_1.png\" alt=\"\"></p><h3 id=\"结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\"><a href=\"#结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\" class=\"headerlink\" title=\"结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\"></a>结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利</h3><p>1、开发人员可以只关注整个结构中的其中某一层；</p><p>2、可以很容易的用新的实现来替换原有层次的实现；</p><p>3、可以降低层与层之间的依赖；</p><p>4、有利于标准化；</p><p>5、利于各层逻辑的复用。</p><p>6、结构更加的明确</p><p>7、在后期维护的时候，极大地降低了维护成本和维护时间</p><h2 id=\"研究-VUE-与-Flux-状态管理的异同\"><a href=\"#研究-VUE-与-Flux-状态管理的异同\" class=\"headerlink\" title=\"研究 VUE 与 Flux 状态管理的异同\"></a>研究 VUE 与 Flux 状态管理的异同</h2><h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>核心概念：</p><ul><li>State：Vuex 使用<strong>单一状态树</strong>——用一个对象就包含了全部的应用层级状态。</li><li>Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</li><li>Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。</li><li>Action：和Action 类似于 mutation，不同在于：<ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></li><li>Module：<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</li></ul><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><p><a href=\"https://blog.csdn.net/u010644262/article/details/79443567\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>Flux是Facebook用于构建客户端Web应用程序的一个<strong>系统架构</strong>。它通过<strong>利用单向数据流来补充React的可组合视图组件</strong>。它更像是一种模式，而不是一个正式的框架。<br>Flux将一个应用分成<strong>四个部分</strong>。</p><ul><li>View： 视图层</li><li>Action（动作）：视图层发出的消息（比如mouseClick）</li><li>Dispatcher（派发器）：用来接收Actions、执行回调函数</li><li>Store（数据层）：用来存放应用的状态，一旦发生变动就提醒Views要更新页面</li></ul><p>流程：</p><ol><li>用户访问 View</li><li>View 发出用户的 Action</li><li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li><li>Store 更新后，发出一个”change”事件</li><li>View 收到”change”事件后，更新页面</li></ol><h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>Vuex将action分为了异步和同步两种而Flux没有区分。</p><h3 id=\"联系：\"><a href=\"#联系：\" class=\"headerlink\" title=\"联系：\"></a>联系：</h3><p>Vuex是基于Flux进行改进的。</p>","site":{"data":{}},"excerpt":"<h2 id=\"描述软件架构与框架之间的区别与联系\"><a href=\"#描述软件架构与框架之间的区别与联系\" class=\"headerlink\" title=\"描述软件架构与框架之间的区别与联系\"></a>描述软件架构与框架之间的区别与联系</h2><h3 id=\"软件架构\"><a href=\"#软件架构\" class=\"headerlink\" title=\"软件架构\"></a>软件架构</h3><p>软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。</p>","more":"<h3 id=\"软件框架\"><a href=\"#软件框架\" class=\"headerlink\" title=\"软件框架\"></a>软件框架</h3><p>软件框架其实就是将代码放到一个我们看不到的容器中，规定架构。当我们使用的时候直接调用。</p><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><pre><code>框架是软件，架构不是软件。\n\n框架是一种特殊的软件，它并不能提供完整无缺的解决方案，而是为构建解决方案提供良好的基础。框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务可以被最终应用系统直接调用，而框架中的扩展点是供应用开发人员定制的“可变化点”\n\n软件架构不是软件，而是关于软件如何设计的重要决策。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件框架之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。\n\n我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构。\n</code></pre><h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><pre><code>架构是框架的抽象，框架是架构的具体实现。\n\n框架可能集合了一种或多种架构。\n</code></pre><h2 id=\"以你的项目为案例\"><a href=\"#以你的项目为案例\" class=\"headerlink\" title=\"以你的项目为案例\"></a>以你的项目为案例</h2><h3 id=\"绘制三层架构模型图，细致到分区\"><a href=\"#绘制三层架构模型图，细致到分区\" class=\"headerlink\" title=\"绘制三层架构模型图，细致到分区\"></a>绘制三层架构模型图，细致到分区</h3><p><img src=\"/images/lesson13_1.png\" alt=\"\"></p><h3 id=\"结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\"><a href=\"#结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\" class=\"headerlink\" title=\"结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利\"></a>结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利</h3><p>1、开发人员可以只关注整个结构中的其中某一层；</p><p>2、可以很容易的用新的实现来替换原有层次的实现；</p><p>3、可以降低层与层之间的依赖；</p><p>4、有利于标准化；</p><p>5、利于各层逻辑的复用。</p><p>6、结构更加的明确</p><p>7、在后期维护的时候，极大地降低了维护成本和维护时间</p><h2 id=\"研究-VUE-与-Flux-状态管理的异同\"><a href=\"#研究-VUE-与-Flux-状态管理的异同\" class=\"headerlink\" title=\"研究 VUE 与 Flux 状态管理的异同\"></a>研究 VUE 与 Flux 状态管理的异同</h2><h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>核心概念：</p><ul><li>State：Vuex 使用<strong>单一状态树</strong>——用一个对象就包含了全部的应用层级状态。</li><li>Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</li><li>Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。</li><li>Action：和Action 类似于 mutation，不同在于：<ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></li><li>Module：<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</li></ul><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><p><a href=\"https://blog.csdn.net/u010644262/article/details/79443567\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a></p><p>Flux是Facebook用于构建客户端Web应用程序的一个<strong>系统架构</strong>。它通过<strong>利用单向数据流来补充React的可组合视图组件</strong>。它更像是一种模式，而不是一个正式的框架。<br>Flux将一个应用分成<strong>四个部分</strong>。</p><ul><li>View： 视图层</li><li>Action（动作）：视图层发出的消息（比如mouseClick）</li><li>Dispatcher（派发器）：用来接收Actions、执行回调函数</li><li>Store（数据层）：用来存放应用的状态，一旦发生变动就提醒Views要更新页面</li></ul><p>流程：</p><ol><li>用户访问 View</li><li>View 发出用户的 Action</li><li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li><li>Store 更新后，发出一个”change”事件</li><li>View 收到”change”事件后，更新页面</li></ol><h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>Vuex将action分为了异步和同步两种而Flux没有区分。</p><h3 id=\"联系：\"><a href=\"#联系：\" class=\"headerlink\" title=\"联系：\"></a>联系：</h3><p>Vuex是基于Flux进行改进的。</p>"},{"title":"系统分析与设计作业十六","toc":true,"date":"2018-06-30T07:12:15.000Z","_content":"\n## 使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）\n\n<!-- more -->\n\n### 用例简介\n\n用户提交订单后填写用户信息、确认房间和时间后完成订单。\n\n### 顺序图\n\n![](/images/lesson16_1.png)\n\n### 类图\n\n![](/images/lesson16_2.png)\n\n## 将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\n\n![](/images/lesson16_3.png)","source":"_posts/系统分析与设计作业十六.md","raw":"---\ntitle: 系统分析与设计作业十六\ntoc: true\ndate: 2018-06-30 15:12:15\ncategories:\n- 系统分析与设计\ntags:\n- UMLet\n- 用例图\n---\n\n## 使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）\n\n<!-- more -->\n\n### 用例简介\n\n用户提交订单后填写用户信息、确认房间和时间后完成订单。\n\n### 顺序图\n\n![](/images/lesson16_1.png)\n\n### 类图\n\n![](/images/lesson16_2.png)\n\n## 将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\n\n![](/images/lesson16_3.png)","slug":"系统分析与设计作业十六","published":1,"updated":"2018-10-10T08:44:49.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1y10050fmagoxiwrzak","content":"<h2 id=\"使用-ECB-实现-make-reservation-用例的详细设计（包含用例简介，顺序图，类图）\"><a href=\"#使用-ECB-实现-make-reservation-用例的详细设计（包含用例简介，顺序图，类图）\" class=\"headerlink\" title=\"使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）\"></a>使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）</h2><a id=\"more\"></a><h3 id=\"用例简介\"><a href=\"#用例简介\" class=\"headerlink\" title=\"用例简介\"></a>用例简介</h3><p>用户提交订单后填写用户信息、确认房间和时间后完成订单。</p><h3 id=\"顺序图\"><a href=\"#顺序图\" class=\"headerlink\" title=\"顺序图\"></a>顺序图</h3><p><img src=\"/images/lesson16_1.png\" alt=\"\"></p><h3 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h3><p><img src=\"/images/lesson16_2.png\" alt=\"\"></p><h2 id=\"将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\"><a href=\"#将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\" class=\"headerlink\" title=\"将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\"></a>将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类</h2><p><img src=\"/images/lesson16_3.png\" alt=\"\"></p>","site":{"data":{}},"excerpt":"<h2 id=\"使用-ECB-实现-make-reservation-用例的详细设计（包含用例简介，顺序图，类图）\"><a href=\"#使用-ECB-实现-make-reservation-用例的详细设计（包含用例简介，顺序图，类图）\" class=\"headerlink\" title=\"使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）\"></a>使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图）</h2>","more":"<h3 id=\"用例简介\"><a href=\"#用例简介\" class=\"headerlink\" title=\"用例简介\"></a>用例简介</h3><p>用户提交订单后填写用户信息、确认房间和时间后完成订单。</p><h3 id=\"顺序图\"><a href=\"#顺序图\" class=\"headerlink\" title=\"顺序图\"></a>顺序图</h3><p><img src=\"/images/lesson16_1.png\" alt=\"\"></p><h3 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h3><p><img src=\"/images/lesson16_2.png\" alt=\"\"></p><h2 id=\"将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\"><a href=\"#将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\" class=\"headerlink\" title=\"将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类\"></a>将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类</h2><p><img src=\"/images/lesson16_3.png\" alt=\"\"></p>"},{"title":"继续磕面经","toc":true,"date":"2018-09-26T09:31:07.000Z","_content":"\n### js的基本数据类型\n\nUndefined、Null、Boolean、Number、String五种基本数据类型\n\n<!-- more -->\n\n### 获取变量的数据类型有哪些方法\n\n1. `typeof`，返回六种结果：undefined、boolean、number、string、object、function\n\n   ```js\n   typeof ''; // string\n   typeof 1; // number\n   typeof true; // boolean\n   typeof undefined; // undefined\n   typeof null; //object\n   typeof []; // object\n   typeof new Function(); //function\n   typeof new Date(); //object\n   typeof new RegExp(); //object\n   ```\n\n2. `instanceof`，判断是否是一个类的实例\n\n   ```js\n   true instanceof Boolean; // false\n   1 instanceof Number; // false\n   '' instanceof String; // false\n   [] instanceof Array; // true\n   ({}) instanceof Object; // true\n   (function(){}) instanceof Function; // true\n   new Boolean(true) instanceof Boolean; // true\n   ```\n\n3. `constructor`，一个类的prototype会指向自己的引用。\n\n   需要注意的是：\n\n   - `null`和`undefined`是无效的对象，因此没有constructor，需要通过typeof来判断。\n   - JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。\n\n   ```js\n   ''.constructor == String; // true\n   (1).constructor Number; // true\n   true.constructor == Boolean; // true\n   new Function().constructor == Function; // true\n   new Date().constructor == Date; //true\n   ```\n\n4. `Object.prototype.toString`\n\n   ```js\n   Object.prototype.toString.call('');   //[object String]\n   Object.prototype.toString.call(1);    //[object Number]\n   Object.prototype.toString.call(true); //[object Boolean]\n   Object.prototype.toString.call(undefined); //[object Undefined]\n   Object.prototype.toString.call(null); //[object Null]\n   Object.prototype.toString.call(new Function()); //[object Function]\n   Object.prototype.toString.call(new Date()); //[object Date]\n   Object.prototype.toString.call([]); //[object Array]\n   Object.prototype.toString.call(new RegExp()); //[object RegExp]\n   Object.prototype.toString.call(new Error()); //[object Error]\n   Object.prototype.toString.call(document); //[object HTMLDocument]\n   Object.prototype.toString.call(window); //[object global] window是全局对象global的引用\n   // 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy \n   ```\n\n### JS的拷贝？\n\n基本数据类型会新开辟一个数据段来保存值，\n\n但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。\n\n### 深拷贝的方法\n\n需要注意的是：slice()和concat()只深拷贝了一级属性。\n\n1. 递归复制所有属性\n\n   ```js\n   function deepClone(arg) {\n     if (arg == null || typeof arg != 'object') return arg;\n     let newObj = Array.isArray(arg) ? [] : {};\n     for (let key in arg) {\n       if (arg[key] != null && typeof arg[key] == 'object') {\n         newObj[key] = deepClone(arg[key]);\n       } else {\n         newObj[key] = arg[key];\n       }\n     }\n     return newObj;\n   }\n   ```\n\n2. 使用JSON的parse和stringify\n\n   ```js\n   function deepClone(arg) {\n     return typeof arg == 'object' ? argJSON.parse(JSON.stringify(arg)) : arg;\n   }\n   ```\n\n3. 使用JQuery的extend方法\n\n   `$.extend([deep], target, object1[, objectN ])`\n\n   - 用于将一个或多个对象的内容合并到目标对象\n   - 如果多个对象具有相同的属性，则后者会覆盖前者的属性值\n\n   ```js\n   function deepClone(arg) {\n     if (arg == null || typeof arg != 'object') return arg;\n     if (arg instanceof Array) return $.extend(true,[],arg);\n     else return $.extend(true,{},arg);\n   }\n   ```\n\n### CSS单位有哪些\n\n#### 相对长度\n\n| 单位 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| em   | 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px； |\n| ex   | 依赖于英文子母小 x 的高度                                    |\n| ch   | 数字 0 的宽度                                                |\n| rem  | 根元素（html）的 font-size                                   |\n| vw   | viewpoint width，视窗宽度，1vw=视窗宽度的1%                  |\n| vh   | viewpoint height，视窗高度，1vh=视窗高度的1%                 |\n| vmin | vw和vh中较小的那个。                                         |\n| vmax | vw和vh中较大的那个。                                         |\n| %    | [介绍链接](https://blog.zmj97.top/2018/09/10/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#%E7%99%BE%E5%88%86%E6%AF%94) |\n\n#### 绝对长度\n\n| 单位 | 描述                                   |\n| ---- | -------------------------------------- |\n| cm   | 厘米                                   |\n| mm   | 毫米                                   |\n| in   | 英寸 (1in = 96px = 2.54cm)             |\n| px   | 像素 (1px = 1/96 of 1in)               |\n| pt   | point，大约1/72英寸； (1pt = 1/72in)   |\n| pc   | pica，大约6pt，1/6英寸； (1pc = 12 pt) |\n\n### 网页渲染的流程\n\n参考：https://www.cnblogs.com/dojo-lzz/p/3983335.html\n\n页面解析渲染该过程主要分为以下步骤：\n\n1. 解析HTML\n2. 构建DOM树\n3. DOM树与CSS样式进行附着构造呈现树\n4. 布局\n5. 绘制\n\n\n\n- 浏览器怎么知道收到的包是html文件（content-type）\n- CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行）\n- 知道哪些content-type（[参考链接](https://blog.csdn.net/luyu13141314/article/details/81129069?utm_source=copy )）\n  - **text/html**  ：HTML格式\n  - **text/plain** ：纯文本格式      \n  - **text/xml**   ：XML格式\n  - **image/gif**  ：gif图片格式    \n  - **image/jpeg** ：jpg图片格式 \n  - **image/png**  ：png图片格式\n  - **application/xml**     ： XML数据格式\n  - **application/json**    ： JSON数据格式\n  - **application/pdf**     ： pdf格式  \n  - **application/msword**  ： Word文档格式\n  - **application/octet-stream** ： 二进制流数据（如文件下载）\n  - **application/x-www-form-urlencoded** ： POST 提交数据\n  - **multipart/form-data** ： 表单上传文件\n- bfc（[看这里](https://www.cnblogs.com/dojo-lzz/p/3999013.html)）\n- 清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear）\n- 水平方向有margin叠加么（没有）\n\n### JS继承\n\n1. 工厂模式\n2. 构造函数模式\n3. 原型链模式\n4. 组合使用构造器和原型链模式\n5. 原型式继承（浅拷贝）\n6. 寄生式继承（5的增强版）\n7. 寄生组合式继承\n\n\n\n- 原型继承可以继承非原型属性么\n- 修正constructor\n- apply/call方法和原型方法的区别\n\n### vue：v-model\n\n双向绑定\n\n```html\n<input v-model=\"searchText\">\n```\n\n等价于：\n\n```html\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\n### 设计模式\n\n[23种设计模式](https://www.cnblogs.com/tongkey/p/7170826.html)\n\n### 单例模式\n\n- 用来解决哪些问题\n- 只能用闭包实现么\n- 写个单例模式\n\n### 预解析\n\n在当前作用域下，js运行之前，会把带有var和function关键字的事先**声明**，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。\n\n### DOM\n\n- 已知父节点获取第一个子节点（parentObj.firstChild）\n- 查兄弟节点（previousSibing前一个，nextSibing后一个）\n- 在某个子节点后面插入节点（insertBefore()）\n\n### 对象的存储方式\n\n实际存储在堆中，在栈中存储的是堆内存储地址。\n\n所以可以把变量名看做指针。\n\n### 内存回收方式\n\n标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题）\n\n### String为什么有length属性\n\n基本包装类型\n\n### 已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例\n\n函数内部判断this是否为window\n\n### 用数据结构表示项目之间的依赖\n\n双向链表？map？不知道。。。\n\n### 判断一个图有没有环\n\n无向图：不断去掉度为1的点\n\n有向图：拓扑排序\n\n### 从输入url到显示完成了什么\n\n1. 用户输入URL地址\n2. 浏览器解析URL解析出主机名\n3. 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）\n4. 浏览器将端口号从URL中解析出来\n5. 浏览器建立一条与目标Web服务器的TCP连接（三次握手）\n6. 浏览器向服务器发送一条HTTP请求报文\n7. 服务器向浏览器返回一条HTTP响应报文\n8. 浏览器解析文档\n9. 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕\n10. 关闭连接\n11. 渲染页面\n\n\n\n- 浏览器会不会缓存dns\n  - 会，不同浏览器缓存时间不一样\n- https多了什么步骤\n  - **https**: http + 通信加密 + 证书 + 完整性保护，http secure　\n  - **证书**可以证明服务器或客户端的身份\n  - **ssl**: secure socket layer，安全套接层\n  - 多了**SSL安全套接层**。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。\n- 假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）\n- 浏览器解析数据是全部收到才解析还是边收边解析\n- 如果加载`<link>`需要十秒，分别在head和body那么加载时用户会看到什么\n- script，同上，还有外联/内联\n\n### 实现parse函数解析?b=1&c=2这样的字段\n\n```js\nfunction myParse(arg) {\n  arg = arg.split('?')[1].split('&');\n  let obj = {};\n  for (let i = 0; i < arg.length; i++) {\n    obj[arg[i].split('=')[0]] = arg[i].split('=')[1];\n  }\n  return obj;\n}\n```\n\n### 箭头函数的区别，能当做构造函数么\n\n### ES6如何获取函数参数\n\n### setTimeout准时么\n\n### ES6手写观察者模式\n\n### 产生0-100的随机数\n\n### http报文结构，header有哪些字段\n\n### 跨域\n\n### 手写所有排序算法和DFS、BFS\n\n快排、堆排、基数排序\n\n### 盒模型\n\n标准盒模型和IE盒模型\n\n### session和cookie区别\n\n### 替换元素\n\n浏览器根据元素的标签和属性，来决定元素的具体显示内容\n\nimg、input、textarea、select、obejct、button、label都是替换元素（置换元素）\n\n### 面向对象的特性\n\n### C++怎么实现多态的\n\n### 同步异步区别\n\n### js异步加载方法\n\n### 串行和并行\n\n### 数据库index及实现\n\n### 进程和线程\n\n\n\n### 进程间通信方法\n\n### 进程或线程的同步方法\n\n### 虚拟DOM的作用\n\n### 尾递归\n\n### position\n\n### 浮动\n\n### 圣杯布局、双飞翼布局\n\n### 动画实现div无限旋转\n\n### 前端性能优化\n\n### 304实现原理\n\n### webSocket是哪一层的\n\n应用层\n\n### 实现add(1)(2)(3) == 6\n\n### js是单线程的，如何实现定时\n\n### ES6代理\n\n### 计算一个数转换成二进制后1的个数\n\n### HTTP长连接\n\n### 状态码5xx\n\n### https默认端口\n\n### tcp连接过程中的状态考察\n\n### 三次握手四次挥手详细\n\n### http2.0\n\n### 多路复用和1.x请求的区别\n\n### unsigned int类型扩展长度\n\n### 一个长度为一百万的数组中，超过一半都是某一个值，求这个值\n\nhttps://www.cnblogs.com/yanliang12138/p/4763743.html\n\n### 渐进增强和优雅降级\n\n### 前端缓存机制\n\n### 没有辅助空间的情况下交换两个数的值\n\n### 前端安全\n\n### let暂时性死区和块级作用域\n\n### 类数组\n\n### for in 缺点\n\n### forEach()\n\n### ES6中map遍历实现原理\n\n### 数组去重\n\n### 死锁\n\n### https详细过程\n\n加密算法，对称还是非对称。md5,SHA,AES\n\n### 模块化\n\nwebpack、AMD、CMD\n\n### 数组的各种方法\n\n### 内存换页算法\n\n### 事件循环\n\n### ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\n\n### 手写封装jsonp\n\n### 事件委托\n\n### TCP和UDP\n\n### soket阻塞模式\n\n### doctype\n\n### AJAX实现原理，手写实现","source":"_posts/继续磕面经.md","raw":"---\ntitle: 继续磕面经\ntoc: true\ndate: 2018-09-26 17:31:07\ncategories:\n- Web\ntags:\n- JavaScript\n- HTML\n- CSS\n- Vue\n- 设计模式\n- HTTP\n- ES6\n---\n\n### js的基本数据类型\n\nUndefined、Null、Boolean、Number、String五种基本数据类型\n\n<!-- more -->\n\n### 获取变量的数据类型有哪些方法\n\n1. `typeof`，返回六种结果：undefined、boolean、number、string、object、function\n\n   ```js\n   typeof ''; // string\n   typeof 1; // number\n   typeof true; // boolean\n   typeof undefined; // undefined\n   typeof null; //object\n   typeof []; // object\n   typeof new Function(); //function\n   typeof new Date(); //object\n   typeof new RegExp(); //object\n   ```\n\n2. `instanceof`，判断是否是一个类的实例\n\n   ```js\n   true instanceof Boolean; // false\n   1 instanceof Number; // false\n   '' instanceof String; // false\n   [] instanceof Array; // true\n   ({}) instanceof Object; // true\n   (function(){}) instanceof Function; // true\n   new Boolean(true) instanceof Boolean; // true\n   ```\n\n3. `constructor`，一个类的prototype会指向自己的引用。\n\n   需要注意的是：\n\n   - `null`和`undefined`是无效的对象，因此没有constructor，需要通过typeof来判断。\n   - JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。\n\n   ```js\n   ''.constructor == String; // true\n   (1).constructor Number; // true\n   true.constructor == Boolean; // true\n   new Function().constructor == Function; // true\n   new Date().constructor == Date; //true\n   ```\n\n4. `Object.prototype.toString`\n\n   ```js\n   Object.prototype.toString.call('');   //[object String]\n   Object.prototype.toString.call(1);    //[object Number]\n   Object.prototype.toString.call(true); //[object Boolean]\n   Object.prototype.toString.call(undefined); //[object Undefined]\n   Object.prototype.toString.call(null); //[object Null]\n   Object.prototype.toString.call(new Function()); //[object Function]\n   Object.prototype.toString.call(new Date()); //[object Date]\n   Object.prototype.toString.call([]); //[object Array]\n   Object.prototype.toString.call(new RegExp()); //[object RegExp]\n   Object.prototype.toString.call(new Error()); //[object Error]\n   Object.prototype.toString.call(document); //[object HTMLDocument]\n   Object.prototype.toString.call(window); //[object global] window是全局对象global的引用\n   // 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy \n   ```\n\n### JS的拷贝？\n\n基本数据类型会新开辟一个数据段来保存值，\n\n但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。\n\n### 深拷贝的方法\n\n需要注意的是：slice()和concat()只深拷贝了一级属性。\n\n1. 递归复制所有属性\n\n   ```js\n   function deepClone(arg) {\n     if (arg == null || typeof arg != 'object') return arg;\n     let newObj = Array.isArray(arg) ? [] : {};\n     for (let key in arg) {\n       if (arg[key] != null && typeof arg[key] == 'object') {\n         newObj[key] = deepClone(arg[key]);\n       } else {\n         newObj[key] = arg[key];\n       }\n     }\n     return newObj;\n   }\n   ```\n\n2. 使用JSON的parse和stringify\n\n   ```js\n   function deepClone(arg) {\n     return typeof arg == 'object' ? argJSON.parse(JSON.stringify(arg)) : arg;\n   }\n   ```\n\n3. 使用JQuery的extend方法\n\n   `$.extend([deep], target, object1[, objectN ])`\n\n   - 用于将一个或多个对象的内容合并到目标对象\n   - 如果多个对象具有相同的属性，则后者会覆盖前者的属性值\n\n   ```js\n   function deepClone(arg) {\n     if (arg == null || typeof arg != 'object') return arg;\n     if (arg instanceof Array) return $.extend(true,[],arg);\n     else return $.extend(true,{},arg);\n   }\n   ```\n\n### CSS单位有哪些\n\n#### 相对长度\n\n| 单位 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| em   | 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px； |\n| ex   | 依赖于英文子母小 x 的高度                                    |\n| ch   | 数字 0 的宽度                                                |\n| rem  | 根元素（html）的 font-size                                   |\n| vw   | viewpoint width，视窗宽度，1vw=视窗宽度的1%                  |\n| vh   | viewpoint height，视窗高度，1vh=视窗高度的1%                 |\n| vmin | vw和vh中较小的那个。                                         |\n| vmax | vw和vh中较大的那个。                                         |\n| %    | [介绍链接](https://blog.zmj97.top/2018/09/10/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#%E7%99%BE%E5%88%86%E6%AF%94) |\n\n#### 绝对长度\n\n| 单位 | 描述                                   |\n| ---- | -------------------------------------- |\n| cm   | 厘米                                   |\n| mm   | 毫米                                   |\n| in   | 英寸 (1in = 96px = 2.54cm)             |\n| px   | 像素 (1px = 1/96 of 1in)               |\n| pt   | point，大约1/72英寸； (1pt = 1/72in)   |\n| pc   | pica，大约6pt，1/6英寸； (1pc = 12 pt) |\n\n### 网页渲染的流程\n\n参考：https://www.cnblogs.com/dojo-lzz/p/3983335.html\n\n页面解析渲染该过程主要分为以下步骤：\n\n1. 解析HTML\n2. 构建DOM树\n3. DOM树与CSS样式进行附着构造呈现树\n4. 布局\n5. 绘制\n\n\n\n- 浏览器怎么知道收到的包是html文件（content-type）\n- CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行）\n- 知道哪些content-type（[参考链接](https://blog.csdn.net/luyu13141314/article/details/81129069?utm_source=copy )）\n  - **text/html**  ：HTML格式\n  - **text/plain** ：纯文本格式      \n  - **text/xml**   ：XML格式\n  - **image/gif**  ：gif图片格式    \n  - **image/jpeg** ：jpg图片格式 \n  - **image/png**  ：png图片格式\n  - **application/xml**     ： XML数据格式\n  - **application/json**    ： JSON数据格式\n  - **application/pdf**     ： pdf格式  \n  - **application/msword**  ： Word文档格式\n  - **application/octet-stream** ： 二进制流数据（如文件下载）\n  - **application/x-www-form-urlencoded** ： POST 提交数据\n  - **multipart/form-data** ： 表单上传文件\n- bfc（[看这里](https://www.cnblogs.com/dojo-lzz/p/3999013.html)）\n- 清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear）\n- 水平方向有margin叠加么（没有）\n\n### JS继承\n\n1. 工厂模式\n2. 构造函数模式\n3. 原型链模式\n4. 组合使用构造器和原型链模式\n5. 原型式继承（浅拷贝）\n6. 寄生式继承（5的增强版）\n7. 寄生组合式继承\n\n\n\n- 原型继承可以继承非原型属性么\n- 修正constructor\n- apply/call方法和原型方法的区别\n\n### vue：v-model\n\n双向绑定\n\n```html\n<input v-model=\"searchText\">\n```\n\n等价于：\n\n```html\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\n### 设计模式\n\n[23种设计模式](https://www.cnblogs.com/tongkey/p/7170826.html)\n\n### 单例模式\n\n- 用来解决哪些问题\n- 只能用闭包实现么\n- 写个单例模式\n\n### 预解析\n\n在当前作用域下，js运行之前，会把带有var和function关键字的事先**声明**，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。\n\n### DOM\n\n- 已知父节点获取第一个子节点（parentObj.firstChild）\n- 查兄弟节点（previousSibing前一个，nextSibing后一个）\n- 在某个子节点后面插入节点（insertBefore()）\n\n### 对象的存储方式\n\n实际存储在堆中，在栈中存储的是堆内存储地址。\n\n所以可以把变量名看做指针。\n\n### 内存回收方式\n\n标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题）\n\n### String为什么有length属性\n\n基本包装类型\n\n### 已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例\n\n函数内部判断this是否为window\n\n### 用数据结构表示项目之间的依赖\n\n双向链表？map？不知道。。。\n\n### 判断一个图有没有环\n\n无向图：不断去掉度为1的点\n\n有向图：拓扑排序\n\n### 从输入url到显示完成了什么\n\n1. 用户输入URL地址\n2. 浏览器解析URL解析出主机名\n3. 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）\n4. 浏览器将端口号从URL中解析出来\n5. 浏览器建立一条与目标Web服务器的TCP连接（三次握手）\n6. 浏览器向服务器发送一条HTTP请求报文\n7. 服务器向浏览器返回一条HTTP响应报文\n8. 浏览器解析文档\n9. 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕\n10. 关闭连接\n11. 渲染页面\n\n\n\n- 浏览器会不会缓存dns\n  - 会，不同浏览器缓存时间不一样\n- https多了什么步骤\n  - **https**: http + 通信加密 + 证书 + 完整性保护，http secure　\n  - **证书**可以证明服务器或客户端的身份\n  - **ssl**: secure socket layer，安全套接层\n  - 多了**SSL安全套接层**。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。\n- 假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）\n- 浏览器解析数据是全部收到才解析还是边收边解析\n- 如果加载`<link>`需要十秒，分别在head和body那么加载时用户会看到什么\n- script，同上，还有外联/内联\n\n### 实现parse函数解析?b=1&c=2这样的字段\n\n```js\nfunction myParse(arg) {\n  arg = arg.split('?')[1].split('&');\n  let obj = {};\n  for (let i = 0; i < arg.length; i++) {\n    obj[arg[i].split('=')[0]] = arg[i].split('=')[1];\n  }\n  return obj;\n}\n```\n\n### 箭头函数的区别，能当做构造函数么\n\n### ES6如何获取函数参数\n\n### setTimeout准时么\n\n### ES6手写观察者模式\n\n### 产生0-100的随机数\n\n### http报文结构，header有哪些字段\n\n### 跨域\n\n### 手写所有排序算法和DFS、BFS\n\n快排、堆排、基数排序\n\n### 盒模型\n\n标准盒模型和IE盒模型\n\n### session和cookie区别\n\n### 替换元素\n\n浏览器根据元素的标签和属性，来决定元素的具体显示内容\n\nimg、input、textarea、select、obejct、button、label都是替换元素（置换元素）\n\n### 面向对象的特性\n\n### C++怎么实现多态的\n\n### 同步异步区别\n\n### js异步加载方法\n\n### 串行和并行\n\n### 数据库index及实现\n\n### 进程和线程\n\n\n\n### 进程间通信方法\n\n### 进程或线程的同步方法\n\n### 虚拟DOM的作用\n\n### 尾递归\n\n### position\n\n### 浮动\n\n### 圣杯布局、双飞翼布局\n\n### 动画实现div无限旋转\n\n### 前端性能优化\n\n### 304实现原理\n\n### webSocket是哪一层的\n\n应用层\n\n### 实现add(1)(2)(3) == 6\n\n### js是单线程的，如何实现定时\n\n### ES6代理\n\n### 计算一个数转换成二进制后1的个数\n\n### HTTP长连接\n\n### 状态码5xx\n\n### https默认端口\n\n### tcp连接过程中的状态考察\n\n### 三次握手四次挥手详细\n\n### http2.0\n\n### 多路复用和1.x请求的区别\n\n### unsigned int类型扩展长度\n\n### 一个长度为一百万的数组中，超过一半都是某一个值，求这个值\n\nhttps://www.cnblogs.com/yanliang12138/p/4763743.html\n\n### 渐进增强和优雅降级\n\n### 前端缓存机制\n\n### 没有辅助空间的情况下交换两个数的值\n\n### 前端安全\n\n### let暂时性死区和块级作用域\n\n### 类数组\n\n### for in 缺点\n\n### forEach()\n\n### ES6中map遍历实现原理\n\n### 数组去重\n\n### 死锁\n\n### https详细过程\n\n加密算法，对称还是非对称。md5,SHA,AES\n\n### 模块化\n\nwebpack、AMD、CMD\n\n### 数组的各种方法\n\n### 内存换页算法\n\n### 事件循环\n\n### ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\n\n### 手写封装jsonp\n\n### 事件委托\n\n### TCP和UDP\n\n### soket阻塞模式\n\n### doctype\n\n### AJAX实现原理，手写实现","slug":"继续磕面经","published":1,"updated":"2018-10-10T08:44:39.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1y30053fmagv1eafa7v","content":"<h3 id=\"js的基本数据类型\"><a href=\"#js的基本数据类型\" class=\"headerlink\" title=\"js的基本数据类型\"></a>js的基本数据类型</h3><p>Undefined、Null、Boolean、Number、String五种基本数据类型</p><a id=\"more\"></a><h3 id=\"获取变量的数据类型有哪些方法\"><a href=\"#获取变量的数据类型有哪些方法\" class=\"headerlink\" title=\"获取变量的数据类型有哪些方法\"></a>获取变量的数据类型有哪些方法</h3><ol><li><p><code>typeof</code>，返回六种结果：undefined、boolean、number、string、object、function</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">typeof</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// string</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// number</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// boolean</span>\n<span class=\"token keyword\">typeof</span> undefined<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// undefined</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// object</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object</span>\n</code></pre></li><li><p><code>instanceof</code>，判断是否是一个类的实例</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token boolean\">true</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token number\">1</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token string\">''</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n</code></pre></li><li><p><code>constructor</code>，一个类的prototype会指向自己的引用。</p><p>需要注意的是：</p><ul><li><code>null</code>和<code>undefined</code>是无效的对象，因此没有constructor，需要通过typeof来判断。</li><li>JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。</li></ul><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token string\">''</span><span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> String<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>constructor Number<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token boolean\">true</span><span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Boolean<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Function<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Date<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n</code></pre></li><li><p><code>Object.prototype.toString</code></p><pre class=\" language-js\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//[object String]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//[object Number]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Boolean]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>undefined<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Undefined]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Null]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Function]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Date]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Array]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object RegExp]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object Error]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object HTMLDocument]</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[object global] window是全局对象global的引用</span>\n<span class=\"token comment\" spellcheck=\"true\">// 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy </span>\n</code></pre></li></ol><h3 id=\"JS的拷贝？\"><a href=\"#JS的拷贝？\" class=\"headerlink\" title=\"JS的拷贝？\"></a>JS的拷贝？</h3><p>基本数据类型会新开辟一个数据段来保存值，</p><p>但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。</p><h3 id=\"深拷贝的方法\"><a href=\"#深拷贝的方法\" class=\"headerlink\" title=\"深拷贝的方法\"></a>深拷贝的方法</h3><p>需要注意的是：slice()和concat()只深拷贝了一级属性。</p><ol><li><p>递归复制所有属性</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span> arg <span class=\"token operator\">!=</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arg<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> newObj <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> arg<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      newObj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      newObj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> newObj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></li><li><p>使用JSON的parse和stringify</p><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> arg <span class=\"token operator\">==</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">?</span> argJSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> arg<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></li><li><p>使用JQuery的extend方法</p><p><code>$.extend([deep], target, object1[, objectN ])</code></p><ul><li>用于将一个或多个对象的内容合并到目标对象</li><li>如果多个对象具有相同的属性，则后者会覆盖前者的属性值</li></ul><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span> arg <span class=\"token operator\">!=</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arg<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arg <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> $<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> $<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></li></ol><h3 id=\"CSS单位有哪些\"><a href=\"#CSS单位有哪些\" class=\"headerlink\" title=\"CSS单位有哪些\"></a>CSS单位有哪些</h3><h4 id=\"相对长度\"><a href=\"#相对长度\" class=\"headerlink\" title=\"相对长度\"></a>相对长度</h4><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>em</td><td>它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；</td></tr><tr><td>ex</td><td>依赖于英文子母小 x 的高度</td></tr><tr><td>ch</td><td>数字 0 的宽度</td></tr><tr><td>rem</td><td>根元素（html）的 font-size</td></tr><tr><td>vw</td><td>viewpoint width，视窗宽度，1vw=视窗宽度的1%</td></tr><tr><td>vh</td><td>viewpoint height，视窗高度，1vh=视窗高度的1%</td></tr><tr><td>vmin</td><td>vw和vh中较小的那个。</td></tr><tr><td>vmax</td><td>vw和vh中较大的那个。</td></tr><tr><td>%</td><td><a href=\"https://blog.zmj97.top/2018/09/10/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#%E7%99%BE%E5%88%86%E6%AF%94\" target=\"_blank\" rel=\"noopener\">介绍链接</a></td></tr></tbody></table><h4 id=\"绝对长度\"><a href=\"#绝对长度\" class=\"headerlink\" title=\"绝对长度\"></a>绝对长度</h4><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td></tr><tr><td>mm</td><td>毫米</td></tr><tr><td>in</td><td>英寸 (1in = 96px = 2.54cm)</td></tr><tr><td>px</td><td>像素 (1px = 1/96 of 1in)</td></tr><tr><td>pt</td><td>point，大约1/72英寸； (1pt = 1/72in)</td></tr><tr><td>pc</td><td>pica，大约6pt，1/6英寸； (1pc = 12 pt)</td></tr></tbody></table><h3 id=\"网页渲染的流程\"><a href=\"#网页渲染的流程\" class=\"headerlink\" title=\"网页渲染的流程\"></a>网页渲染的流程</h3><p>参考：<a href=\"https://www.cnblogs.com/dojo-lzz/p/3983335.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/dojo-lzz/p/3983335.html</a></p><p>页面解析渲染该过程主要分为以下步骤：</p><ol><li>解析HTML</li><li>构建DOM树</li><li>DOM树与CSS样式进行附着构造呈现树</li><li>布局</li><li>绘制</li></ol><ul><li>浏览器怎么知道收到的包是html文件（content-type）</li><li>CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行）</li><li>知道哪些content-type（<a href=\"https://blog.csdn.net/luyu13141314/article/details/81129069?utm_source=copy\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>）<ul><li><strong>text/html</strong> ：HTML格式</li><li><strong>text/plain</strong> ：纯文本格式</li><li><strong>text/xml</strong> ：XML格式</li><li><strong>image/gif</strong> ：gif图片格式</li><li><strong>image/jpeg</strong> ：jpg图片格式</li><li><strong>image/png</strong> ：png图片格式</li><li><strong>application/xml</strong> ： XML数据格式</li><li><strong>application/json</strong> ： JSON数据格式</li><li><strong>application/pdf</strong> ： pdf格式</li><li><strong>application/msword</strong> ： Word文档格式</li><li><strong>application/octet-stream</strong> ： 二进制流数据（如文件下载）</li><li><strong>application/x-www-form-urlencoded</strong> ： POST 提交数据</li><li><strong>multipart/form-data</strong> ： 表单上传文件</li></ul></li><li>bfc（<a href=\"https://www.cnblogs.com/dojo-lzz/p/3999013.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">看这里</a>）</li><li>清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear）</li><li>水平方向有margin叠加么（没有）</li></ul><h3 id=\"JS继承\"><a href=\"#JS继承\" class=\"headerlink\" title=\"JS继承\"></a>JS继承</h3><ol><li>工厂模式</li><li>构造函数模式</li><li>原型链模式</li><li>组合使用构造器和原型链模式</li><li>原型式继承（浅拷贝）</li><li>寄生式继承（5的增强版）</li><li>寄生组合式继承</li></ol><ul><li>原型继承可以继承非原型属性么</li><li>修正constructor</li><li>apply/call方法和原型方法的区别</li></ul><h3 id=\"vue：v-model\"><a href=\"#vue：v-model\" class=\"headerlink\" title=\"vue：v-model\"></a>vue：v-model</h3><p>双向绑定</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">v-model</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>searchText<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n</code></pre><p>等价于：</p><pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span>\n  <span class=\"token attr-name\"><span class=\"token namespace\">v-bind:</span>value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>searchText<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\"><span class=\"token namespace\">v-on:</span>input</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>searchText <span class=\"token punctuation\">=</span> $event.target.value<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">></span></span>\n</code></pre><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p><a href=\"https://www.cnblogs.com/tongkey/p/7170826.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">23种设计模式</a></p><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul><li>用来解决哪些问题</li><li>只能用闭包实现么</li><li>写个单例模式</li></ul><h3 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h3><p>在当前作用域下，js运行之前，会把带有var和function关键字的事先<strong>声明</strong>，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。</p><h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><ul><li>已知父节点获取第一个子节点（parentObj.firstChild）</li><li>查兄弟节点（previousSibing前一个，nextSibing后一个）</li><li>在某个子节点后面插入节点（insertBefore()）</li></ul><h3 id=\"对象的存储方式\"><a href=\"#对象的存储方式\" class=\"headerlink\" title=\"对象的存储方式\"></a>对象的存储方式</h3><p>实际存储在堆中，在栈中存储的是堆内存储地址。</p><p>所以可以把变量名看做指针。</p><h3 id=\"内存回收方式\"><a href=\"#内存回收方式\" class=\"headerlink\" title=\"内存回收方式\"></a>内存回收方式</h3><p>标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题）</p><h3 id=\"String为什么有length属性\"><a href=\"#String为什么有length属性\" class=\"headerlink\" title=\"String为什么有length属性\"></a>String为什么有length属性</h3><p>基本包装类型</p><h3 id=\"已知一个function-ClassA-，如何使得new-ClassA-和ClassA-返回的值都是新的实例\"><a href=\"#已知一个function-ClassA-，如何使得new-ClassA-和ClassA-返回的值都是新的实例\" class=\"headerlink\" title=\"已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例\"></a>已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例</h3><p>函数内部判断this是否为window</p><h3 id=\"用数据结构表示项目之间的依赖\"><a href=\"#用数据结构表示项目之间的依赖\" class=\"headerlink\" title=\"用数据结构表示项目之间的依赖\"></a>用数据结构表示项目之间的依赖</h3><p>双向链表？map？不知道。。。</p><h3 id=\"判断一个图有没有环\"><a href=\"#判断一个图有没有环\" class=\"headerlink\" title=\"判断一个图有没有环\"></a>判断一个图有没有环</h3><p>无向图：不断去掉度为1的点</p><p>有向图：拓扑排序</p><h3 id=\"从输入url到显示完成了什么\"><a href=\"#从输入url到显示完成了什么\" class=\"headerlink\" title=\"从输入url到显示完成了什么\"></a>从输入url到显示完成了什么</h3><ol><li>用户输入URL地址</li><li>浏览器解析URL解析出主机名</li><li>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</li><li>浏览器将端口号从URL中解析出来</li><li>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</li><li>浏览器向服务器发送一条HTTP请求报文</li><li>服务器向浏览器返回一条HTTP响应报文</li><li>浏览器解析文档</li><li>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</li><li>关闭连接</li><li>渲染页面</li></ol><ul><li>浏览器会不会缓存dns<ul><li>会，不同浏览器缓存时间不一样</li></ul></li><li>https多了什么步骤<ul><li><strong>https</strong>: http + 通信加密 + 证书 + 完整性保护，http secure　</li><li><strong>证书</strong>可以证明服务器或客户端的身份</li><li><strong>ssl</strong>: secure socket layer，安全套接层</li><li>多了<strong>SSL安全套接层</strong>。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。</li></ul></li><li>假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）</li><li>浏览器解析数据是全部收到才解析还是边收边解析</li><li>如果加载<code>&lt;link&gt;</code>需要十秒，分别在head和body那么加载时用户会看到什么</li><li>script，同上，还有外联/内联</li></ul><h3 id=\"实现parse函数解析-b-1-amp-c-2这样的字段\"><a href=\"#实现parse函数解析-b-1-amp-c-2这样的字段\" class=\"headerlink\" title=\"实现parse函数解析?b=1&amp;c=2这样的字段\"></a>实现parse函数解析?b=1&amp;c=2这样的字段</h3><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">myParse</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arg <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&amp;'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arg<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    obj<span class=\"token punctuation\">[</span>arg<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'='</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3 id=\"箭头函数的区别，能当做构造函数么\"><a href=\"#箭头函数的区别，能当做构造函数么\" class=\"headerlink\" title=\"箭头函数的区别，能当做构造函数么\"></a>箭头函数的区别，能当做构造函数么</h3><h3 id=\"ES6如何获取函数参数\"><a href=\"#ES6如何获取函数参数\" class=\"headerlink\" title=\"ES6如何获取函数参数\"></a>ES6如何获取函数参数</h3><h3 id=\"setTimeout准时么\"><a href=\"#setTimeout准时么\" class=\"headerlink\" title=\"setTimeout准时么\"></a>setTimeout准时么</h3><h3 id=\"ES6手写观察者模式\"><a href=\"#ES6手写观察者模式\" class=\"headerlink\" title=\"ES6手写观察者模式\"></a>ES6手写观察者模式</h3><h3 id=\"产生0-100的随机数\"><a href=\"#产生0-100的随机数\" class=\"headerlink\" title=\"产生0-100的随机数\"></a>产生0-100的随机数</h3><h3 id=\"http报文结构，header有哪些字段\"><a href=\"#http报文结构，header有哪些字段\" class=\"headerlink\" title=\"http报文结构，header有哪些字段\"></a>http报文结构，header有哪些字段</h3><h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><h3 id=\"手写所有排序算法和DFS、BFS\"><a href=\"#手写所有排序算法和DFS、BFS\" class=\"headerlink\" title=\"手写所有排序算法和DFS、BFS\"></a>手写所有排序算法和DFS、BFS</h3><p>快排、堆排、基数排序</p><h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p>标准盒模型和IE盒模型</p><h3 id=\"session和cookie区别\"><a href=\"#session和cookie区别\" class=\"headerlink\" title=\"session和cookie区别\"></a>session和cookie区别</h3><h3 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h3><p>浏览器根据元素的标签和属性，来决定元素的具体显示内容</p><p>img、input、textarea、select、obejct、button、label都是替换元素（置换元素）</p><h3 id=\"面向对象的特性\"><a href=\"#面向对象的特性\" class=\"headerlink\" title=\"面向对象的特性\"></a>面向对象的特性</h3><h3 id=\"C-怎么实现多态的\"><a href=\"#C-怎么实现多态的\" class=\"headerlink\" title=\"C++怎么实现多态的\"></a>C++怎么实现多态的</h3><h3 id=\"同步异步区别\"><a href=\"#同步异步区别\" class=\"headerlink\" title=\"同步异步区别\"></a>同步异步区别</h3><h3 id=\"js异步加载方法\"><a href=\"#js异步加载方法\" class=\"headerlink\" title=\"js异步加载方法\"></a>js异步加载方法</h3><h3 id=\"串行和并行\"><a href=\"#串行和并行\" class=\"headerlink\" title=\"串行和并行\"></a>串行和并行</h3><h3 id=\"数据库index及实现\"><a href=\"#数据库index及实现\" class=\"headerlink\" title=\"数据库index及实现\"></a>数据库index及实现</h3><h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><h3 id=\"进程间通信方法\"><a href=\"#进程间通信方法\" class=\"headerlink\" title=\"进程间通信方法\"></a>进程间通信方法</h3><h3 id=\"进程或线程的同步方法\"><a href=\"#进程或线程的同步方法\" class=\"headerlink\" title=\"进程或线程的同步方法\"></a>进程或线程的同步方法</h3><h3 id=\"虚拟DOM的作用\"><a href=\"#虚拟DOM的作用\" class=\"headerlink\" title=\"虚拟DOM的作用\"></a>虚拟DOM的作用</h3><h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><h3 id=\"position\"><a href=\"#position\" class=\"headerlink\" title=\"position\"></a>position</h3><h3 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h3><h3 id=\"圣杯布局、双飞翼布局\"><a href=\"#圣杯布局、双飞翼布局\" class=\"headerlink\" title=\"圣杯布局、双飞翼布局\"></a>圣杯布局、双飞翼布局</h3><h3 id=\"动画实现div无限旋转\"><a href=\"#动画实现div无限旋转\" class=\"headerlink\" title=\"动画实现div无限旋转\"></a>动画实现div无限旋转</h3><h3 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h3><h3 id=\"304实现原理\"><a href=\"#304实现原理\" class=\"headerlink\" title=\"304实现原理\"></a>304实现原理</h3><h3 id=\"webSocket是哪一层的\"><a href=\"#webSocket是哪一层的\" class=\"headerlink\" title=\"webSocket是哪一层的\"></a>webSocket是哪一层的</h3><p>应用层</p><h3 id=\"实现add-1-2-3-6\"><a href=\"#实现add-1-2-3-6\" class=\"headerlink\" title=\"实现add(1)(2)(3) == 6\"></a>实现add(1)(2)(3) == 6</h3><h3 id=\"js是单线程的，如何实现定时\"><a href=\"#js是单线程的，如何实现定时\" class=\"headerlink\" title=\"js是单线程的，如何实现定时\"></a>js是单线程的，如何实现定时</h3><h3 id=\"ES6代理\"><a href=\"#ES6代理\" class=\"headerlink\" title=\"ES6代理\"></a>ES6代理</h3><h3 id=\"计算一个数转换成二进制后1的个数\"><a href=\"#计算一个数转换成二进制后1的个数\" class=\"headerlink\" title=\"计算一个数转换成二进制后1的个数\"></a>计算一个数转换成二进制后1的个数</h3><h3 id=\"HTTP长连接\"><a href=\"#HTTP长连接\" class=\"headerlink\" title=\"HTTP长连接\"></a>HTTP长连接</h3><h3 id=\"状态码5xx\"><a href=\"#状态码5xx\" class=\"headerlink\" title=\"状态码5xx\"></a>状态码5xx</h3><h3 id=\"https默认端口\"><a href=\"#https默认端口\" class=\"headerlink\" title=\"https默认端口\"></a>https默认端口</h3><h3 id=\"tcp连接过程中的状态考察\"><a href=\"#tcp连接过程中的状态考察\" class=\"headerlink\" title=\"tcp连接过程中的状态考察\"></a>tcp连接过程中的状态考察</h3><h3 id=\"三次握手四次挥手详细\"><a href=\"#三次握手四次挥手详细\" class=\"headerlink\" title=\"三次握手四次挥手详细\"></a>三次握手四次挥手详细</h3><h3 id=\"http2-0\"><a href=\"#http2-0\" class=\"headerlink\" title=\"http2.0\"></a>http2.0</h3><h3 id=\"多路复用和1-x请求的区别\"><a href=\"#多路复用和1-x请求的区别\" class=\"headerlink\" title=\"多路复用和1.x请求的区别\"></a>多路复用和1.x请求的区别</h3><h3 id=\"unsigned-int类型扩展长度\"><a href=\"#unsigned-int类型扩展长度\" class=\"headerlink\" title=\"unsigned int类型扩展长度\"></a>unsigned int类型扩展长度</h3><h3 id=\"一个长度为一百万的数组中，超过一半都是某一个值，求这个值\"><a href=\"#一个长度为一百万的数组中，超过一半都是某一个值，求这个值\" class=\"headerlink\" title=\"一个长度为一百万的数组中，超过一半都是某一个值，求这个值\"></a>一个长度为一百万的数组中，超过一半都是某一个值，求这个值</h3><p><a href=\"https://www.cnblogs.com/yanliang12138/p/4763743.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/yanliang12138/p/4763743.html</a></p><h3 id=\"渐进增强和优雅降级\"><a href=\"#渐进增强和优雅降级\" class=\"headerlink\" title=\"渐进增强和优雅降级\"></a>渐进增强和优雅降级</h3><h3 id=\"前端缓存机制\"><a href=\"#前端缓存机制\" class=\"headerlink\" title=\"前端缓存机制\"></a>前端缓存机制</h3><h3 id=\"没有辅助空间的情况下交换两个数的值\"><a href=\"#没有辅助空间的情况下交换两个数的值\" class=\"headerlink\" title=\"没有辅助空间的情况下交换两个数的值\"></a>没有辅助空间的情况下交换两个数的值</h3><h3 id=\"前端安全\"><a href=\"#前端安全\" class=\"headerlink\" title=\"前端安全\"></a>前端安全</h3><h3 id=\"let暂时性死区和块级作用域\"><a href=\"#let暂时性死区和块级作用域\" class=\"headerlink\" title=\"let暂时性死区和块级作用域\"></a>let暂时性死区和块级作用域</h3><h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><h3 id=\"for-in-缺点\"><a href=\"#for-in-缺点\" class=\"headerlink\" title=\"for in 缺点\"></a>for in 缺点</h3><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><h3 id=\"ES6中map遍历实现原理\"><a href=\"#ES6中map遍历实现原理\" class=\"headerlink\" title=\"ES6中map遍历实现原理\"></a>ES6中map遍历实现原理</h3><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><h3 id=\"https详细过程\"><a href=\"#https详细过程\" class=\"headerlink\" title=\"https详细过程\"></a>https详细过程</h3><p>加密算法，对称还是非对称。md5,SHA,AES</p><h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>webpack、AMD、CMD</p><h3 id=\"数组的各种方法\"><a href=\"#数组的各种方法\" class=\"headerlink\" title=\"数组的各种方法\"></a>数组的各种方法</h3><h3 id=\"内存换页算法\"><a href=\"#内存换页算法\" class=\"headerlink\" title=\"内存换页算法\"></a>内存换页算法</h3><h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><h3 id=\"ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\"><a href=\"#ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\" class=\"headerlink\" title=\"ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\"></a>ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理</h3><h3 id=\"手写封装jsonp\"><a href=\"#手写封装jsonp\" class=\"headerlink\" title=\"手写封装jsonp\"></a>手写封装jsonp</h3><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><h3 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h3><h3 id=\"soket阻塞模式\"><a href=\"#soket阻塞模式\" class=\"headerlink\" title=\"soket阻塞模式\"></a>soket阻塞模式</h3><h3 id=\"doctype\"><a href=\"#doctype\" class=\"headerlink\" title=\"doctype\"></a>doctype</h3><h3 id=\"AJAX实现原理，手写实现\"><a href=\"#AJAX实现原理，手写实现\" class=\"headerlink\" title=\"AJAX实现原理，手写实现\"></a>AJAX实现原理，手写实现</h3>","site":{"data":{}},"excerpt":"<h3 id=\"js的基本数据类型\"><a href=\"#js的基本数据类型\" class=\"headerlink\" title=\"js的基本数据类型\"></a>js的基本数据类型</h3><p>Undefined、Null、Boolean、Number、String五种基本数据类型</p>","more":"<h3 id=\"获取变量的数据类型有哪些方法\"><a href=\"#获取变量的数据类型有哪些方法\" class=\"headerlink\" title=\"获取变量的数据类型有哪些方法\"></a>获取变量的数据类型有哪些方法</h3><ol><li><p><code>typeof</code>，返回六种结果：undefined、boolean、number、string、object、function</p><pre><code class=\"js\">typeof &#39;&#39;; // string\ntypeof 1; // number\ntypeof true; // boolean\ntypeof undefined; // undefined\ntypeof null; //object\ntypeof []; // object\ntypeof new Function(); //function\ntypeof new Date(); //object\ntypeof new RegExp(); //object\n</code></pre></li><li><p><code>instanceof</code>，判断是否是一个类的实例</p><pre><code class=\"js\">true instanceof Boolean; // false\n1 instanceof Number; // false\n&#39;&#39; instanceof String; // false\n[] instanceof Array; // true\n({}) instanceof Object; // true\n(function(){}) instanceof Function; // true\nnew Boolean(true) instanceof Boolean; // true\n</code></pre></li><li><p><code>constructor</code>，一个类的prototype会指向自己的引用。</p><p>需要注意的是：</p><ul><li><code>null</code>和<code>undefined</code>是无效的对象，因此没有constructor，需要通过typeof来判断。</li><li>JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。</li></ul><pre><code class=\"js\">&#39;&#39;.constructor == String; // true\n(1).constructor Number; // true\ntrue.constructor == Boolean; // true\nnew Function().constructor == Function; // true\nnew Date().constructor == Date; //true\n</code></pre></li><li><p><code>Object.prototype.toString</code></p><pre><code class=\"js\">Object.prototype.toString.call(&#39;&#39;);   //[object String]\nObject.prototype.toString.call(1);    //[object Number]\nObject.prototype.toString.call(true); //[object Boolean]\nObject.prototype.toString.call(undefined); //[object Undefined]\nObject.prototype.toString.call(null); //[object Null]\nObject.prototype.toString.call(new Function()); //[object Function]\nObject.prototype.toString.call(new Date()); //[object Date]\nObject.prototype.toString.call([]); //[object Array]\nObject.prototype.toString.call(new RegExp()); //[object RegExp]\nObject.prototype.toString.call(new Error()); //[object Error]\nObject.prototype.toString.call(document); //[object HTMLDocument]\nObject.prototype.toString.call(window); //[object global] window是全局对象global的引用\n// 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy \n</code></pre></li></ol><h3 id=\"JS的拷贝？\"><a href=\"#JS的拷贝？\" class=\"headerlink\" title=\"JS的拷贝？\"></a>JS的拷贝？</h3><p>基本数据类型会新开辟一个数据段来保存值，</p><p>但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。</p><h3 id=\"深拷贝的方法\"><a href=\"#深拷贝的方法\" class=\"headerlink\" title=\"深拷贝的方法\"></a>深拷贝的方法</h3><p>需要注意的是：slice()和concat()只深拷贝了一级属性。</p><ol><li><p>递归复制所有属性</p><pre><code class=\"js\">function deepClone(arg) {\n  if (arg == null || typeof arg != &#39;object&#39;) return arg;\n  let newObj = Array.isArray(arg) ? [] : {};\n  for (let key in arg) {\n    if (arg[key] != null &amp;&amp; typeof arg[key] == &#39;object&#39;) {\n      newObj[key] = deepClone(arg[key]);\n    } else {\n      newObj[key] = arg[key];\n    }\n  }\n  return newObj;\n}\n</code></pre></li><li><p>使用JSON的parse和stringify</p><pre><code class=\"js\">function deepClone(arg) {\n  return typeof arg == &#39;object&#39; ? argJSON.parse(JSON.stringify(arg)) : arg;\n}\n</code></pre></li><li><p>使用JQuery的extend方法</p><p><code>$.extend([deep], target, object1[, objectN ])</code></p><ul><li>用于将一个或多个对象的内容合并到目标对象</li><li>如果多个对象具有相同的属性，则后者会覆盖前者的属性值</li></ul><pre><code class=\"js\">function deepClone(arg) {\n  if (arg == null || typeof arg != &#39;object&#39;) return arg;\n  if (arg instanceof Array) return $.extend(true,[],arg);\n  else return $.extend(true,{},arg);\n}\n</code></pre></li></ol><h3 id=\"CSS单位有哪些\"><a href=\"#CSS单位有哪些\" class=\"headerlink\" title=\"CSS单位有哪些\"></a>CSS单位有哪些</h3><h4 id=\"相对长度\"><a href=\"#相对长度\" class=\"headerlink\" title=\"相对长度\"></a>相对长度</h4><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>em</td><td>它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；</td></tr><tr><td>ex</td><td>依赖于英文子母小 x 的高度</td></tr><tr><td>ch</td><td>数字 0 的宽度</td></tr><tr><td>rem</td><td>根元素（html）的 font-size</td></tr><tr><td>vw</td><td>viewpoint width，视窗宽度，1vw=视窗宽度的1%</td></tr><tr><td>vh</td><td>viewpoint height，视窗高度，1vh=视窗高度的1%</td></tr><tr><td>vmin</td><td>vw和vh中较小的那个。</td></tr><tr><td>vmax</td><td>vw和vh中较大的那个。</td></tr><tr><td>%</td><td><a href=\"https://blog.zmj97.top/2018/09/10/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#%E7%99%BE%E5%88%86%E6%AF%94\" target=\"_blank\" rel=\"noopener\">介绍链接</a></td></tr></tbody></table><h4 id=\"绝对长度\"><a href=\"#绝对长度\" class=\"headerlink\" title=\"绝对长度\"></a>绝对长度</h4><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td></tr><tr><td>mm</td><td>毫米</td></tr><tr><td>in</td><td>英寸 (1in = 96px = 2.54cm)</td></tr><tr><td>px</td><td>像素 (1px = 1/96 of 1in)</td></tr><tr><td>pt</td><td>point，大约1/72英寸； (1pt = 1/72in)</td></tr><tr><td>pc</td><td>pica，大约6pt，1/6英寸； (1pc = 12 pt)</td></tr></tbody></table><h3 id=\"网页渲染的流程\"><a href=\"#网页渲染的流程\" class=\"headerlink\" title=\"网页渲染的流程\"></a>网页渲染的流程</h3><p>参考：<a href=\"https://www.cnblogs.com/dojo-lzz/p/3983335.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/dojo-lzz/p/3983335.html</a></p><p>页面解析渲染该过程主要分为以下步骤：</p><ol><li>解析HTML</li><li>构建DOM树</li><li>DOM树与CSS样式进行附着构造呈现树</li><li>布局</li><li>绘制</li></ol><ul><li>浏览器怎么知道收到的包是html文件（content-type）</li><li>CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行）</li><li>知道哪些content-type（<a href=\"https://blog.csdn.net/luyu13141314/article/details/81129069?utm_source=copy\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">参考链接</a>）<ul><li><strong>text/html</strong> ：HTML格式</li><li><strong>text/plain</strong> ：纯文本格式</li><li><strong>text/xml</strong> ：XML格式</li><li><strong>image/gif</strong> ：gif图片格式</li><li><strong>image/jpeg</strong> ：jpg图片格式</li><li><strong>image/png</strong> ：png图片格式</li><li><strong>application/xml</strong> ： XML数据格式</li><li><strong>application/json</strong> ： JSON数据格式</li><li><strong>application/pdf</strong> ： pdf格式</li><li><strong>application/msword</strong> ： Word文档格式</li><li><strong>application/octet-stream</strong> ： 二进制流数据（如文件下载）</li><li><strong>application/x-www-form-urlencoded</strong> ： POST 提交数据</li><li><strong>multipart/form-data</strong> ： 表单上传文件</li></ul></li><li>bfc（<a href=\"https://www.cnblogs.com/dojo-lzz/p/3999013.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">看这里</a>）</li><li>清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear）</li><li>水平方向有margin叠加么（没有）</li></ul><h3 id=\"JS继承\"><a href=\"#JS继承\" class=\"headerlink\" title=\"JS继承\"></a>JS继承</h3><ol><li>工厂模式</li><li>构造函数模式</li><li>原型链模式</li><li>组合使用构造器和原型链模式</li><li>原型式继承（浅拷贝）</li><li>寄生式继承（5的增强版）</li><li>寄生组合式继承</li></ol><ul><li>原型继承可以继承非原型属性么</li><li>修正constructor</li><li>apply/call方法和原型方法的区别</li></ul><h3 id=\"vue：v-model\"><a href=\"#vue：v-model\" class=\"headerlink\" title=\"vue：v-model\"></a>vue：v-model</h3><p>双向绑定</p><pre><code class=\"html\">&lt;input v-model=&quot;searchText&quot;&gt;\n</code></pre><p>等价于：</p><pre><code class=\"html\">&lt;input\n  v-bind:value=&quot;searchText&quot;\n  v-on:input=&quot;searchText = $event.target.value&quot;\n&gt;\n</code></pre><h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p><a href=\"https://www.cnblogs.com/tongkey/p/7170826.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">23种设计模式</a></p><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul><li>用来解决哪些问题</li><li>只能用闭包实现么</li><li>写个单例模式</li></ul><h3 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h3><p>在当前作用域下，js运行之前，会把带有var和function关键字的事先<strong>声明</strong>，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。</p><h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><ul><li>已知父节点获取第一个子节点（parentObj.firstChild）</li><li>查兄弟节点（previousSibing前一个，nextSibing后一个）</li><li>在某个子节点后面插入节点（insertBefore()）</li></ul><h3 id=\"对象的存储方式\"><a href=\"#对象的存储方式\" class=\"headerlink\" title=\"对象的存储方式\"></a>对象的存储方式</h3><p>实际存储在堆中，在栈中存储的是堆内存储地址。</p><p>所以可以把变量名看做指针。</p><h3 id=\"内存回收方式\"><a href=\"#内存回收方式\" class=\"headerlink\" title=\"内存回收方式\"></a>内存回收方式</h3><p>标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题）</p><h3 id=\"String为什么有length属性\"><a href=\"#String为什么有length属性\" class=\"headerlink\" title=\"String为什么有length属性\"></a>String为什么有length属性</h3><p>基本包装类型</p><h3 id=\"已知一个function-ClassA-，如何使得new-ClassA-和ClassA-返回的值都是新的实例\"><a href=\"#已知一个function-ClassA-，如何使得new-ClassA-和ClassA-返回的值都是新的实例\" class=\"headerlink\" title=\"已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例\"></a>已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例</h3><p>函数内部判断this是否为window</p><h3 id=\"用数据结构表示项目之间的依赖\"><a href=\"#用数据结构表示项目之间的依赖\" class=\"headerlink\" title=\"用数据结构表示项目之间的依赖\"></a>用数据结构表示项目之间的依赖</h3><p>双向链表？map？不知道。。。</p><h3 id=\"判断一个图有没有环\"><a href=\"#判断一个图有没有环\" class=\"headerlink\" title=\"判断一个图有没有环\"></a>判断一个图有没有环</h3><p>无向图：不断去掉度为1的点</p><p>有向图：拓扑排序</p><h3 id=\"从输入url到显示完成了什么\"><a href=\"#从输入url到显示完成了什么\" class=\"headerlink\" title=\"从输入url到显示完成了什么\"></a>从输入url到显示完成了什么</h3><ol><li>用户输入URL地址</li><li>浏览器解析URL解析出主机名</li><li>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</li><li>浏览器将端口号从URL中解析出来</li><li>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</li><li>浏览器向服务器发送一条HTTP请求报文</li><li>服务器向浏览器返回一条HTTP响应报文</li><li>浏览器解析文档</li><li>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</li><li>关闭连接</li><li>渲染页面</li></ol><ul><li>浏览器会不会缓存dns<ul><li>会，不同浏览器缓存时间不一样</li></ul></li><li>https多了什么步骤<ul><li><strong>https</strong>: http + 通信加密 + 证书 + 完整性保护，http secure　</li><li><strong>证书</strong>可以证明服务器或客户端的身份</li><li><strong>ssl</strong>: secure socket layer，安全套接层</li><li>多了<strong>SSL安全套接层</strong>。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。</li></ul></li><li>假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）</li><li>浏览器解析数据是全部收到才解析还是边收边解析</li><li>如果加载<code>&lt;link&gt;</code>需要十秒，分别在head和body那么加载时用户会看到什么</li><li>script，同上，还有外联/内联</li></ul><h3 id=\"实现parse函数解析-b-1-amp-c-2这样的字段\"><a href=\"#实现parse函数解析-b-1-amp-c-2这样的字段\" class=\"headerlink\" title=\"实现parse函数解析?b=1&amp;c=2这样的字段\"></a>实现parse函数解析?b=1&amp;c=2这样的字段</h3><pre><code class=\"js\">function myParse(arg) {\n  arg = arg.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;);\n  let obj = {};\n  for (let i = 0; i &lt; arg.length; i++) {\n    obj[arg[i].split(&#39;=&#39;)[0]] = arg[i].split(&#39;=&#39;)[1];\n  }\n  return obj;\n}\n</code></pre><h3 id=\"箭头函数的区别，能当做构造函数么\"><a href=\"#箭头函数的区别，能当做构造函数么\" class=\"headerlink\" title=\"箭头函数的区别，能当做构造函数么\"></a>箭头函数的区别，能当做构造函数么</h3><h3 id=\"ES6如何获取函数参数\"><a href=\"#ES6如何获取函数参数\" class=\"headerlink\" title=\"ES6如何获取函数参数\"></a>ES6如何获取函数参数</h3><h3 id=\"setTimeout准时么\"><a href=\"#setTimeout准时么\" class=\"headerlink\" title=\"setTimeout准时么\"></a>setTimeout准时么</h3><h3 id=\"ES6手写观察者模式\"><a href=\"#ES6手写观察者模式\" class=\"headerlink\" title=\"ES6手写观察者模式\"></a>ES6手写观察者模式</h3><h3 id=\"产生0-100的随机数\"><a href=\"#产生0-100的随机数\" class=\"headerlink\" title=\"产生0-100的随机数\"></a>产生0-100的随机数</h3><h3 id=\"http报文结构，header有哪些字段\"><a href=\"#http报文结构，header有哪些字段\" class=\"headerlink\" title=\"http报文结构，header有哪些字段\"></a>http报文结构，header有哪些字段</h3><h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><h3 id=\"手写所有排序算法和DFS、BFS\"><a href=\"#手写所有排序算法和DFS、BFS\" class=\"headerlink\" title=\"手写所有排序算法和DFS、BFS\"></a>手写所有排序算法和DFS、BFS</h3><p>快排、堆排、基数排序</p><h3 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h3><p>标准盒模型和IE盒模型</p><h3 id=\"session和cookie区别\"><a href=\"#session和cookie区别\" class=\"headerlink\" title=\"session和cookie区别\"></a>session和cookie区别</h3><h3 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h3><p>浏览器根据元素的标签和属性，来决定元素的具体显示内容</p><p>img、input、textarea、select、obejct、button、label都是替换元素（置换元素）</p><h3 id=\"面向对象的特性\"><a href=\"#面向对象的特性\" class=\"headerlink\" title=\"面向对象的特性\"></a>面向对象的特性</h3><h3 id=\"C-怎么实现多态的\"><a href=\"#C-怎么实现多态的\" class=\"headerlink\" title=\"C++怎么实现多态的\"></a>C++怎么实现多态的</h3><h3 id=\"同步异步区别\"><a href=\"#同步异步区别\" class=\"headerlink\" title=\"同步异步区别\"></a>同步异步区别</h3><h3 id=\"js异步加载方法\"><a href=\"#js异步加载方法\" class=\"headerlink\" title=\"js异步加载方法\"></a>js异步加载方法</h3><h3 id=\"串行和并行\"><a href=\"#串行和并行\" class=\"headerlink\" title=\"串行和并行\"></a>串行和并行</h3><h3 id=\"数据库index及实现\"><a href=\"#数据库index及实现\" class=\"headerlink\" title=\"数据库index及实现\"></a>数据库index及实现</h3><h3 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h3><h3 id=\"进程间通信方法\"><a href=\"#进程间通信方法\" class=\"headerlink\" title=\"进程间通信方法\"></a>进程间通信方法</h3><h3 id=\"进程或线程的同步方法\"><a href=\"#进程或线程的同步方法\" class=\"headerlink\" title=\"进程或线程的同步方法\"></a>进程或线程的同步方法</h3><h3 id=\"虚拟DOM的作用\"><a href=\"#虚拟DOM的作用\" class=\"headerlink\" title=\"虚拟DOM的作用\"></a>虚拟DOM的作用</h3><h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><h3 id=\"position\"><a href=\"#position\" class=\"headerlink\" title=\"position\"></a>position</h3><h3 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h3><h3 id=\"圣杯布局、双飞翼布局\"><a href=\"#圣杯布局、双飞翼布局\" class=\"headerlink\" title=\"圣杯布局、双飞翼布局\"></a>圣杯布局、双飞翼布局</h3><h3 id=\"动画实现div无限旋转\"><a href=\"#动画实现div无限旋转\" class=\"headerlink\" title=\"动画实现div无限旋转\"></a>动画实现div无限旋转</h3><h3 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h3><h3 id=\"304实现原理\"><a href=\"#304实现原理\" class=\"headerlink\" title=\"304实现原理\"></a>304实现原理</h3><h3 id=\"webSocket是哪一层的\"><a href=\"#webSocket是哪一层的\" class=\"headerlink\" title=\"webSocket是哪一层的\"></a>webSocket是哪一层的</h3><p>应用层</p><h3 id=\"实现add-1-2-3-6\"><a href=\"#实现add-1-2-3-6\" class=\"headerlink\" title=\"实现add(1)(2)(3) == 6\"></a>实现add(1)(2)(3) == 6</h3><h3 id=\"js是单线程的，如何实现定时\"><a href=\"#js是单线程的，如何实现定时\" class=\"headerlink\" title=\"js是单线程的，如何实现定时\"></a>js是单线程的，如何实现定时</h3><h3 id=\"ES6代理\"><a href=\"#ES6代理\" class=\"headerlink\" title=\"ES6代理\"></a>ES6代理</h3><h3 id=\"计算一个数转换成二进制后1的个数\"><a href=\"#计算一个数转换成二进制后1的个数\" class=\"headerlink\" title=\"计算一个数转换成二进制后1的个数\"></a>计算一个数转换成二进制后1的个数</h3><h3 id=\"HTTP长连接\"><a href=\"#HTTP长连接\" class=\"headerlink\" title=\"HTTP长连接\"></a>HTTP长连接</h3><h3 id=\"状态码5xx\"><a href=\"#状态码5xx\" class=\"headerlink\" title=\"状态码5xx\"></a>状态码5xx</h3><h3 id=\"https默认端口\"><a href=\"#https默认端口\" class=\"headerlink\" title=\"https默认端口\"></a>https默认端口</h3><h3 id=\"tcp连接过程中的状态考察\"><a href=\"#tcp连接过程中的状态考察\" class=\"headerlink\" title=\"tcp连接过程中的状态考察\"></a>tcp连接过程中的状态考察</h3><h3 id=\"三次握手四次挥手详细\"><a href=\"#三次握手四次挥手详细\" class=\"headerlink\" title=\"三次握手四次挥手详细\"></a>三次握手四次挥手详细</h3><h3 id=\"http2-0\"><a href=\"#http2-0\" class=\"headerlink\" title=\"http2.0\"></a>http2.0</h3><h3 id=\"多路复用和1-x请求的区别\"><a href=\"#多路复用和1-x请求的区别\" class=\"headerlink\" title=\"多路复用和1.x请求的区别\"></a>多路复用和1.x请求的区别</h3><h3 id=\"unsigned-int类型扩展长度\"><a href=\"#unsigned-int类型扩展长度\" class=\"headerlink\" title=\"unsigned int类型扩展长度\"></a>unsigned int类型扩展长度</h3><h3 id=\"一个长度为一百万的数组中，超过一半都是某一个值，求这个值\"><a href=\"#一个长度为一百万的数组中，超过一半都是某一个值，求这个值\" class=\"headerlink\" title=\"一个长度为一百万的数组中，超过一半都是某一个值，求这个值\"></a>一个长度为一百万的数组中，超过一半都是某一个值，求这个值</h3><p><a href=\"https://www.cnblogs.com/yanliang12138/p/4763743.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.cnblogs.com/yanliang12138/p/4763743.html</a></p><h3 id=\"渐进增强和优雅降级\"><a href=\"#渐进增强和优雅降级\" class=\"headerlink\" title=\"渐进增强和优雅降级\"></a>渐进增强和优雅降级</h3><h3 id=\"前端缓存机制\"><a href=\"#前端缓存机制\" class=\"headerlink\" title=\"前端缓存机制\"></a>前端缓存机制</h3><h3 id=\"没有辅助空间的情况下交换两个数的值\"><a href=\"#没有辅助空间的情况下交换两个数的值\" class=\"headerlink\" title=\"没有辅助空间的情况下交换两个数的值\"></a>没有辅助空间的情况下交换两个数的值</h3><h3 id=\"前端安全\"><a href=\"#前端安全\" class=\"headerlink\" title=\"前端安全\"></a>前端安全</h3><h3 id=\"let暂时性死区和块级作用域\"><a href=\"#let暂时性死区和块级作用域\" class=\"headerlink\" title=\"let暂时性死区和块级作用域\"></a>let暂时性死区和块级作用域</h3><h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><h3 id=\"for-in-缺点\"><a href=\"#for-in-缺点\" class=\"headerlink\" title=\"for in 缺点\"></a>for in 缺点</h3><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><h3 id=\"ES6中map遍历实现原理\"><a href=\"#ES6中map遍历实现原理\" class=\"headerlink\" title=\"ES6中map遍历实现原理\"></a>ES6中map遍历实现原理</h3><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><h3 id=\"https详细过程\"><a href=\"#https详细过程\" class=\"headerlink\" title=\"https详细过程\"></a>https详细过程</h3><p>加密算法，对称还是非对称。md5,SHA,AES</p><h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>webpack、AMD、CMD</p><h3 id=\"数组的各种方法\"><a href=\"#数组的各种方法\" class=\"headerlink\" title=\"数组的各种方法\"></a>数组的各种方法</h3><h3 id=\"内存换页算法\"><a href=\"#内存换页算法\" class=\"headerlink\" title=\"内存换页算法\"></a>内存换页算法</h3><h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><h3 id=\"ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\"><a href=\"#ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\" class=\"headerlink\" title=\"ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理\"></a>ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理</h3><h3 id=\"手写封装jsonp\"><a href=\"#手写封装jsonp\" class=\"headerlink\" title=\"手写封装jsonp\"></a>手写封装jsonp</h3><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><h3 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h3><h3 id=\"soket阻塞模式\"><a href=\"#soket阻塞模式\" class=\"headerlink\" title=\"soket阻塞模式\"></a>soket阻塞模式</h3><h3 id=\"doctype\"><a href=\"#doctype\" class=\"headerlink\" title=\"doctype\"></a>doctype</h3><h3 id=\"AJAX实现原理，手写实现\"><a href=\"#AJAX实现原理，手写实现\" class=\"headerlink\" title=\"AJAX实现原理，手写实现\"></a>AJAX实现原理，手写实现</h3>"},{"title":"遇见逆水寒男号女NPC奇物好感统计","toc":true,"date":"2018-08-23T11:42:20.000Z","_content":"\n特别感谢[秦沨_JONAS](https://weibo.com/u/3744087174?source=webim)及其小伙伴们的辛苦统计！\n\n<!-- more -->\n\n---\n\n\n\n### B\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 半截蜡烛 | 2      | 2      | 2    | 2      | 5      |\n| 拨浪鼓   | 10     | 15     | 20   | 15     | 10     |\n| 筚篥     | 15     | 10     | 10   | 20     | 10     |\n| 薄荷     | 10     | 15     | 10   | 15     | 15     |\n| 剥皮小刀 | 20     | 10     | 15   | 10     | 10     |\n| 冰糖糕   | 15     | 15     | 10   | 15     | 15     |\n| 布老虎   |        | 15     | 10   |        |        |\n| 碧血战铠 | 15     | 5      | 5    | 5      | 5      |\n| 碧血战籍 | 15     | 10     | 5    | 5      | 5      |\n| 碧血毒蝎 | 20     | 5      | 5    | 5      | 5      |\n\n### C\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 草帽     | 15   | 15   | 10   | 10   | 10   |\n| 彩球     | 10 | 15 | 10   | 15   | 15   |\n| 词韵曲谱 |      | 15   |      | 20   | 15   |\n| 蹴鞠     | 10   | 10   | 20   | 10   | 10   |\n\n### D\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 冬虫夏草 | 10   | 10   | 10 |      | 20   |\n\n### F\n\n[返回首字母索引](#首字母索引)\n\n| 道具   | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| ------ | ------ | ------ | ---- | ------ | ------ |\n| 风俗画 | 5      | 5      |      |        | 20     |\n\n### G\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 弓箭     | 15   | 10   | 15   | 10   | 10   |\n| 枸杞     |      | 10   |      |      | 15   |\n| 蝈蝈笼   | 10   | 15   | 15   | 10   | 15   |\n| 关外鹿肉 | 10   | 10   | 15   | 10   | 10   |\n| 高丽泡菜 | 5    | 10   | 5    | 10   | 15   |\n| 鬼谷算盘 |      | 5    | 10   | 5    | 5 |\n| 关外鹿皮 | 15   | 10   | 15   | 10   | 10   |\n| 关外人参 | 15   | 10   | 15   | 15   | 20   |\n\n### H\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 花盆土     | 2    | 5    | 2    | 2    | 2    |\n| 红泪面脂 | 15 | 15 | 15 | 20 | 20 |\n| 花瓶       | 2    | 5    | 5    | 5    | 2    |\n| 虎皮围裙   | 10   | 10   | 15   | 10   | 10   |\n| 虎骨酒     | 15   | 5    | 15   | 10   | 10   |\n| 荷包       | 10   | 10   | 10   | 15   | 15   |\n| 和田玉坠   | 10   | 15   | 15   | 15   | 20   |\n| 和田玉石   | 10   | 15   | 15   | 20   | 20   |\n| 毁诺城女装 | 5    | 15   | 20   | 15   | 15   |\n| 河豚       | 10   | 10   | 15   | 15   | 15   |\n| 化骨水     | 20   | 5    | 5    | 5    | 5    |\n| 海螺       | 15   | 15   | 10   | 15   | 15   |\n| 胡笳十八拍 | 5    | 10   | 5    | 20   | 15   |\n| 火铳       | 20   | 5    | 20   | 5    | 5    |\n| 黑白玲珑子 | 15   | 10   | 15   | 15   | 10   |\n\n### J\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 毽子       | 5    | 15   | 15   | 10   | 10   |\n| 鸡毛掸子   | 5    | 10   | 15   | 10   | 5    |\n| 金秀铁骨扇 | 15   | 10   | 15   | 10   | 10   |\n| 金丝楠木   | 15   | 10   | 15   | 15   | 10   |\n| 绢花绸伞   | 10   | 15   | 10   | 15   | 15   |\n| 嘉禾肉粽   | 10   | 15   | 5    | 15   | 15   |\n| 机械鸟     | 15   | 15   | 20   | 15   | 10   |\n| 江山笔记   | 10   | 10   | 10   | 10 | 10 |\n| 剑门豆腐   | 15   | 15   | 15   | 15   | 15   |\n| 酒葫芦     | 10   | 10   | 15   | 10   | 15   |\n| 金叶子     | 10   | 10   | 10   | 15   | 15   |\n\n### K\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 孔雀石 | 10   | 15   | 10     | 15   | 20   |\n| 孔雀翎 |      | 15 | 10（20 | 15   | 15   |\n\n### L\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 绿茶茶叶   | 5    | 2    | 2    | 5    | 5    |\n| 莲花河灯   | 10   | 20   |      |      |      |\n| 狼毫笔     | 2    | 2    | 2    | 5    | 2    |\n| 鎏金碧玉勺 | 10   | 15   | 10   | 15   | 15   |\n| 楼兰蜜酒   | 10   | 15   | 15   | 15   | 20   |\n| 灵芝       | 15   | 15   | 15   | 20   | 20   |\n| 龙井黑猪肉 | 10   | 10   | 5 |      |      |\n| 柳笛       | 10   | 15   | 10   | 15   | 15   |\n| 龙渊       | 20   | 10   | 15   | 10   | 10   |\n\n### M\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 磨刀石   | 2    | 2    | 5    | 2    | 2    |\n| 沐浴香药 | 15   | 10   | 15   | 20   | 20   |\n| 明前龙井 |      | 15 | 10   | 20   |      |\n| 美人图 | |  |  |  | 20 |\n| 棉花     | 5    | 5    | 2    | 2    | 2    |\n\n### N\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 女儿红 | 10   | 15   | 20   | 15   | 15   |\n| 泥鳅   | 5    | 5    | 15   | 5    | 15   |\n\n### P\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 判官笔     | 5    | 5    | 5    | 10   | 10   |\n| 苹果       | 5    | 20   |      |      |      |\n| 霹雳堂火器 | 20   | 5    | 20   | 5    | 5    |\n| 霹雳堂炮仗 | 15   | 5    | 20   |      |      |\n\n### Q\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 青城脸谱   | 15   | 5      | 15   | 10   | 5    |\n| 邛窑茶盏   | 15   | 15     | 10   | 20   | 15   |\n| 契丹瓜子   | 15   | 15     | 15   | 10   | 15   |\n| 契丹牛乳   | 15   | 15     | 15   | 10   | 15   |\n| 青铜锭     | 5    | 10     | 5    | 10   | 10   |\n| 庆力善治方 | 10   | 10（15 | 10   | 10   | 10   |\n\n### R\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 阮       |      |      | 5    | 20   |      |\n| 汝窑茶盏 | 10   | 15   | 10   | 20   | 10   |\n\n### S\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 神秘妆匣   | 2    | 2    | 2    | 2    | 2    |\n| 时空碎片   | 2    | 2    | 2    | 2    | 2    |\n| 锁子甲     | 15   | 5    | 15   | 5    | 5    |\n| 水域全图   | 15   | 10   | 15   | 10   | 10 |\n| 兽皮包裹   | 15   | 10   | 15   | 10   | 10   |\n| 碎月海龟   | 10   | 10   | 15   | 15   | 10   |\n| 碎月明虾   | 15   | 15   | 10   | 15   | 15   |\n| 扇子       | 10   | 15   | 10   | 15   | 15   |\n| 蒜香排骨   |      | 10   | 10   | 5    | 10   |\n| 梳妆匣     | 10   | 15   | 20   | 20   | 20   |\n| 蛇骨手串   | 20   | 5    | 15   | 10   | 10   |\n| 司南       | 15   | 15   | 15   | 10   | 10   |\n| 三合美酒   | 10   | 15   | 20   | 15   | 15   |\n| 蓑衣（农家 | 15   | 10   | 10   | 10   | 10   |\n| 蓑衣（桃溪 | 15   |      |      |      |      |\n\n### T\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 陶罐     | 5    | 2    | 5    | 2    | 2    |\n| 桃溪钓竿 | 10   | 15 | 10   | 10 | 10   |\n| 桃溪花枝 | 10   | 20   |      | 10   | 10   |\n| 糖葫芦   | 10   | 20   | 15   | 15   | 10   |\n| 团扇     |      |      | 5    | 20   | 20   |\n| 桃木剑   | 10   | 15   | 10   | 10 | 10   |\n| 桃溪河虾 |  | 20 | 10 |  | 15 |\n| 桃花雪   | 10   | 20   | 15   | 15   | 15   |\n| 桃溪泥人 | 15   | 20 |      |      | 10   |\n| 桃溪豆腐 | 15   | 20   | 10   |      | 15   |\n| 铜镜     | 10   | 15   | 10   | 15   | 15 |\n| 铜丝手套 | 20   | 10   | 15   | 10   | 10   |\n\n### W\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 武经总要 | 5 | 10   | 5    | 10   | 5    |\n| 武安蹴鞠 | 10   | 10   | 20   | 5    | 10   |\n| 武林秘籍 | 20   | 10   | 15   | 5    | 5    |\n\n### X\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 小暖       | 15   | 20   | 20   | 15   | 10   |\n| 雪梨       | 15   | 15   | 10   | 15   | 15   |\n| 雪狐皮     | 20   | 15   | 15   | 15   | 15   |\n| 雪村鸡蛋   | 15   | 15   | 10   | 10 | 15 |\n| 熙春调味料 | 10   | 10   | 15   | 15   | 15   |\n| 宣州紫毫笔 | 10   | 15   | 10   | 15   | 10   |\n| 绣花娟帕   | 10   | 15   | 10   | 15   | 20   |\n| 西湖莲花   | 10   | 15   | 10 | 15   | 15   |\n| 西湖莲蓬   | 10   | 20   | 15   | 15   | 10   |\n| 西域葡萄   | 15   | 15   | 15   | 15   | 15   |\n| 西域炼乳   | 15   | 10   | 15   | 15   | 15   |\n\n### Y\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 一颗大白菜   | 2    | 2    | 2    | 2    | 2    |\n| 一块木板     | 2    | 2    | 2    | 2    | 2    |\n| 一块帆布     | 2    | 2    | 2    | 2    | 2    |\n| 一根茄子     | 2    | 2    | 2    | 2    | 5 |\n| 一根萝卜     | 2    | 2    | 2    | 2    | 2    |\n| 一片枫叶     | 5    | 5    | 2    | 2    | 5    |\n| 一袋面粉     | 2    | 2    | 2    | 2 | 2 |\n| 一捆麻绳     | 2    | 2    | 2    | 2    | 5    |\n| 一袋大麦     | 2    | 2    | 2    | 2    | 2    |\n| 一块粗麻布   | 2    | 2    | 2    | 2    | 2    |\n| 一袋麦麸     | 2    | 2    | 2    | 2    | 2    |\n| 一束桃花     |      | 20   |      | 15   | 15   |\n| 一袋红豆     | 2    | 2    | 2    | 5    | 2    |\n| 一捆线球     | 2    | 2    | 2    | 2    | 2    |\n| 一筐蔬菜     | 2    | 2    | 2    | 2    | 2    |\n| 一屉包子     | 10   |      |      |      | 10   |\n| 一只寒梅     | 20   |      |      |      | 15   |\n| 羊毫笔       | 2    | 2    | 2    | 5    | 2    |\n| 野生牛筋     | 10   | 10 | 15   |      | 10   |\n| 萤火虫       | 15   | 20   | 10   | 15   | 15   |\n| 云西竹笋     | 15   | 20   |      |      | 15   |\n| 月影碎空残卷 | 20   | 15   | 15   | 5    | 5    |\n| 养颜阿胶     | 20   | 20   | 20   | 20   | 20   |\n| 药粥         | 15   | 15   |      | 10 | 10 |\n| 玉扳指       | 20   | 5    | 15   | 15   | 15   |\n| 玉红叶       | 15   | 15   | 10   | 20   | 20   |\n\n### Z\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 针线包 | 2 | 5 | 2 | 2 | 2 |\n| 竹哨           | 15   | 15   | 10   | 10   | 10   |\n| 竹陀螺         | 10   | 15   | 20   | 10   | 10   |\n| 醉螺           | 10   | 10   | 15   | 10   | 15   |\n| 粽子           | 5 |      | 5    | 2 | 5    |\n| 竹笋           |      |      | 10   |      |      |\n| 竹竿           | 2    | 2    | 5    | 2    | 2 |\n| 追风翼（白帝城 | 15   | 10   | 20   | 10   | 10   |\n| 追风翼         | 15   | 10   | 15   | 10   | 10   |","source":"_posts/遇见逆水寒男号女NPC奇物好感统计.md","raw":"---\ntitle: 遇见逆水寒男号女NPC奇物好感统计\ntoc: true\ndate: 2018-08-23 19:42:20\ncategories:\ntags:\n- 遇见逆水寒\n---\n\n特别感谢[秦沨_JONAS](https://weibo.com/u/3744087174?source=webim)及其小伙伴们的辛苦统计！\n\n<!-- more -->\n\n---\n\n\n\n### B\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 半截蜡烛 | 2      | 2      | 2    | 2      | 5      |\n| 拨浪鼓   | 10     | 15     | 20   | 15     | 10     |\n| 筚篥     | 15     | 10     | 10   | 20     | 10     |\n| 薄荷     | 10     | 15     | 10   | 15     | 15     |\n| 剥皮小刀 | 20     | 10     | 15   | 10     | 10     |\n| 冰糖糕   | 15     | 15     | 10   | 15     | 15     |\n| 布老虎   |        | 15     | 10   |        |        |\n| 碧血战铠 | 15     | 5      | 5    | 5      | 5      |\n| 碧血战籍 | 15     | 10     | 5    | 5      | 5      |\n| 碧血毒蝎 | 20     | 5      | 5    | 5      | 5      |\n\n### C\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 草帽     | 15   | 15   | 10   | 10   | 10   |\n| 彩球     | 10 | 15 | 10   | 15   | 15   |\n| 词韵曲谱 |      | 15   |      | 20   | 15   |\n| 蹴鞠     | 10   | 10   | 20   | 10   | 10   |\n\n### D\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 冬虫夏草 | 10   | 10   | 10 |      | 20   |\n\n### F\n\n[返回首字母索引](#首字母索引)\n\n| 道具   | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| ------ | ------ | ------ | ---- | ------ | ------ |\n| 风俗画 | 5      | 5      |      |        | 20     |\n\n### G\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 弓箭     | 15   | 10   | 15   | 10   | 10   |\n| 枸杞     |      | 10   |      |      | 15   |\n| 蝈蝈笼   | 10   | 15   | 15   | 10   | 15   |\n| 关外鹿肉 | 10   | 10   | 15   | 10   | 10   |\n| 高丽泡菜 | 5    | 10   | 5    | 10   | 15   |\n| 鬼谷算盘 |      | 5    | 10   | 5    | 5 |\n| 关外鹿皮 | 15   | 10   | 15   | 10   | 10   |\n| 关外人参 | 15   | 10   | 15   | 15   | 20   |\n\n### H\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 花盆土     | 2    | 5    | 2    | 2    | 2    |\n| 红泪面脂 | 15 | 15 | 15 | 20 | 20 |\n| 花瓶       | 2    | 5    | 5    | 5    | 2    |\n| 虎皮围裙   | 10   | 10   | 15   | 10   | 10   |\n| 虎骨酒     | 15   | 5    | 15   | 10   | 10   |\n| 荷包       | 10   | 10   | 10   | 15   | 15   |\n| 和田玉坠   | 10   | 15   | 15   | 15   | 20   |\n| 和田玉石   | 10   | 15   | 15   | 20   | 20   |\n| 毁诺城女装 | 5    | 15   | 20   | 15   | 15   |\n| 河豚       | 10   | 10   | 15   | 15   | 15   |\n| 化骨水     | 20   | 5    | 5    | 5    | 5    |\n| 海螺       | 15   | 15   | 10   | 15   | 15   |\n| 胡笳十八拍 | 5    | 10   | 5    | 20   | 15   |\n| 火铳       | 20   | 5    | 20   | 5    | 5    |\n| 黑白玲珑子 | 15   | 10   | 15   | 15   | 10   |\n\n### J\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 毽子       | 5    | 15   | 15   | 10   | 10   |\n| 鸡毛掸子   | 5    | 10   | 15   | 10   | 5    |\n| 金秀铁骨扇 | 15   | 10   | 15   | 10   | 10   |\n| 金丝楠木   | 15   | 10   | 15   | 15   | 10   |\n| 绢花绸伞   | 10   | 15   | 10   | 15   | 15   |\n| 嘉禾肉粽   | 10   | 15   | 5    | 15   | 15   |\n| 机械鸟     | 15   | 15   | 20   | 15   | 10   |\n| 江山笔记   | 10   | 10   | 10   | 10 | 10 |\n| 剑门豆腐   | 15   | 15   | 15   | 15   | 15   |\n| 酒葫芦     | 10   | 10   | 15   | 10   | 15   |\n| 金叶子     | 10   | 10   | 10   | 15   | 15   |\n\n### K\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 孔雀石 | 10   | 15   | 10     | 15   | 20   |\n| 孔雀翎 |      | 15 | 10（20 | 15   | 15   |\n\n### L\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 绿茶茶叶   | 5    | 2    | 2    | 5    | 5    |\n| 莲花河灯   | 10   | 20   |      |      |      |\n| 狼毫笔     | 2    | 2    | 2    | 5    | 2    |\n| 鎏金碧玉勺 | 10   | 15   | 10   | 15   | 15   |\n| 楼兰蜜酒   | 10   | 15   | 15   | 15   | 20   |\n| 灵芝       | 15   | 15   | 15   | 20   | 20   |\n| 龙井黑猪肉 | 10   | 10   | 5 |      |      |\n| 柳笛       | 10   | 15   | 10   | 15   | 15   |\n| 龙渊       | 20   | 10   | 15   | 10   | 10   |\n\n### M\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 磨刀石   | 2    | 2    | 5    | 2    | 2    |\n| 沐浴香药 | 15   | 10   | 15   | 20   | 20   |\n| 明前龙井 |      | 15 | 10   | 20   |      |\n| 美人图 | |  |  |  | 20 |\n| 棉花     | 5    | 5    | 2    | 2    | 2    |\n\n### N\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 女儿红 | 10   | 15   | 20   | 15   | 15   |\n| 泥鳅   | 5    | 5    | 15   | 5    | 15   |\n\n### P\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 判官笔     | 5    | 5    | 5    | 10   | 10   |\n| 苹果       | 5    | 20   |      |      |      |\n| 霹雳堂火器 | 20   | 5    | 20   | 5    | 5    |\n| 霹雳堂炮仗 | 15   | 5    | 20   |      |      |\n\n### Q\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 青城脸谱   | 15   | 5      | 15   | 10   | 5    |\n| 邛窑茶盏   | 15   | 15     | 10   | 20   | 15   |\n| 契丹瓜子   | 15   | 15     | 15   | 10   | 15   |\n| 契丹牛乳   | 15   | 15     | 15   | 10   | 15   |\n| 青铜锭     | 5    | 10     | 5    | 10   | 10   |\n| 庆力善治方 | 10   | 10（15 | 10   | 10   | 10   |\n\n### R\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 阮       |      |      | 5    | 20   |      |\n| 汝窑茶盏 | 10   | 15   | 10   | 20   | 10   |\n\n### S\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 神秘妆匣   | 2    | 2    | 2    | 2    | 2    |\n| 时空碎片   | 2    | 2    | 2    | 2    | 2    |\n| 锁子甲     | 15   | 5    | 15   | 5    | 5    |\n| 水域全图   | 15   | 10   | 15   | 10   | 10 |\n| 兽皮包裹   | 15   | 10   | 15   | 10   | 10   |\n| 碎月海龟   | 10   | 10   | 15   | 15   | 10   |\n| 碎月明虾   | 15   | 15   | 10   | 15   | 15   |\n| 扇子       | 10   | 15   | 10   | 15   | 15   |\n| 蒜香排骨   |      | 10   | 10   | 5    | 10   |\n| 梳妆匣     | 10   | 15   | 20   | 20   | 20   |\n| 蛇骨手串   | 20   | 5    | 15   | 10   | 10   |\n| 司南       | 15   | 15   | 15   | 10   | 10   |\n| 三合美酒   | 10   | 15   | 20   | 15   | 15   |\n| 蓑衣（农家 | 15   | 10   | 10   | 10   | 10   |\n| 蓑衣（桃溪 | 15   |      |      |      |      |\n\n### T\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 陶罐     | 5    | 2    | 5    | 2    | 2    |\n| 桃溪钓竿 | 10   | 15 | 10   | 10 | 10   |\n| 桃溪花枝 | 10   | 20   |      | 10   | 10   |\n| 糖葫芦   | 10   | 20   | 15   | 15   | 10   |\n| 团扇     |      |      | 5    | 20   | 20   |\n| 桃木剑   | 10   | 15   | 10   | 10 | 10   |\n| 桃溪河虾 |  | 20 | 10 |  | 15 |\n| 桃花雪   | 10   | 20   | 15   | 15   | 15   |\n| 桃溪泥人 | 15   | 20 |      |      | 10   |\n| 桃溪豆腐 | 15   | 20   | 10   |      | 15   |\n| 铜镜     | 10   | 15   | 10   | 15   | 15 |\n| 铜丝手套 | 20   | 10   | 15   | 10   | 10   |\n\n### W\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 武经总要 | 5 | 10   | 5    | 10   | 5    |\n| 武安蹴鞠 | 10   | 10   | 20   | 5    | 10   |\n| 武林秘籍 | 20   | 10   | 15   | 5    | 5    |\n\n### X\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 小暖       | 15   | 20   | 20   | 15   | 10   |\n| 雪梨       | 15   | 15   | 10   | 15   | 15   |\n| 雪狐皮     | 20   | 15   | 15   | 15   | 15   |\n| 雪村鸡蛋   | 15   | 15   | 10   | 10 | 15 |\n| 熙春调味料 | 10   | 10   | 15   | 15   | 15   |\n| 宣州紫毫笔 | 10   | 15   | 10   | 15   | 10   |\n| 绣花娟帕   | 10   | 15   | 10   | 15   | 20   |\n| 西湖莲花   | 10   | 15   | 10 | 15   | 15   |\n| 西湖莲蓬   | 10   | 20   | 15   | 15   | 10   |\n| 西域葡萄   | 15   | 15   | 15   | 15   | 15   |\n| 西域炼乳   | 15   | 10   | 15   | 15   | 15   |\n\n### Y\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 一颗大白菜   | 2    | 2    | 2    | 2    | 2    |\n| 一块木板     | 2    | 2    | 2    | 2    | 2    |\n| 一块帆布     | 2    | 2    | 2    | 2    | 2    |\n| 一根茄子     | 2    | 2    | 2    | 2    | 5 |\n| 一根萝卜     | 2    | 2    | 2    | 2    | 2    |\n| 一片枫叶     | 5    | 5    | 2    | 2    | 5    |\n| 一袋面粉     | 2    | 2    | 2    | 2 | 2 |\n| 一捆麻绳     | 2    | 2    | 2    | 2    | 5    |\n| 一袋大麦     | 2    | 2    | 2    | 2    | 2    |\n| 一块粗麻布   | 2    | 2    | 2    | 2    | 2    |\n| 一袋麦麸     | 2    | 2    | 2    | 2    | 2    |\n| 一束桃花     |      | 20   |      | 15   | 15   |\n| 一袋红豆     | 2    | 2    | 2    | 5    | 2    |\n| 一捆线球     | 2    | 2    | 2    | 2    | 2    |\n| 一筐蔬菜     | 2    | 2    | 2    | 2    | 2    |\n| 一屉包子     | 10   |      |      |      | 10   |\n| 一只寒梅     | 20   |      |      |      | 15   |\n| 羊毫笔       | 2    | 2    | 2    | 5    | 2    |\n| 野生牛筋     | 10   | 10 | 15   |      | 10   |\n| 萤火虫       | 15   | 20   | 10   | 15   | 15   |\n| 云西竹笋     | 15   | 20   |      |      | 15   |\n| 月影碎空残卷 | 20   | 15   | 15   | 5    | 5    |\n| 养颜阿胶     | 20   | 20   | 20   | 20   | 20   |\n| 药粥         | 15   | 15   |      | 10 | 10 |\n| 玉扳指       | 20   | 5    | 15   | 15   | 15   |\n| 玉红叶       | 15   | 15   | 10   | 20   | 20   |\n\n### Z\n\n[返回首字母索引](#首字母索引)\n\n| 道具     | 花将离 | 叶雪清 | 温柔 | 李师师 | 姬蜜儿 |\n| -------- | ------ | ------ | ---- | ------ | ------ |\n| 针线包 | 2 | 5 | 2 | 2 | 2 |\n| 竹哨           | 15   | 15   | 10   | 10   | 10   |\n| 竹陀螺         | 10   | 15   | 20   | 10   | 10   |\n| 醉螺           | 10   | 10   | 15   | 10   | 15   |\n| 粽子           | 5 |      | 5    | 2 | 5    |\n| 竹笋           |      |      | 10   |      |      |\n| 竹竿           | 2    | 2    | 5    | 2    | 2 |\n| 追风翼（白帝城 | 15   | 10   | 20   | 10   | 10   |\n| 追风翼         | 15   | 10   | 15   | 10   | 10   |","slug":"遇见逆水寒男号女NPC奇物好感统计","published":1,"updated":"2018-10-10T08:44:25.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1y40056fmagtj65mduy","content":"<p>特别感谢<a href=\"https://weibo.com/u/3744087174?source=webim\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">秦沨_JONAS</a>及其小伙伴们的辛苦统计！</p><a id=\"more\"></a><hr><h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>半截蜡烛</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>拨浪鼓</td><td>10</td><td>15</td><td>20</td><td>15</td><td>10</td></tr><tr><td>筚篥</td><td>15</td><td>10</td><td>10</td><td>20</td><td>10</td></tr><tr><td>薄荷</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>剥皮小刀</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>冰糖糕</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>布老虎</td><td></td><td>15</td><td>10</td><td></td><td></td></tr><tr><td>碧血战铠</td><td>15</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>碧血战籍</td><td>15</td><td>10</td><td>5</td><td>5</td><td>5</td></tr><tr><td>碧血毒蝎</td><td>20</td><td>5</td><td>5</td><td>5</td><td>5</td></tr></tbody></table><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>草帽</td><td>15</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>彩球</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>词韵曲谱</td><td></td><td>15</td><td></td><td>20</td><td>15</td></tr><tr><td>蹴鞠</td><td>10</td><td>10</td><td>20</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>冬虫夏草</td><td>10</td><td>10</td><td>10</td><td></td><td>20</td></tr></tbody></table><h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>风俗画</td><td>5</td><td>5</td><td></td><td></td><td>20</td></tr></tbody></table><h3 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>弓箭</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>枸杞</td><td></td><td>10</td><td></td><td></td><td>15</td></tr><tr><td>蝈蝈笼</td><td>10</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>关外鹿肉</td><td>10</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>高丽泡菜</td><td>5</td><td>10</td><td>5</td><td>10</td><td>15</td></tr><tr><td>鬼谷算盘</td><td></td><td>5</td><td>10</td><td>5</td><td>5</td></tr><tr><td>关外鹿皮</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>关外人参</td><td>15</td><td>10</td><td>15</td><td>15</td><td>20</td></tr></tbody></table><h3 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>花盆土</td><td>2</td><td>5</td><td>2</td><td>2</td><td>2</td></tr><tr><td>红泪面脂</td><td>15</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>花瓶</td><td>2</td><td>5</td><td>5</td><td>5</td><td>2</td></tr><tr><td>虎皮围裙</td><td>10</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>虎骨酒</td><td>15</td><td>5</td><td>15</td><td>10</td><td>10</td></tr><tr><td>荷包</td><td>10</td><td>10</td><td>10</td><td>15</td><td>15</td></tr><tr><td>和田玉坠</td><td>10</td><td>15</td><td>15</td><td>15</td><td>20</td></tr><tr><td>和田玉石</td><td>10</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>毁诺城女装</td><td>5</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>河豚</td><td>10</td><td>10</td><td>15</td><td>15</td><td>15</td></tr><tr><td>化骨水</td><td>20</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>海螺</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>胡笳十八拍</td><td>5</td><td>10</td><td>5</td><td>20</td><td>15</td></tr><tr><td>火铳</td><td>20</td><td>5</td><td>20</td><td>5</td><td>5</td></tr><tr><td>黑白玲珑子</td><td>15</td><td>10</td><td>15</td><td>15</td><td>10</td></tr></tbody></table><h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>毽子</td><td>5</td><td>15</td><td>15</td><td>10</td><td>10</td></tr><tr><td>鸡毛掸子</td><td>5</td><td>10</td><td>15</td><td>10</td><td>5</td></tr><tr><td>金秀铁骨扇</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>金丝楠木</td><td>15</td><td>10</td><td>15</td><td>15</td><td>10</td></tr><tr><td>绢花绸伞</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>嘉禾肉粽</td><td>10</td><td>15</td><td>5</td><td>15</td><td>15</td></tr><tr><td>机械鸟</td><td>15</td><td>15</td><td>20</td><td>15</td><td>10</td></tr><tr><td>江山笔记</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>剑门豆腐</td><td>15</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>酒葫芦</td><td>10</td><td>10</td><td>15</td><td>10</td><td>15</td></tr><tr><td>金叶子</td><td>10</td><td>10</td><td>10</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"K\"><a href=\"#K\" class=\"headerlink\" title=\"K\"></a>K</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>孔雀石</td><td>10</td><td>15</td><td>10</td><td>15</td><td>20</td></tr><tr><td>孔雀翎</td><td></td><td>15</td><td>10（20</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>绿茶茶叶</td><td>5</td><td>2</td><td>2</td><td>5</td><td>5</td></tr><tr><td>莲花河灯</td><td>10</td><td>20</td><td></td><td></td><td></td></tr><tr><td>狼毫笔</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>鎏金碧玉勺</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>楼兰蜜酒</td><td>10</td><td>15</td><td>15</td><td>15</td><td>20</td></tr><tr><td>灵芝</td><td>15</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>龙井黑猪肉</td><td>10</td><td>10</td><td>5</td><td></td><td></td></tr><tr><td>柳笛</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>龙渊</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>磨刀石</td><td>2</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>沐浴香药</td><td>15</td><td>10</td><td>15</td><td>20</td><td>20</td></tr><tr><td>明前龙井</td><td></td><td>15</td><td>10</td><td>20</td><td></td></tr><tr><td>美人图</td><td></td><td></td><td></td><td></td><td>20</td></tr><tr><td>棉花</td><td>5</td><td>5</td><td>2</td><td>2</td><td>2</td></tr></tbody></table><h3 id=\"N\"><a href=\"#N\" class=\"headerlink\" title=\"N\"></a>N</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>女儿红</td><td>10</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>泥鳅</td><td>5</td><td>5</td><td>15</td><td>5</td><td>15</td></tr></tbody></table><h3 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>判官笔</td><td>5</td><td>5</td><td>5</td><td>10</td><td>10</td></tr><tr><td>苹果</td><td>5</td><td>20</td><td></td><td></td><td></td></tr><tr><td>霹雳堂火器</td><td>20</td><td>5</td><td>20</td><td>5</td><td>5</td></tr><tr><td>霹雳堂炮仗</td><td>15</td><td>5</td><td>20</td><td></td></tr></tbody></table><h3 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>青城脸谱</td><td>15</td><td>5</td><td>15</td><td>10</td><td>5</td></tr><tr><td>邛窑茶盏</td><td>15</td><td>15</td><td>10</td><td>20</td><td>15</td></tr><tr><td>契丹瓜子</td><td>15</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>契丹牛乳</td><td>15</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>青铜锭</td><td>5</td><td>10</td><td>5</td><td>10</td><td>10</td></tr><tr><td>庆力善治方</td><td>10</td><td>10（15</td><td>10</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>阮</td><td></td><td></td><td>5</td><td>20</td><td></td></tr><tr><td>汝窑茶盏</td><td>10</td><td>15</td><td>10</td><td>20</td><td>10</td></tr></tbody></table><h3 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>神秘妆匣</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>时空碎片</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>锁子甲</td><td>15</td><td>5</td><td>15</td><td>5</td><td>5</td></tr><tr><td>水域全图</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>兽皮包裹</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>碎月海龟</td><td>10</td><td>10</td><td>15</td><td>15</td><td>10</td></tr><tr><td>碎月明虾</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>扇子</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>蒜香排骨</td><td></td><td>10</td><td>10</td><td>5</td><td>10</td></tr><tr><td>梳妆匣</td><td>10</td><td>15</td><td>20</td><td>20</td><td>20</td></tr><tr><td>蛇骨手串</td><td>20</td><td>5</td><td>15</td><td>10</td><td>10</td></tr><tr><td>司南</td><td>15</td><td>15</td><td>15</td><td>10</td><td>10</td></tr><tr><td>三合美酒</td><td>10</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>蓑衣（农家</td><td>15</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>蓑衣（桃溪</td><td>15</td><td></td><td></td><td></td></tr></tbody></table><h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"T\"></a>T</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>陶罐</td><td>5</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>桃溪钓竿</td><td>10</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>桃溪花枝</td><td>10</td><td>20</td><td></td><td>10</td><td>10</td></tr><tr><td>糖葫芦</td><td>10</td><td>20</td><td>15</td><td>15</td><td>10</td></tr><tr><td>团扇</td><td></td><td></td><td>5</td><td>20</td><td>20</td></tr><tr><td>桃木剑</td><td>10</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>桃溪河虾</td><td></td><td>20</td><td>10</td><td></td><td>15</td></tr><tr><td>桃花雪</td><td>10</td><td>20</td><td>15</td><td>15</td><td>15</td></tr><tr><td>桃溪泥人</td><td>15</td><td>20</td><td></td><td></td><td>10</td></tr><tr><td>桃溪豆腐</td><td>15</td><td>20</td><td>10</td><td></td><td>15</td></tr><tr><td>铜镜</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>铜丝手套</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"W\"><a href=\"#W\" class=\"headerlink\" title=\"W\"></a>W</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>武经总要</td><td>5</td><td>10</td><td>5</td><td>10</td><td>5</td></tr><tr><td>武安蹴鞠</td><td>10</td><td>10</td><td>20</td><td>5</td><td>10</td></tr><tr><td>武林秘籍</td><td>20</td><td>10</td><td>15</td><td>5</td><td>5</td></tr></tbody></table><h3 id=\"X\"><a href=\"#X\" class=\"headerlink\" title=\"X\"></a>X</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>小暖</td><td>15</td><td>20</td><td>20</td><td>15</td><td>10</td></tr><tr><td>雪梨</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>雪狐皮</td><td>20</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>雪村鸡蛋</td><td>15</td><td>15</td><td>10</td><td>10</td><td>15</td></tr><tr><td>熙春调味料</td><td>10</td><td>10</td><td>15</td><td>15</td><td>15</td></tr><tr><td>宣州紫毫笔</td><td>10</td><td>15</td><td>10</td><td>15</td><td>10</td></tr><tr><td>绣花娟帕</td><td>10</td><td>15</td><td>10</td><td>15</td><td>20</td></tr><tr><td>西湖莲花</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>西湖莲蓬</td><td>10</td><td>20</td><td>15</td><td>15</td><td>10</td></tr><tr><td>西域葡萄</td><td>15</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>西域炼乳</td><td>15</td><td>10</td><td>15</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"Y\"><a href=\"#Y\" class=\"headerlink\" title=\"Y\"></a>Y</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>一颗大白菜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块木板</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块帆布</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一根茄子</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一根萝卜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一片枫叶</td><td>5</td><td>5</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一袋面粉</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一捆麻绳</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一袋大麦</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块粗麻布</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一袋麦麸</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一束桃花</td><td></td><td>20</td><td></td><td>15</td><td>15</td></tr><tr><td>一袋红豆</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>一捆线球</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一筐蔬菜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一屉包子</td><td>10</td><td></td><td></td><td></td><td>10</td></tr><tr><td>一只寒梅</td><td>20</td><td></td><td></td><td></td><td>15</td></tr><tr><td>羊毫笔</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>野生牛筋</td><td>10</td><td>10</td><td>15</td><td></td><td>10</td></tr><tr><td>萤火虫</td><td>15</td><td>20</td><td>10</td><td>15</td><td>15</td></tr><tr><td>云西竹笋</td><td>15</td><td>20</td><td></td><td></td><td>15</td></tr><tr><td>月影碎空残卷</td><td>20</td><td>15</td><td>15</td><td>5</td><td>5</td></tr><tr><td>养颜阿胶</td><td>20</td><td>20</td><td>20</td><td>20</td><td>20</td></tr><tr><td>药粥</td><td>15</td><td>15</td><td></td><td>10</td><td>10</td></tr><tr><td>玉扳指</td><td>20</td><td>5</td><td>15</td><td>15</td><td>15</td></tr><tr><td>玉红叶</td><td>15</td><td>15</td><td>10</td><td>20</td><td>20</td></tr></tbody></table><h3 id=\"Z\"><a href=\"#Z\" class=\"headerlink\" title=\"Z\"></a>Z</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>针线包</td><td>2</td><td>5</td><td>2</td><td>2</td><td>2</td></tr><tr><td>竹哨</td><td>15</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>竹陀螺</td><td>10</td><td>15</td><td>20</td><td>10</td><td>10</td></tr><tr><td>醉螺</td><td>10</td><td>10</td><td>15</td><td>10</td><td>15</td></tr><tr><td>粽子</td><td>5</td><td></td><td>5</td><td>2</td><td>5</td></tr><tr><td>竹笋</td><td></td><td></td><td>10</td><td></td><td></td></tr><tr><td>竹竿</td><td>2</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>追风翼（白帝城</td><td>15</td><td>10</td><td>20</td><td>10</td><td>10</td></tr><tr><td>追风翼</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table>","site":{"data":{}},"excerpt":"<p>特别感谢<a href=\"https://weibo.com/u/3744087174?source=webim\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">秦沨_JONAS</a>及其小伙伴们的辛苦统计！</p>","more":"<hr><h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>半截蜡烛</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>拨浪鼓</td><td>10</td><td>15</td><td>20</td><td>15</td><td>10</td></tr><tr><td>筚篥</td><td>15</td><td>10</td><td>10</td><td>20</td><td>10</td></tr><tr><td>薄荷</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>剥皮小刀</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>冰糖糕</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>布老虎</td><td></td><td>15</td><td>10</td><td></td><td></td></tr><tr><td>碧血战铠</td><td>15</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>碧血战籍</td><td>15</td><td>10</td><td>5</td><td>5</td><td>5</td></tr><tr><td>碧血毒蝎</td><td>20</td><td>5</td><td>5</td><td>5</td><td>5</td></tr></tbody></table><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>草帽</td><td>15</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>彩球</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>词韵曲谱</td><td></td><td>15</td><td></td><td>20</td><td>15</td></tr><tr><td>蹴鞠</td><td>10</td><td>10</td><td>20</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>冬虫夏草</td><td>10</td><td>10</td><td>10</td><td></td><td>20</td></tr></tbody></table><h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>风俗画</td><td>5</td><td>5</td><td></td><td></td><td>20</td></tr></tbody></table><h3 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>弓箭</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>枸杞</td><td></td><td>10</td><td></td><td></td><td>15</td></tr><tr><td>蝈蝈笼</td><td>10</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>关外鹿肉</td><td>10</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>高丽泡菜</td><td>5</td><td>10</td><td>5</td><td>10</td><td>15</td></tr><tr><td>鬼谷算盘</td><td></td><td>5</td><td>10</td><td>5</td><td>5</td></tr><tr><td>关外鹿皮</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>关外人参</td><td>15</td><td>10</td><td>15</td><td>15</td><td>20</td></tr></tbody></table><h3 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>花盆土</td><td>2</td><td>5</td><td>2</td><td>2</td><td>2</td></tr><tr><td>红泪面脂</td><td>15</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>花瓶</td><td>2</td><td>5</td><td>5</td><td>5</td><td>2</td></tr><tr><td>虎皮围裙</td><td>10</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>虎骨酒</td><td>15</td><td>5</td><td>15</td><td>10</td><td>10</td></tr><tr><td>荷包</td><td>10</td><td>10</td><td>10</td><td>15</td><td>15</td></tr><tr><td>和田玉坠</td><td>10</td><td>15</td><td>15</td><td>15</td><td>20</td></tr><tr><td>和田玉石</td><td>10</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>毁诺城女装</td><td>5</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>河豚</td><td>10</td><td>10</td><td>15</td><td>15</td><td>15</td></tr><tr><td>化骨水</td><td>20</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>海螺</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>胡笳十八拍</td><td>5</td><td>10</td><td>5</td><td>20</td><td>15</td></tr><tr><td>火铳</td><td>20</td><td>5</td><td>20</td><td>5</td><td>5</td></tr><tr><td>黑白玲珑子</td><td>15</td><td>10</td><td>15</td><td>15</td><td>10</td></tr></tbody></table><h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>毽子</td><td>5</td><td>15</td><td>15</td><td>10</td><td>10</td></tr><tr><td>鸡毛掸子</td><td>5</td><td>10</td><td>15</td><td>10</td><td>5</td></tr><tr><td>金秀铁骨扇</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>金丝楠木</td><td>15</td><td>10</td><td>15</td><td>15</td><td>10</td></tr><tr><td>绢花绸伞</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>嘉禾肉粽</td><td>10</td><td>15</td><td>5</td><td>15</td><td>15</td></tr><tr><td>机械鸟</td><td>15</td><td>15</td><td>20</td><td>15</td><td>10</td></tr><tr><td>江山笔记</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>剑门豆腐</td><td>15</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>酒葫芦</td><td>10</td><td>10</td><td>15</td><td>10</td><td>15</td></tr><tr><td>金叶子</td><td>10</td><td>10</td><td>10</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"K\"><a href=\"#K\" class=\"headerlink\" title=\"K\"></a>K</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>孔雀石</td><td>10</td><td>15</td><td>10</td><td>15</td><td>20</td></tr><tr><td>孔雀翎</td><td></td><td>15</td><td>10（20</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>绿茶茶叶</td><td>5</td><td>2</td><td>2</td><td>5</td><td>5</td></tr><tr><td>莲花河灯</td><td>10</td><td>20</td><td></td><td></td><td></td></tr><tr><td>狼毫笔</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>鎏金碧玉勺</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>楼兰蜜酒</td><td>10</td><td>15</td><td>15</td><td>15</td><td>20</td></tr><tr><td>灵芝</td><td>15</td><td>15</td><td>15</td><td>20</td><td>20</td></tr><tr><td>龙井黑猪肉</td><td>10</td><td>10</td><td>5</td><td></td><td></td></tr><tr><td>柳笛</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>龙渊</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>磨刀石</td><td>2</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>沐浴香药</td><td>15</td><td>10</td><td>15</td><td>20</td><td>20</td></tr><tr><td>明前龙井</td><td></td><td>15</td><td>10</td><td>20</td><td></td></tr><tr><td>美人图</td><td></td><td></td><td></td><td></td><td>20</td></tr><tr><td>棉花</td><td>5</td><td>5</td><td>2</td><td>2</td><td>2</td></tr></tbody></table><h3 id=\"N\"><a href=\"#N\" class=\"headerlink\" title=\"N\"></a>N</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>女儿红</td><td>10</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>泥鳅</td><td>5</td><td>5</td><td>15</td><td>5</td><td>15</td></tr></tbody></table><h3 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>判官笔</td><td>5</td><td>5</td><td>5</td><td>10</td><td>10</td></tr><tr><td>苹果</td><td>5</td><td>20</td><td></td><td></td><td></td></tr><tr><td>霹雳堂火器</td><td>20</td><td>5</td><td>20</td><td>5</td><td>5</td></tr><tr><td>霹雳堂炮仗</td><td>15</td><td>5</td><td>20</td><td></td></tr></tbody></table><h3 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>青城脸谱</td><td>15</td><td>5</td><td>15</td><td>10</td><td>5</td></tr><tr><td>邛窑茶盏</td><td>15</td><td>15</td><td>10</td><td>20</td><td>15</td></tr><tr><td>契丹瓜子</td><td>15</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>契丹牛乳</td><td>15</td><td>15</td><td>15</td><td>10</td><td>15</td></tr><tr><td>青铜锭</td><td>5</td><td>10</td><td>5</td><td>10</td><td>10</td></tr><tr><td>庆力善治方</td><td>10</td><td>10（15</td><td>10</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>阮</td><td></td><td></td><td>5</td><td>20</td><td></td></tr><tr><td>汝窑茶盏</td><td>10</td><td>15</td><td>10</td><td>20</td><td>10</td></tr></tbody></table><h3 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>神秘妆匣</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>时空碎片</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>锁子甲</td><td>15</td><td>5</td><td>15</td><td>5</td><td>5</td></tr><tr><td>水域全图</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>兽皮包裹</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr><tr><td>碎月海龟</td><td>10</td><td>10</td><td>15</td><td>15</td><td>10</td></tr><tr><td>碎月明虾</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>扇子</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>蒜香排骨</td><td></td><td>10</td><td>10</td><td>5</td><td>10</td></tr><tr><td>梳妆匣</td><td>10</td><td>15</td><td>20</td><td>20</td><td>20</td></tr><tr><td>蛇骨手串</td><td>20</td><td>5</td><td>15</td><td>10</td><td>10</td></tr><tr><td>司南</td><td>15</td><td>15</td><td>15</td><td>10</td><td>10</td></tr><tr><td>三合美酒</td><td>10</td><td>15</td><td>20</td><td>15</td><td>15</td></tr><tr><td>蓑衣（农家</td><td>15</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>蓑衣（桃溪</td><td>15</td><td></td><td></td><td></td></tr></tbody></table><h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"T\"></a>T</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>陶罐</td><td>5</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>桃溪钓竿</td><td>10</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>桃溪花枝</td><td>10</td><td>20</td><td></td><td>10</td><td>10</td></tr><tr><td>糖葫芦</td><td>10</td><td>20</td><td>15</td><td>15</td><td>10</td></tr><tr><td>团扇</td><td></td><td></td><td>5</td><td>20</td><td>20</td></tr><tr><td>桃木剑</td><td>10</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>桃溪河虾</td><td></td><td>20</td><td>10</td><td></td><td>15</td></tr><tr><td>桃花雪</td><td>10</td><td>20</td><td>15</td><td>15</td><td>15</td></tr><tr><td>桃溪泥人</td><td>15</td><td>20</td><td></td><td></td><td>10</td></tr><tr><td>桃溪豆腐</td><td>15</td><td>20</td><td>10</td><td></td><td>15</td></tr><tr><td>铜镜</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>铜丝手套</td><td>20</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table><h3 id=\"W\"><a href=\"#W\" class=\"headerlink\" title=\"W\"></a>W</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>武经总要</td><td>5</td><td>10</td><td>5</td><td>10</td><td>5</td></tr><tr><td>武安蹴鞠</td><td>10</td><td>10</td><td>20</td><td>5</td><td>10</td></tr><tr><td>武林秘籍</td><td>20</td><td>10</td><td>15</td><td>5</td><td>5</td></tr></tbody></table><h3 id=\"X\"><a href=\"#X\" class=\"headerlink\" title=\"X\"></a>X</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>小暖</td><td>15</td><td>20</td><td>20</td><td>15</td><td>10</td></tr><tr><td>雪梨</td><td>15</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>雪狐皮</td><td>20</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>雪村鸡蛋</td><td>15</td><td>15</td><td>10</td><td>10</td><td>15</td></tr><tr><td>熙春调味料</td><td>10</td><td>10</td><td>15</td><td>15</td><td>15</td></tr><tr><td>宣州紫毫笔</td><td>10</td><td>15</td><td>10</td><td>15</td><td>10</td></tr><tr><td>绣花娟帕</td><td>10</td><td>15</td><td>10</td><td>15</td><td>20</td></tr><tr><td>西湖莲花</td><td>10</td><td>15</td><td>10</td><td>15</td><td>15</td></tr><tr><td>西湖莲蓬</td><td>10</td><td>20</td><td>15</td><td>15</td><td>10</td></tr><tr><td>西域葡萄</td><td>15</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>西域炼乳</td><td>15</td><td>10</td><td>15</td><td>15</td><td>15</td></tr></tbody></table><h3 id=\"Y\"><a href=\"#Y\" class=\"headerlink\" title=\"Y\"></a>Y</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>一颗大白菜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块木板</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块帆布</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一根茄子</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一根萝卜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一片枫叶</td><td>5</td><td>5</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一袋面粉</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一捆麻绳</td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>一袋大麦</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一块粗麻布</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一袋麦麸</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一束桃花</td><td></td><td>20</td><td></td><td>15</td><td>15</td></tr><tr><td>一袋红豆</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>一捆线球</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一筐蔬菜</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>一屉包子</td><td>10</td><td></td><td></td><td></td><td>10</td></tr><tr><td>一只寒梅</td><td>20</td><td></td><td></td><td></td><td>15</td></tr><tr><td>羊毫笔</td><td>2</td><td>2</td><td>2</td><td>5</td><td>2</td></tr><tr><td>野生牛筋</td><td>10</td><td>10</td><td>15</td><td></td><td>10</td></tr><tr><td>萤火虫</td><td>15</td><td>20</td><td>10</td><td>15</td><td>15</td></tr><tr><td>云西竹笋</td><td>15</td><td>20</td><td></td><td></td><td>15</td></tr><tr><td>月影碎空残卷</td><td>20</td><td>15</td><td>15</td><td>5</td><td>5</td></tr><tr><td>养颜阿胶</td><td>20</td><td>20</td><td>20</td><td>20</td><td>20</td></tr><tr><td>药粥</td><td>15</td><td>15</td><td></td><td>10</td><td>10</td></tr><tr><td>玉扳指</td><td>20</td><td>5</td><td>15</td><td>15</td><td>15</td></tr><tr><td>玉红叶</td><td>15</td><td>15</td><td>10</td><td>20</td><td>20</td></tr></tbody></table><h3 id=\"Z\"><a href=\"#Z\" class=\"headerlink\" title=\"Z\"></a>Z</h3><p><a href=\"#首字母索引\">返回首字母索引</a></p><table><thead><tr><th>道具</th><th>花将离</th><th>叶雪清</th><th>温柔</th><th>李师师</th><th>姬蜜儿</th></tr></thead><tbody><tr><td>针线包</td><td>2</td><td>5</td><td>2</td><td>2</td><td>2</td></tr><tr><td>竹哨</td><td>15</td><td>15</td><td>10</td><td>10</td><td>10</td></tr><tr><td>竹陀螺</td><td>10</td><td>15</td><td>20</td><td>10</td><td>10</td></tr><tr><td>醉螺</td><td>10</td><td>10</td><td>15</td><td>10</td><td>15</td></tr><tr><td>粽子</td><td>5</td><td></td><td>5</td><td>2</td><td>5</td></tr><tr><td>竹笋</td><td></td><td></td><td>10</td><td></td><td></td></tr><tr><td>竹竿</td><td>2</td><td>2</td><td>5</td><td>2</td><td>2</td></tr><tr><td>追风翼（白帝城</td><td>15</td><td>10</td><td>20</td><td>10</td><td>10</td></tr><tr><td>追风翼</td><td>15</td><td>10</td><td>15</td><td>10</td><td>10</td></tr></tbody></table>"},{"title":"部署hexo后github pages页面未更新或无法打开问题","date":"2018-03-30T07:34:29.000Z","_content":"\n\n\n# 部署\n\n本地编写完成后，要同步Github Pages，运行以下三个命令即可：\n\n```\nhexo clean\nhexo g\nhexo d\n```\n\n需要注意的是**这些命令应该在hexo目录的根目录下进行**。\n\n<!-- more -->\n\n# 部署后页面未更新\n\n使用**无痕模式**浏览或者**等一段时间**再查看。\n\n\n\n---\n\n更推荐运行`hexo s`后利用本地服务器在**localhost:4000**查看效果，效果满意后直接部署，过段时间页面自然会更新的。","source":"_posts/部署hexo后github-pages页面未更新或无法打开问题.md","raw":"---\ntitle: 部署hexo后github pages页面未更新或无法打开问题\ndate: 2018-03-30 15:34:29\ncategories:\n- methods\ntags:\n- hexo\n- github pages\n---\n\n\n\n# 部署\n\n本地编写完成后，要同步Github Pages，运行以下三个命令即可：\n\n```\nhexo clean\nhexo g\nhexo d\n```\n\n需要注意的是**这些命令应该在hexo目录的根目录下进行**。\n\n<!-- more -->\n\n# 部署后页面未更新\n\n使用**无痕模式**浏览或者**等一段时间**再查看。\n\n\n\n---\n\n更推荐运行`hexo s`后利用本地服务器在**localhost:4000**查看效果，效果满意后直接部署，过段时间页面自然会更新的。","slug":"部署hexo后github-pages页面未更新或无法打开问题","published":1,"updated":"2018-10-10T08:43:47.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjn30m1y60059fmag18xt4ahy","content":"<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>本地编写完成后，要同步Github Pages，运行以下三个命令即可：</p><pre><code>hexo clean\nhexo g\nhexo d\n</code></pre><p>需要注意的是<strong>这些命令应该在hexo目录的根目录下进行</strong>。</p><a id=\"more\"></a><h1 id=\"部署后页面未更新\"><a href=\"#部署后页面未更新\" class=\"headerlink\" title=\"部署后页面未更新\"></a>部署后页面未更新</h1><p>使用<strong>无痕模式</strong>浏览或者<strong>等一段时间</strong>再查看。</p><hr><p>更推荐运行<code>hexo s</code>后利用本地服务器在<strong>localhost:4000</strong>查看效果，效果满意后直接部署，过段时间页面自然会更新的。</p>","site":{"data":{}},"excerpt":"<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>本地编写完成后，要同步Github Pages，运行以下三个命令即可：</p><pre><code>hexo clean\nhexo g\nhexo d\n</code></pre><p>需要注意的是<strong>这些命令应该在hexo目录的根目录下进行</strong>。</p>","more":"<h1 id=\"部署后页面未更新\"><a href=\"#部署后页面未更新\" class=\"headerlink\" title=\"部署后页面未更新\"></a>部署后页面未更新</h1><p>使用<strong>无痕模式</strong>浏览或者<strong>等一段时间</strong>再查看。</p><hr><p>更推荐运行<code>hexo s</code>后利用本地服务器在<strong>localhost:4000</strong>查看效果，效果满意后直接部署，过段时间页面自然会更新的。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjn30m1us0001fmagnubydlh4","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1vc000efmag35wmoyut"},{"post_id":"cjn30m1v8000cfmagsit4nw0y","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vh000kfmag7zqa3nq7"},{"post_id":"cjn30m1uy0003fmagtirqd2w3","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vj000ofmagyedu0qsq"},{"post_id":"cjn30m1vb000dfmag5z45rx86","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vl000qfmag3xn38wie"},{"post_id":"cjn30m1vf000hfmagym3jndn0","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vn000ufmagfflxr901"},{"post_id":"cjn30m1v30006fmagdopyjia2","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vo000xfmag3tlwxgch"},{"post_id":"cjn30m1vg000jfmagt0rapvda","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vq0012fmag1ou9742b"},{"post_id":"cjn30m1vi000nfmaguq3im2ie","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vu0015fmagcdge1jr1"},{"post_id":"cjn30m1v40007fmagj0nivtbb","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vw0018fmagfxat56j9"},{"post_id":"cjn30m1vm000tfmag9vl96f1b","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vx001bfmag83gutkya"},{"post_id":"cjn30m1v60008fmag8hldfzeb","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1vz001efmag0ol826c7"},{"post_id":"cjn30m1vk000pfmagjayrsdy0","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1w1001ifmag1zab6wy8"},{"post_id":"cjn30m1vt0014fmag7tiswv7p","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1w2001lfmagq8785ciw"},{"post_id":"cjn30m1vv0017fmagdkkbu7qf","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1w4001pfmag6u6l1ub7"},{"post_id":"cjn30m1vn000wfmagdgfgwkto","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1w6001sfmage56mn7wi"},{"post_id":"cjn30m1vw001afmagybii45mi","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1w8001wfmag2dt0p8mb"},{"post_id":"cjn30m1vy001dfmagbqf4czw7","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1w90020fmagaytul66o"},{"post_id":"cjn30m1vp0011fmag0bqqu2l1","category_id":"cjn30m1vy001cfmagvf9gfmb8","_id":"cjn30m1wb0024fmagrzkkvqta"},{"post_id":"cjn30m1w0001hfmagz26wsyf1","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1wd0027fmagyhxdcsbx"},{"post_id":"cjn30m1w1001kfmagfshxz64x","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wf002afmagqkstobqg"},{"post_id":"cjn30m1w3001ofmag1zz34iy7","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wg002dfmagnm9q9bxc"},{"post_id":"cjn30m1w7001vfmagvue96jov","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wi002gfmagi0asukjs"},{"post_id":"cjn30m1w9001zfmagfochq6ro","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wk002ifmago1822eyw"},{"post_id":"cjn30m1wa0023fmagrk6t3y1b","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wl002lfmagq0ou0feb"},{"post_id":"cjn30m1w4001rfmagturhei1u","category_id":"cjn30m1w8001xfmag7y94ebxf","_id":"cjn30m1wo002ofmag81ck6fge"},{"post_id":"cjn30m1wc0026fmag4qlle4uh","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wq002sfmagg31isu65"},{"post_id":"cjn30m1we0029fmagtp2mymdc","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wt002vfmagkq99east"},{"post_id":"cjn30m1wg002cfmagrpjs7dxd","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wv002yfmag8fzit3iy"},{"post_id":"cjn30m1wh002ffmagrja1ce06","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wx0030fmagsi5ueq1j"},{"post_id":"cjn30m1wj002hfmag3hlsffxw","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1wy0032fmag7w8islze"},{"post_id":"cjn30m1wl002kfmagl93tgmxc","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1wz0037fmag1myk7fnr"},{"post_id":"cjn30m1wn002nfmagxiopfes5","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1x0003afmagxtxzj7sv"},{"post_id":"cjn30m1wp002rfmag9t4np1jo","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1x2003dfmage71bxefb"},{"post_id":"cjn30m1wr002ufmag3jnhawh0","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1x4003ffmagckvgrhij"},{"post_id":"cjn30m1wu002xfmag3xmdw03w","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1x6003ifmaglqoasjyb"},{"post_id":"cjn30m1wx0031fmagakyr3bga","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1x7003lfmagiudrcy8i"},{"post_id":"cjn30m1wz0036fmaghyviq3en","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1xb003pfmago87owtpm"},{"post_id":"cjn30m1x00039fmagqs0pj7he","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1xd003rfmagvqwlpo9k"},{"post_id":"cjn30m1ww002zfmagxnn0g680","category_id":"cjn30m1wy0034fmag7tgtxjjd","_id":"cjn30m1xf003vfmagsjqo3o63"},{"post_id":"cjn30m1x1003cfmagd9ijdkgc","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1xh003yfmagq7i0ed7x"},{"post_id":"cjn30m1x3003efmagmfhs1kz3","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1xj0041fmagjqdsqq0f"},{"post_id":"cjn30m1x5003hfmagwo31wlzq","category_id":"cjn30m1wy0034fmag7tgtxjjd","_id":"cjn30m1xm0045fmagvix28gew"},{"post_id":"cjn30m1x6003kfmag1gsj0r59","category_id":"cjn30m1vy001cfmagvf9gfmb8","_id":"cjn30m1xn0047fmagzj8qm0n0"},{"post_id":"cjn30m1xa003ofmagc71hjdhv","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xo004afmagthm3jykb"},{"post_id":"cjn30m1xb003qfmagou6fa3e4","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xq004dfmag8zq3zg3j"},{"post_id":"cjn30m1xe003ufmag51188ac7","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xr004gfmag9mel5w82"},{"post_id":"cjn30m1xg003xfmagg5b3pru1","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xs004kfmagabz2as6c"},{"post_id":"cjn30m1xi0040fmaggzsalgpe","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xu004ofmagdhkhuwfp"},{"post_id":"cjn30m1xk0044fmagzgd7bsl3","category_id":"cjn30m1vo000yfmagqcyhta9c","_id":"cjn30m1xv004rfmagiys9bppo"},{"post_id":"cjn30m1xm0046fmagqx3k985v","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1xy004tfmagmhiekj8d"},{"post_id":"cjn30m1xo0049fmagvapgznp6","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1y0004yfmagiyfq5jnv"},{"post_id":"cjn30m1xt004nfmag0k4ndflc","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y20051fmagyzji2ec3"},{"post_id":"cjn30m1xp004cfmagpv7c92rz","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y30054fmag225i1usv"},{"post_id":"cjn30m1xu004pfmagwo8ijq6i","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y50057fmag8y0q2n1z"},{"post_id":"cjn30m1xx004sfmagsokuwmyf","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y7005afmag0seftkop"},{"post_id":"cjn30m1xq004ffmagxh71zicq","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y7005cfmagj6n0j7dj"},{"post_id":"cjn30m1xz004wfmagdk0f5kp6","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y8005efmaglonxtvny"},{"post_id":"cjn30m1y10050fmagoxiwrzak","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y9005ffmagivrpzwba"},{"post_id":"cjn30m1xr004jfmagtj8mz4wt","category_id":"cjn30m1xr004ifmag7m4ta93s","_id":"cjn30m1y9005hfmagj2c4lt7p"},{"post_id":"cjn30m1y30053fmagv1eafa7v","category_id":"cjn30m1v60009fmagyfto08gq","_id":"cjn30m1y9005jfmagigdvr6rq"},{"post_id":"cjn30m1y60059fmag18xt4ahy","category_id":"cjn30m1v00004fmag6srluo8w","_id":"cjn30m1ya005lfmagf0832lag"}],"PostTag":[{"post_id":"cjn30m1us0001fmagnubydlh4","tag_id":"cjn30m1v20005fmagpahsyw2c","_id":"cjn30m1v7000bfmag6f9m3fzj"},{"post_id":"cjn30m1uy0003fmagtirqd2w3","tag_id":"cjn30m1v7000afmagc8j8r1ph","_id":"cjn30m1vg000ifmag77xzjxll"},{"post_id":"cjn30m1v30006fmagdopyjia2","tag_id":"cjn30m1v7000afmagc8j8r1ph","_id":"cjn30m1vn000vfmag4oqvzopf"},{"post_id":"cjn30m1v30006fmagdopyjia2","tag_id":"cjn30m1vi000mfmagho315yhl","_id":"cjn30m1vo000zfmagrysky8xa"},{"post_id":"cjn30m1v40007fmagj0nivtbb","tag_id":"cjn30m1vl000sfmag3kefscqu","_id":"cjn30m1vq0013fmagym9dat5m"},{"post_id":"cjn30m1vw001afmagybii45mi","tag_id":"cjn30m1v7000afmagc8j8r1ph","_id":"cjn30m1w0001gfmag8nyuqiuw"},{"post_id":"cjn30m1vw001afmagybii45mi","tag_id":"cjn30m1vi000mfmagho315yhl","_id":"cjn30m1w1001jfmag2799c6vg"},{"post_id":"cjn30m1vw001afmagybii45mi","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1w3001nfmagkz9bwib1"},{"post_id":"cjn30m1v60008fmag8hldfzeb","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1w4001qfmagf1lr201x"},{"post_id":"cjn30m1v60008fmag8hldfzeb","tag_id":"cjn30m1vw0019fmagv64of0yq","_id":"cjn30m1w7001ufmag6p2movb2"},{"post_id":"cjn30m1v8000cfmagsit4nw0y","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1w8001yfmagmw72ha1s"},{"post_id":"cjn30m1vb000dfmag5z45rx86","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1wa0022fmagvq1ban83"},{"post_id":"cjn30m1vf000hfmagym3jndn0","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1wc0025fmaghhlpyeb8"},{"post_id":"cjn30m1vg000jfmagt0rapvda","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1wf002bfmagagqa8r1j"},{"post_id":"cjn30m1vi000nfmaguq3im2ie","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1wm002mfmag135z3v9z"},{"post_id":"cjn30m1vi000nfmaguq3im2ie","tag_id":"cjn30m1wh002efmag4iv4snc9","_id":"cjn30m1wp002pfmagcs91lgwn"},{"post_id":"cjn30m1vk000pfmagjayrsdy0","tag_id":"cjn30m1wk002jfmag8ika28zi","_id":"cjn30m1wr002tfmag8ttfji21"},{"post_id":"cjn30m1vm000tfmag9vl96f1b","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1wy0035fmagkac2zs6u"},{"post_id":"cjn30m1vm000tfmag9vl96f1b","tag_id":"cjn30m1wu002wfmag1drch47t","_id":"cjn30m1x00038fmagexzvp3wt"},{"post_id":"cjn30m1vn000wfmagdgfgwkto","tag_id":"cjn30m1wy0033fmaggrcv2lob","_id":"cjn30m1x6003jfmagdaaxk5a3"},{"post_id":"cjn30m1vn000wfmagdgfgwkto","tag_id":"cjn30m1wk002jfmag8ika28zi","_id":"cjn30m1x7003mfmagug0l7n2h"},{"post_id":"cjn30m1xa003ofmagc71hjdhv","tag_id":"cjn30m1wk002jfmag8ika28zi","_id":"cjn30m1xd003sfmagpceg17hs"},{"post_id":"cjn30m1vp0011fmag0bqqu2l1","tag_id":"cjn30m1x4003gfmagb1r6yf3i","_id":"cjn30m1xg003wfmagx3xzonyk"},{"post_id":"cjn30m1vp0011fmag0bqqu2l1","tag_id":"cjn30m1x9003nfmag07burlxe","_id":"cjn30m1xi003zfmag02m9gyv3"},{"post_id":"cjn30m1vt0014fmag7tiswv7p","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1xk0043fmagadbd45bl"},{"post_id":"cjn30m1xm0046fmagqx3k985v","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1xp004bfmagw99wsjwf"},{"post_id":"cjn30m1vv0017fmagdkkbu7qf","tag_id":"cjn30m1xj0042fmag8zu0g3zh","_id":"cjn30m1xr004hfmagwyzil2aq"},{"post_id":"cjn30m1vv0017fmagdkkbu7qf","tag_id":"cjn30m1xn0048fmagdepe3y8k","_id":"cjn30m1xs004lfmagakmnoev5"},{"post_id":"cjn30m1vy001dfmagbqf4czw7","tag_id":"cjn30m1xq004efmag87gwa1q5","_id":"cjn30m1xz004vfmags504fkha"},{"post_id":"cjn30m1vy001dfmagbqf4czw7","tag_id":"cjn30m1xt004mfmagt1r08rmp","_id":"cjn30m1y1004zfmagje8mj13m"},{"post_id":"cjn30m1w0001hfmagz26wsyf1","tag_id":"cjn30m1xz004ufmag7shzm8zr","_id":"cjn30m1y40055fmaglkni0ani"},{"post_id":"cjn30m1w1001kfmagfshxz64x","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1y7005bfmaggxfbwrdo"},{"post_id":"cjn30m1w3001ofmag1zz34iy7","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1y9005ifmag2e198thu"},{"post_id":"cjn30m1w3001ofmag1zz34iy7","tag_id":"cjn30m1y8005dfmagpi63eiix","_id":"cjn30m1y9005kfmagdbpm8z7q"},{"post_id":"cjn30m1w4001rfmagturhei1u","tag_id":"cjn30m1y9005gfmagzbupgbbh","_id":"cjn30m1yb005nfmagc4d45y5b"},{"post_id":"cjn30m1w7001vfmagvue96jov","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yf005qfmagif52x69h"},{"post_id":"cjn30m1w7001vfmagvue96jov","tag_id":"cjn30m1yc005ofmage69ogleb","_id":"cjn30m1yf005rfmagve8e9f0e"},{"post_id":"cjn30m1w9001zfmagfochq6ro","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yf005ufmag1b84dqty"},{"post_id":"cjn30m1w9001zfmagfochq6ro","tag_id":"cjn30m1yf005sfmagat46jy2o","_id":"cjn30m1yg005vfmagk9162u1q"},{"post_id":"cjn30m1wa0023fmagrk6t3y1b","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yg005xfmagy1pe8s9b"},{"post_id":"cjn30m1wc0026fmag4qlle4uh","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yh0061fmag2gx85wyw"},{"post_id":"cjn30m1wc0026fmag4qlle4uh","tag_id":"cjn30m1yc005ofmage69ogleb","_id":"cjn30m1yi0062fmagjk0q1xa0"},{"post_id":"cjn30m1wc0026fmag4qlle4uh","tag_id":"cjn30m1yh005zfmagaqcv4wr2","_id":"cjn30m1yi0064fmagpa3hdves"},{"post_id":"cjn30m1we0029fmagtp2mymdc","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yi0066fmaguk4q9w2v"},{"post_id":"cjn30m1we0029fmagtp2mymdc","tag_id":"cjn30m1yi0063fmagtal437ty","_id":"cjn30m1yi0067fmagyt3sf69n"},{"post_id":"cjn30m1wg002cfmagrpjs7dxd","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yj006afmag367d97ip"},{"post_id":"cjn30m1wg002cfmagrpjs7dxd","tag_id":"cjn30m1yf005sfmagat46jy2o","_id":"cjn30m1yj006bfmagpkm9v7rq"},{"post_id":"cjn30m1wh002ffmagrja1ce06","tag_id":"cjn30m1yj0069fmagyj4ws2mt","_id":"cjn30m1yk006dfmag4j1pfpzw"},{"post_id":"cjn30m1wj002hfmag3hlsffxw","tag_id":"cjn30m1wk002jfmag8ika28zi","_id":"cjn30m1yl006gfmagjr5bryst"},{"post_id":"cjn30m1wj002hfmag3hlsffxw","tag_id":"cjn30m1yk006efmagwtqnigfe","_id":"cjn30m1yl006hfmaggqpdmd94"},{"post_id":"cjn30m1wl002kfmagl93tgmxc","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1ym006kfmag6ri0woke"},{"post_id":"cjn30m1wl002kfmagl93tgmxc","tag_id":"cjn30m1yl006ifmagvswzlt00","_id":"cjn30m1ym006lfmagv8bmd1e3"},{"post_id":"cjn30m1wn002nfmagxiopfes5","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1yn006qfmagcauvehw3"},{"post_id":"cjn30m1wn002nfmagxiopfes5","tag_id":"cjn30m1ym006mfmagw588xu2c","_id":"cjn30m1yn006rfmag1z7hlbfq"},{"post_id":"cjn30m1wn002nfmagxiopfes5","tag_id":"cjn30m1yn006nfmagxcr18u6j","_id":"cjn30m1yo006tfmag34mi5m03"},{"post_id":"cjn30m1wn002nfmagxiopfes5","tag_id":"cjn30m1yn006ofmagtfp75toi","_id":"cjn30m1yo006ufmagphg8a24f"},{"post_id":"cjn30m1wp002rfmag9t4np1jo","tag_id":"cjn30m1v7000afmagc8j8r1ph","_id":"cjn30m1yo006wfmagbj4m4mmq"},{"post_id":"cjn30m1wp002rfmag9t4np1jo","tag_id":"cjn30m1yn006pfmagaqm1gcvs","_id":"cjn30m1yo006xfmagzxdxumdi"},{"post_id":"cjn30m1wp002rfmag9t4np1jo","tag_id":"cjn30m1yn006sfmagy4z6co9k","_id":"cjn30m1yp006zfmagw9h9u2iq"},{"post_id":"cjn30m1wr002ufmag3jnhawh0","tag_id":"cjn30m1yo006vfmag2lq52tsn","_id":"cjn30m1yq0071fmag0ug20oab"},{"post_id":"cjn30m1wr002ufmag3jnhawh0","tag_id":"cjn30m1yo006yfmagb0ktjq61","_id":"cjn30m1yq0072fmagbkrb65pt"},{"post_id":"cjn30m1wu002xfmag3xmdw03w","tag_id":"cjn30m1xd003tfmag60ze7tdp","_id":"cjn30m1yr0076fmagqgnnbzs6"},{"post_id":"cjn30m1wu002xfmag3xmdw03w","tag_id":"cjn30m1yq0073fmagefmoukun","_id":"cjn30m1yr0077fmagdayeu87n"},{"post_id":"cjn30m1wu002xfmag3xmdw03w","tag_id":"cjn30m1yr0074fmag4whyo7sg","_id":"cjn30m1ys0079fmagizgnw72v"},{"post_id":"cjn30m1ww002zfmagxnn0g680","tag_id":"cjn30m1yr0075fmagjauld07g","_id":"cjn30m1ys007afmagllrs35m3"},{"post_id":"cjn30m1wx0031fmagakyr3bga","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1yt007efmag2ucrsmqi"},{"post_id":"cjn30m1wx0031fmagakyr3bga","tag_id":"cjn30m1ym006mfmagw588xu2c","_id":"cjn30m1yu007ffmagb7s62rzp"},{"post_id":"cjn30m1wx0031fmagakyr3bga","tag_id":"cjn30m1yt007cfmagzgy32s4z","_id":"cjn30m1yu007hfmagsf73u0jb"},{"post_id":"cjn30m1wz0036fmaghyviq3en","tag_id":"cjn30m1yt007dfmagpqof8xbz","_id":"cjn30m1yw007jfmagmoiqfhp3"},{"post_id":"cjn30m1wz0036fmaghyviq3en","tag_id":"cjn30m1yu007gfmagdcyahu8x","_id":"cjn30m1yw007kfmagwirbmyl4"},{"post_id":"cjn30m1x00039fmagqs0pj7he","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1yx007nfmagkh5172hn"},{"post_id":"cjn30m1x00039fmagqs0pj7he","tag_id":"cjn30m1ym006mfmagw588xu2c","_id":"cjn30m1yx007ofmagsud2y98x"},{"post_id":"cjn30m1x1003cfmagd9ijdkgc","tag_id":"cjn30m1yx007mfmagzjqlxnk2","_id":"cjn30m1yy007qfmagdlpajse4"},{"post_id":"cjn30m1x3003efmagmfhs1kz3","tag_id":"cjn30m1yt007dfmagpqof8xbz","_id":"cjn30m1yz007sfmagfy843d8j"},{"post_id":"cjn30m1x5003hfmagwo31wlzq","tag_id":"cjn30m1yy007rfmagc1121pk0","_id":"cjn30m1yz007ufmagmqyx4450"},{"post_id":"cjn30m1x6003kfmag1gsj0r59","tag_id":"cjn30m1yz007tfmagdhx1zdm8","_id":"cjn30m1z0007wfmagndoysd6d"},{"post_id":"cjn30m1xb003qfmagou6fa3e4","tag_id":"cjn30m1yz007vfmagdpv6l5fc","_id":"cjn30m1z0007yfmag79qwvj5c"},{"post_id":"cjn30m1xe003ufmag51188ac7","tag_id":"cjn30m1z0007xfmage99p9225","_id":"cjn30m1z10080fmag5ryrvrki"},{"post_id":"cjn30m1xo0049fmagvapgznp6","tag_id":"cjn30m1z0007zfmagnum7ea56","_id":"cjn30m1z10083fmagtr7lyxr2"},{"post_id":"cjn30m1xo0049fmagvapgznp6","tag_id":"cjn30m1z10081fmag96lygykf","_id":"cjn30m1z20084fmag6umgspj1"},{"post_id":"cjn30m1xq004ffmagxh71zicq","tag_id":"cjn30m1z10082fmagdbci3wxi","_id":"cjn30m1z30088fmagpl1gg62o"},{"post_id":"cjn30m1xq004ffmagxh71zicq","tag_id":"cjn30m1z20085fmag8tokrvc7","_id":"cjn30m1z30089fmagkyqi4fsb"},{"post_id":"cjn30m1xq004ffmagxh71zicq","tag_id":"cjn30m1z20086fmagckg8v18k","_id":"cjn30m1z3008bfmagrm9szzou"},{"post_id":"cjn30m1xr004jfmagtj8mz4wt","tag_id":"cjn30m1z10082fmagdbci3wxi","_id":"cjn30m1z3008dfmagc14rpm2k"},{"post_id":"cjn30m1xr004jfmagtj8mz4wt","tag_id":"cjn30m1z3008afmagbckt4jsq","_id":"cjn30m1z4008efmagv9lqnqbv"},{"post_id":"cjn30m1xt004nfmag0k4ndflc","tag_id":"cjn30m1z3008cfmagd6pgj6hg","_id":"cjn30m1z4008hfmagvgpewe2i"},{"post_id":"cjn30m1xt004nfmag0k4ndflc","tag_id":"cjn30m1z4008ffmagylmg0dhv","_id":"cjn30m1z4008ifmag6tjz5ip7"},{"post_id":"cjn30m1xu004pfmagwo8ijq6i","tag_id":"cjn30m1z10082fmagdbci3wxi","_id":"cjn30m1z6008mfmagp6tgloyh"},{"post_id":"cjn30m1xu004pfmagwo8ijq6i","tag_id":"cjn30m1z20085fmag8tokrvc7","_id":"cjn30m1z6008nfmagyfphbrwf"},{"post_id":"cjn30m1xu004pfmagwo8ijq6i","tag_id":"cjn30m1z3008afmagbckt4jsq","_id":"cjn30m1z7008pfmagilp07abv"},{"post_id":"cjn30m1xx004sfmagsokuwmyf","tag_id":"cjn30m1z10082fmagdbci3wxi","_id":"cjn30m1z7008sfmagkzrtln0y"},{"post_id":"cjn30m1xx004sfmagsokuwmyf","tag_id":"cjn30m1z20085fmag8tokrvc7","_id":"cjn30m1z8008tfmagju41bu6w"},{"post_id":"cjn30m1xx004sfmagsokuwmyf","tag_id":"cjn30m1z7008qfmagobhuoe6a","_id":"cjn30m1z8008vfmagr8ox780y"},{"post_id":"cjn30m1xz004wfmagdk0f5kp6","tag_id":"cjn30m1z7008rfmagtib0awms","_id":"cjn30m1z9008yfmagu7ny4i5v"},{"post_id":"cjn30m1xz004wfmagdk0f5kp6","tag_id":"cjn30m1z8008ufmag0lmya1t3","_id":"cjn30m1z9008zfmag7acvd6lq"},{"post_id":"cjn30m1xz004wfmagdk0f5kp6","tag_id":"cjn30m1z8008wfmag6wrwfrkb","_id":"cjn30m1z90091fmagl1w540l7"},{"post_id":"cjn30m1y10050fmagoxiwrzak","tag_id":"cjn30m1z10082fmagdbci3wxi","_id":"cjn30m1za0093fmagyxddu2gx"},{"post_id":"cjn30m1y10050fmagoxiwrzak","tag_id":"cjn30m1z20085fmag8tokrvc7","_id":"cjn30m1za0094fmag25fixlrp"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1vp0010fmagzl5967sj","_id":"cjn30m1zb0096fmag8poi702s"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1v7000afmagc8j8r1ph","_id":"cjn30m1zb0097fmagm9eyxr7g"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1vi000mfmagho315yhl","_id":"cjn30m1zc0099fmags3xobyec"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1xj0042fmag8zu0g3zh","_id":"cjn30m1zc009afmag2jm7yv76"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1z90092fmag7nch4s9r","_id":"cjn30m1zc009bfmagv53fdrx5"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1vl000sfmag3kefscqu","_id":"cjn30m1zc009cfmaggsqvpery"},{"post_id":"cjn30m1y30053fmagv1eafa7v","tag_id":"cjn30m1wu002wfmag1drch47t","_id":"cjn30m1zc009dfmag0zdu1qps"},{"post_id":"cjn30m1y40056fmagtj65mduy","tag_id":"cjn30m1za0095fmaghtbub2ob","_id":"cjn30m1zc009efmago6zlrwvm"},{"post_id":"cjn30m1y60059fmag18xt4ahy","tag_id":"cjn30m1y20052fmagb8o08dbj","_id":"cjn30m1zc009ffmagpu25jmo6"},{"post_id":"cjn30m1y60059fmag18xt4ahy","tag_id":"cjn30m1zb0098fmageern1iqq","_id":"cjn30m1zc009gfmagcsptabjx"}],"Tag":[{"name":"youtube","_id":"cjn30m1v20005fmagpahsyw2c"},{"name":"HTML","_id":"cjn30m1v7000afmagc8j8r1ph"},{"name":"CSS","_id":"cjn30m1vi000mfmagho315yhl"},{"name":"HTTP","_id":"cjn30m1vl000sfmag3kefscqu"},{"name":"JavaScript","_id":"cjn30m1vp0010fmagzl5967sj"},{"name":"prototype","_id":"cjn30m1vw0019fmagv64of0yq"},{"name":"双向链表","_id":"cjn30m1wh002efmag4iv4snc9"},{"name":"TensorFlow","_id":"cjn30m1wk002jfmag8ika28zi"},{"name":"ES6","_id":"cjn30m1wu002wfmag1drch47t"},{"name":"MNIST","_id":"cjn30m1wy0033fmaggrcv2lob"},{"name":"PAT","_id":"cjn30m1x4003gfmagb1r6yf3i"},{"name":"刷题","_id":"cjn30m1x9003nfmag07burlxe"},{"name":"ubuntu","_id":"cjn30m1xd003tfmag60ze7tdp"},{"name":"Vue","_id":"cjn30m1xj0042fmag8zu0g3zh"},{"name":"Vuex","_id":"cjn30m1xn0048fmagdepe3y8k"},{"name":"cookie","_id":"cjn30m1xq004efmag87gwa1q5"},{"name":"webstorage","_id":"cjn30m1xt004mfmagt1r08rmp"},{"name":"git","_id":"cjn30m1xz004ufmag7shzm8zr"},{"name":"hexo","_id":"cjn30m1y20052fmagb8o08dbj"},{"name":"网站收录","_id":"cjn30m1y8005dfmagpi63eiix"},{"name":"numpy","_id":"cjn30m1y9005gfmagzbupgbbh"},{"name":"Chrome","_id":"cjn30m1yc005ofmage69ogleb"},{"name":"iNode","_id":"cjn30m1yf005sfmagat46jy2o"},{"name":"图片显示","_id":"cjn30m1yh005zfmagaqcv4wr2"},{"name":"快捷方式","_id":"cjn30m1yi0063fmagtal437ty"},{"name":"Ubuntu","_id":"cjn30m1yj0069fmagyj4ws2mt"},{"name":"TensorBoard","_id":"cjn30m1yk006efmagwtqnigfe"},{"name":"markdown","_id":"cjn30m1yl006ifmagvswzlt00"},{"name":"gitment","_id":"cjn30m1ym006mfmagw588xu2c"},{"name":"OAuth","_id":"cjn30m1yn006nfmagxcr18u6j"},{"name":"阿里云","_id":"cjn30m1yn006ofmagtfp75toi"},{"name":"ajax","_id":"cjn30m1yn006pfmagaqm1gcvs"},{"name":"form","_id":"cjn30m1yn006sfmagy4z6co9k"},{"name":"同步","_id":"cjn30m1yo006vfmag2lq52tsn"},{"name":"异步","_id":"cjn30m1yo006yfmagb0ktjq61"},{"name":"Typora","_id":"cjn30m1yq0073fmagefmoukun"},{"name":"Markdown","_id":"cjn30m1yr0074fmag4whyo7sg"},{"name":"内存","_id":"cjn30m1yr0075fmagjauld07g"},{"name":"Valine","_id":"cjn30m1yt007cfmagzgy32s4z"},{"name":"数据库","_id":"cjn30m1yt007dfmagpqof8xbz"},{"name":"SQL","_id":"cjn30m1yu007gfmagdcyahu8x"},{"name":"操作系统","_id":"cjn30m1yx007mfmagzjqlxnk2"},{"name":"指针","_id":"cjn30m1yy007rfmagc1121pk0"},{"name":"归并","_id":"cjn30m1yz007tfmagdhx1zdm8"},{"name":"Tmux","_id":"cjn30m1yz007vfmagdpv6l5fc"},{"name":"BN","_id":"cjn30m1z0007xfmage99p9225"},{"name":"爬虫","_id":"cjn30m1z0007zfmagnum7ea56"},{"name":"Python","_id":"cjn30m1z10081fmag96lygykf"},{"name":"UMLet","_id":"cjn30m1z10082fmagdbci3wxi"},{"name":"用例图","_id":"cjn30m1z20085fmag8tokrvc7"},{"name":"数据库建模","_id":"cjn30m1z20086fmagckg8v18k"},{"name":"建模","_id":"cjn30m1z3008afmagbckt4jsq"},{"name":"mongoDB","_id":"cjn30m1z3008cfmagd6pgj6hg"},{"name":"Flask","_id":"cjn30m1z4008ffmagylmg0dhv"},{"name":"SCRUM","_id":"cjn30m1z7008qfmagobhuoe6a"},{"name":"VUE","_id":"cjn30m1z7008rfmagtib0awms"},{"name":"Flux","_id":"cjn30m1z8008ufmag0lmya1t3"},{"name":"三层架构","_id":"cjn30m1z8008wfmag6wrwfrkb"},{"name":"设计模式","_id":"cjn30m1z90092fmag7nch4s9r"},{"name":"遇见逆水寒","_id":"cjn30m1za0095fmaghtbub2ob"},{"name":"github pages","_id":"cjn30m1zb0098fmageern1iqq"}]}}