---
title: 小米前端二面面经
toc: true
date: 2018-10-20 13:04:04
categories:
- Web
tags:
- JavaScript
- HTTP
- TCP
- UDP
- Cookie
---

正好都是不会的。。。所以完整地记录一下。

简单来说就是JS和网络掌握地并不是很全面。

<!-- more -->

## JavaScript严格模式

ES5中新增`use strict`



**不允许使用未声明的变量：**

```js
"use strict";
x = 3.14;                // 报错 (x 未定义)

"use strict";
// 	对象也是一个变量。
x = {p1:10, p2:20};      // 报错 (x 未定义)
```

**不允许删除变量或对象：**

```js
"use strict";
var x = 3.14;
delete x;                // 报错
```

**不允许删除函数:**

```js
"use strict";
function x(p1, p2) {}; 
delete x;                // 报错 
```

**不允许变量重名:**

```js
"use strict";
function x(p1, p1) {};   // 报错
```

**不允许使用八进制:**

```js
"use strict";
var x = 010;             // 报错
```

**不允许使用转义字符:**

```js
"use strict";
var x = \010;            // 报错
```

**不允许对只读属性赋值:**

```js
"use strict";
var obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});

obj.x = 3.14;            // 报错
```

**不允许对一个使用getter方法读取的属性进行赋值**:

```js
"use strict";
var obj = {get x() {return 0} };

obj.x = 3.14;            // 报错
```

**不允许删除一个不允许删除的属性：**

```js
"use strict";
delete Object.prototype; // 报错
```

**变量名不能使用 "eval" 字符串:**

```js
"use strict";
var eval = 3.14;         // 报错
```

**变量名不能使用 "arguments" 字符串:**

```js
"use strict";
var arguments = 3.14;    // 报错
```

**不允许使用以下这种语句:**

```js
"use strict";
with (Math){x = cos(2)}; // 报错
```

**由于一些安全原因，在作用域 eval() 创建的变量不能被调用：**

```js
"use strict";
eval ("var x = 2");
alert (x);               // 报错
```

**禁止this关键字指向全局对象:**

```js
function f(){
    return !this;
} 
// 返回false，因为"this"指向全局对象，"!this"就是false

function f(){ 
    "use strict";
    return !this;
} 
// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
```

因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。

```js
function f(){
    "use strict";
    this.a = 1;
};
f();// 报错，this未定义
```

## 作用域、上下文

**scope**指的是 函数被调用的时候, 各个**变量的作用区域**:

- 全局作用域
- 局部作用域

**content**指的是 函数被调用的时候, 查看**this指向**哪个object, 那么那个`object` 就是当前的 "上下文"。

## JavaScript中this指向问题(以及不同模式下)

1. 元素绑定事件，方法中的this是当前操作的元素
2. 方法名前有点则点前面是谁this就是谁，没有点则this是window（严格模式下是undefined）
3. 构造函数执行，方法体中的this是当前类的一个实例
4. 匿名函数具有全局性，因此this对象通常指向window

第二条也可以理解为：

- 方法调用中谁调用this指向谁
- 全局作用域或者普通函数中this指向全局对象window（严格模式下不能指向window所以是undefined）

## TCP和UDP的区别

[参考链接](https://www.cnblogs.com/-wang-cheng/p/5421988.html)

`TCP(Transmission Control Protocol)：传输控制协议`

`UDP(User Datagram Protocol)：用户数据报协议`



主要从连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等8个方面来讲：

 

1. <u>TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；</u>

   TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。

   UDP发送数据前不需要建立连接。

 

2. <u>TCP可靠，UDP不可靠；</u>

   TCP丢包会自动重传，UDP不会。

 

3. <u>TCP有序，UDP无序；</u>

   消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。

 

4. <u>TCP无界，UDP有界；</u>

   TCP通过字节流传输，UDP中每一个包都是单独的。

   有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的； 

   而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。

 

5. <u>TCP有流量控制（拥塞控制），UDP没有；</u>

   主要靠三次握手实现。以及慢开始、拥塞避免、快重传、快恢复

 

6. <u>TCP传输慢，UDP传输快；</u>

   因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。

 

7. <u>TCP是重量级的，UDP是轻量级的；</u>

   TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。TCP首部开销20字节;UDP的首部开销小，只有8个字节

 

8. <u>TCP对系统资源要求较多，UDP对系统资源要求较少</u>

 

9. <u>应用场合不同：</u>

   TCP一般应用在对可靠性要求比较高的场合，例如http,ftp等等

   而UDP一般应用在对实时性要求较高场合，例如视频直播，大文件传输等等

 

小结：

TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。

TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。

TCP无界有拥塞控制，UDP有界无拥塞控制。

  

补充：

基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。

基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP，IGMP，RIP。

## Cookie是否可以跨域

只可以跨二级域名进行访问

https://blog.csdn.net/u012572955/article/details/61198654

https://www.cnblogs.com/waters/articles/2869855.html

## 需要认证、跨域时、GATEWAY等HTTP状态码

401 Unauthorized —— 请求要求用户的身份认证

403 Forbidden —— 服务器理解请求客户端的请求，但是拒绝执行此请求

502 Bad GateWay —— 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求

## 闭包的优缺点

闭包的作用：保存、保护

第一个就是可以读取自身函数外部的变量（沿着作用域链寻找） 
第二个就是让这些外部变量始终保存在内存中 

**优点**： 

1. 保护函数内的变量安全,加强了封装性 
2. 在内存中维持一个变量(用的太多就变成了缺点，占内存) 

**缺点：**

1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。