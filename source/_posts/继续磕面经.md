---
title: 继续磕面经
toc: true
date: 2018-09-26 17:31:07
categories:
- Web
tags:
- JavaScript
- HTML
- CSS
- Vue
- 设计模式
- HTTP
- ES6
---

### js的基本数据类型

Undefined、Null、Boolean、Number、String五种基本数据类型

### 获取变量的数据类型有哪些方法

1. `typeof`，返回六种结果：undefined、boolean、number、string、object、function

   ```js
   typeof ''; // string
   typeof 1; // number
   typeof true; // boolean
   typeof undefined; // undefined
   typeof null; //object
   typeof []; // object
   typeof new Function(); //function
   typeof new Date(); //object
   typeof new RegExp(); //object
   ```

2. `instanceof`，判断是否是一个类的实例

   ```js
   true instanceof Boolean; // false
   1 instanceof Number; // false
   '' instanceof String; // false
   [] instanceof Array; // true
   ({}) instanceof Object; // true
   (function(){}) instanceof Function; // true
   new Boolean(true) instanceof Boolean; // true
   ```

3. `constructor`，一个类的prototype会指向自己的引用。

   需要注意的是：

   - `null`和`undefined`是无效的对象，因此没有constructor，需要通过typeof来判断。
   - JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。

   ```js
   ''.constructor == String; // true
   (1).constructor Number; // true
   true.constructor == Boolean; // true
   new Function().constructor == Function; // true
   new Date().constructor == Date; //true
   ```

4. `Object.prototype.toString`

   ```js
   Object.prototype.toString.call('');   //[object String]
   Object.prototype.toString.call(1);    //[object Number]
   Object.prototype.toString.call(true); //[object Boolean]
   Object.prototype.toString.call(undefined); //[object Undefined]
   Object.prototype.toString.call(null); //[object Null]
   Object.prototype.toString.call(new Function()); //[object Function]
   Object.prototype.toString.call(new Date()); //[object Date]
   Object.prototype.toString.call([]); //[object Array]
   Object.prototype.toString.call(new RegExp()); //[object RegExp]
   Object.prototype.toString.call(new Error()); //[object Error]
   Object.prototype.toString.call(document); //[object HTMLDocument]
   Object.prototype.toString.call(window); //[object global] window是全局对象global的引用
   // 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy 
   ```

### JS的拷贝？

基本数据类型会新开辟一个数据段来保存值，

但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。

### 深拷贝的方法

需要注意的是：slice()和concat()只深拷贝了一级属性。

1. 递归复制所有属性

   ```js
   function deepClone(arg) {
     if (arg == null || typeof arg != 'object') return arg;
     let newObj = Array.isArray(arg) ? [] : {};
     for (let key in arg) {
       if (arg[key] != null && typeof arg[key] == 'object') {
         newObj[key] = deepClone(arg[key]);
       } else {
         newObj[key] = arg[key];
       }
     }
     return newObj;
   }
   ```

2. 使用JSON的parse和stringify

   ```js
   function deepClone(arg) {
     return typeof arg == 'object' ? argJSON.parse(JSON.stringify(arg)) : arg;
   }
   ```

3. 使用JQuery的extend方法

   `$.extend([deep], target, object1[, objectN ])`

   - 用于将一个或多个对象的内容合并到目标对象
   - 如果多个对象具有相同的属性，则后者会覆盖前者的属性值

   ```js
   function deepClone(arg) {
     if (arg == null || typeof arg != 'object') return arg;
     if (arg instanceof Array) return $.extend(true,[],arg);
     else return $.extend(true,{},arg);
   }
   ```

### CSS单位有哪些

#### 相对长度

| 单位 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| em   | 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px； |
| ex   | 依赖于英文子母小 x 的高度                                    |
| ch   | 数字 0 的宽度                                                |
| rem  | 根元素（html）的 font-size                                   |
| vw   | viewpoint width，视窗宽度，1vw=视窗宽度的1%                  |
| vh   | viewpoint height，视窗高度，1vh=视窗高度的1%                 |
| vmin | vw和vh中较小的那个。                                         |
| vmax | vw和vh中较大的那个。                                         |
| %    | [介绍链接](https://blog.zmj97.top/2018/09/10/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#%E7%99%BE%E5%88%86%E6%AF%94) |

#### 绝对长度

| 单位 | 描述                                   |
| ---- | -------------------------------------- |
| cm   | 厘米                                   |
| mm   | 毫米                                   |
| in   | 英寸 (1in = 96px = 2.54cm)             |
| px   | 像素 (1px = 1/96 of 1in)               |
| pt   | point，大约1/72英寸； (1pt = 1/72in)   |
| pc   | pica，大约6pt，1/6英寸； (1pc = 12 pt) |

### 网页渲染的流程

- 浏览器怎么知道收到的包是html文件
- CSS会阻塞DOM解析么
- 知道哪些content-type
- bfc
- 清浮动的方法
- 水平方向有margin叠加么

### JS继承

1. 工厂模式
2. 构造函数模式
3. 原型链模式
4. 组合使用构造器和原型链模式
5. 原型式继承（浅拷贝）
6. 寄生式继承（5的增强版）
7. 寄生组合式继承



- 原型继承可以继承非原型属性么
- 修正constructor
- apply/call方法和原型方法的区别

### vue：v-model

双向绑定

### 设计模式

[23种设计模式](https://www.cnblogs.com/tongkey/p/7170826.html)

### 单例模式

- 用来解决哪些问题
- 只能用闭包实现么
- 写个单例模式

### 预解析

变量提升

### DOM

- 已知父节点获取第一个子节点（parentObj.firstChild）
- 查兄弟节点（previousSibing前一个，nextSibing后一个）
- 在某个子节点后面插入节点（insertBefore()）

### 对象的存储方式

### 内存回收方式

### String为什么有length属性

基本包装类型

### 已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例

函数内部判断this是否为window

### 用数据结构表示项目之间的依赖

### 判断一个图有没有环

应用

### 从输入url到显示完成了什么

1. 用户输入URL地址
2. 浏览器解析URL解析出主机名
3. 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）
4. 浏览器将端口号从URL中解析出来
5. 浏览器建立一条与目标Web服务器的TCP连接（三次握手）
6. 浏览器向服务器发送一条HTTP请求报文
7. 服务器向浏览器返回一条HTTP响应报文
8. 浏览器解析文档
9. 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕
10. 关闭连接
11. 渲染页面



- 浏览器会不会缓存dns
  - 会，不同浏览器缓存时间不一样
- https多了什么步骤
  - **https**: http + 通信加密 + 证书 + 完整性保护，http secure　
  - **证书**可以证明服务器或客户端的身份
  - **ssl**: secure socket layer，安全套接层
  - 多了**SSL安全套接层**。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。
- 假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）
- 浏览器解析数据是全部收到才解析还是边收边解析
- 如果加载`<link>`需要十秒，分别在head和body那么加载时用户会看到什么
- script，同上，还有外联/内联

### 实现parse函数解析?b=1&c=2这样的字段

```js
function myParse(arg) {
  arg = arg.split('?')[1].split('&');
  let obj = {};
  for (let i = 0; i < arg.length; i++) {
    obj[arg[i].split('=')[0]] = arg[i].split('=')[1];
  }
  return obj;
}
```

### 箭头函数的区别，能当做构造函数么

### ES6如何获取函数参数

### setTimeout准时么

### ES6手写观察者模式

### 产生0-100的随机数

### http报文结构，header有哪些字段

### 跨域

### 手写所有排序算法和DFS、BFS

快排、堆排、基数排序

### 盒模型

### session和cookie区别

### 替换元素

### 面向对象的特性

### C++怎么实现多态的

### 同步异步区别

### js异步加载方法

### 串行和并行

### 数据库index及实现

### 进程和线程

### 进程间通信方法

### 进程或线程的同步方法

### 虚拟DOM的作用

### 尾递归

### position

### 浮动

### 圣杯布局、双飞翼布局

### 动画实现div无限旋转

### 前端性能优化

### 304实现原理

### webSocket是哪一层的

### 实现add(1)(2)(3) == 6

### js是单线程的，如何实现定时

### ES6代理

### 计算一个数转换成二进制后1的个数

### HTTP长连接

### 状态码5xx

### https默认端口

### tcp连接过程中的状态考察

### 三次握手四次挥手详细

### http2.0

### 多路复用和1.x请求的区别

### unsigned int类型扩展长度

### 一个长度为一百万的数组中，超过一半都是某一个值，求这个值

https://www.cnblogs.com/yanliang12138/p/4763743.html

### 渐进增强和优雅降级

### 前端缓存机制

### 没有辅助空间的情况下交换两个数的值

### 前端安全

### let暂时性死区和块级作用域

### 类数组

### for in 缺点

### forEach()

### ES6中map遍历实现原理

### 数组去重

### 死锁

### https详细过程

加密算法，对称还是非对称。md5,SHA,AES

### 模块化

webpack、AMD、CMD

### 数组的各种方法

### 内存换页算法

### 事件循环

### ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理

### 手写封装jsonp

### 事件委托

### TCP和UDP

### soket阻塞模式

### doctype

### AJAX实现原理，手写实现