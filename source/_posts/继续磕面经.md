---
title: 继续磕面经
toc: true
date: 2018-09-26 17:31:07
categories:
- Web
tags:
- JavaScript
- HTML
- CSS
- Vue
- 设计模式
- HTTP
- ES6
---

### js的基本数据类型

Undefined、Null、Boolean、Number、String五种基本数据类型

<!-- more -->

### 获取变量的数据类型有哪些方法

1. `typeof`，返回六种结果：undefined、boolean、number、string、object、function

   ```js
   typeof ''; // string
   typeof 1; // number
   typeof true; // boolean
   typeof undefined; // undefined
   typeof null; //object
   typeof []; // object
   typeof new Function(); //function
   typeof new Date(); //object
   typeof new RegExp(); //object
   ```

2. `instanceof`，判断是否是一个类的实例

   ```js
   true instanceof Boolean; // false
   1 instanceof Number; // false
   '' instanceof String; // false
   [] instanceof Array; // true
   ({}) instanceof Object; // true
   (function(){}) instanceof Function; // true
   new Boolean(true) instanceof Boolean; // true
   ```

3. `constructor`，一个类的prototype会指向自己的引用。

   需要注意的是：

   - `null`和`undefined`是无效的对象，因此没有constructor，需要通过typeof来判断。
   - JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。

   ```js
   ''.constructor == String; // true
   (1).constructor Number; // true
   true.constructor == Boolean; // true
   new Function().constructor == Function; // true
   new Date().constructor == Date; //true
   ```

4. `Object.prototype.toString`

   ```js
   Object.prototype.toString.call('');   //[object String]
   Object.prototype.toString.call(1);    //[object Number]
   Object.prototype.toString.call(true); //[object Boolean]
   Object.prototype.toString.call(undefined); //[object Undefined]
   Object.prototype.toString.call(null); //[object Null]
   Object.prototype.toString.call(new Function()); //[object Function]
   Object.prototype.toString.call(new Date()); //[object Date]
   Object.prototype.toString.call([]); //[object Array]
   Object.prototype.toString.call(new RegExp()); //[object RegExp]
   Object.prototype.toString.call(new Error()); //[object Error]
   Object.prototype.toString.call(document); //[object HTMLDocument]
   Object.prototype.toString.call(window); //[object global] window是全局对象global的引用
   // 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy 
   ```

### JS的拷贝？

基本数据类型会新开辟一个数据段来保存值，

但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。

### 深拷贝的方法

需要注意的是：slice()和concat()只深拷贝了一级属性。

1. 递归复制所有属性

   ```js
   function deepClone(arg) {
     if (arg == null || typeof arg != 'object') return arg;
     let newObj = Array.isArray(arg) ? [] : {};
     for (let key in arg) {
       if (arg[key] != null && typeof arg[key] == 'object') {
         newObj[key] = deepClone(arg[key]);
       } else {
         newObj[key] = arg[key];
       }
     }
     return newObj;
   }
   ```

2. 使用JSON的parse和stringify

   ```js
   function deepClone(arg) {
     return typeof arg == 'object' ? JSON.parse(JSON.stringify(arg)) : arg;
   }
   ```

3. 使用JQuery的extend方法

   `$.extend([deep], target, object1[, objectN ])`

   - 用于将一个或多个对象的内容合并到目标对象
   - 如果多个对象具有相同的属性，则后者会覆盖前者的属性值

   ```js
   function deepClone(arg) {
     if (arg == null || typeof arg != 'object') return arg;
     if (arg instanceof Array) return $.extend(true,[],arg);
     else return $.extend(true,{},arg);
   }
   ```

### CSS单位有哪些

#### 相对长度

| 单位 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| em   | 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px； |
| ex   | 依赖于英文子母小 x 的高度                                    |
| ch   | 数字 0 的宽度                                                |
| rem  | 根元素（html）的 font-size                                   |
| vw   | viewpoint width，视窗宽度，1vw=视窗宽度的1%                  |
| vh   | viewpoint height，视窗高度，1vh=视窗高度的1%                 |
| vmin | vw和vh中较小的那个。                                         |
| vmax | vw和vh中较大的那个。                                         |
| %    | [介绍链接](https://blog.zmj97.top/HTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html#%E7%99%BE%E5%88%86%E6%AF%94) |

#### 绝对长度

| 单位 | 描述                                   |
| ---- | -------------------------------------- |
| cm   | 厘米                                   |
| mm   | 毫米                                   |
| in   | 英寸 (1in = 96px = 2.54cm)             |
| px   | 像素 (1px = 1/96 of 1in)               |
| pt   | point，大约1/72英寸； (1pt = 1/72in)   |
| pc   | pica，大约6pt，1/6英寸； (1pc = 12 pt) |

### 网页渲染的流程

参考：https://www.cnblogs.com/dojo-lzz/p/3983335.html

页面解析渲染该过程主要分为以下步骤：

1. 解析HTML
2. 构建DOM树
3. DOM树与CSS样式进行附着构造呈现树
4. 布局
5. 绘制



- 浏览器怎么知道收到的包是html文件（content-type）
- CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行）
- 知道哪些content-type（[参考链接](https://blog.csdn.net/luyu13141314/article/details/81129069?utm_source=copy )）
  - **text/html**  ：HTML格式
  - **text/plain** ：纯文本格式      
  - **text/xml**   ：XML格式
  - **image/gif**  ：gif图片格式    
  - **image/jpeg** ：jpg图片格式 
  - **image/png**  ：png图片格式
  - **application/xml**     ： XML数据格式
  - **application/json**    ： JSON数据格式
  - **application/pdf**     ： pdf格式  
  - **application/msword**  ： Word文档格式
  - **application/octet-stream** ： 二进制流数据（如文件下载）
  - **application/x-www-form-urlencoded** ： POST 提交数据
  - **multipart/form-data** ： 表单上传文件
- bfc（[看这里](https://www.cnblogs.com/dojo-lzz/p/3999013.html)）
- 清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear）
- 水平方向有margin叠加么（没有）

### JS继承

1. 工厂模式
2. 构造函数模式
3. 原型链模式
4. 组合使用构造器和原型链模式
5. 原型式继承（浅拷贝）
6. 寄生式继承（5的增强版）
7. 寄生组合式继承



- 原型继承可以继承非原型属性么
- 修正constructor
- apply/call方法和原型方法的区别

### vue：v-model

双向绑定

```html
<input v-model="searchText">
```

等价于：

```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```

### 设计模式

[23种设计模式](https://www.cnblogs.com/tongkey/p/7170826.html)

### 单例模式

- 用来解决哪些问题
- 只能用闭包实现么
- 写个单例模式

### 预解析

在当前作用域下，js运行之前，会把带有var和function关键字的事先**声明**，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。

### DOM

- 已知父节点获取第一个子节点（parentObj.firstChild）
- 查兄弟节点（previousSibing前一个，nextSibing后一个）
- 在某个子节点后面插入节点（insertBefore()）

### 对象的存储方式

实际存储在堆中，在栈中存储的是堆内存储地址。

所以可以把变量名看做指针。

### 内存回收方式

标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题）

### String为什么有length属性

基本包装类型

### 已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例

函数内部判断this是否为window

### 用数据结构表示项目之间的依赖

双向链表？map？不知道。。。

### 判断一个图有没有环

无向图：不断去掉度为1的点

有向图：拓扑排序

### 从输入url到显示完成了什么

1. 用户输入URL地址
2. 浏览器解析URL解析出主机名
3. 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）
4. 浏览器将端口号从URL中解析出来
5. 浏览器建立一条与目标Web服务器的TCP连接（三次握手）
6. 浏览器向服务器发送一条HTTP请求报文
7. 服务器向浏览器返回一条HTTP响应报文
8. 浏览器解析文档
9. 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕
10. 关闭连接
11. 渲染页面



- 浏览器会不会缓存dns
  - 会，不同浏览器缓存时间不一样
- https多了什么步骤
  - **https**: http + 通信加密 + 证书 + 完整性保护，http secure　
  - **证书**可以证明服务器或客户端的身份
  - **ssl**: secure socket layer，安全套接层
  - 多了**SSL安全套接层**。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。
- 假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD）
- 浏览器解析数据是全部收到才解析还是边收边解析
- 如果加载`<link>`需要十秒，分别在head和body那么加载时用户会看到什么
- script，同上，还有外联/内联

### 实现parse函数解析?b=1&c=2这样的字段

```js
function myParse(arg) {
  arg = arg.split('?')[1].split('&');
  let obj = {};
  for (let i = 0; i < arg.length; i++) {
    obj[arg[i].split('=')[0]] = arg[i].split('=')[1];
  }
  return obj;
}
```

### 箭头函数的区别，能当做构造函数么

### ES6如何获取函数参数

rest

### setTimeout准时么

不准时，只是到了时间后加入执行队列

### ES6手写观察者模式

**观察者模式** 
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

### 产生0-100的随机数

Math.floor(Math.random()*100);

### http报文结构，header有哪些字段

起始行、首部、主体。之间由CR+LF（回车换行）隔开。

header：首部

[常用请求首部字段](https://blog.zmj97.top/HTTP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html#%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E4%BF%A1%E6%81%AF)

### 跨域

只有当 **域名、协议、端口** 都相同时才视为同源。

方法：

- 跨资源共享
- document.domain
- 图像ping
- jsonp
- comet
- websocket

### 手写所有排序算法和DFS、BFS

快排、堆排、基数排序

### 盒模型

标准盒模型和IE盒模型

### session和cookie区别

### 替换元素

浏览器根据元素的标签和属性，来决定元素的具体显示内容

img、input、textarea、select、obejct、button、label都是替换元素（置换元素）

### 面向对象的特性

封装继承多态

**封装**：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

**继承**：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

**多态**：实现多态，有二种方式：覆盖，重载。

### 同步异步区别

- **同步方法**调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
- **异步方法**调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。

### js异步加载方法

defer、async、创建script插入到DOM中

### 串行和并行

**串行**是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。

**并行**指的是多个任务可以同时执行。

### 数据库index及实现

### 进程和线程

| 方面     | 进程                                                         | 线程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 根本区别 | 操作系统资源分配的基本单位                                   | 任务调度和执行的基本单位                                     |
| 开销方面 | 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销 | 线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小 |
| 所处环境 | 操作系统中多个进程可以并发运行                               | 同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） |
| 内存分配 | 系统在运行时会为每个进程分配不同的内存空间                   | 除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源 |
| 包含关系 | 进程可以包含多个线程，且这些线程可以并发运行                 | 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程   |

### 进程间通信方法

- 共享内存
- 信息传递
- 管道通信

### 进程或线程的同步方法

管程、信号量

### 尾递归

若一个函数在尾位置调用本身（或是一个尾调用本身的其他函数等），则称这种情况为尾递归，是递归的一种特殊情形。而形式上只要是最后一个return语句返回的是一个完整函数，它就是**尾递归**。这里注意：尾调用不一定是递归调用，但是尾递归一定是尾调用。

### position

### 浮动

### 圣杯布局、双飞翼布局

### 动画实现div无限旋转

### 前端性能优化

https://blog.csdn.net/mapbar_front/article/details/79836443

### 304实现原理

如果web服务器返回304响应，则表示此请求的本地缓存是最新的，可以直接使用。这种方法可以节省带宽，避免重复响应。

### webSocket是哪一层的

应用层

### 实现add(1)(2)(3) == 6

```js
function add(num) {
  num += add.num?add.num:0;
  add.num = num;
  return add;
}

add.valueOf = function() {
  return add.num;
};
```

### js是单线程的，如何实现定时

setTimeout

### ES6代理



### 计算一个数转换成二进制后1的个数

```js
function oneCount(num) {
  var re = 0;
  num = num.toString(2);
  for (var i = 0; i < num.length; i++) {
    if (num[i] == '1') re++;
  }
  return re;
}
```



### HTTP长连接

HTTP/1.1开始`Connection:keep-alive`

### 状态码5xx

服务器端问题

### https默认端口

443

### tcp连接过程中的状态考察

https://blog.csdn.net/qwertyupoiuytr/article/details/68938963

### 三次握手四次挥手详细

### http2.0

### 多路复用和1.x请求的区别

### unsigned int类型扩展长度

### 一个长度为一百万的数组中，超过一半都是某一个值，求这个值

https://blog.csdn.net/bzfys/article/details/73733917

### 渐进增强和优雅降级

**渐进增强（Progressive Enhancement）**：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

**优雅降级（Graceful Degradation）**：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

### 前端缓存机制

### 没有辅助空间的情况下交换两个数的值

### 前端安全

### let暂时性死区和块级作用域

### 类数组

### for in 缺点

### forEach()

### ES6中map遍历实现原理

### 数组去重

### 死锁

### https详细过程

加密算法，对称还是非对称。md5,SHA,AES

### 模块化

webpack、AMD、CMD

### 数组的各种方法

### 内存换页算法

### 事件循环

### ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理

### 手写封装jsonp

```js
function myCallback(data) {
  console.log(data);
}

function jsonp(url, data, callback) {
  if (data == 'string') {
    callback = data;
    data = {};
  }
  
  url += url.indexOf('?') == -1 ? '?' : '&';
  url += 'callback=' + callback;
  
  for (var key in data) {
    url += '&' + key + '=' + data[key];
  }
  
  var script = document.createElement('script');
  script.setAttribute('src', url);
  document.querySelector('head').appendChild(script);
}
```

### 事件委托

### TCP和UDP

### soket阻塞模式

### doctype

### AJAX实现原理，手写实现

使用XMLHttpRequest实现

