---
title: 智能指针
date: 2018-04-02 15:21:32
categories: 
- C/C++
tags:
- 指针
---



## 为什么使用动态指针？

在C++中，动态内存的管理是通过一对运算符来完成的：

<!-- more -->

- new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。
- delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。

这样动态内存的使用就很容易出现问题：

- 忘记释放内存（delete）就会产生内存泄漏的问题。
- 过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。

为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。

## 什么是智能指针？

智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

## 智能指针的原理是什么？

资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。

定义一个类来封装资源的分配和释放，在构造函数完成资源的分配
和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。

在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。

## 常见的智能指针？

C++11提供的两个智能指针为**shared_ptr**和**unique_ptr**，还定义了一个伴随类**weak_ptr**，这三个类都定义在**memory**头文件中。以及C++98引入的使用起来到处是坑的**auto_ptr**。

### shared_ptr（[官方文档](http://en.cppreference.com/w/cpp/memory/shared_ptr)）

>  shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。
>
> 每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。
>
> shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。
>
> 不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。

### unique_ptr

> unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。
>
> 相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。
>
> unique_ptr指针本身的生命周期：
>
> - 从unique_ptr指针创建时开始，直到离开作用域。
> - 离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。
>
> unique_ptr指针与其所指对象的关系：
>
> 在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

### weak_ptr

> weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它**不具有普通指针的行为，没有重载operator*和->**,它的最大作用在于协助shared_ptr工作，**像旁观者那样观测资源的使用情况**。
>
> weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。
>
> 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
>
> weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。

## 循环引用问题

首先看下面的代码理解什么是循环引用：

```c++
class B;
class A
{
public:
　　shared_ptr<B> m_b;
};
 
class B
{
public:
　　shared_ptr<A> m_a;
};
 
void test()
{
　　shared_ptr<A> a(new A); //new出来的A的引用计数此时为1
　　shared_ptr<B> b(new B); //new出来的B的引用计数此时为1
　　a->m_b = b; //B的引用计数增加为2
　　b->m_a = a; //A的引用计数增加为2
 
　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放
　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放
}
```

因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）：

```c++
class B;
class A
{
public:
　　weak_ptr<B> m_b;
};
 
class B
{
public:
　　weak_ptr<A> m_a;
};
 
void test()
{
　　shared_ptr<A> a(new A);
　　shared_ptr<B> b(new B);
　　a->m_b = b;
　　b->m_a = a;
}
```

### auto_ptr

缺陷：（[参考链接](https://www.zhihu.com/question/37351146/answer/83379043)，来源：知乎，作者：Sen Zhang）

> auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。
>
> 例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。
>
> 而现在C++11的对move语义的支持，使得这样的资源转移**通常**只会在**必要的场合**发生，例如转移一个临时变量（右值）给某个named variable（左值）
>
> 这也就是用unique_ptr代替auto_ptr的原因，
>
> 本质上来说，就是unique_ptr禁用了copy，而用move替代。

```c++
std::unique_ptr<bar> b0(new bar());
std::unique_ptr<bar> b1(std::move(b0));
```

## 智能指针的实现

```c++
template <typename T>
class SmartPointer {
public:
    //构造函数
    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){
        if(p)
            *_reference_count = 1; 
        else
            *_reference_count = 0; 
    }
    //拷贝构造函数
    SmartPointer(const SmartPointer& src) {
        if(this!=&src) {
            _ptr = src._ptr;
            _reference_count = src._reference_count;
            (*_reference_count)++;
        }
    }
    //重载赋值操作符
    SmartPointer& operator=(const SmartPointer& src) {
        if(_ptr==src._ptr) {
            return *this;
        }
        releaseCount();
        _ptr = src._ptr;
        _reference_count = src._reference_count;
        (*_reference_count)++;
        return *this;
    }

    //重载操作符
    T& operator*() {
        if(ptr) {
            return *_ptr;
        }
        //throw exception
    }
    //重载操作符
    T* operator->() {
        if(_ptr) {
            return _ptr;
        }
        //throw exception
    }
    //析构函数
    ~SmartPointer() {
        if (--(*_reference_count) == 0) {
            delete _ptr;
            delete _reference_count;
        }
    }
private:
    T *_ptr;
    size_t *_reference_count;
    void releaseCount() {
        if(_ptr) {
            (*_reference_count)--;
            if((*_reference_count)==0) {
                delete _ptr;
                delete _reference_count;
            }    
        }
    }
};

int main() 
{
    SmartPointer<char> cp1(new char('a'));
    SmartPointer<char> cp2(cp1);
    SmartPointer<char> cp3;
    cp3 = cp2;
    cp3 = cp1;
    cp3 = cp3;
    SmartPointer<char> cp4(new char('b'));
    cp3 = cp4;
}
```

