<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[7个好用的在线YouTube视频下载工具]]></title>
    <url>%2F7%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9C%A8%E7%BA%BFYouTube%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[ClipConverter.CC Converto.io Video Grabber SaveFrom.net Catchvideo Y2mate Online Video Converter]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>youtube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现双向链表]]></title>
    <url>%2FJavaScript%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[append(element): 添加元素到链表尾部 insert(position,element): 向双向链表中某个位置插入元素 removeAt(position): 移除双向链表中某个位置的元素 getHead(): 获取双向链表的头部 getTail(): 获取双向链表的尾部 isEmpty(): 检查双向链表是否为空，为空则返回true size(): 返回双向链表长度 function DoublyLinkedList() { var Node = function (element) { this.element = element; this.next = null; this.prev = null; } var length = 0; var head = null; var tail = null; this.append = function (element) { var node = new Node(element); if (head === null) { head = node tail = node } else { tail.next = node; node.prev = tail; tail = node; } length++; return true; } /** * 向双向链表中某个位置插入元素 * * @param {any} position 要插入的位置 * @param {any} element 要插入的元素 * @returns 插入成功或失败 */ this.insert = function (position, element) { var node = new Node(element), current = head, previous, index = 0; if (position &lt; 0 &amp;&amp; position > length) { return false; } if (position === 0) { node.next = head head.prev = node head = node } else if (position === length) { tail.next = node; node.prev = tail; tail = node; } else { while (index++ &lt; position) { previous = current current = current.next; } previous.next = node; node.prev = previous; node.next = current; current.prev = node; } length++; return true; } /** * 移除双向链表中某个位置的元素 * * @param {any} position 要移除元素的位置 * @returns 移除成功，返回移除的元素 */ this.removeAt = function (position) { var previous, current = head, index = 0; if (position &lt; 0 &amp;&amp; position >= length) { return false; } if (position === 0) { head = current.next; head.prev = null; } else if(position === length - 1) { current = tail; tail = current.prev; tail.next = null; } else { while (index++ &lt; position) { previous = current current = current.next; } previous.next = current.next; current.next.prev = previous; } length--; return current.element; } this.getHead = function () { return head.element; } this.isEmpty = function () { return length === 0 } this.getTail = function () { return tail.element; } this.size = function () { return length } }]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步与异步]]></title>
    <url>%2F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5.html</url>
    <content type="text"><![CDATA[转自：https://www.cnblogs.com/anny0404/p/5691379.html 同步和异步通常用来形容一次方法调用。 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。 栗子： 打个比方，比如我们去购物，如果你去商场实体店买一台空调，当你到了商场看中了一款空调，你就想售货员下单。售货员去仓库帮你调配物品。这天你热的实在不行了。就催着商家赶紧给你配送，于是你就等在商场里，候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。**这就是同步调用。** 不过，如果我们赶时髦，就坐再家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。这就是异步调用。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise与async/await]]></title>
    <url>%2FPromise%E4%B8%8Easync-await.html</url>
    <content type="text"><![CDATA[PromisePromise对象代表一个异步操作，有三个状态： pending进行中 fulfilled已成功 rejected已失败 Promise对象有两个特点： 对象的状态不受外界影响。只有异步操作的结果可以决定当前是哪一种状态。 一旦状态改变，就不会再变。只要状态发生改变（pending到fulfilled或pending到rejected），状态就凝固了，一直保持这个结果，这时就称为 resolved（已定型）。 Promise的缺点： 无法取消。一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 例子： const getJSON = function(url) { // Promise 新建后就会立即执行。 const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { // resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例 resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); }); return promise; }; /* * then方法可以接受两个回调函数作为参数。 * 第一个回调函数在Promise对象的状态变为resolved时调用。 * 第二个回调函数在Promise对象的状态变为rejected时调用。 * then方法是定义在原型对象Promise.prototype上的。 */ getJSON("/posts.json").then(function(json) { console.log('Contents: ' + json); }, function(error) { console.error('出错了', error); }); async/awaitasync放置在函数前，确保这个函数返回一个promise（返回的不是promise也会被包装成promise）。 await只能在async函数中工作。 promise前面的await关键字能够使JavaScript等待，直到promise处理结束。 async function showAvatar() { // read our JSON let response = await fetch('/article/promise-chaining/user.json') let user = await response.json() // read github user let githubResponse = await fetch(`https://api.github.com/users/${user.name}`) let githubUser = await githubResponse.json() // 展示头像 let img = document.createElement('img') img.src = githubUser.avatar_url img.className = 'promise-avatar-example' documenmt.body.append(img) // 等待3s await new Promise((resolve, reject) => { setTimeout(resolve, 3000) }) img.remove() return githubUser } showAvatar()]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu修改顶栏颜色]]></title>
    <url>%2Fubuntu%E4%BF%AE%E6%94%B9%E9%A1%B6%E6%A0%8F%E9%A2%9C%E8%89%B2.html</url>
    <content type="text"><![CDATA[编辑shell主题的css文件，比如我的shell主题是Vimix-Beryl： sudo gedit /usr/share/themes/Vimix-Beryl/gnome-shell/gnome-shell.css 打开之后搜索top bar，会看到这样一段： /* TOP BAR */ #panel { background-color: rgba(0, 0, 0, 0.6); /* transition from solid to transparent */ transition-duration: 250ms; font-weight: bold; height: 32px; } 按照自己的喜好修改background-color即可^_^ 补充：修改完可能并不能直接看到效果，可以在tweaks里先切换成别的主题再换成修改了的主题。 再补充：因为我是把透明度调到了大概0.2左右，导致使用hide top bar扩展时使用鼠标触发top bar后几乎看不清，可以往下找一下#panel.solid，把background-color改成这样： #panel.solid { background-color: rgba(0, 0, 0, 0.5);; /* transition from transparent to solid */ transition-duration: 250ms; background-gradient-direction: none; text-shadow: none; }]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用SQL语句]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8SQL%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[一些最重要的 SQL 命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECTSELECT column1, column2, ... FROM table_name; 这里，column1，column2，…是要从中选择数据的表的字段名称。如果要选择表中可用的所有字段，请使用以下语法： SELECT * FROM table_name; SELECT DISTINCT语法用于仅返回不同的（different）值。 SELECT DISTINCT column1, column2, ... FROM table_name; 可以用COUNT获取不同值的数量： SELECT COUNT(DISTINCT Country) FROM Customers; WHEREWHERE子句用于提取满足指定标准的记录，WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等。 SELECT column1, column2, ... FROM table_name WHERE condition; 例如： SELECT * FROM Customers WHERE Country='Mexico'; WHERE子句中可以使用以下运算符： 运算符 描述 = 等于 &lt;&gt; 不等于。 注意：在某些版本的SQL中，这个操作符可能写成！= &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 为列指定多个可能的值 AND &amp; OR &amp; NOTWHERE子句可以与AND，OR和NOT运算符结合使用。 AND和OR运算符用于根据多个条件筛选记录： 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。 如果由OR分隔的任何条件为真，则OR运算符显示记录。 如果条件不为真，则利用NOT运算符显示记录。 AND语法 SELECT column1, column2, ... FROM table_name WHERE condition1 AND condition2 AND condition3 ...; OR语法 SELECT column1, column2, ... FROM table_name WHERE condition1 OR condition2 OR condition3 ...; NOT语法 SELECT column1, column2, ... FROM table_name WHERE NOT condition; ORDER BYORDER BY 关键字用于按升序或降序对结果集进行排序。 ORDER BY 关键字默认情况下按升序排序记录。 如果需要按降序对记录进行排序，可以使用DESC关键字。 SELECT column1, column2, ... FROM table_name ORDER BY column1, column2, ... ASC|DESC; 例如： SELECT * FROM Customers ORDER BY Country DESC; UPDATEUPDATE 语句用于更新表中已存在的记录。 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！ 栗子： UPDATE Customers SET ContactName='Juan' WHERE Country='Mexico'; DELETEDELETE 语句用于删除表中的行。 DELETE FROM table_name WHERE condition; WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！ 栗子： DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste'; INSERT INTOINSERT INTO 语句用于向表中插入新记录。 INSERT INTO 语句可以用两种形式编写。 指定要插入数据的列的名称，提供要插入的值： INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。INSERT INTO语法如下所示： INSERT INTO table_name VALUES (value1, value2, value3, ...); 空值NULL用于表示缺失的值。 数据表中的 NULL 值表示该值所处的字段为空。 具有NULL值的字段是没有值的字段。 如何测试NULL值？ 使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。 我们将不得不使用IS NULL和IS NOT NULL运算符。 IS NULL语法 SELECT column_names FROM table_name WHERE column_name IS NULL; IS NOT NULL语法 SELECT column_names FROM table_name WHERE column_name IS NOT NULL; 更多的可以看： https://www.cnblogs.com/acpe/p/4970765.html https://www.w3cschool.cn/sql/dlwiyfom.html]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础知识]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[数据库系统数据库系统的组成数据库系统是由数据库、数据库管理系统、支持数据库运行的软硬件环境、数据库应用软件和数据库管理员组成的。 数据库：长期储存在计算机内、有组织的、可共享的大量数据的集合。 数据库管理系统：DBMS，管理数据库的软件，是用户和数据库之间的接口，负责完成各项数据处理操作：数据定义、数据操纵、数据库运行管理、数据库的建立和维护。 支持数据库运行的软硬件环境：有足够大的内存来保障数据库系统的运行，操作系统要提供对数据管理系统的支持等。 数据库应用软件：由用户或第三方软件公司设计的有特殊用途的应用软件，实现用户和数据库管理系统之间的沟通和交流。例如图书管理系统等。 数据库管理员：Database Administrator，DBA，负责建立、管理和维护数据的人员。主要职责包括：定义并存储数据库的内容、监督并控制数据库的使用、负责数据库的日常维护、必要时重组和改进数据库。 数据库的体系结构数据库三级模式结构模式是对数据库中全部数据的逻辑结构和特征的描述，仅仅涉及到“型”的描述，不涉及具体的值。 数据库由内模式、模式、外模式三级组成。 内模式：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。 模式：又称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式：通常是模式的一个子集，又称为子模式。外模式面向的是用户，是用户眼中的数据库，所以外模式又称为用户视图。 三级模式之间的映射 外模式/模式间的映射：模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对于同一个模式，可以有任意个外模式。对于每个外模式，数据库系统都有一个外模式/模式之间的映射。 模式/内模式间的映射：数据库只有唯一的模式和内模式，因此它们之间的映射也是唯一的，这个映射定义了数据库全局逻辑结构和存储结构之间的对应关系。 数据模型概念数据模型是一种模型，是现实世界数据特征的抽象。 数据模型通常包括数据结构、数据操作和完整性约束三部分。 数据结构：是所研究对象的集合，描述的是数据库结构的组成、特性和其互相之间的联系。数据库系统通常按数据结构的类型来命名数据模型，如关系结构的模型命名为关系模型。 数据操作：数据库中各种对象的实例允许执行的操作的集合。主要包括检索和维护两大类。 完整性约束：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容。 实体与关系 实体：客观存在并可相互区分的事物，一个实体可以用若干属性来描述。具有相同属性的实体集合称为实体集。 关系：有一对一、一对多、多对多三种。 常见的数据模型 层次模型：数据结构是一颗有向树，特征是： 有且仅有一个结点没有父结点，即根结点 除了根结点，其他结点有且只有一个父结点 网状模型：结点间可以任意发生关系，特征是： 可以有一个以上的结点没有父结点 允许结点有多于一个的父结点 关系模型：用二维表结构表示实体与实体之间的联系。E-R方法（实体-关系方法）是表示实体与关系的最常用的方法。在E-R图中： 长方形表示实体 椭圆表示属性 菱形表示关系 关系与实体间用实线连接，并注明关系的类型 关系数据库的规范化为了使数据库设计更加优化，提出了规范化理论。 关系数据库必须满足一定的要求，即满足不同的范式。 在第一范式（1NF）的基础上进一步满足更多要求的称为第二范式（2NF），以此类推。一般来说，数据库只要满足第三范式（3NF）即可。 第一范式（1NF）：无重复的列，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成。 第二范式（2NF）：先满足1NF，同时要求属性完全依赖于主键。 第三范式（3NF）：先满足2NF，同时要求不存在传递依赖关系。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统面试相关总结]]></title>
    <url>%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[参考课程：操作系统 参考资料：计算机操作系统教程 操作系统的四个特性 并发：同一时间段内多个程序执行 需要区别并行和并发 并行为同一时刻多个程序执行 共享：系统中的资源可以被内存中的多个并发执行的进线程共同使用 虚拟：通过时分复用和空分复用技术实现把一个物理实体虚拟为多个 时分复用：如分时系统，就是将提供给整个信道传输信息的事件划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用 空分复用：如虚拟内存，指让同一个频段在不同的空间内得到重复利用 异步：操作系统允许多个程序并发执行，但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可知的速度向前推进 这导致当操作系统运行在一种随机的环境下时，可能导致进程产生与时间有关的错误 但只要运行环境相同，操作系统必须保证多次运行进程都获得相同的结果 操作系统的主要功能 进程管理：包括进程控制、进程同步、进程通信和进程调度 内存管理：包括内存分配、内存保护、地址映射和内存扩充 设备管理：负责管理各类外围设备（简称：外设），包括分配、启动和故障处理等 完成用户的IO请求 为用户进程分配IO设备 提高IO设备利用率 提高IO速度 方便IO的使用 文件管理：管理系统文件和用户文件，方便使用同时保证安全性 磁盘存储空间管理 目录管理 文件读写管理 文件共享和保护 作业管理：每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制（根据用户的需要控制作业运行的步骤） 进程的状态与转换 新建： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息 运行：当一个进程在处理机上运行时，则称该进程处于运行状态 处于此状态的进程的数目小于等于处理器的数目 对于单处理机系统，处于运行状态的进程只有一个 在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列: 当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列 当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态 终止：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程） 进程与线程 方面 进程 线程 根本区别 操作系统资源分配的基本单位 任务调度和执行的基本单位 开销方面 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销 线程可以看做是轻量级的进程。同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销很小 所处环境 操作系统中多个进程可以并发运行 同一个进程中可以有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配 系统在运行时会为每个进程分配不同的内存空间 除了CPU外，系统不会为线程分配内存（线程使用的资源来自其所属进程的资源），线程组之间只能共享资源 包含关系 进程可以包含多个线程，且这些线程可以并发运行 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程 进程通信进程之间的信息交换。 共享内存 信息传递 管道通信 管道，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道 而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在 进程同步多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。 进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。 同步机制需要遵循的原则： 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等 让权等待：当进程无法进入临界区的时候，需要释放处理机，以免陷入忙等 经典的进程同步问题： 生产者-消费者问题 哲学家进餐问题 读者-写者问题 同步的解决方案： 管程 信号量 用户态和内核态 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。 用户态切换到内核态的3种方式 系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 死锁多个进程在运行过程中，因为争夺资源而造成的一种僵局。 死锁原因 竞争资源：请求同一有限资源的进程数多于可用资源数 进程推进顺序不当：进程执行中，请求和释放资源顺序不合理，如资源等待链 死锁的四个必要条件 互斥:在一个时间只能有一个进程使用资源 持有并等待：进程持有至少一个资源时，等待获取其他进程持有的额外资源 无抢占：进程对于已经申请到的资源在使用完成之前不可以被剥夺 循环等待：存在进程集合{P0,P1,…,PN}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，……，PN-1正在等待PN占用的资源，PN正在等待P0占用的资源 死锁处理 确保系统永远不会进入死锁状态 系统可能进入死锁状态，若进入死锁状态则进行恢复 忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX。 死锁预防：破坏产生死锁的4个必要条件中的一个或者多个 互斥：不互斥可能带来不确定性问题 持有并等待：让一个资源在请求资源时，不持有任何其他资源。为请求资源的进程分配所有资源；仅当进程不占有资源时才可以请求资源。但是这会导致资源利用率低，还可能发生饥饿。 无抢占：抢占资源只能kill掉正在占有资源的进程，不合理 循环等待：对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。在嵌入式系统中经常这种方法，因为嵌入式系统资源比较有限 死锁避免：额外的先行验证 最简单最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目 限定提供与分配的资源数量和进程的最大需求 在进程申请资源时检查资源分配状态来进行资源分配，以确保永远不会有一个环形等待状态 银行家算法：死锁避免的著名算法。以银行借贷系统的分配策略为基础，判断并保证系统的安全运行 死锁检测：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 死锁恢复：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。 进程调度算法 先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利； 短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ； 高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ; 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。 内存连续分配动态分区分配时所采用的几种算法。 动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。 这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。 因此系统中分区的大小和数目是可变的。 首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 基本分页储存管理方式把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。 每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。 由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。 在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。 基本分段储存管理方式分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。 访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。 分段分页方式的比较页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制； 段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。 页的大小是固定的，由系统决定； 段的大小是不确定的，由用户决定。 段页式存储基本思想分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。 在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。 段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量 程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。 为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。 地址变换的过程 程序执行时，从PCB（进程控制块）中取出段表始址和段表长度，装入段表寄存器。 由地址变换机构将逻辑地址自动分成段号、页号和页内地址。 将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。 将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。 取出段描述子得到该段的页表始址和页表长度。 将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。 将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。 取出页描述子得到该页的物理块号。 对该页的存取控制进行检查。 将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。 虚拟内存如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。 单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。 因此可以从逻辑的角度扩充内存容量，即可解决上述两种问题。 基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。 在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。 另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。 这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 虚拟存储器的特征： 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性 对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据) 虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上 页面置换算法 最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。 最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继续磕面经]]></title>
    <url>%2F%E7%BB%A7%E7%BB%AD%E7%A3%95%E9%9D%A2%E7%BB%8F.html</url>
    <content type="text"><![CDATA[js的基本数据类型Undefined、Null、Boolean、Number、String五种基本数据类型 获取变量的数据类型有哪些方法 typeof，返回六种结果：undefined、boolean、number、string、object、function typeof ''; // string typeof 1; // number typeof true; // boolean typeof undefined; // undefined typeof null; //object typeof []; // object typeof new Function(); //function typeof new Date(); //object typeof new RegExp(); //object instanceof，判断是否是一个类的实例 true instanceof Boolean; // false 1 instanceof Number; // false '' instanceof String; // false [] instanceof Array; // true ({}) instanceof Object; // true (function(){}) instanceof Function; // true new Boolean(true) instanceof Boolean; // true constructor，一个类的prototype会指向自己的引用。 需要注意的是： null和undefined是无效的对象，因此没有constructor，需要通过typeof来判断。 JS对象的constructor是不稳定的。当开发者重写prototype后，原有的constructor会丢失，constructor会默认为Object。 ''.constructor == String; // true (1).constructor Number; // true true.constructor == Boolean; // true new Function().constructor == Function; // true new Date().constructor == Date; //true Object.prototype.toString Object.prototype.toString.call(''); //[object String] Object.prototype.toString.call(1); //[object Number] Object.prototype.toString.call(true); //[object Boolean] Object.prototype.toString.call(undefined); //[object Undefined] Object.prototype.toString.call(null); //[object Null] Object.prototype.toString.call(new Function()); //[object Function] Object.prototype.toString.call(new Date()); //[object Date] Object.prototype.toString.call([]); //[object Array] Object.prototype.toString.call(new RegExp()); //[object RegExp] Object.prototype.toString.call(new Error()); //[object Error] Object.prototype.toString.call(document); //[object HTMLDocument] Object.prototype.toString.call(window); //[object global] window是全局对象global的引用 // 代码来自 红尘客栈-古月 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/mozuncangtianbaxue/article/details/77151598?utm_source=copy JS的拷贝？基本数据类型会新开辟一个数据段来保存值， 但是对象的拷贝实际上是拷贝了对实际对象的引用，我们可以把对象名看做指针。 深拷贝的方法需要注意的是：slice()和concat()只深拷贝了一级属性。 递归复制所有属性 function deepClone(arg) { if (arg == null || typeof arg != 'object') return arg; let newObj = Array.isArray(arg) ? [] : {}; for (let key in arg) { if (arg[key] != null &amp;&amp; typeof arg[key] == 'object') { newObj[key] = deepClone(arg[key]); } else { newObj[key] = arg[key]; } } return newObj; } 使用JSON的parse和stringify function deepClone(arg) { return typeof arg == 'object' ? argJSON.parse(JSON.stringify(arg)) : arg; } 使用JQuery的extend方法 $.extend([deep], target, object1[, objectN ]) 用于将一个或多个对象的内容合并到目标对象 如果多个对象具有相同的属性，则后者会覆盖前者的属性值 function deepClone(arg) { if (arg == null || typeof arg != 'object') return arg; if (arg instanceof Array) return $.extend(true,[],arg); else return $.extend(true,{},arg); } CSS单位有哪些相对长度 单位 描述 em 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px； ex 依赖于英文子母小 x 的高度 ch 数字 0 的宽度 rem 根元素（html）的 font-size vw viewpoint width，视窗宽度，1vw=视窗宽度的1% vh viewpoint height，视窗高度，1vh=视窗高度的1% vmin vw和vh中较小的那个。 vmax vw和vh中较大的那个。 % 介绍链接 绝对长度 单位 描述 cm 厘米 mm 毫米 in 英寸 (1in = 96px = 2.54cm) px 像素 (1px = 1/96 of 1in) pt point，大约1/72英寸； (1pt = 1/72in) pc pica，大约6pt，1/6英寸； (1pc = 12 pt) 网页渲染的流程参考：https://www.cnblogs.com/dojo-lzz/p/3983335.html 页面解析渲染该过程主要分为以下步骤： 解析HTML 构建DOM树 DOM树与CSS样式进行附着构造呈现树 布局 绘制 浏览器怎么知道收到的包是html文件（content-type） CSS会阻塞DOM解析么（不会阻塞DOM解析，会阻塞DOM渲染，阻塞后面的JS执行） 知道哪些content-type（参考链接） text/html ：HTML格式 text/plain ：纯文本格式 text/xml ：XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png ：png图片格式 application/xml ： XML数据格式 application/json ： JSON数据格式 application/pdf ： pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如文件下载） application/x-www-form-urlencoded ： POST 提交数据 multipart/form-data ： 表单上传文件 bfc（看这里） 清浮动的方法（父元素:after，结尾空div clear，父元素定义height，overflow，父元素table，结尾br clear） 水平方向有margin叠加么（没有） JS继承 工厂模式 构造函数模式 原型链模式 组合使用构造器和原型链模式 原型式继承（浅拷贝） 寄生式继承（5的增强版） 寄生组合式继承 原型继承可以继承非原型属性么 修正constructor apply/call方法和原型方法的区别 vue：v-model双向绑定 &lt;input v-model="searchText"> 等价于： &lt;input v-bind:value="searchText" v-on:input="searchText = $event.target.value" > 设计模式23种设计模式 单例模式 用来解决哪些问题 只能用闭包实现么 写个单例模式 预解析在当前作用域下，js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好。然后再从上到下执行js语句。函数声明会最先得到提升，然后是变量声明。 DOM 已知父节点获取第一个子节点（parentObj.firstChild） 查兄弟节点（previousSibing前一个，nextSibing后一个） 在某个子节点后面插入节点（insertBefore()） 对象的存储方式实际存储在堆中，在栈中存储的是堆内存储地址。 所以可以把变量名看做指针。 内存回收方式标记清除、引用计数（问题：循环引用，IE9之前BOM和DOM是COM实现的，垃圾收集采用的是引用计数，因此也会出现问题） String为什么有length属性基本包装类型 已知一个function ClassA() {}，如何使得new ClassA()和ClassA()返回的值都是新的实例函数内部判断this是否为window 用数据结构表示项目之间的依赖双向链表？map？不知道。。。 判断一个图有没有环无向图：不断去掉度为1的点 有向图：拓扑排序 从输入url到显示完成了什么 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 关闭连接 渲染页面 浏览器会不会缓存dns 会，不同浏览器缓存时间不一样 https多了什么步骤 https: http + 通信加密 + 证书 + 完整性保护，http secure 证书可以证明服务器或客户端的身份 ssl: secure socket layer，安全套接层 多了SSL安全套接层。HTTP直接和TCP通信。当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。所以HTTPS可以看做身披SSL协议外壳的HTTP。 假如客户端最大下行10m，服务端最大上行100m，服务端会直接以10m的速率发包么（加增乘减，AIMD） 浏览器解析数据是全部收到才解析还是边收边解析 如果加载&lt;link&gt;需要十秒，分别在head和body那么加载时用户会看到什么 script，同上，还有外联/内联 实现parse函数解析?b=1&amp;c=2这样的字段function myParse(arg) { arg = arg.split('?')[1].split('&amp;'); let obj = {}; for (let i = 0; i &lt; arg.length; i++) { obj[arg[i].split('=')[0]] = arg[i].split('=')[1]; } return obj; } 箭头函数的区别，能当做构造函数么ES6如何获取函数参数setTimeout准时么ES6手写观察者模式产生0-100的随机数http报文结构，header有哪些字段跨域手写所有排序算法和DFS、BFS快排、堆排、基数排序 盒模型标准盒模型和IE盒模型 session和cookie区别替换元素浏览器根据元素的标签和属性，来决定元素的具体显示内容 img、input、textarea、select、obejct、button、label都是替换元素（置换元素） 面向对象的特性C++怎么实现多态的同步异步区别js异步加载方法串行和并行数据库index及实现进程和线程进程间通信方法进程或线程的同步方法虚拟DOM的作用尾递归position浮动圣杯布局、双飞翼布局动画实现div无限旋转前端性能优化304实现原理webSocket是哪一层的应用层 实现add(1)(2)(3) == 6js是单线程的，如何实现定时ES6代理计算一个数转换成二进制后1的个数HTTP长连接状态码5xxhttps默认端口tcp连接过程中的状态考察三次握手四次挥手详细http2.0多路复用和1.x请求的区别unsigned int类型扩展长度一个长度为一百万的数组中，超过一半都是某一个值，求这个值https://www.cnblogs.com/yanliang12138/p/4763743.html 渐进增强和优雅降级前端缓存机制没有辅助空间的情况下交换两个数的值前端安全let暂时性死区和块级作用域类数组for in 缺点forEach()ES6中map遍历实现原理数组去重死锁https详细过程加密算法，对称还是非对称。md5,SHA,AES 模块化webpack、AMD、CMD 数组的各种方法内存换页算法事件循环ajax调用中，后台数据返回线程和前端UI线程是怎样通信和交互的，说一下实现原理手写封装jsonp事件委托TCP和UDPsoket阻塞模式doctypeAJAX实现原理，手写实现]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTTP</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Vue</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、sessionStorage和localStorage]]></title>
    <url>%2Fcookie%E3%80%81sessionStorage%E5%92%8ClocalStorage.html</url>
    <content type="text"><![CDATA[cookie由于HTTP协议是无状态的，它自身不对请求和响应之间的通信状态进行保存，因此为了实现保持登录状态等功能，引入了Cookie。 Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。 若不为Cookie设置过期时间，那么Cookie会在浏览器关闭时被删除。 因为Cookie被携带在http报文中，所以Cookie只适合存储比较小的数据，不能超过4KB。 webstorageHTML5提供的在客户端存储数据的方式。 webstorage有两种存储数据的方式： sessionStorage，针对一个session（会话）的存储 localStorages，持久化的本地存储 容量上限： Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>webstorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端向后台发送请求有哪些方式]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%90%91%E5%90%8E%E5%8F%B0%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[共七种： link标签的href属性 script标签的src属性 img标签的src属性 iframe标签的src属性 a标签的href属性 表单提交发送请求 ajax发送请求]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>ajax</tag>
        <tag>form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git相关整理]]></title>
    <url>%2Fgit%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[git merge 和 git merge –no–ff有什么区别?git merge命令用于合并指定分支到当前分支。默认情况下，执行快进式合并（fast-farward merge），直接通过把master指向feature来将两个分支并为一个分支，只保存master的分支信息。 git merge --no--ff执行正常合并，在master分支上生成新的节点，就可以保存之前的feature分支历史。能够更好的查看merge历史和branch状态。 因此为了保证版本演进的清晰，推荐使用--no--ff的方法。 工作区与暂存区工作区：workspace，git管理的当前文件夹 暂存区：stage/index，工作区与分支之间的中转站 git add——将修改添加到暂存区 git checkout -- filename——撤销工作区中指定文件的修改 git checkout . ——撤销工作区中当前目录中的所有更改 git rm --cached filename——删除暂存区中的指定文件，但保留本地文件 git rm filename——删除暂存区中的指定文件，同时删除本地文件 版本回退resetgit reset --soft ——只回退commit，暂存区和工作区不做出改变。 git reset --hard——回退commit、暂存区、工作区，即本地的代码也会回退，慎用！ git reset --mixed——回退commit和暂存区，以上两种情况的中和版本，reset不带参数的默认方式 关于版本： HEAD——当前版本 HEAD^——上一个版本 HEAD^^——上上一个版本 HEAD^^^——上上上一个版本 HEAD~n——上n个版本 也可以使用commitID 一个栗子： git reset --soft HEAD^ 只回退commit到上一个版本 reset回退不会保留回退到的版本之后的所有commit，因此在push时会因为落后于远程commit而报错，若想强制覆盖，可以为push命令加上--force或-f来进行强制操作。 revertrevert用一个新提交来消除一个历史提交所做的所有修改，即 revert不影响以前的所有commit git revert HEAD // 撤销最近一次提交 git revert HEAD^ // 撤销上上次提交 git revert commitID // 撤销指定id的提交 回退暂存区的修改git reset HEAD，命令具体含义看上边的版本回退。 删除分支git branch -d BranchName——删除本地分支 git push origin --delete BranchName/git push origin :BranchName——删除远程分支 git pull 与 git fetch 区别git fetch——拉取远程分支并更新到origin/BranchName分支中 git pull——拉取远程分支后与本地当前分支合并 git fetch origin master // 保存在本地'origin/master'分支中 git merge origin/master // 将fetch到的分支合并到本地的当前分支中 git pull origin master // 以上两句命令相当于这一句命令 合并时出现冲突的解决办法git merge显示冲突时， 使用git status查看冲突的文件， 冲突部分用&lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;标示， 编辑冲突的文件： // …… &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // 合并当前分支的内容 // …… ======= // …… &gt;&gt;&gt;&gt;&gt;&gt;&gt; BranchName // 合并前要合并的分支的内容 // …… 然后git add冲突文件发现成功了！秒啊！]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04开机慢的解决办法]]></title>
    <url>%2Fubuntu18-04%E5%BC%80%E6%9C%BA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[在终端中输入： sudo gedit /etc/default/grub 将打开的文件中的GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot; 修改为GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash noresume&quot; 保存退出后在终端中运行下面的命令来让修改生效： sudo update-grub 重启电脑感受一下吧！]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门]]></title>
    <url>%2FVuex%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[vuex文档学习笔记。 安装比较常用的两种： 直接下载或CDN引用从https://unpkg.com/vuex下载后利用script标签在vue后引入： &lt;script src="/path/to/vue.js">&lt;/script> &lt;script src="/path/to/vuex.js">&lt;/script> 或 &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;script src="https://unpkg.com/vuex@3.0.1/dist/vuex.js">&lt;/script> 使用npm在项目目录下运行： npm install vuex --save 在模块化的打包系统中利用这种方法时，必须显式地利用Vue.use()来安装Vuex（而script标签引入后是自动安装的）： import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) 介绍功能：把组件的共享状态抽取出来，用一个全局单例模式管理。 核心：store（仓库），它包含了应用中的大部分state（状态，驱动应用的数据源）。 这种全局单例模式管理和单纯的全局变量的区别： Vuex 的状态存储是响应式的。若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变store中的state。改变 store 中的state的唯一途径就是显式地commit (提交) mutation（变化）。这样我们可以方便地跟踪每一个状态的变化。 一个栗子： // 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) // 触发状态变更 store.commit('increment') console.log(store.state.count) // -> 1 再次强调，使用提交 mutation ，而不是直接改变 store.state.count， 是因为我们想要更明确地追踪到状态的变化。 当然，使用 Vuex 并不意味着需要将所有的状态放入 Vuex。 虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。 如果有些状态严格属于单个组件，最好还是作为组件的局部状态。 你应该根据你的应用开发需要进行权衡和确定。 核心概念State每个应用只包含一个 store 实例，它包含了所有需要vuex管理的状态。 利用计算属性读取state从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `&lt;div>{{ count }}&lt;/div>`, computed: { count () { return store.state.count } } } 但这种模式导致组件依赖全局状态单例。 注册 store 选项为了解决上述模式导致的组件依赖全局状态单例的问题， 我们可以通过在根实例中注册 store 选项—— 这样 store 实例会注入到根组件下的所有子组件中， 且子组件能通过 this.$store 访问到：（需调用 Vue.use(Vuex)） // 根组件 const app = new Vue({ el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class="app"> &lt;counter>&lt;/counter> &lt;/div> ` }) // 子组件 const Counter = { template: `&lt;div>{{ count }}&lt;/div>`, computed: { count () { // 通过 this.$store 访问store return this.$store.state.count } } } mapState辅助函数当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。 为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { // ... computed: mapState({ // 箭头函数可使代码更简练 // 将 `this.count` 映射为 `this.$store.state.count count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) 对象展开操作符ES6引入的新语法，由名字就可以看出来这个操作符的含义：把对象展开， 来个栗子更容易理解： var a = {'a':1, 'b':2, 'c':3}; {...a,'d':4} // {a: 1, b: 2, c: 3, d: 4} var b = [1,2,3]; [...b,4] // [1, 2, 3, 4] 有了这个操作符，我们就可以把mapState函数和局部计算属性混合使用了： computed: { // 局部计算属性 localComputed () { /* ... */ }, // 使用对象展开运算符将此对象展开混入到外部对象中 ...mapState({ // ... }) } GetterVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。 就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值；getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。 Getter 接受 state 作为其第一个参数： const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state => { return state.todos.filter(todo => todo.done) } } }) store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }] Getter 也可以接受其他 getter 作为第二个参数： getters: { // ... doneTodosCount: (state, getters) => { return getters.doneTodos.length } } store.getters.doneTodosCount // -> 1 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 getters: { // ... // getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 getTodoById: (state) => (id) => { return state.todos.find(todo => todo.id === id) } } store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false } 我们可以很容易地在任何组件中使用getter： computed: { doneTodosCount () { return this.$store.getters.doneTodosCount } } 我们也可以使用mapGetters 辅助函数将 store 中的 getter 映射到局部计算属性： import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount', // ... ]) } } Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： const store = new Vuex.Store({ state: { count: 1 }, mutations: { // 这里的事件类型为 'increment' increment (state) { // 变更状态 state.count++ } } }) 但我们不能直接调用一个 mutation 回调函数，就像前面说的，我们只能提交 mutation。 就像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。” 要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法（即提交mutation）： store.commit('increment') 提交载荷Payload我们还可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： // ... mutations: { increment (state, n) { state.count += n } } store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段，并且记录的 mutation 会更易读： // ... mutations: { increment (state, payload) { state.count += payload.amount } } // ... store.commit('increment', { amount: 10 }) 我们可以使用对象风格的提交方式，将一个直接包含 type 属性的对象作为载荷传给 mutations ： store.commit({ type: 'increment', amount: 10 }) 并且handler 无需改变： mutations: { increment (state, payload) { state.count += payload.amount } } Mutation 需遵守 Vue 的响应规则因为 Vuex 的 store 中的状态是响应式的，那么当我们使用Mutation变更状态时，监视状态的 Vue 组件也会自动更新。 因此使用 Vuex 中的 mutation 也需要像使用Vue 一样遵守一些注意事项： 提前在 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, &#39;newProp&#39;, 123), 或者 以新对象替换老对象。例如利用ES6的对象展开运算符： state.obj = { ...state.obj, newProp: 123 } Mutation 必须是同步函数 mutation 必须是同步函数。为什么？请参考下面的例子： mutations: { someMutation (state) { api.callAsyncMethod(() => { state.count++ }) } } 假设我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志： 每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。 然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成： 当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用—— 实质上任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交 Mutation我们可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation， 或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）： import { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } } 使用常量替代 Mutation 事件类型使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： // mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION' // store.js import Vuex from 'vuex' import { SOME_MUTATION } from './mutation-types' const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) 用不用常量取决于实际情况——在需要多人协作的大型项目中，这会很有帮助。你果然如果不想用，也完全可以不用。 ActionAction 类似于 mutation，不同在于： Action 是提交 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { // 变更状态 state.count++ } }, actions: { // 接受一个与 store 实例具有相同方法和属性的 context 对象 increment (context) { // 提交mutation context.commit('increment') } } }) 实践中，我们可以使用 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： actions: { increment ({ commit }) { commit('increment') } } 进行异步操作因为action是提交mutation而不是直接变更状态，因此我们就可以在action内部执行异步操作了： actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } 分发ActionAction 通过 store.dispatch 方法触发： store.dispatch('increment') Actions 支持Mutation同样的载荷方式和对象方式进行分发： // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) // 以对象形式分发 store.dispatch({ type: 'incrementAsync', amount: 10 }) 也可以在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } 组合 ActionAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 使用promisestore.dispatch 可以处理被触发的 action 的处理函数返回的 Promise， 然后返回这个 Promise： actions: { actionA ({ commit }) { return new Promise((resolve, reject) => { setTimeout(() => { commit('someMutation') resolve() }, 1000) }) } } 现在我们就可以： store.dispatch('actionA').then(() => { // ... }) 在另外一个 action 中也可以： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() => { commit('someOtherMutation') }) } } 使用async / await如果我们可以利用 async / await，我们还可以如下组合 action： // 假设 gotData() 和 gotOtherData() 返回的是 Promise actions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) } } 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -> moduleA 的状态 store.state.b // -> moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。 const moduleA = { state: { count: 0 }, mutations: { increment (state) { // 这里的 `state` 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } } } 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState： const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } } } 对于模块内部的 getter，根节点状态也会作为第三个参数暴露出来： const moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState) { return state.count + rootState.count } } } 项目结构Vuex 并不限制我们的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。 对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例： ├── index.html ├── main.js ├── api │ └── ... # 抽取出API请求 ├── components │ ├── App.vue │ └── ... └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 有时候看不进去文档，一边总结一边看就能看进去了 :)]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求包含每个有序数组(共k个)至少一个元素的最小区间]]></title>
    <url>%2F%E6%B1%82%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-%E5%85%B1k%E4%B8%AA-%E8%87%B3%E5%B0%91%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4.html</url>
    <content type="text"><![CDATA[给定k个有序数组, 每个数组有个N个元素，找出一个最小的闭区间，使其包含每个数组中的至少一个元素。 关于最小区间—— 给定两个区间[a,b], [c,d]： 如果 b-a &lt; d-c，则认为[a, b]是更小的区间； 如果 b-a == d-c，且a &lt; c，则认为[a, b]是更小的区间。 不妨设k为3，分别为a,b,c数组且a1&lt;=b1&lt;=c1，当前最小区间长度为INT_MAX 假设三个数组所有元素排序后为： a1,…,b1,…,c1,….. 我们考虑最小的a1，若最小区间包含的a数组的元素为a1，则若[a1,c1]的长度小于当前最小区间长度，更新最小区间长度为c1-a1， 然后我们丢弃a1，因为若最小区间包含的a数组元素为a1，则最小区间一定为[a1,c1]，而我们已经更新了这个长度；若不是a1,则丢弃a1也无关紧要，不影响最后结果。 那么现在我们一直的最小区间长度为c1-a1，三个数组剩下所有元素排序后可能为 a2,..,b1,..,c1,…或 b1,..,a2,..c1,…或 b1,..,c1,..a2… 第一种情况就类似于上边讨论的情况，更新最小区间长度为c1-a2，然后丢弃a2。 对于后两种情况，我们考虑最小的b1： 若最小区间包含的b数组的元素为b1，则最小区间包含的一定为b1,c1,a2，我们更新最小区间长度，然后丢弃b1， 若不是b1，则丢弃b1; 这样不断循环地考虑最小值，直到丢弃完了某一个数组的所有值，这样我们的当前最小区间长度就是所求结果。 下边是代码： #include #include #include using namespace std; int main() { int k, n; cin>>k>>n; if (k]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP学习记录]]></title>
    <url>%2FHTTP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[HTTP协议，HyperText Transfer Protocol，超文本传输协议，是因特网上应用最为 广泛的一种网络传输协议。 版本HTTP/0.9已过时，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。 因为这个版本不支持POST方法，因此客户端无法向服务器传递太多信息。 HTTP/1.0第一个在通讯中指定版本号的版本，至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.1当前版本，默认采用持久连接，并能很好地配合代理服务器工作。 支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。 SPDYSPDY (发音为”speedy”) ，是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。 HTTP/2.0简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接）。 协议之间的比较HTTP/1.1相较于HTTP/1.0的主要区别 缓存处理 带宽优化及网络连接的使用 错误通知的管理 消息在网络中的发送 互联网地址的维护 安全性及完整性 HTTP/2与HTTP/1.1比较 HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以藉由新特性得到更好的速度。 HTTP/2 保留了 HTTP/1.1 的大部分语义，例如请求方法、状态码乃至URI和绝大多数HTTP头部字段一致。 但是 HTTP/2 采用了新的方法来编码、传输客户端/服务器间的数据。 HTTP/1.1与SPDY的区别 其与HTTP/1.1相比，SPDY主要的改变有： 实现无需先入先出的多路复用 为简化客户端和服务器开发的消息—帧机制 强制性压缩（包括HTTP头部） 优先级排序 双向通讯 HTTP/2与SPDY的比较 HTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于霍夫曼编码，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以CRIME为代表。此外，HTTP/2禁用了诸多加密套件，以保证基于TLS的连接的前向安全。 简介基于TCP/IP通信协议传递数据。 工作原理HTTP协议工作在客户端-服务端架构（C/S）上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有Apache服务器、IIS（Internet Informatica Services）服务器等。 Web服务器根据接收到的请求，向客户端发送响应信息。 HTTP默认端口号为80，我们也可以改为8080或者其他端口。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）定位互联网上的资源。 注意事项HTTP是： 无连接的：每次连接只处理一个请求。服务器处理完客户的请求并受到客户的应答后就断开连接。采用这种方式可以节省传输时间。 媒体独立的：只要客户端和服务端都知道如何处理数据内容，任何类型都可以通过HTTP发送。客户端和服务器指定合适的MIME-tyoe内容类型。 无状态的：协议对于事务处理没有记忆能力。HTTP协议自身不对请求和响应之间的通信状态进行保存。 这是为了更快地处理大量事务，确保协议的可伸缩性而特意设计的。但这也导致业务处理变得棘手的情况增多，比如要保持登录状态，因为HTTP无状态，因此需要额外保存用户状态。 HTTP/1.1虽然也是无状态协议，但是为了实现比如保持状态的功能，引入了Cookie技术，这让管理状态变得简单。 Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。 HTTP协议通信流程： Web浏览器&lt;=HTTP协议=&gt;HTTP服务器&lt;=&gt;CGI（通用网关接口）应用程序&lt;=&gt;数据库 其中CGI： 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。 HTTP报文用于HTTP协议交互的信息称为HTTP报文。请求端(客户端)的HTTP报文称为请求报文，响应端（服务器端）的叫响应报文． HTTP报文本身是由多行（用CR+LF作为换行符）数据构成的字符串文本。 HTTP报文大致可分为报文首部和报文主体，两者由最初出现的空行（CR+LF）来划分。 通常并不一定要有报文主体。 报文首部 服务器端或客户端需处理的请求或响应的内容及内容 请求报文的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段、其他组成 响应报文的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段、其他组成 CR+LF CR，Carriage Return，回车符，16进制0x0d LF，Line Feed，换行符，16进制0x0a 报文主体 应被发送的数据 常用请求首部信息（参考自红宝书） 虽然不同浏览器实际发送的头部信息会有所不同，但下边这些基本上是所有浏览器都会发送的： Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够显示的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在的域 Referer：发出请求的页面的URI。注意HTTP规范将这个字段拼写错了（正确拼法为Referrer），但为了保证与规范一致，也只能将错就错了。 User-Agent：浏览器的代理用户字段。 注意，这些字段名是一个字母都不应有区别的，一旦有区别，那它就不是首部字段。 请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET GET方法请求指定的页面信息. 使用GET的请求应该只被用于获取数据. HEAD HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体. POST POST方法用于向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT PUT方法从客户端向服务器传送的数据取代指定的文档的内容。 注意：因为HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。 DELETE DELETE方法删除指定的资源。 注意：和PUT一样，因为HTTP/1.1的DELETE方法自身不带验证机制，存在安全性问题，因此一般的web网站不使用该方法。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 询问支持的方法，查询请求URI指定的资源支持的方法。 TRACE 回显服务器收到的请求，查询发送出去的请求是怎样被加工/修改的，主要用于测试或诊断（因为从代理服务器路由中转时请求可能被篡改）。不常用。 PATCH PATCH方法用于对资源进行部分修改。（PUT为对资源进行整体覆盖） HTTP状态码 1XX信息，服务器收到请求，需要请求者继续执行操作 2XX成功，操作被成功接收并处理 3XX重定向，需要进一步的操作以完成请求 4XX客户端错误，请求包含语法错误或无法完成请求 5XX服务器错误，服务器在处理请求的过程中发生了错误 常见状态码： 200 OK， 一切正常，对GET和POST请求的应答文档跟在后面 301 Moved Permanently，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。 304 Not Modified，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 307 Temporary Redirect，和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清楚地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。 400 Bad Request，请求出现语法错误。 401 Unauthorized，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求 403 Forbidden， 资源不可用。 404 Not Found，无法找到指定位置的资源 410 Gone， 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用 500 Internal Server Error，服务器遇到了意料不到的情况，不能完成客户的请求 501 Not Implemented，服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求 503 Service Unavailable ，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头 Content-TypeContent-Type: text/html; charset=UTF-8 实体首部字段，表示实体主体的媒体类型。 字段值采用type/subtype形式赋值。 对照表链接：https://www.w3cschool.cn/http/ahkmgfmz.html W3C的教程的学习笔记，过两天再啃一下MDN和《图解HTTP》，还要再复习一下计网，很多都忘了… emmmW3C有的是错的…使用网络教程需谨慎…. 关于HTTP/2.0以及SPDY等均来自维基百科。 这里只是重新回忆一下什么是HTTP，还是要看文档！啃《图解HTTP》！复习计网！]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网前端挑战编程题解]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E5%89%8D%E7%AB%AF%E6%8C%91%E6%88%98%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3.html</url>
    <content type="text"><![CDATA[OJ链接：https://www.nowcoder.com/ta/front-end 注意：在牛客不能用ES6的东西！ 修改this指向 封装函数 f，使 f 的 this 指向指定的对象 代码 function bindThis(f, oTarget) { // 考虑浏览器兼容 if (f.bind) { return f.bind(oTarget); } else { // apply()为立即执行函数，因此需要放在一个函数里，到需要使用的时候再立即执行 return function() { // arguments不能省略，在执行f时可能会传入参数 return f.apply(oTarget, arguments); } } } 获取url参数 获取 url 中的参数 指定参数名称，返回该参数的值 或者 空字符串 不指定参数名称，返回全部的参数对象 或者 {} 如果存在多个同名参数，则返回数组 输入 http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe 输出 [1, 2, 3] 代码 function getUrlParam(sUrl, sKey) { var result = {}; // 先取?和#之间的字符串，然后按照&amp;分割 var querys = ((sUrl.split('?')[1]).split('#')[0]).split('&amp;'); for (var i = 0; i &lt; querys.length; i++) { var key = querys[i].split('=')[0]; var value = querys[i].split('=')[1]; // 如果result[key]未定义，则创建一个含有value的数组 if (result[key] == undefined) result[key] = [value]; else result[key].push(value); } // 不指定参数名称，返回全部的参数对象 if (sKey == undefined) return result; if (result[sKey] == undefined) return ""; else if (result[sKey].length == 1) return result[sKey][0]; else return result[sKey]; } 还有大神的正则的方法…直接贴出来吧： // 链接：https://www.nowcoder.com/questionTerminal/a3ded747e3884a3c86d09d88d1652e10 // 来源：牛客网 function getUrlParam(sUrl, sKey) { var obj = {}; var reg = /[?&amp;](\w+)=(\w+)/g; while(reg.exec(sUrl)) obj[RegExp.$1] ? obj[RegExp.$1]=[].concat(obj[RegExp.$1],RegExp.$2) : obj[RegExp.$1]=RegExp.$2; return sKey ? obj[sKey]||"" : obj; } dom节点查找 查找两个节点的最近的一个共同父节点，可以包括节点自身 输入描述 oNode1 和 oNode2 在同一文档中，且不会为相同的节点 代码 function commonParentNode(oNode1, oNode2) { for (;oNode1;oNode1 = oNode1.parentNode) { if (oNode1.contains(oNode2)) { return oNode1; } } } 还是对DOM的相关属性啊什么的不了解。。红宝书刚看到DOM。。。要加油鸭 根据包名，在指定空间中创建对象输入描述 namespace({a: {test: 1, b: 2}}, &#39;a.b.c.d&#39;) 输出描述 {a: {test: 1, b: {c: {d: {}}}}} 代码 function namespace(oNamespace, sPackage) { var tmpPoint = oNamespace; var keys = sPackage.split('.'); for (var i = 0; i &lt; keys.length; i++) { if (tmpPoint[keys[i]] == undefined) tmpPoint[keys[i]] = {}; tmpPoint = tmpPoint[keys[i]]; } return oNamespace; } 记住，对象名就像是指针一样。 数组去重 为 Array 对象添加一个去除重复项的方法 输入 [false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;, &#39;a&#39;, NaN] 输出 [false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;] 代码 Array.prototype.uniq = function () { var hasNaN = false; for (var i = 0; i &lt; this.length; i++) { if ((hasNaN === false) &amp;&amp; (this[i] != this[i])) { hasNaN = true; continue; } if (this.indexOf(this[i]) &lt; i) this.splice(i--,1); } return this; } 关于NaN的问题调试了好几次。。 使用this.indexOf(this[i]) &lt; i判断的时候， 因为NaN和任何值都不相等，因此index是-1，因此在这里一定会被删掉， 因此需要先判断是不是已经遇到过NaN了，遇到过的话再次遇到就直接删掉，没有遇到的话遇到时就把hasNaN设为true，然后continue来跳过splice。 斐波那契数列 用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等 emmmmm，不知道为什么会有斐波那契这种题。。。。 // 暴力递归 function fibonacci(n) { if (n &lt;= 0) return 0; if (n == 1) return 1; return fibonacci(n-1) + fibonacci(n-2); } // 本来想用callee，结果严格模式不让用。。。红宝书一直说callee多么多么好。。。搞得我不用好难受 // 循环 function fibonacci(n) { if (n &lt;= 0) return 0; if (n == 1) return 1; var a = 0, b = 1, c = 1; for (var i = 2; i &lt;= n; i++) { c = a + b; a = b; b = c; } return c; } 时间格式化输出 按所给的时间格式输出指定的时间格式说明对于 2014.09.05 13:14:20yyyy: 年份，2014yy: 年份，14MM: 月份，补满两位，09M: 月份, 9dd: 日期，补满两位，05d: 日期, 5HH: 24制小时，补满两位，13H: 24制小时，13hh: 12制小时，补满两位，01h: 12制小时，1mm: 分钟，补满两位，14m: 分钟，14ss: 秒，补满两位，20s: 秒，20w: 星期，为 [‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’] 中的某一个，本 demo 结果为 五 输入 formatDate(new Date(1409894060000), &#39;yyyy-MM-dd HH:mm:ss 星期w&#39;) 输出 2014-09-05 13:14:20 星期五 代码 function formatDate(date, format) { var myDate = { yyyy: date.getFullYear(), yy: date.getFullYear()%100, MM: ("0" + (date.getMonth()+1)).slice(-2), M: date.getMonth()+1, dd: ("0" + (date.getDate())).slice(-2), d: date.getDate(), HH: ("0" + date.getHours()).slice(-2), H: date.getHours(), hh: ("0" + (date.getHours() % 12)).slice(-2), h: date.getHours() % 12, mm: ("0" + date.getMinutes()).slice(-2), m: date.getMinutes(), ss: ("0" + date.getSeconds()).slice(-2), s: date.getSeconds(), w: ['日', '一', '二', '三', '四', '五', '六'][date.getDay()] } return format.replace(/([a-z]+)/ig,function($1){return myDate[$1];}); } 参考了大神的代码。。。自己差点就十几个if了。。。 关于代码说明几点： getFullYear()为年份四位表示 getMonth()为月份0-11 getDate()为日期1-31 getHours()为小时0-23 getMinutes()为分钟0-59 getSeconds()为秒数0-59 getDay()为0-6表示[‘日’, ‘一’, ‘二’, ‘三’, ‘四’, ‘五’, ‘六’] RegExp.$1...RegExp.$9表示用于存储第一、……第九个匹配的捕获组，至于什么是捕获组可以看下边这个例子： var text = "this has been a short summer"; var pattern = /(..)or(.)/g; if (pattern.exec(text)) { alert(RegExp.$1); // "sh" alert(RegExp.$2); // "t" } 获取字符串长度 如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1否则如果字符 Unicode 编码 &gt; 255 则长度为 2 输入 &#39;hello world, 牛客&#39;, false 输出 17 代码 function strLength(s, bUnicode255For1) { if (bUnicode255For1 === true) { return s.length; } else { var result = 0; for (var i = 0; i &lt; s.length; i++) { if (s.charCodeAt(i) > 255) result+=2; else result+=1; } return result; } } 刚开始一直没看懂题。。。这道题应该有点问题，js默认utf-16编码，所以不是所有字符都长度为1，有的字符是长度为2的。。。忽略这个写这个题吧。。。 邮箱字符串判断输入描述 邮箱字符串 输出描述 true表示格式正确 代码 function isAvailableEmail(sEmail) { var reg = /^[\w\.]+@[\w\.]+\.[\w\.]+$/i; return reg.test(sEmail); } \w 匹配字母或数字或下划线或汉字 等价于 ‘[^A-Za-z0-9_]’。 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 \w能不能匹配汉字要视你的操作系统和你的应用环境而定 颜色字符串转换 将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff rgb 中每个 , 后面的空格数量不固定 十六进制表达式使用六位小写字母 如果输入不符合 rgb 格式，返回原始输入 输入 &#39;rgb(255, 255, 255)&#39; 输出 #ffffff 代码 function rgb2hex(sRGB) { if(sRGB.slice(0,4)!=='rgb(' || sRGB.slice(-1)!==')') return sRGB; var tmp = (sRGB.split('(')[1]).split(')')[0]; var colors = tmp.split(','); if (colors.length != 3) return sRGB; var re = "#"; for (var i = 0; i &lt; colors.length; i++) { var value = parseInt(colors[i].substring(colors[i].lastIndexOf(' '))); if (value &lt; 0 || value > 255) return sRGB; re += ("0" + (value).toString(16)).slice(-2); } return re; } 又使用了最水的办法。。。 看一下大佬的正则的方法： //链接：https://www.nowcoder.com/questionTerminal/80b08802a833419f9c4ccc6e042c1cca //来源：牛客网 function rgb2hex(sRGB) { return sRGB.replace(/^rgb\((\d+)\s*\,\s*(\d+)\s*\,\s*(\d+)\)$/g, function(a, r, g, b){ return '#' + hex(r) + hex(g) + hex(b); }); } function hex(n){ return n &lt; 16 ? '0' + (+n).toString(16) : (+n).toString(16); } a代表正则匹配的整个字符串, r ,g, b代表红绿蓝三个通道, 分别是正则中的三个括号匹配的字符串. 通常用的$0, $1, $2, $3。 但是吧，可能是用例不全，这个方法并没有判断是不是超出0-255也能AC。。 可以在hex函数里加个判断，如果规范才返回字符串，然后在replace里的那个函数里加个判断hex(r)、hex(g)、hex(b)是否为undefined，像这样： function rgb2hex(sRGB) { return sRGB.replace(/^rgb\((\d+)\s*\,\s*(\d+)\s*\,\s*(\d+)\)$/g, function(a, r, g, b){ if (hex(r) == undefined || hex(g) == undefined || hex(b) == undefined) return sRGB; return '#' + hex(r) + hex(g) + hex(b); }); } function hex(n){ if (n > -1 &amp;&amp; n &lt; 256) { return n &lt; 16 ? '0' + (+n).toString(16) : (+n).toString(16); } } 这样就可以啦！ 将字符串转换为驼峰模式 css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能 以 - 为分隔符，将第二个起的非空单词首字母转为大写 -webkit-border-image 转换后的结果为 webkitBorderImage 输入 &#39;font-size&#39; 输出 fontSize 代码 function cssStyle2DomStyle(sName) { if (sName[0] == "-") sName = sName.slice(1); var words = sName.split('-'); var re = words[0]; for (var i = 1; i &lt; words.length; i++) { re = re + words[i][0].toUpperCase() + words[i].slice(1); } return re; } 大神的代码： // 链接：https://www.nowcoder.com/questionTerminal/2ded24e34ec34325a62d42d0c8479bae // 来源：牛客网 return sName.replace(/\-[a-z]/g , function(a, b){ return b == 0 ? a.replace('-','') : a.replace('-','').toUpperCase(); }); 其中b是offset。 replace第二个参数函数的参数表： 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 字符串字符统计 统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率 不限制 key 的顺序 输入的字符串参数不会为空 忽略空白字符 输入 &#39;hello world&#39; 输出 {h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1} 大神的代码： function count(str) { var obj = {}; str.replace(/\S/g,function(s){ !obj[s]?obj[s]=1:obj[s]++; }) return obj; } \S匹配非空字符串，function(s)里的s代表匹配到的每一项。 哎总结一句就是我好菜。。对JS了解还是太少。。。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端错题模糊题记录]]></title>
    <url>%2FWeb%E5%89%8D%E7%AB%AF%E9%94%99%E9%A2%98%E6%A8%A1%E7%B3%8A%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[HTML元素的alt和title有什么异同？ alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。 关于html5标签？ \&lt;audio> 标签定义声音，比如音乐或其他音频流。\&lt;canvas> 标签定义图形，比如图表和其他图像。\&lt;canvas> 标签只是图形容器，必须使用脚本来绘制图形。\&lt;article>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\&lt;menu> 标签定义命令的列表或菜单。\&lt;menu> 标签用于上下文菜单、工具栏以及用于列出表单控件和命令。command 元素表示用户能够调用的命令。\&lt;command> 标签可以定义命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。 有关HTML的Doctype和严格模式与混杂模式？ 文档类型 DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。 DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。 如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。 浏览器模式 浏览器有两种呈现模式：标准模式和混杂模式（quirks mode，也叫兼容模式）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。 DOCTYPE 切换 对于 HTML 4.01 文档， 包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。 包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。 但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。 DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。 NOSCRIPT标签是做什么用的？ noscript 元素用来定义在脚本未被执行时的替代内容（文本）。 CSS关于CSS的position属性？ static没有定位，元素出现在正常的流中。 fixed是相对于窗口的固定定位。 关于border:none以及border:0? 当定义border:none时，表示无边框样式，浏览器并不会对边框进行渲染，也就没有实际的宽度； 定义边框时，除了设置宽度外，还必须设置边框的样式才能显示出来。 关于CSS sprites图片字节？ CSS Sprites能减少图片的字节，曾经比较过多次，3张图片合并成1张图片的字节总是小于这3张图片的字节总和。 关于浏览器引擎？ Wekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。 另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。 还有Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。 另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核。 JavaScriptflash和js通过什么类如何交互? ExternalInterface。Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。 有关浏览器中使用js跨域获取数据？ 只要协议 、 域名 、 端口有任何一个不同, 都被当作是 不同 的域。 1.CORS CORS（Cross-Origin Resource Sharing，跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。 2.document.domain 将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。 注意： 不能将值设置为URL中不包含的域； 松散的域名不能再设置为紧绷的域名。 3.图像Ping var img=new Image(); img.onload=img.onerror=function(){ … … } img.src=”url?name=value”; 请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。 图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 缺点： 只能发送GET请求； 无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。 4.Jsonp var script=document.createElement(“script”); script.src=”url?callback=handleResponse”; document.body.insertBefore(script,document.body.firstChild); JSONP由两部分组成：回调函数和数据 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 数据是传入回调函数中的JSON数据。 优点： 能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 缺点： JSONP从其他域中加载代码执行，其他域可能不安全； 难以确定JSONP请求是否失败。 5.Comet Comet可实现服务器向浏览器推送数据。 Comet是实现方式：长轮询和流 短轮询即浏览器定时向服务器发送请求，看有没有数据更新。 长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。 流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。 6.WebSocket WebSocket可在一个单独的持久连接上提供全双工、双向通信。 WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。 var webSocket=new WebSocket(“ws://“); webSocket.send(message); webSocket.onmessage=function(event){ var data=event.data; … …. } 注意： 必须给WebSocket构造函数传入绝对URL； WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器； WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。 优点： 在客户端和服务器之间发送非常少的数据，减少字节开销。 如何获取一个元素节点（id 为 test）的父元素，找到之后如何删除这个元素节点（id 为 test）？ var testNode = document.getElementById('test'); var parentNode = testNode.parentNode; parentNode.removeChild(testNode); !编写一个 js 函数 jsonp 的处理函数: 讲解链接 // 手写jsonp function myCallback(data) { console.log(data) } function jsonp(url, data, callback) { // data是否是字符串，是的话证明data值就是函数名 if (typeof data == 'string') { callback = data data = {} } // 拼接data url += url.indexOf('?') === -1 ? '?' : '&amp;' url += 'callback=' + callback var params = "" for (var i in data) { params += '&amp;' + i + '=' + data[i] } url += params // 在页面插入script标签 var script = document.createElement('script') script.setAttribute('src', url) document.querySelector('head').appendChild(script) } jsonp('http://baidu.com/index.html', { id: 34 }, 'myCallback') jsonp('http://baidu.com/index.html?name="zjn"', { id: 34 }, 'myCallback') 编写一个函数判断参数是否是数组类型，如果是返回 true // 方法一： function isArray(arg){ return (arg instanceof Array); } // 方法二： function isArray(arg){ return Object.prototype.toString.call(arg) == '[object Array]' ? true : false; } // 方法三： function isArray(arg){ return arg.__proto__.constructor.name == 'Array' ？true : false; } 关于对象的length属性： Window.length //返回在当前窗口中frames的数量（包括IFRAMES） String.length //返回字符串中的字符数目 Function.length //获取一个函数定义的参数数目 Array.length //返回数组中元素的数目 如何获取 url 中的 query 字段对应的值，比如：https://m.mobike.com?source=part1，编写一个函数获取 source 对应的值 part1 let query = (url) => { let p = url.split('?')[1]; let sourcePos = p.indexOf('source'); if (sourcePos > -1) { if (p.indexOf('&amp;', sourcePos+7) > -1) { return p.substring(sourcePos+7,p.indexOf('&amp;', sourcePos+7)); } else { return p.substring(sourcePos+7); } } }; 关于IE的event对象支持的方法： IE的所有事件对象都支持的方法和属性： cancelBubble 默认为false，设置为true就可以取消事件冒泡 returnValue 默认为true，设置为false可以取消事件的默认行为 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用 type 被触发事件的类型 DOM事件的方法（IE的事件模型不支持）： initEvent() 初始化新创建的 Event 对象的属性 preventDefault() 通知浏览器不要执行与事件关联的默认动作 stopPropagation() 不再派发事件 JavaScript的函数调用有哪几种方式？请举例说明，并分析其不同之处。 以下 javascript 代码，在浏览器中运行的结果是 先全部输出first，然后全部输出second。 js 是运行于单线程环境中，定时器作用是在规定时间内将事件加入执行队列，而加入的前提是当前事件队列没有任何东西。 其他和后端 API 服务通信的方式有哪些 ajax websocket SSE 服务器端渲染 POST 提交的时候，content-type 有哪几种？ 常见的有四种 application/x-www-form-urlencoded application/json multipart/form-data text/xml 对前端工程化的理解，以及任意构建工具(webpack、gulp、grunt、rollup)的某一个使用的一些描述 前端工程化 https://blog.csdn.net/mayfla/article/details/78697020 webpack webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 Node.js 的核心模块 HTTP模块、URL模块、Query Strings模块、File System模块、Path模块、Global模块。 ajax事件有哪些]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下使用Deepin-wine的移植版安装qq微信等]]></title>
    <url>%2FUbuntu%E4%B8%8B%E4%BD%BF%E7%94%A8Deepin-wine%E7%9A%84%E7%A7%BB%E6%A4%8D%E7%89%88%E5%AE%89%E8%A3%85qq%E5%BE%AE%E4%BF%A1%E7%AD%89.html</url>
    <content type="text"><![CDATA[下载Deepin-wine的Ubuntu移植版： git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git 进入 deepin-wine-for-ubuntu/文件夹 在终端内运行./install.sh 这样就安装完成啦，现在就可以安装qq微信之类的软件啦： 所有deepin-wine内支持的windows软件下载地址 其中qq下载地址为：http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb 微信下载地址为：http://202.116.81.74/cache/6/01/mirrors.aliyun.com/2fcea7de3a93db0339ae7eb601f36a83/deepin.com.wechat_2.6.2.31deepin0_i386.deb 下载之后进入下载目录，终端内运行： sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb 和 sudo dpkg -i deepin.com.wechat_2.6.2.31deepin0_i386.deb即可。 然后在自己的应用程序目录就可以看到qq和微信了。]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习记录四]]></title>
    <url>%2FJavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B.html</url>
    <content type="text"><![CDATA[——《JavaScript高级程序设计（第2版）》学习笔记 要多查阅MDN Web 文档 BOMBrowser Object Model，浏览器对象模型。 BOM提供了很多用于访问浏览器的功能，这些功能与任何网页内容无关。 BOM缺少事实上的规范，因此浏览器之间共有的对象就成了事实上的标准。 没有所谓的标准BOM实现或者标准BOM接口。 图片来源于网络： window对象window文档 BOM的核心对象是window，表示浏览器的一个实例。 在浏览器中，window对象有双重角色： 通过JavaScript访问浏览器窗口的一个接口 ECMAScript规定的Global对象 因此window对象有权访问parseInt()等方法。 全局作用域因为window对象又是ECMAScript中的Global对象，因此在全局作用域中声明的所有变量、函数都会变成window对象的属性和方法。 在全局作用域中，this指向window。 ！窗口关系及框架因为书中使用的frameset和frame已经被HTML5废弃，用iframe取代，因此在看了HTML5后再来补充这一部分。 top、parent、一个框架一个window对象 ！窗口位置screenLeft、screenX、moveTo等属性等看完文档再来详细记。 ！窗口大小innerWidth、outerWidth、clientWidth、pageWidth、resizeTo()等属性等看完文档再来详细记。 导航和打开窗口window.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口，返回指向新窗口的引用。 window.open(URL,name,specs,replace)，具体格式看这里。 新创建的window对象有一个opener属性，保存着打开它的原始窗口对象。 安全限制弹窗广告问题。 为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。 弹出窗口屏蔽程序弹出窗口被屏蔽有两种可能： 被浏览器内置的屏蔽程序阻止，则window.open()很有可能返回null 被浏览器扩展或其他程序阻止，则window.open()通常会抛出异常 因此要想准确地检测弹出窗口是否被屏蔽： var blocked = false; try { var popup = window.open("https://blog.zmj97.top", "_blank"); if (popup == null) { blocked = true; } } catch(e) { blocked = true; } if (blocked) { alert("The Popup was blocked!"); } 检测弹出窗口是否被屏蔽并不会阻止浏览器显示与被屏蔽窗口的相关信息。 超时调用setTimeout()函数接受两个参数，要执行的代码和执行代码前要等待多少毫秒。 第一个参数可以是一个包含JavaScript代码的字符串（不推荐，就和在eval()函数中使用的字符串一样）， 也可以是一个函数： setTimeout("alert('Hello World!')", 1000); // 不推荐 // 推荐的调用方式 setTimeout(function() { alert('Hello World!'); }, 1000); 调用setTImeout()后，该方法会返回一个数值ID，表示超时调用， 可以用它作为参数调用clearTimeout()来取消超时调用。 超时调用ID是计划执行代码的唯一标识符。 // 设置超时调用 var timeoutId = setTimeout(function() { alert('Hello World!'); }, 1000); // 把它取消 clearTimeout(timeoutId); 超时调用的代码都是在全局作用域中执行的，因此函数中的this的值通常指向window对象。 间歇调用setInterval()函数接受两个参数，要执行的代码和每次执行代码前要等待多少毫秒。 setInterval("alert('Hello World!')", 1000); // 不推荐 // 推荐的调用方式 setInterval(function() { alert('Hello World!'); }, 1000); 取消间歇调用： var num = 0; var max = 10; var intervalId = null; function incrementNumber() { num++; // 如果执行次数到达max，则取消间歇调用 if (num == max) { clearInterval(intervalId); alert("Done"); } } intervalId = setInterval(incrementNumber, 500); 实际上，使用超时调用来模拟间歇调用被认为是最佳模式，因为后一个间歇调用可能会在前一个间歇调用结束之前启动。 var num = 0; var max = 10; function incrementNumber() { num++; // 如果执行次数未到达max，则设置另一次超时调用 if (num &lt; max) { setTimeout(incrementNumber, 500); } else { alert("Done"); } } setTimeout(incrementNumber, 500); 系统对话框alert()只有一个确认按钮 confirm()有确认和取消两个按钮，返回true表示点了确认，false表示点了取消 prompt()，提示框，有一个文本输入域和确认取消按钮，两个参数为要显示给用户的提示内容和文本输入域内的默认内容，如果点击确认则返回文本输入域的值，否则返回null。 三者均不涉及HTML、CSS、JavaScript。 还有含有复选框的对话框选择是否阻止后续的对话框的显示。 还可以在JavaScript中通过window.print()和window.find()来显示打印和查找对话框。这两者是异步显示的，因此对话框计数器的不会吧它们计算在内。 location对象提供了与当前窗口中加载的文档有关的信息和一些导航功能。 location对象既是window对象的属性，有事document对象的属性。 location将URL解析为独立的片段。 下面是location对象的所有属性（忽略了每个属性前的location前缀）： 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “blog.zmj97.top:80” 返回服务器名称和端口号（如果有） hostname “blog.zmj97.top” 返回不带端口号的服务器名称 href “https://blog.zmj97.top&quot; 返回当前加载页面的完整URL。location对象的toString()方法也返回这个值 pathname “/tag/“ 返回URL中的目录和/或文件名 port “8080” 返回URL指定的端口号。如果URL中不包含端口号，则返回空字符串 protocol “https:” 返回页面使用的协议，通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 查询字符串参数尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问每个查询字符串参数，因此可以： function getQueryStringArgs() { // 取得查询字符串并去掉开头的问号 var qs = (location.search.length > 0 ? location.search.substring(1) : ""); // 保存数据的对象 var args = {}; // 取得每一项 var items = qs.split("&amp;"); var item = null, name = null, value = null; // 逐个添加到args中 for (var i = 0; i &lt; items.length; i++) { item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); args[name] = value; } return args; } 位置操作location.assign(&quot;https://blog.zmj97.top&quot;)，立即打开新URL并在浏览器的历史记录中生成一条记录。 window.location = &quot;https://blog.zmj97.top&quot;和location.href = &quot;https://blog.zmj97.top&quot;与调用assign()的效果一样。 每次修改location对象的属性，页面都会以新URL重新加载（hash除外），并在浏览器的历史记录中生成一条新纪录（包括hash）。 使用location.replace(&quot;https://blog.zmj97.top&quot;)加载新页面后不会生成历史记录，也不能后退。 location.reload()重新加载，有可能从缓存中加载 location.reload(true)从服务器重新加载 位于reload()调用之后的代码可能会也可能不会执行，取决于网络延迟或系统资源等因素。 因此最好将reload()放在代码的最后一行。 navigator对象用于识别客户端浏览器，包含有关浏览器的信息。 检测插件navigator.plugins数组的每一项包含下列属性： name：插件名字 description：插件描述 filename：插件文件名 length：插件所处理的MIME类型数量 // 检查插件（IE中无效） function hasPlugin(name) { name = name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) { if (navigator.plugins[i].toLowerCase().indexOf(name) > -1) { return true; } } return false; } 每个插件对象本身也是一个MimeType对象的数组，包括四个属性： MIME类型描述description 回指插件对象的enablePlugin MIME类型对应的文件扩展名的字符串suffixes（以逗号分割） 完整MIME类型字符串type 在IE中检查插件只能使用专有的ActiveXObject类型，还要知道插件的COM标识符。 plugins集合有一个refresh()方法用于刷新插件，传入true会加载包含插件的所有页面。否则只更新插件不重新加载页面。 注册处理程序registerContentHandler()、registerProtocalHandler() 为站点指明处理特定类型的信息 screen对象所有浏览器都支持的属性： availHeight：可用的屏幕高度（像素高度-系统部件高度），只读 availWidth：可用的屏幕宽度（像素宽度-系统部件宽度），只读 colorDepth：用于表现颜色的位数，多数系统都是32位，只读 height：屏幕的像素高度 width：屏幕的像素宽度 history对象保存用户上网的历史记录 使用go()方法可以在用户的历史记录中任意跳转 history.go(-1); // 后退一页 history.go(2); // 前进两页 history.back(); // 后退一页 history.forward(); // 前进一页 也可以传入一个字符串：浏览器会跳转到历史记录中最近包含该字符串的页面 history.go("wrox.com"); // 跳转到最近的wrox.com页面 客户端检测不到万不得已，不要使用客户端检测。 先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。 能力检测又称特性检测，是最受人们接受的检测方式。 能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。 不用顾及特定的浏览器如何如何，只要它支持特定的能力，就可以给出解决方案。 基本模式： if (object.propertyInQuestion) { // 使用object.propertyInQuestion } 先测试达成目的的最常用的特性 必须测试实际要用到的特性，而不是通过判断另一个特性是否存在来判断是什么浏览器，然后决定是否用这个特性 如果确定自己的应用程序需要使用哪些特定的浏览器特性，最好一次性检测所有相关特性： // 确定浏览器是否支持Netscape风格的插件 var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length); 在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。 怪癖检测怪癖检测的目标是识别浏览器的特殊行为，知道浏览器存在什么缺陷。 例如IE中有一个bug，如果某个实例属性与标记为[[DontEnum]]的某个原型属性同名，则该实例属性不会出现在for-in循环中： var hasDontEnumQuirk = function() { var o = { toString: function() {} }; for (var prop in o) { if (prop == toString) { return false; } } return true; }(); 怪癖通常为某个浏览器独有的，且被归类为bug。 由于检测怪癖涉及运行代码，因此仅检测有直接影响的怪癖，且最好在脚本一开始就执行此类检测，以便尽早解决问题。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习记录三]]></title>
    <url>%2FJavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89.html</url>
    <content type="text"><![CDATA[——《JavaScript高级程序设计（第2版）》学习笔记 要多查阅MDN Web 文档 面向对象的程序设计创建对象工厂模式工厂模式是软件工程领域广为人知的一种设计模式，这种模式抽象了创建具体对象的过程。 用函数来封装以特定接口创建对象的细节： function createPerson(name, age, job) { var o = new Object; o.name = name; o.age = age; o.jpb = job; o.sayName = function() { alert(this.name); }; return o; } var person1 = createPerson("Nicholas", 29, "Software Engineer"); var person2 = createPerson("Greg", 27, "Doctor"); person1.sayName(); // "Nicholas" person2.sayName(); // "Greg" 工厂模式虽然解决了创建多个相似对的问题，却没有解决对象识别的问题。 构造函数模式我们可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。 function Person(name, age, job) { this.name = name; this.age = age; this.jpb = job; this.sayName = function() { alert(this.name); }; } var person1 = new Person("Nicholas", 29, "Software Engineer"); var person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // "Nicholas" person2.sayName(); // "Greg" 构造函数模式与工厂模式的区别： 没有显示地创建对象(new Object()) 直接将属性和方法赋给了this对象 没有return语句 函数名首字母大写 要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此this指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 这样通过构造函数模式创建的两个对象都有一个constructor（构造函数）属性，该属性指向Person： person1.constructor == Person; // true person1 instanceof Person; // true person1 instanceof Object; // true， 因为所有对象均继承自Object 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这正是构造函数模式优于工厂模式的地方。 将构造函数当做函数前边例子中的Person()函数可以通过下边任何一种方式来调用： // 当做构造函数使用 var person = new Person("Nicholas", 29, "Software Engineer"); person.sayName(); // 作为普通函数调用 Person("Greg", 27, "Doctor"); // 添加到window window.sayName(); // "Greg" //在另一个对象的作用域中调用 var o = new Obeject(); Person.call(o, "Kristen", 25, "Nurse"); o.sayName(); // "Kristen" 构造函数的问题使用构造函数的主要问题，是每个方法都要在每个实例上重新创建一遍，这是没有必要的，因此Person()可以像下边这样定义： function Person(name, age, job) { this.name = name; this.age = age; this.jpb = job; this.sayName = sayName; } function sayName() { alert(this.name); } 但是这样的话，在全局作用域中定义的函数(sayName())只能被 某个对象调用，这让全局作用域有点名不副实，而且如果对象需要定义很多方法，那么就要定义很多个全局函数，这样我们自定义的引用类型就毫无封装性可言。 但是这些问题可以通过使用原型模式解决。 原型模式关于prototype可以先看这一篇。 然后看下边这个例子： function Person() {} Person.prototype.name = "Nicolas"; Person.prototype.age = 29; Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); person1.sayName(); // "Nicolas" var person2 = new Person(); person2.sayName(); // "Nicolas" person1.sayName == person2.sayName; // true 在原型模式下，对象调用这些属性和方法时，实际上是调用prototype的属性和方法。 理解原型默认情况下，所有prototype属性都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype所在函数的指针。 如果person1的__proto指向Person的prototype，则 Person.prototype.isPrototypeOf(person); // true 当为对象实例添加一个属性时，这个属性就会屏蔽源性对象中保存的同名属性，但不会修改那个属性。 如果将为对象实例添加的这个属性设为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。 要想重新访问原型中的属性，可以使用delete操作符完全删除实例属性， 使用hasOwnProperty()可以检测一个属性是否存在于实例中（这个方法是从Object继承来的），如果是原型属性则返回false： function Person() {} Person.prototype.name = "Nicolas"; Person.prototype.age = 29; Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.hasOwnProperty("name"); // false person1.name = "Greg"; person1.name; // "Greg"————来自实例 person2.name; // "Nicolas"————来自原型 person1.hasOwnProperty("name"); // true person2.hasOwnProperty("name"); // false delete person1.name; person1.name; // "Nicolas"————来自原型 person1.hasOwnProperty("name"); // false 原型与in操作符in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。因此对于上面的例子，在person1和person2声明后，无论何时调用&quot;name&quot; in person1或&quot;name&quot; in person2都会得到true。 因此，在hasOwnPrototype()返回false而使用in操作符返回true时，就说明这个属性是原型属性。 in操作符还可以通过for-in循环使用，返回的是所有能通过对象访问的、可枚举的（enumerated）属性和方法。 原型中不可枚举的属性和方法（即设置了[[DontEnum]]标记的属性和方法）有hasOwnProperty()、propertyIsEnumerable()、toLocalString()、toString()和valueOf()，有的浏览器也为constructor和prototype打上标记， 但是当我们在实例中添加这些属性和方法从而屏蔽了原型中的这些属性和方法时，那么这些属性和方法就会被认为是可枚举的（IE中除外）： var o = { toString: function() { return "My Object"; } }; for (var prop in o) { if (prop == "toString") { alert("Found toString"); // 在IE中不会显示，其他浏览器显示 } } 更简单的原型方法每添加一个属性和方法就要敲一遍Person.prototype是不必要的，同事也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： function Person() {} Person.prototype = { /* 重写prototype会导致其constructor等于Object， * 若constructor的值很重要，可以给constructor设置回适当的值 */ constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", sayName: function(){ alert(this.name); } }; var person = new Person(); person.constructor == Person; // 若是添加了上边constructor那一句则为true 原型的动态性由于在原型中查找值的过程是一次搜索，因此对原型对象的修改都能够立即从实例中反映出来， 但是如果像上边的例子一样重写了原型，在重写原型之前声明的实例的__proto__指向的仍是最初的原型： function Person() {} var person = new Person(); Person.prototype.sayHi = function() { alert("hi"); }; person.sayHi(); // "hi"，没有问题 Person.prototype = { constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", sayName: function(){ alert(this.name); } }; person.sayHi(); // "hi"，没有问题 person.sayName(); //error 原生对象的原型所有原生的引用类型，都是采用原型模式创建的。因此我们亦可以对原生引用类型的prototype添加属性或方法。 以String为例： String.prototype.startsWith = function(text) { return this.indexOf(text) == 0; }; var msg = "Hello World!"; msg.startsWith("Hello"); // true 但是不建议在产品化的程序中修改原生对象的原型。 原型对象的问题如果一个原型的属性包含引用类型值时，实例对该属性进行操作时，实际上修改的就是原型中的属性（引用类型对象名可以看做指针），因此当其他实例访问该属性时，得到的就是这个实例修改后的值： function Person() {} Person.prototype = { constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", friends: ["Shelby", "Court"], // 属性值为引用类型 sayName: function(){ alert(this.name); } }; var person1 = new Person(); var person2 = new Person(); person1.friends.push("Van"); person1.friends; // ["Shelby", "Court", "Van"] person2.friends; // ["Shelby", "Court", "Van"] person1.friends == person2.friends; // true 组合使用构造函数模式和原型模式使用构造函数模式定义实例属性，原型模式定义方法和共享的属性， 这样每个实例都会有自已的一份实例属性的副本，又共享着对方法的引用，最大限度地节省了内存，还可以向构造函数传递参数： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.friends = ["Shelby", "Court"]; } Person.prototype = { constructor: Person, sayName: function(){ alert(this.name); } }; var person1 = new Person("Nicholas", 29, "Software Engineer"); var person2 = new Person("Greg", 27, "Doctor"); person1.friends.push("Van"); person1.friends; // ["Shelby", "Court", "Van"] person2.friends; // ["Shelby", "Court"] person1.friends == person2.friends; // false person1.sayName == person2.sayName; // true 这种混合使用的模式是ECMAScript中使用最广泛、认同度最高的自定义类型的方法。可以说是一种默认模式。 动态原型模式这种模式把所有信息都封装在了构造函数中，并在构造函数中通过检查某个应该存在的方法是否有效，来决定是否需要初始化模型： function Person(name, age, job) { // 属性 this.name = name; this.age = age; this.job = job; // 方法 // 只有在sayName()方法不存在时才将其添加到原型中 // 即只有在初次调用构造函数时才会执行下面的代码 // if语句只需要判断一个方法（例如sayName）是否存在 if (typeof this.sayName != "function") { Person.prototype = { constructor: Person, sayName: function() { alert(this.name); }, sayHi: function() { alert("hi"); } }; } } 其他构造函数模式寄生构造函数模式和稳妥构造函数模式，寄生构造模式没有什么意义这里就不再赘述，稳妥构造函数模式相当于为引用类型添加了private属性，有兴趣可以自行搜索。 继承在ECMAScript中无法实现接口继承（与函数无法重载的理由相同，ECMAScript中的函数没有签名）， 但是可以利用原型链实现实现继承。 原型链除了这一篇讲到的，还应注意： 别忘记默认的原型：Object.prototype 确认原型和实例的关系：利用instanceof和isPrototypeOf() 谨慎地定义方法 给原型添加方法的代码一定要放在替换原型的语句之后 在通过原型链实现继承时，不同通过对象字面量创建原型方法（重写原型会切断原型链） 原型链的问题 与原型的问题相同，如果原型包含引用类型值，那么所有同一个继承类型的实例都会共享一个引用类型值 在创建子类型的实例时，不能像超类型的构造函数传递参数 借用构造函数又叫伪造继承或经典继承。 在子类型构造函数得到内部利用调用超类型的构造函数，还可以传递参数。 function SuperType(name) { this.name = name; } function SubType() { // 继承了SuperType，同时还传递了参数 SuperType.call(this, "Nicholas"); // 实例属性 this.age = 29; } var instance = new SubType(); instance.name; // "Nicholas" instance.age; // 29 但是如果方法都在构造函数中定义，函数复用就无从谈起了。 组合继承combination inheritance，伪经典继承，组合使用原型链和借用构造函数。 使用原型链实现原型属性和方法的继承，通过借用构造函数实现实例属性的继承， 这样既可以实现函数复用，又能保证每个实例都有它自己的属性。 同时，instanceof和isPrototypeOf也能识别基于组合继承创建的对象。 function SuperType(name) { this.name = name; this.colors = ["red", "green", "blue"]; } SuperType.prototype.sayName = function() { alert(this.name); }; function SubType(name, age) { // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function(){ alert(this.age); }; var instance1 = new SubType("Nicholas", 29); instance1.colors.push("black"); instance1.colors; // ["red", "green", "blue", "black"] instance1.sayName(); // "Nicholas" instance1.sayAge(); // 29 var instance2 = new SubType("Greg", 27); instance1.colors; // ["red", "green", "blue] instance1.sayName(); // "Greg" instance1.sayAge(); // 27 组合继承融合了前两者的优点，因此成为JavaScript中最常用的继承模式。 原型式继承主要用于只是想让一个对象与另一个对象保持类似，没有必要兴师动众地创建构造函数。 function object(o) { function F() {} F.prototype = o; return new F(); } 这样子实际上是object()函数对传入的对象执行了一次浅复制： var person = { name: "Nicholas", friends: ["Shelby", "Court", "Van"]; }; var anotherPerson = object(person); anotherPerson.name = "Greg"; anotherPerson.friends.push("Rob"); person.friends; // ["Shelby", "Court", "Van", "Rob"] person.name; // "Nicholas" anotherPerson.name; // "Greg" 寄生式继承寄生式，parasitic。 思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象。 但是也会因为做不到函数复用而降低效率。 适用于主要考虑对象而不是自定义类型和构造函数的情况： function createAnother(original) { // 通过调用函数创建一个新对象，不一定使用object()函数 var clone = object(original); // 以某种方式增强这个对象 clone.sayHi = function() { alert("hi"); }; // 返回这个对象 return clone; } var person = { name: "Nicholas", friends: ["Shelby", "Court", "Van"]; }; var anotherPerson = createAnother(person); anotherPerson.sayHi(); // "hi" 寄生组合式继承对于为什么要寄生组合式继承，看了这篇文章还有知乎上的一些回答，主要的优势是组合继承两次调用了构造函数，而寄生只使用了一次。 刚开始不理解的是，为什么在创建超类型原型副本时对超类型原型的实例化就不算调用构造函数呢？ 后来仔细想了一下，的确可以不算调用了构造函数—— object()函数内的临时类型F的构造函数为空（function F() {}），因此可以忽略不计。 以下是代码： function object(o) { // 主要区别就是这里，构造函数的不同 function F() {} F.prototype = o; return new F(); } function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); // 拷贝原型 prototype.constructor = subType; // 弥补因重写prototype而失去的默认的constructor属性 subType.prototype = prototype; // 替换子类型原型 } function SuperType(name) { this.name = name; this.colors = ["red", "green", "blue"]; } SuperType.prototype.sayName = function() { alert(this.name); }; function SubType(name, age) { // 继承属性 SuperType.call(this, name); this.age = age; } // 寄生组合式继承 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function(){ alert(this.age); }; 匿名函数没有名字的函数，也成为拉姆达(lamda)函数。 像 var functionName = function(arg0, arg1, arg2) { // 函数体 } 这样的函数表达式相当于创建了一个匿名函数，然后将这个匿名函数赋给一个变量。 将函数作为参数传入另一个函数，或者从一个函数中返回另一个函数时，通常都是用匿名函数。 递归（虽然不知道为什么这本书要在这里再讲一遍这个，也许可能意思是callee指向的实际上是匿名函数，不管怎么样复习一下callee吧） 前边在讲到函数内部对象arguments的属性callee(指向拥有这个arguments的函数)时有提到过递归阶乘函数这个例子： function factorial(num) { if (num &lt;= 1) { return 1; } else { return num * arguments.callee(num-1); // 建议 // return num * factorial(num-1); // 不建议 } } var anotherFactorial = factorial; factorial = null; anotherFactorial(4); // 使用callee这里结果为24， 函数内使用factorial这里会出错 闭包有些人会分不清闭包和匿名函数。 闭包指的是有权访问另一个函数作用域的函数。 创建闭包的常见方式是在一个函数内部创建另一个函数。 作用域链首先先回顾一下作用域链（scope chain）。 当一个函数第一次被调用时，会创建一个执行环境（execute context）及相应的作用域链，并将作用域链赋值给一个特殊的内部属性[[Scope]]。 然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。 这个活动对象处于作用域链的顶端，外部函数的活动对象处于第二位，外部函数的外部函数的活动对象处于第三位，… … 直到全局执行环境的变量对象处于作用域链终点。 一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。 但是，闭包的情况又有所不同。 在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中，当外部函数执行完毕后，如果内部的这个函数还未执行，即其作用域链还在引用外部函数的活动对象时，这个活动对象就不会被销毁。 知道内部的这个函数执行完毕，外部函数的活动对象才会随之一起销毁。 由于闭包会携带包含它的函数的作用域，因此回比其它函数占用更多内存，因此建议只有在必要时再考虑使用闭包。 闭包与变量作用域链的这种配置机制有一个副作用：闭包只能取得包含函数的任何变量的最后一个值。 function createFunctions() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function() { return i; }; } return result; } var funcs = createFunctions(); // 每个函数都输出10 for (var i = 0; i &lt; funcs.length; i++) { document.write(funcs[i]() + "&lt;br />"); } 因为每个函数的作用域链都保存着createFunctions()的活动对象，因此它们引用的都是同一个变量i， 当createFunctions()函数返回后，变量i的值为10， 所以每个函数内部的i都是10。 可以通过创建另一个匿名函数强制让闭包行为符合预期： for (var i = 0; i &lt; 10; i++) { result[i] = (function(num) { return function(){ return num; }; })(i); } 在这里，定义了一个立即执行的匿名函数，并将它的结果赋给数组。 在立即执行时，传入了变量i，又因为函数参数是按值传递的，因此就会将i的当前值赋给num。 而这个函数内部，又创建并返回了一个访问num的闭包。 这样，result数组中每个函数都有一个自己的num变量的副本，就可以返回不同的值了。 关于this对象在闭包中使用this对象也可能导致一些问题。 this对象是在运行时基于函数的运行环境绑定的： 在全局函数中，this等于window 当函数被作为某个对象的方法调用时，this等于那个对象 匿名函数的执行环境具有全局性，如果通过call()或者apply()改变环境执行环境，this会指向其他环境，但通常this指向window。 arguments也有同样的问题， 因此如果想访问作用域中的this和arguments对象，必须将对它们的引用保存到另一个闭包能够访问的变量中，然后就可以让闭包访问该对象了，以this为例： var name = "The Window"; var object = { name: "My Object", getNameFunc1: function() { return function() { return this.name; } }, getNameFunc2: function() { var that = this; return function() { return that.name; } } }; object.getNameFunc1(); // "The Window" object.getNameFunc2(); // "My Object" 内存泄露由于IE对JScript对象和COM（组件对象模型）对象使用不同的垃圾收集例程，因此闭包在IE中可能会导致问题。 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁： function assignHansdler() { var element = document.getElementById("someElement"); element.onclick = function() { alert(element.id); }; } 以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。 由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。 只要匿名函数存在，element的引用数至少也是1，因此它占用的内存永远都不会被回收。 可以用如下方式解决： function assignHansdler() { var element = document.getElementById("someElement"); var id = element.id; element.onclick = function() { alert(id); }; element = null; } 这样就消除了循环引用。 需要注意的是，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。 因此 ，有必要把element设为null。 模仿块级作用域JavaScript在遇到多次声明一个变量的情况时，会自动忽略后边的声明，但是会执行后边声明中的初始化。 JavaScript没有块级作用域的概念， 因此块语句中定义的变量，实际上是在包含函数中而不是语句中创建的。 可以用匿名函数来模仿块级作用域（私有作用域）来避免这个问题： (function() { // 块级作用域 })(); 需要注意的是，JavaScript将function当做一个函数声明的开始，而函数声明后边是不能跟括号的。 因此上边代码中函数外面包括的括号不能省略。这样可以把函数声明转换成函数表达式。 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。 在匿名函数中的任何变量，都会在执行结束时销毁。 我们应该通过创造私有作用域来尽量少地向全局作用域添加变量和函数，以免导致命名冲突。 私有变量除了前边提到的稳妥构造函数模式，还可以： 在构造函数中定义特权方法： function MyObject() { // 函数的私有变量 var privateVariable = 10; // 函数的私有函数 function privateFunction() { return false; } // 特权方法 this.publicMethod = function() { privateVariable++; return privateFunction(); }; } 在创建MyObject实例后，除了publicMethod没有任何方法可以直接访问privateVariable和privateFunction()。 或者利用私有和特权成员，隐藏那些不应该被直接修改的数据： function Person(name) { this.getName = function() { return name; }; this.setName = function(value) { name = value; } } var person = new Person("Nicholas"); person.getName(); // "Nicholas" person.setName("Greg"); person.getName(); // "Greg" 私有变量name在每一个实例的作用域中都不相同，因为每次调用构造函数都会重新创建这两个方法。 但是这样使用构造函数会有构造函数模式的缺陷：无法方法复用。每次创建实例都会创建同样一组方法，用静态私有变量来实现特权方法就可以解决这个问题。 静态私有变量(function() { var name = ""; // 没有使用var声明，因此为全局变量 Person = function(value) { name = value; } Person.prototype.getName = function() { return name; } Person.prototype.setName = function(value) { name = value; } })(); var person1 = new Person("Nicholas"); person1.getName(); // "NIcholas" person1.setName("Greg"); person1.getName(); // "Greg" var person2 = new Person("MIchael"); person1.getName(); // "MIchael" person2.getName(); // "MIchael" 在这种模式下，name就变成了静态的、由所有实例共享的属性。 因此每次改变name改变的是所有实例的name。 这样创造静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 因此使用哪个方法还要视具体情况而定。 多查找作用域链的一个层次会一定程度上影响查找速度，这正是闭包和私有变量的一个明显的不足之处。 对于私有变量，我认为可以使用两者组合的模式，不知道对不对，这里贴出想法，欢迎指正（zmj原创，转载需注明出处）： function Person(name) { this.getName = function() { return name; }; this.setName = function(value) { name = value; } } (function() { var teacher = "Nicholas"; // 初始化 Person.prototype.getTeacher = function() { return teacher; } Person.prototype.setTeacher = function(value) { teacher = value; } })(); 这样，就既有实例自己的私有变量，也有静态私有变量了。 模块模式模块模式（module pattern）是为单例（singleton）创建私有变量和私有方法。 所谓单例就是只有一个实例的对象，一般以对象字面量的方式来创建： var singleton = { name: value, method: function() { // 这里是方法的代码 } }; 模块模式通过为单例添加私有变量和特权方法来使其增强： var singleton = function() { // 私有变量和私有函数 var privateVariable = 10; function privateFunction() { return false; } // 特权/公有方法和属性 return { publicProperty: true, publicMethod: function() { privateVariable++; return privateFunction(); } }; }(); 这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是十分有用的： function BaseComponent() {} function OtherComponent() {} var application = function() { // 私有变量和函数 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 公共 return { getComponentCount: function() { return components.length; }, registerComponent: function(component) { if (typeof component == "object") { components.push(component); } } }; }(); application.registerComponent(new OtherComponent()); application.getComponentCount(); // 2 在Web应用程序中，经常使用一个单例来管理应用程序级的信息。 以这种模式创建的单例都是Object的实例。 增强的模块模式如果单例必须是某种类型的实例，还必须添加某些属性和/或方法加以增强，可以使用增强的模块模式： function BaseComponent() {} var application = function() { // 私有变量和函数 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 创造application的一个局部副本 var app = new BaseComponent(); // 公共接口 app.getComponentCount: function() { return components.length; }； app.registerComponent: function(component) { if (typeof component == "object") { components.push(component); } }； // 返回这个副本 return app; }();]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo的评论系统由gitment改为Valine]]></title>
    <url>%2F%E5%B0%86hexo%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%94%B1gitment%E6%94%B9%E4%B8%BAValine.html</url>
    <content type="text"><![CDATA[首先注册LeanCloud，注册后添加应用，然后选择应用&gt;设置&gt;应用key就可以看到自己的AppID和AppKey了。 然后进入自己的主题目录（比如我的主题是默认的landscape）： 删除配置gitment时/themes/landscape/layout/_partial/post目录下添加的git.ejs文件， 然后编辑/themes/landscape/layout/_partial/目录下的article.ejs，将原本配置gitment时添加在最后的那段代码删掉，添加： new Valine({ el: '#vcomments', appId: '你的appid', appKey: '你的appkey', notify:true, verify:true, visitor:true, avatar:'mm', placeholder: '嘻嘻嘻' }) 其中notify为邮件提醒功能是否开启，verify为验证码功能，visitor为文章访问量统计功能，avatar为Gravatar 头像展示方式。 在leancloud的应用&gt;设置&gt;安全中心&gt;Web安全域名中添加你的域名。 然后就OK啦！！ 有其他问题可以访问Valine官方文档查看。 关于出现Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置.的问题： 我的问题是同时在github和coding上部署了，但是在leancloud的应用&gt;设置&gt;安全中心&gt;Web安全域名中只添加了github的域名，因此在coding的那个域名访问时就会出现上述问题，添加域名即可解决问题。]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习记录二]]></title>
    <url>%2FJavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C.html</url>
    <content type="text"><![CDATA[——《JavaScript高级程序设计（第2版）》学习笔记 要多查阅MDN Web 文档 变量、作用域和内存问题基本类型和引用类型的值ECMAScript变量可能包含两种不同数据类型的值： 基本类型值：保存在栈内存中的简单数据段，这种值完全保存在内存中的一个位置 引用类型值：保存在堆内存中的对象，保存的实际上是一个指针，指针指向内存中真正对象保存的位置 五种基本数据类型：Undefined、Null、Boolean、Number、String在内存中占有固定大小的空间，因此可以保存在栈内存中。因为我们操作的是它们实际保存的值，所以它们是按值访问的。 对于对象，先从栈中读取内存地址，然后再按照地址找到保存在堆中的值。因为我们操作的不是实际的值，而是那个值所引用的对象，因此我们称之为按引用访问的。（图片来源于网络，cr 水印） 动态属性对于对象，我们可以改变和删除其属性和方法，但是不能给基本类型的值添加属性。 即只能给引用类型值动态地添加属性。 复制变量值当复制基本类型值的时候，会在栈中为其开辟一块新的内存保存其值。 但是当复制引用类型的值时，实际上复制保存的是这个对象在堆内存中的地址，也就是两者指向的是同一个对象。 传递参数ECMAScript中所有的函数的参数都是按值传递的。 传递基本类型值就如基本类型变量的复制一样，传递引用类型变量时也如同引用变量的复制。 因此传递引用类型的变量时，传递的相当于是拷贝的指针。 可以看下边这个例子（我觉得可以把对象看做是一个指向对象的指针，然后函数传递的是一个拷贝的指针）： function setName(obj) { obj.name = "Nicholas"; obj = new Object(); obj.name = "Greg"; } var person = new Obejct(); setName(person); alert(person.name); // "Nicholas" 检测类型typeof检测null返回”object” 当我们想知道一个对象是什么类型的对象时，可以使用instanceof，它的语法是： result = variable instanceof constructor 如果变量是给定引用类型（由构造函数表示）的实例，则instanceof返回true： alert(person instanceof Object); // 变量person是Object么？ alert(colors instanceof Array); // 变量colors是Array么？ 当使用instanceof检测基本类型的值时始终返回false，因为基本类型不是对象。 注： 在Safiri和Chrome中使用typeof检测正则表达式会错误的返回”function”。 执行环境和作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。 一个执行环境中的所有代码执行完毕后，该环境和保存在其中的所有变量和函数定义都被销毁， 全局执行环境直到关闭页面或者浏览器时才会被销毁。 关于作用域链可以看这里。 延长作用域链 with语句： 其变量对象包含为指定的对象的所有属性和方法所做的变量声明。 catch语句： 包含被抛出的错误对象的声明 在IE的JavaScript实现中，catch语句捕获的错误对象会被添加到执行环境的变量对象中。 没有块级作用域 使用if 、for语句创建的变量会保存在语句外部的执行环境中。 函数内部是一个局部环境 访问局部变量比全局变量快，因为不用向上搜索作用域链 垃圾收集JavaScript具有自动垃圾收集机制，按照固定的时间间隔或代码执行中预定的收集时间，周期性地找出不再使用的变量释放其内存。 关于垃圾收集方式的详细解释可以看这里。 关于性能问题和管理内存可以看这里。 引用类型Object类型创建Object实例的方式： var xxx = new Object() var xxx = {age: 29}, {}是对象字面量边界 可以用xxx.age或者xxx[&#39;age&#39;]来访问属性，更建议用点表示法。 Array类型ECMAScript数组的每一项可以保存任何类型的数据。 数组的索引从0开始。 数组的项数保存在其length属性中，它并不是只读的，可以通过设置它来在数组的末尾移除或添加项，添加项的初始值为undefined。 因为JavaScript使用一个32位整数保存数组元素个数，因此数组最多可以包含4294967295项（2的32次方减1）。 以下是创建数组的例子： // new 可以省略 var a = new Array(); // 创建一个空数组 var b = new Array(20); // 创造一个包含20项的数组，每一项的初始值都是undefined var c = new Array("red", "blue", "green"); // 创造一个包含三项："red","blue","green"的数组 var d = ["red", "blue", "green"]; // 创造一个包含三项："red","blue","green"的数组 var e = []; // 创建一个空数组 var f = [1,2,]; // 不要这样！这样会创建一个包含2或3项的数组 var g = [,,,,,]; // 不要这样！这样会创建一个包含5或6项的数组 转换方法valueOf()返回当前对象的原始值； toString()方法先调用每一项的toString()方法，然后用逗号将它们拼接起来并返回； toLocalString()方法先调用每一项的toLocalString()方法，然后用逗号将它们拼接起来并返回； 如果使用join()方法可以使用不同的分隔符来构建这个字符串： var a = ['a','b','c']; alert(a.join(',')); // 'a,b,c' alert(a.join('||')); // 'a||b||c' 如果某一项是undefined或null，那么在toString()、toLocalString()、join()方法返回的结果中以空字符串表示。 栈方法ECMAScript为数组提供了push()和pop()方法，以便实现类似栈的行为（LIFO，后进先出）。 push()方法可以接受任意数量的参数，然后把它们逐个添加到数组末尾，并返回修改后的数组长度 pop()方法则从数组末尾移除最后一项，并将length减一，返回移除的项。 队列方法可以使用push()和shift()方法，实现类似于队列的行为（FIFO，先进先出）。 shift()方法从数组开头移除第一项，并将length减一，返回移除的项。 ECMAScript还提供了unshift()方法，可以接受任意数量的参数，然后把它们逐个添加到数组头部，并返回修改后的数组长度（IE返回undefined）。 关于unshift()的添加多个变量的顺序： a = ["a", "b", "c", null]； a.unshift('1','2'); // ["1", "2", "a", "b", "c", null] 重排序方法reverse()会反转数组项的顺序： var a = [1,2,6,5,3,0]; a.reverse(); alert(a); // 0,3,5,6,2,1 sort()为排序函数，默认从小到大排序，也可以传入一个比较函数： var a = [1,2,6,5,3,0]; a.sort(); alert(a); // 0,1,2,3,5,6 function compare(v1, v2) { if (v1 &lt; v2) { return 1; } else if (v1 > v2) { return -1; } else { return 0; } } a.sort(compare); alert(a); // 6,5,3,2,1,0 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以简化一下比较函数： // 升序排序 function compare1(v1, v2) { return v1 - v2; } // 降序排序 function compare1(v1, v2) { return v2 - v1; } 操作方法concat()——先创建一个当前数组的副本，然后将接收到的参数添加到这个副本的末尾，返回新构建的这个数组： var a = ['1','2','3']; var b = a.concat('4',['5','6']); alert(a); // 1,2,3 alert(b); // 1,2,3,4,5,6 slice()——局部拷贝数组，接受一个参数或两个参数； 一个参数时拷贝从这个参数指定的位置到结尾； 两个参数时，拷贝两个参数之间的项，不包含结束为止的项。 当参数为负数时，则用该数加数组长度： 若加完之后大于等于零则用加完后的数计算 若加完之后还小于0则把该数看做0 若起始位置大于结束位置，则返回空数组。 下边为一个简单的例子： var a = [0,1,2,3,4]; var b = a.slice(1); var c = a.slice(1,4); alert(a); // 1,2,3,4 alert(b); // 1,2,3 splice()主要用途是向数组的中部插入项，对原数组进行操作 使用方式主要有三种： 删除： 指定两个参数——要删除的第一项的位置和要删除的项数，返回被删除的项 插入： 指定三个参数——起始位置、0（要删除的项数）、要插入的项（任意数量），返回被删除的项（空） 替换： 指定三个参数——起始位置、要删除的项数、要插入的项（任意数量），返回被删除的项（空） 代码例子可以看这里。 Date类型是在早期Java中的java.util.Date类基础上构建的。 因此Date类型使用自UTC（国际协调时间）1970年1月1日零时开始经过的毫秒数来保存日期。 Date类型保存的日期能够精确到1970年1月1日前后285616年。 关于创建日期和设置日期可以看这里。 Date对象属性及方法可以看这里。 将表示日期的字符串传递给Date构造函数，后台会自动调用Date.parse()，然后将得到的值传给构造函数。 Date对象可以直接进行大小比较。 可以进行日期加减，下边的例子表示五天后的日期： var myDate=new Date(); myDate.setDate(myDate.getDate()+5); RegExp类型正则表达式： var expression = / pattern / flags 正则表达式语法看这里。 flags为一个或多个标志，正则表达式的匹配模式支持下面三个标志： g——全局(global)模式，应用于所有字符串 i——不区分带小写(case-insensitive)模式 m——多行(multiiline)模式，到达一行文本末尾时还会继续查找喜爱航是否存在与模式匹配的项 元字符：()[]{}\^$|?*+.，元字符必须转义。 以下是一些例子： var pattern1 = /at/g; // 匹配字符串中所有"at"实例 var pattern2 = /.at/gi; // 匹配字符串中所有以"at"结尾的三个字符的实例，不区分大小写 var pattern3 = /\.at/gi; // 匹配字符串中所有".at"实例，不区分大小写 var pattern4 = /[bc]at/i; // 匹配字符串中第一个"bat"或"cat"实例，不区分大小写 var pattern5 = /\[bc\]at/i; // 匹配字符串中第一个"[bc]at"实例，不区分大小写 也可以使用构造函数来定义，例如下边两个式子得到的值是等价==相同的： var pattern1 = /[bc]at/i; var pattern2 = new RegExp("[bc]at", "i"); 需要注意的是，构造函数的字符串中，元字符必须双重转义，比如/\./双重转义为”\\.” 实例属性 global——布尔值，表示是否设置了g标志 ignoreCase——布尔值，表示是否设置了i标志 multiline——布尔值，表示是否设置了m标志 lastIndex——整数，表示开始搜索下一个匹配项的字符位置，从0算起 source——正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法关于exec()方法看这里。 关于test()方法看这里。 RegExp构造函数属性 长属性名 短属性名 说明 input $_ 最近一次要匹配的字符串 lastMatch $&amp; 最近一次的匹配项 lastParen $+ 最近一次匹配的捕获组 leftContext $` input字符串中lastMatch之前的文本 rightContext $’ input字符串中lastMatch之后的文本 multiline $* 布尔值，表示是否所有表达式都使用多行模式 注：书中说Opera不支持input、lastMatch、lastParent、multiline，但查阅MDN文档显示的是支持的，因此待验证。 关于如何使用，以lastMatch为例： var re = /hi/g; re.test('hi there!'); RegExp.lastMatch; // "hi" RegExp['$&amp;']; // "hi" 另外对于书中提到的ECMAScript正则表达式不支持的特性，因为版本不断更新，比如现在已经支持Unicode，因此就不在这里列出来了。 Function类型所有函数实际上都是Function类型的实例，且与其他引用数据类型一样具有属性和方法。 “函数是对象，函数名是指针”。 定义函数的方式： function sum1(num1, num2) { return num1 + num2; } var sum2 = function(num1, num2) { return num1 + num2; }; var sum3 = new Function('num1', 'num2', 'return num1 + num2'); // 不推荐 深入理解没有重载将函数名想象为指针，当用同一个函数名重新声明一个函数实际上相当于改变了指针的指向。 指针只能指向一个对象。 函数声明与函数表达式// 函数声明 function sum1(num1, num2) { return num1 + num2; } // 函数表达式 var sum2 = function(num1, num2) { return num1 + num2; }; 解析器会率先读取函数声明，并使其在执行任何代码之前可用， 但是对于函数表达式，必须等到解析器执行到它所在的代码行才会真正被解释执行。 可以同时使用函数声明和函数表达式var sum1 = function sum2() {}，但会在Safari中导致错误。 作为值的函数函数名本身就是变量，因此可以把函数当做参数传递，这里有人总结了当做参数传递的用法。 函数内部属性在函数内部有两个特殊的对象：arguments和this。 arguments还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数，有什么用呢？可以看阶乘函数这个例子： function factorial(num) { if (num &lt;= 1) { return 1; } else { return num * factorial(num-1); } } 像这样递归，我们在修改函数名、拷贝函数后修改原函数内容后都会遇到麻烦，因此就要用到callee属性了： function factorial(num) { if (num &lt;= 1) { return 1; } else { return num * arguments.callee(num-1); // 使用callee属性 } } var trueFactorial = factorial; // 拷贝函数 factorial = function() { // 修改原函数定义 return 0; }; alert(factorial(5)); // 0 alert(trueFactorial(5));// 120 this是函数在执行时所处的作用域（挡在网页的全局作用域调用函数时，this对象引用的就是window），可以看下边这个例子： function sayColor() { alert(this.color); } window.color = 'red'; var b = {color: 'blue'}; b.sayColor = sayColor; sayColor(); //'red' b.sayColor(); //'blue' 函数属性和方法每个函数都包含两个属性：length和prototype。 length：函数希望接收的命名参数的个数 prototype：可以看我这篇文章。 每个函数都包含两个非继承而来的方法：apply()和call()。 这两个的用途都是给函数指定函数体内this的值。 apply 与 call() 非常相似，不同之处在于提供参数的方式。 apply 使用参数数组而不是一组参数列表。apply 可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如 fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 而 call的语法为fun.call(thisArg, arg1, arg2, ...)。 需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。 每个函数都一个非标准的caller属性，指向调用该函数的函数， 因此一般在一个函数的内部，通过arguments.callee.caller来实现对调用栈的追溯， 但只建议将该属性用于调试目的。 基本包装类型先看这篇文章 Boolean类型 基本类型的布尔值： var a = false 引用类型的布尔值： var b = new Boolean(false) 除了包装对象的问题，两个还有两个区别： typeof 的结果一个是”boolean”一个是”object” instanceof测试是否为Boolean对象一个是false，一个是true 建议永远不要使用Boolean对象。 Number类型重写了valueOf()、toLocaleString()和toString()方法。 valueOf()返回对象表示的基本类型的数值。 可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。 toFixed()方法会按照指定的小数位返回数值的字符串表示（四舍五入）：var num = 10;num.toFixed(2)结果为“10.00” toExponential()按照指定的小数位数返回数值的指数表示的字符串：var num = 10;num.toExponential(2)结果为“1.00e+1” toPrecision()接受一个参数作为表示数值所有数字的位数（不包括指数部分），然后返回最合适的表示格式的字符串。 String类型字符方法访问字符串中特定字符：charAt()、charCodeAt() var s = 'hello world!'; s.charAt(1); // "e", 返回字符 s.charCodeAt(1);// "101"， 返回字符编码 s[1]; // "e" 字符串操作方法 concat() ： string.concat(string1, string2, …, stringX)， 连接字符串，不改变原字符串，返回连接后的字符串 slice()：string.slice(start,end)，提取字符串片断，start为要截取的片段的起始下标；end为要截取的片段的结尾下标加一，若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串，如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 substring()：类似于slice() substr()：string.substr(start,length)， 提取字符片段，start为要截取的片段的起始下标；length为要截取的长度，那么返回从 sstart到结尾的字串。 var str1 = "Hello "; var str2 = "world!"; str1.concat(str2); // "Hello world!" str.slice(1,5); // "ello" str.substring(1,5); // "ello" str.substr(2,3); // "llo" 假设p为一个正确的坐标值，m为一个负值，则 string.concat(p,m)x相当于string.concat(p) string.substring(p,m)相当于string.substring(p,0)相当于string.substring(0,p) string.substr(p,m)相当于string.substr(p,0)，返回空字符串 字符串位置方法indexOf()和lastIndexOf()，传入一个字符串，返回这个字符串在源字符串中第一次和最后一次出现的位置，若没有找到则返回-1。 还可以传入第二个参数表示开始查找的位置，indexOf()往后查找，lastIndexOf()往前查找。 字符串大小写转换方法 toLowerCase()、toUpperCase() toLocaleLowerCase()、toLocaleUpperCase()，针对地区应用不同的规则 字符串的模式匹配方法 match()，等价于调用RegExp对象的exec()方法。 match()接受一个正则表达式或者一个RegExp对象作为参数，返回一个数组，数组第一项是与整个模式匹配的字符串，之后的每一项都是和捕获组匹配的字符串。 search()与match()唯一不同的是返回的是第一个匹配项的索引。 replace()添加了一个传入的参数，表示匹配到的字符串要替换成的字符串。如果要全部替换，要记得在正则表达式中指定全局标志(g)。第二个参数也可以是函数，该函数的返回值将替换掉第一个参数匹配到的结果。 替换字符串可以插入下面的特殊变量名： 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $&#39; 插入当前匹配的子串右边的内容。 $*n* 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 splite()，基于指定的分隔符separator将一个字符串分割成多个子字符串，还可以指定第二个参数，一个整数，限定返回的分割片段数量。 "Webkit Moz O ms Khtml".split( " " ) // ["Webkit", "Moz", "O", "ms", "Khtml"] var myString = "Hello World. How are you doing?"; myString.split(" ", 3); // ["Hello", "World.", "How"] 如果 separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。 var myString = "Hello 1 word. Sentence number 2."; var splits = myString.split(/(\d)/); // \d匹配数字 console.log(splits); // [ "Hello ", "1", " word. Sentence number ", "2", "." ] localeCompare()方法referenceStr.localeCompare(compareString[, locales[, options]]) 判断字符串参数compareString是否在字母表中排在字符串referenceStr之前，是的话返回正数，不是返回负数，相等返回0。 locales和options都是可选参数，还没有被所有浏览器支持，具体的含义可以查阅文档。 下边是一个简单的例子： // "c" 在 "a" 之后， 返回负数 'a'.localeCompare('c'); // -2 或者 -1 (或者其他负数) // "against" 在 "check" 之前 'check'.localeCompare('against'); // 2 或者 1 (或者其他正数) // 相同 'a'.localeCompare('a'); // 0 fromCharCode()方法String构造函数的的静态方法，接收一个或者多个字符编码，然后把它们转换成一个字符串。 String.fromCharCode(104, 101, 108, 108, 111); // "hello" HTML方法该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用这些特性。因此不再列出。 内置对象全局(Global)对象在大多是ECMAScript实现中都不能直接访问Global对象，不过Web浏览器实现了承担该角色的window对象，因此在全局作用域中生命的所有变量核函数，就都成为了window对象的属性。 全局函数所有在全局作用域定义的属性和方法都是Global对象的属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。 eval()：将传入的字符串当做 JavaScript 代码进行执行。 uneval() ：返回代表传入对象的源代码的字符串，该特性是非标准的，请尽量不要在生产环境中使用它！ isFinite()：判定一个数字是否是有限数字。isFinite 方法检测它参数的数值。如果参数是 NaN，正无穷大或者负无穷大，会返回false，其他返回 true。 isNaN()：确定一个值是否为NaN 。如果isNaN函数的参数不是Number类型， isNaN函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。 parseFloat()：解析一个字符串参数并返回一个浮点数。 parseInt()：返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。 decodeURI()：解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。 decodeURIComponent() : 解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。 encodeURI()：对统一资源标识符（URI）进行编码，将有效的URI不能包含的字符替换为特殊的UTF-8编码。 encodeURIComponent() ：对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。 escape() ，已废弃。生成新的由十六进制转义序列替换的字符串. 使用 encodeURI 或 encodeURIComponent 代替。 unescape() ，已废弃。 encodeURI 会替换所有的字符，但不包括以下字符，即使它们具有适当的UTF-8转义序列： 类型 包含 保留字符 ; , / ? : @ &amp; = + $ 非转义的字符 字母 数字 - _ . ! ~ * &#39; ( ) 数字符号 # 请注意，encodeURI 自身无法产生能适用于HTTP GET 或 POST 请求的URI，例如对于 XMLHTTPRequests, 因为 “&amp;”, “+”, 和 “=” 不会被编码，然而在 GET 和 POST 请求中它们是特殊字符。 然而encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、&#39;、-和_之外的所有字符。 例子： // 解码一个西里尔字母（Cyrillic）URL decodeURI("https://developer.mozilla.org/ru/docs/JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"); // "https://developer.mozilla.org/ru/docs/JavaScript_шеллы" // 解码一个西里尔字母的URL decodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"); // "JavaScript_шеллы" // ***************************************************************** var fileName = 'my file(2).txt'; var header = "Content-Disposition: attachment; filename*=UTF-8''" + encodeRFC5987ValueChars(fileName); console.log(header); // 输出 "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt" function encodeRFC5987ValueChars (str) { return encodeURIComponent(str). // 注意，仅管 RFC3986 保留 "!"，但 RFC5987 并没有 // 所以我们并不需要过滤它 replace(/['()]/g, escape). // i.e., %27 %28 %29 replace(/\*/g, '%2A'). // 下面的并不是 RFC5987 中 URI 编码必须的 // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性 replace(/%(?:7C|60|5E)/g, unescape); } 注： RFC 3986，保留 !, ‘, (, ), 和 * Global对象的属性特殊值如undefined等、所有原生引用类型的构造函数都是Global对象的属性。 除了这些还有： Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Math对象Math 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。 Math 的所有属性和方法都是静态的：例如常数pi可以用 Math.PI 表示，用 x 作参数 Math.sin(x)调用sin函数。 Math对象的属性Math.E 欧拉常数，也是自然对数的底数, 约等于 2.718. Math.LN2 2的自然对数, 约等于0.693. Math.LN10 10的自然对数, 约等于 2.303. Math.LOG2E 以2为底E的对数, 约等于 1.443. Math.LOG10E 以10为底E的对数, 约等于 0.434. Math.PI 圆周率，一个圆的周长和直径之比，约等于 3.14159. Math.SQRT1_2 1/2的平方根, 约等于 0.707. Math.SQRT2 2的平方根,约等于 1.414. 常用方法Math.max() 返回0个到多个数值中最大值. Math.min() 返回0个到多个数值中最小值. Math.ceil(x) 返回x向上取整后的值. Math.floor(x) 返回小于x的最大整数。 Math.round(x) 返回四舍五入后的整数. Math.random() 返回0到1之间的伪随机数. 所有方法看这里。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习记录一]]></title>
    <url>%2FJavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80.html</url>
    <content type="text"><![CDATA[——《JavaScript高级程序设计（第2版）》学习笔记 要多查阅MDN Web 文档 简介JavaScript是一种专门为网页交互而设计的脚本语言，由以下三个不同的部分组成： ECMAScript（发音 ek-ma-script，伪语言），由ECMA-262定义，提供核心语言功能； 文档对象模型（DOM，Document Object Model），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口； 在HTML中使用JavaScript： 现代Web应用一般都把全部JavaScript引用放在&lt;body&gt;元素中，放在页面内容的后边来最后加载JavaScript代码（虽然defer属性可以实现同样的效果，但是不是所有浏览器都支持这个属性，因此一般不使用这个属性）； 基本概念语法 区分大小写 标识符，指变量、函数、属性的名字，或函数的参数，需要满足： 第一个字符必须是字母、下划线(_)或者一个美元符号($) 其他字符可以是数字、字母、下划线、美元符号 按照惯例，采用驼峰大小写格式，即第一个字母小写，剩下的每个有意义的单词的首字母大写 不能把关键字、保留字、true、false、null用作标识符 注释，跟C++相同 以分号结尾，可以不加分号，但是不推荐 关键字和保留字 关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 保留字： abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 变量 ECMAScript的变量是松散类型（弱类型）的，无需明确的类型声明，可以用来保存任何类型的数据。 未初始化的变量值为undefined 使用var操作符定义的变量将成为定义该变量的作用域中举局部变量 不使用var操作符定义的变量是全局变量（不推荐） 数据类型ECMAScript有五种简单（基本/原始）数据类型： Undefined Null Boolean Number String 和一种复杂数据类型： Object 因为ECMAScript数据类型具有动态性，因此没有再定义其他数据类型的必要。 typeof操作符因为typeof是操作符，因此括号不是必需的，也就是可以typeof 126也可以typeof(126)。 对一个值使用typeof操作符可能返回下列某个字符串： undefined boolean string number object function Undefined类型只有一个值——undefined。 虽然对声明未初始化的变量（假设为a）和未声明的变量（假设为b）使用typeof均返回undefined，但是对他们使用alert会得到不同的结果： 对于a : 会弹出undefined 对于b : 会返回错误Uncaught ReferenceError: b is not defined 因此建议在声明时就进行初始化，以此来分别a和b。 Null类型只有一个值——null。 从逻辑角度来看，null值表示一个空对象指针，因此： var a = null; alert(typeof a); // "object" 因为undefined派生自null，因此ECMA-262规定undefined == null为true。 只要意在保存对象的变量还没有真正的保存对象，都应该让它保存为null。 Boolean类型只有两个值——true和false。 转换为Boolean的转换规则： 数据类型 转换为true的值 转换为false的值 Boolean true false Stirng 任何非空字符串 “”（空字符串） Number 任何非0值（包括无穷大） 0和NaN Object 任何对象 null Undefined n/a（不适用） undefined Number类型使用IEEE754格式表示整数和浮点数。 八进制数以0开头如070表示八进制的56 十六进制数以0x开头如0xA或0xa表示十六进制的10 浮点数必须包含一个小数点，小数点前若为0则可以省略，但不推荐这么做 若小数点后没有跟任何数字如1.或本身就是一个整数如1.0则会被保存为整数（因为保存浮点数值需要的内存空间是整数值的两倍） 可以用科学计数法表示浮点数：例如使用1.26e-9表示1.26乘以10的-9次方 浮点数最高精度为17位小数，但计算精度不如整数，例如0.1加0.2的计算结果不为0.3 Number.MAX_VALUE = 1.7976931348623157e+308, 超出值转换为Infinity Number.MIN_VALUE = 5e-324， 超出值转换为-Infinity 可以使用isFinite()函数判断一个数是否有穷 NaN, Not a Number，非数值，如任何数值除以0都会得到NaN NaN与任何值都不相等，NaN == NaN返回false，因此可以用函数isNaN()判断是否为NaN，true和false可以转换为数值，因此都不是NaN，字符串无法转换为数值，因此是NaN Number()可以将任何数据类型的非数值转换为数值，parseInt()和parseFloat()用于把字符串转换为数值 Number()转换规则： true和false分别转换为1和0 数值只是简单的传入传出 null返回0 undefined返回NaN 字符串遵循以下规则： 若字符串只包含数字，则转换为十进制数值，忽略前置0 若字符串为有效的浮点格式，如“1.1”，不包含数字、小数点、负号以外的字符，则转换为对应的浮点数，忽略前置0 若字符串为有效的十六进制格式，如“0xf”，除了其他字符外还不可以有负号，转换为相同大小的十进制整数值 若字符串是空的，则返回0 其他格式返回NaN 对于parseInt()和parseFloat()： 关于前置0，我在Chrome里试了一下： parseInt(“070”)返回的是70，并不会看做八进制数 parseInt(070)返回的是56，看做八进制数 有效的格式如有效的浮点格式指浮点数处于字符串开头，若字符串开头既不是数字也不是负号则不是有效格式，若以小数点开头，小数点跟有数字则是有效的浮点格式，小数点后跟的不是数字则不是有效的格式 可以指定基数（进制）为第二个参数 String类型由零或多个16位Unicode字符组成的字符序列，即字符串。 字符串用双引号或单引号表示都是有效且没有区别的，但左右引号必须匹配。 字符串a的长度可以用它的属性length即a.length来获得。 JavaScript字符以UTF-16存储，即每个字符要么存储为2个字节，要么存储为4个字节（每个字节8位）；二String的length属性返回的是字符串中两个字节字符的数目，也就是说对于一个4个字节的字符，length会把它当做两个字符。 字符串不能修改，只能销毁再填充。 数的toString()可以传入基数（进制）为参数。 null和undefined没有toString()方法，但可以使用String()方法。 字符字面量（转义序列）： 字面量 含义 \n 换行 \t 制表 \b 空格 \r 回车 \f 进纸 \\ 斜杠 \‘ 单引号 \“ 双引号 \xnn 以16进制代码nn表示的一个字符（其中n为0-F），例如\x41表示“A”。 \unnnn 以16进制代码nnnn表示的一个Unicode字符（其中n为0-F），\u03a3表示希腊字符∑ Object类型对象是一组数据和功能的集合。具体的后边的章节会学到，这里就不展开了。 操作符一元操作符 ++、–对整数、浮点数、字符串、布尔值、对象都适用 对非数值，先使用Number()将其转换为数值再进行加减1 +、- 同样对整数、浮点数、字符串、布尔值、对象都适用，规则和++、–的差不多 位操作符先将64位的数值转换为32位数值，然后进行位操作，最后再转换为64位数值： 对undefined、null、NaN和Infinity应用位操作这两者会被当成0来处理 对非数值，先使用Number()将其转换为数值再应用位操作 按位非(NOT) : ~，返回反码，等于原值的负数减1 按位与(AND) : &amp; 按位或(OR) : | 按位异或(XOR) : ^，异或指操作的两个位均为1或均为0则返回0，一个是1一个是0则返回1 左移 : &lt;&lt;，左移不会影响符号位，左移出现的空位用0填充 有符号右移 : &gt;&gt;，用符号位的值来填充右移出现的空位 无符号右移 : &gt;&gt;&gt;，所有32位都向右移动（包括符号位），并用0填充右移出现的空位 布尔操作符 逻辑非：!，先将操作数转换为布尔值，然后求反 对一个对象进行逻辑非操作，返回false 对一个空字符串进行逻辑非操作，返回true 对非空字符串进行逻辑非操作，返回false 对0、null、NaN、undefined进行逻辑非操作，返回true 对任意非0数值包括Infinity进行逻辑非操作，返回false 同时使用两个逻辑非操作符!!，实际上模拟了Boolean()转型函数的行为，0、空字符串、null、NaN、undefined返回false 逻辑与：&amp;&amp;，逻辑与操作不一定返回布尔值 如果有一个操作数是null，则返回null 如果有一个操作数是NaN，则返回NaN 如果有一个操作数是undefined，则返回undefined 如果第一个操作数是对象或者两个都是对象，返回第二个操作数 如果第二个操作数是对象，则返回第一个操作数 如果第一个操作数为false，则返回false 逻辑或：|| 如果两个操作数都是null，则返回null 如果两个操作数都是NaN，则返回NaN 如果两个操作数都是undefined，则返回undefined 如果第一个操作数是对象或者两个都是对象，返回第一个操作数 如果第一个操作数求值结果为false，则返回第二个操作数 如果第一个操作数求值结果为true，则返回第一个操作数 乘性操作符若操作数不是数值，则后台会先使用Number()将其转换为数值再进行计算 乘法：* 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity 若一个操作数为NaN，则结果为NaN Infinity * 0 等于 NaN Infinity与非0值相乘，结果还是Infinity或-Infinity 除法：/ 若结果超出ECMAScript数值的表示范围，则返回Infinity或-Infinity 若一个操作数为NaN，则结果为NaN Infinity / Infinity 等于 NaN Infinity被任意数值除，结果仍为Infinity 0 / 0 等于 NaN 非零数（包括Infinity）除以0结果为Infinity或-Infinity 求模：% Infinity % 有限值 的结果为NaN 任意值 % 0 的结果为NaN Infinity % Infinity 的结果为NaN 有限大值a % Infinity 的结果为a 0 % 任意值 的结果为0 加性操作符 加法：+ 如果有一个操作符为NaN，则结果为NaN Infinity加-Infinity，结果为NaN +0加+0为+0，-0加-0结果为-0 +0加-0结果为+0 如果两个操作数都为字符串，则拼接起来 若有一个操作数不是数值，则将两个都转换（toString()）为字符串，然后两个字符串拼接起来 减法：- 如果有一个操作符为NaN，则结果为NaN Infinity减Infinity或者-Infinity减-Infinity结果为NaN +0减+0为+0，+0减-0为-0，-0减-0为+0 如果有操作数为字符串、布尔值、null、undefined，则先调用Number()函数将其转换为数值，若有一个转换后为NaN，则结果为NaN 如果有操作数为对象，则调用其valueOf()方法获取其数值，若值为NaN，则结果为NaN，若没有valueOf()方法，则调用其toString()方法并将得到的字符串转化为数值 关系操作符&lt;、&gt;、&lt;=、&gt;= 若两个操作数都是数值则进行数值比较 若两个操作数都是字符串，则比较两个字符串的字符编码值 如果一个是数值，则将另一个操作数转换为一个数值，然后执行数值比较 如果一个操作数是对象，则先用valueOf()换取数值进行比较，若对象没有valueOf()方法，则调用toString()，然后转换为数值进行比较 如果一个操作数是布尔值，则将其转换为数值然后进行比较 如果一个操作数是NaN，则返回false 相等操作符相等和不相等==、!=，先转换再比较 如果一个操作数为布尔值，则将其转换为数值进行比较 如果一个操作数是字符串，一个操作符是数值，则将字符串转换成数值再进行比较 如果一个操作数是对象而另一个不是，则调用对象的valueOf()方法，用得到的数值按照前边的规则进行比较 null和undefined是相等的 在比较相等性之前，不能将null和undefined转换成其他任何值 NaN和任何值（包括NaN）都不相等 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则==返回true，!=返回false 特殊情况结果： null == undefined // true "NaN" == NaN // false 5 == NaN // fale NaN == NaN // false NaN != NaN // true false == 0 // true true == 1 // true true == 2 // false undefined == 0 // false null == 0 // false "5" == 5 // true 全等和不全等===、!==，仅比较不转换，首先类型相同然后值相同 条件操作符variable = boolean_expression ? true_value : false_value 赋值操作符= 复合操作符： *=,/=,%=,+=,-=,&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;= 例如复合操作符加等于+=： var num = 10; num += 5; 相当于： var num = 10; num = num + 5; 逗号操作符声明多个变量、一条语句中执行多个操作用逗号隔开； 在赋值时，逗号操作符总会返回表达式中的最后一项： var num = (1, 2, 6, 5, 3, 0); // num的值为0 语句if、while、for语句即使要执行的只有一句代码也要用{}括起来； 关于循环的块作用域后边的章节会有讲解。 do-while语句在对条件表达式求值之前，循环体内的代码至少会执行一次，这种后测试语句最常用语循环体内的代码至少要执行一次的情形。 for-in语句for (property in expression) statement 例如： for (var propName in window) { console.log(propName); } label、break、continue语句label语句的语法为label: statement，可以由break和continue语句引用，常用与和循环语句配合使用。 例子可以看这里 with语句由于大量使用with语句会导致性能下降，还会给调试代码造成困难，因此开发大型应用程序时不建议使用with语句。 with (expression) statement，将代码的作用于设置到一个特定的对象中。 例如 var qs = location.search.substring(1); var hostName = location.hostname; var url = location.href; 等价于 with (location) { var qs = search.substring(1); var hostName = hostname; var url = href; } switch语句 switch语句中可以使用任何数据类型 每个case的值不一定是常量，可以是变量甚至是表达式 switch在比较值时使用的是全等操作符，因此不会发生类型转换（例如“10”不等于10） 函数function functionName(arg0, arg1, ..., argN) { statements } 返回值不是必需的。 关于参数可以看这篇文章中的例子来理解。需要注意的是：没有传递值的命名参数自动赋予undefined值，关于引用传递可以看这里。 因为ECMAScript函数没有签名（因为其参数是由包含零或多个值的数组来表示的），因此不能像传统意义上那样实现重载。但可以通过检查传入函数的参数类型和数量进行不同的操作来模拟重载。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5与CSS3权威指南之HTML5学习记录]]></title>
    <url>%2FHTML5%E4%B8%8ECSS3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E4%B9%8BHTML5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[学习资料——《HTML5与CSS3权威指南》（第3版） 官方网站： 华章图书 书中所有代码下载链接： 链接：http://pan.baidu.com/s/1c0oGMn2 密码：f7zt HTML5优缺点]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML与CSS学习记录]]></title>
    <url>%2FHTML%E4%B8%8ECSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[《HTML与CSS进阶教程读书笔记》 HTML基础知识HTML与XHTMLHTML指超文本标记语言，是构成网页文档的主要语言。我们常说的HTML指HTML4.01。 XHTML指扩展的超文本标记语言，是XML风格的、更严格、更纯净的HTML。 两者的主要区别： XHTML标签必须闭合。 XHTML标签和属性必须小写。 XHTML标签属性必须加引号。 XHTML标签用id属性代替name属性。 id和class由于id属性具有唯一性，因此W3C建议，对于页面关键的结构或大结构，才能使用id属性，其他地方使用class属性。 因为搜索引擎是根据标签的语义和id属性来识别的，因此id属性的使用和命名都需要谨慎。 一般来说，定义多个class的目的在于：一个class抽取公共样式，一个class定义单独样式。 标题栏小图标在head标签内加入： &lt;link rel="shortcut icon" type="image/x-icon" href="图标路径.ico" /> 其中rel和type是固定属性不用更改，只需要修改图片路径即可。 语义化HTML的精髓在于标签的语义。搜索引擎根据HTML代码识别页面结构。 编写语意结构良好的页面的好处： 利于开发调试和后期维护。 利于搜索引擎优化。 应优先使用正确的语义化标签，如果没有语义化标签可用，再考虑div或者span等无语义标签。 标题语义化h1-h6是标题标签，相比于其他标签，它们在搜索引擎优化（SEO）中占有相当重要的地位。 一般用到h4，h5和h6权重和普通标签差不多，很少使用。 对于标题语义化，我们需要注意的是： 一个页面只能有一个h1标签。 h1-h6之间不要出现断层。 不要用标题标签来定义样式（如为了加粗字体而为文本加上标题标签）。 不要用div来代替标题标签。 div是无语义的标签，如果使用div代替标题标签会使网页在SEO中丢失大量权重。 图片语义化alt属性和title属性alt是给搜索引擎看的，title是给用户看的。 搜索引擎根据alt属性或上下文判断图片内容。 因此img标签必须添加alt属性。 figure元素和figcaption元素对于图片+图注的效果，使用figure和figcaption来增强图片语义化。 例： &lt;figure> &lt;img src="xxx" alt="xxx" /> &lt;figcaption>这是一个图注&lt;/figcaption> &lt;/figure> 更详细的介绍可以看这一篇博客。 表格语义化 标签 说明 table 表格 caption 标题 thead 表头（语义划分） tbody 表身（语义划分） tfoot 表尾（语义划分） tr 行 th 表头单元格 td 表格单元格 表单语义化label标签label标签的for属性有两个作用： 语义上绑定了label元素和表单元素。（\） 当我们点击label中的文本时，其关联的表单元素也会获得焦点。 例： &lt;input id="rdo" name="rdo" type="radio" />&lt;label for="rdo">单选框&lt;/label> fieldset标签和legend标签fieldset标签用于给表单元素进行分组并绘制一个边框，legend标签用于定义某一组表单的标题。 例如这个例子： &lt;form> &lt;fieldset> &lt;legend>Personalia:&lt;/legend> Name: &lt;input type="text">&lt;br> Email: &lt;input type="text">&lt;br> Date of birth: &lt;input type="text"> &lt;/fieldset> &lt;/form> 作用： 增强表单语义。 可以使用fieldset标签的disabled属性来禁用整个组中的表单元素。 其他语义化换行符\W3C标准规定，\标签只能用于段落中的换行。即只能用于p标签内部。 无序列表ul对于列表型数据，不建议使用div实现，而应用无序列表或有序列表实现。 为了实现外观效果，一般使用无序列表而不是有序列表。 strong 标签和em标签W3C对这两个标签赋予了“强调”的语义。 可以在CSS中重新定义它们的样式而不会改变它们的语义。 del标签和ins标签这两个标签一般是配合使用表示更新文本：“delete”和“insert”，被删除的文本和被更新的文本。 一般会用CSS重新定义它们的样式。 实例链接 img标签对于什么时候使用img标签，什么时候使用背景图片，应该根据HTML的语义来判断。 img标签：作为HTML的一部分，希望被搜索引擎识别。 背景图片： 只起到修饰作用，不希望被搜索引擎识别。 语义化验证通过去掉CSS样式，观察页面是否还有很好的可读性来判断一个页面是否语义良好。 HTML5舍弃的标签下边这些已经被舍弃的标签(仅为了定义样式的标签和很少使用或已经被新标签代替的标签)应停止使用： &lt;acronym&gt; 定义首字母缩写，应用abbr代替。 &lt;applet&gt; 定义嵌入的applet，应用object代替。 &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; 定义目录列表，应用ul代替。 &lt;font&gt; &lt;frame&gt; &lt;frameset&gt; &lt;noframes&gt; &lt;strike&gt; &lt;tt&gt; CSS基础知识CSS单位pxpixel，像素，一个图片或计算机屏幕中最小的点。 百分比%CSS中支持百分比的属性： width、height、font-size，它们的百分比是相对于父元素的“相同元素”的值来计算的。 line-height，它的百分比是相对于父元素的font-size值来计算的。 vertical-align，它的百分比是相对于当前元素继承的line-height值来计算的。 em1em等于当前元素的以px为单位的font-size值， 若当前元素的font-size值没有定义，则从父元素继承， 若当前元素的所有祖先元素都没有定义font-size，则继承浏览器默认的font-size值：16px。 使用em的小技巧：首行缩进使用 text-indent: 2em实现。 remCSS3新引入的单位，指相对根元素（即html元素）的字体大小。 CSS特性继承性指子元素继承了父元素的某些样式属性。 在CSS中，具有继承性的样式有三大类： 文本相关属性： font–family，font-size，font-style，font-weight，font，line-height，text-align，text-indent，word-spacing。 列表相关属性： list-style-image，list-style-position，list-style-type，list-style。 颜色相关属性： color。 层叠性“后者居上”原则。 CSS的层叠性指样式的覆盖。对于具有相同权重的相同属性，以最后定义的值为准。 CSS优先级引用方式行内样式&gt;(内部样式=外部样式) 若同时存在权重相同内部样式和外部样式，则以最后引入的样式为准。 继承方式以最近的祖先元素为准。 指定样式常见的伪元素——:before、:after、:first-letter、:first-line。 常见的伪类——:hover、:first-child等。 常用的选择器优先级：行内样式&gt;id选择器&gt;class选择器&gt;元素选择器。 选择器权值表： 选择器 权值 通配符 0 伪元素 1 元素选择器 1 class选择器 10 伪类 10 属性选择器 10 id选择器 100 行内样式 1000 继承样式和和指定样式指定样式权重更高。 !important权值最高，不推荐使用。 CSS引入方式 导入样式表（加载html后加载css，不推荐） 外部样式表（link标签） 内部样式表（style标签） 行内样式表 CSS选择器CSS出去基本的选择器（元素选择器、id选择器、class选择器、群组或分组选择器）， 还有层次选择器： 选择器 说明 M N 后代选择器，选择M元素所有内部后代N元素 M&gt;N 子代选择器，选择M元素所有内部子代N元素 M~N 兄弟选择器，选择M元素所有同级N元素 M+N 相邻选择器，选择M元素相邻的下一个同级元素 CSS规范命名规范CSS文件命名开发阶段按照功能模块划分CSS文件。 文件名 说明 reset.css 重置样式，重置元素默认样式 global.css 全局样式，全站公用，定义页面基础样式 themes.css 主题样式，用于实现换肤功能 module.css 模块样式，用于模块的样式 master.css 母版样式，用于母版页的样式 columes.css 专栏样式，用于专栏的样式 forms.css 表单样式，用于表单的样式 mend.css 补丁样式，用于维护、修改的样式 print.css 打印样式，用于打印的样式 id和class命名建议使用中划线命名，例如column-title。 为了避免class命名的重复，一般取父元素的class名作为前缀，例如column-title。 网页主体部分 命名 最外层 wrapper(一般用于包裹整个页面) 头部 header 内容 content 侧栏 sidebar 栏目 column 热点 hot 新闻 news 下载 download 标志 logo 导航条 nav 主体 main 左侧 main-left 右侧 main-right 底部 footer 友情链接 friendlink 加入我们 joinus 版权 copyright 服务 service 登录 login 注册 register 导航部分 命名 主导航 main-nav 子导航 sub-nav 边导航 side-nav 左导航 leftside-nav 右导航 rightside-nav 顶导航 top-nav 菜单部分 命名 菜单 menu 子菜单 submenu 其他 命名 标题 title 摘要 summary 登录条 loginbar 搜索 search 标签页 tab 广告 banner 小技巧 tips 图标 icon 法律声明 siteinfolegal 网站地图 sitemap 工具条 tool、toolbar 首页 homepage 子页 subpage 合作伙伴 partner 帮助 help 指南 guide 滚动 scroll 提示信息 msg 投票 vote 相关文章 related 文章列表 list 书写规范对于功能代码，应该集中放在一起， 对于其他代码，应按照如下顺序： 影响文档流属性（布局属性）——display，position，float，clear等 自身盒模型属性——width，height，padding，margin，border，overflow等 文本性属性——font，line-height，text-align，text-indent，vertical-align等 装饰性属性——color，background-color，opacity等 其他属性——cursor，content，list-style，quotes等 例如： #main { /* 影响文档流属性 */ display: inline-block; position: absolute; top: 0; left: 0; /* 盒子模型属性 */ width: 100px; height: 100px; border: 2px solid gray; /* 文本性属性 */ font-size: 15px; font-weight: bold; text-indent: 2em; /* 装饰性属性 */ color: white; background-color: red; /* 其他属性 */ cursor: pointer; } 注释规范由于压缩工具会删除所有的注释，因此有时为了保留版权声明等注释信息，需要在注释内容前加一个叹号，如/*! 注释内容 */，这样压缩工具就不会删除这条注释信息。 顶部注释/* *@description:说明 *@author:作者 *@update:更新时间，如2018-09-10 17:42 */ 模块注释/* 导航部分，开始 */ ...... /* 导航部分，结束 */ 简单注释/* 单行注释 */ 或者 /*多行注释 *多行注释 *多行注释 */ CSS reset重置样式，去除元素在浏览器中的默认样式。 是否使用CSS reset根据实际开发需求而定。 盒子模型 外边距叠加又称为“margin叠加”，指当两个外边距相遇时会“合二为一”。叠加后的外边距为两个外边距的最大值。 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 以下图片均来自w3school 负margin 当margin-top或者margin-left为负数时，当前元素会被拉向指定方向。 当margin-bottom或者margin-right为负数时，后续元素会被拉向指定方向。 这里有一篇文章讲得不错，可以参考一下。 圣杯布局、双飞翼布局就是利用这个实现的。 overflow当浮动引起父元素高度塌陷时，可以为父元素加上overflow: hidden来清除浮动。 display属性 属性值 说明 inline 行内元素 block 块元素 inline-block 行内块元素 table 以表格形式显示，类似于table元素 table-row 以表格行形式显示，类似于tr元素 table-cell 以表格单元格形式显示，类似于td元素 none 隐藏元素 块元素 独占一行 内部可以容纳其他块元素或行元素 可以定义width和height 可以定义四个方向的margin inline元素 可以与其他行内元素位于同一行 可以容纳行内元素，但不能容纳块元素 无法定义width和height 可以定义margin-left和margin-right，不能定义margin-top和margin-bottom inline-block元素 可以定义width和height 可以与其他行内元素位于同一行 常见的inline-block元素：img元素和input元素 display: table-cell可以用于实现： 图片垂直居中于元素 等高布局 自动平均划分元素，并在同一行显示 去除inline-block元素间距在父元素中添加font-size: 0 文本效果 文本属性 说明 text-decoration 下划线、删除线、顶划线 text-transform 文本大小写 font-variant 将英文文本转换为小型大写字母 text-indent 段落首行缩进 text-align 文本水平对齐 vertical-align 文本垂直对齐 line-height 行高 letter-spacing 字距 word-spacing 词距 text-indent可以使用 text-indent: -9999px;来隐藏文本。 text-align主要使用的值为left、right、center，对文字、inline元素、inline-block元素都起作用，对块元素不起作用。 利用margin: 0 auto实现块元素的水平居中。 text-align: center在父元素中定义，margin: 0 auto在当前元素中定义。 line-height关于顶线、中线、基线、底线可以自行查阅。 行高（line-height）指的是两行基线之间的距离。 将height和line-height设为相同值可以实现文字垂直居中。 当取值为%或者em时，是相对与父元素的font-size计算的。 当取值为无单位数字时，是相对于当前元素的font-size计算的。 vertical-alignvertical-align对inline、inline-block、table-cell元素有效，对块元素无效。 用于定义周围的文字、inline元素、inline-block元素相对于该元素基线的垂直对齐方式。 可以取负长度值和百分比值。 取值 负值 ： vertical-align: -2px指的是该元素相对于基线向下偏移2px； 百分比 ： 相对于当前元素继承的line-height值计算的，也是该元素相对于基线偏移的值； 关键字 （前四个比较常用）： 值 描述 top 把元素的顶端与行中最高元素的顶端对齐 middle 把此元素放置在父元素的中部。 baseline 默认。元素放置在父元素的基线上。 bottom 把元素的底端与行中最低的元素的顶端对齐。 text-top 把元素的顶端与父元素字体的顶端对齐 text-bottom 把元素的底端与父元素字体的底端对齐。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 inherit 规定应该从父元素继承 vertical-align 属性的值。 应用 为img添加vertical-align: middle可以实现图片与周围的文字居中对齐 要使块元素（如div）也可以使用此属性，可以为其先定义display: table-cell 表单效果radio与checkbox默认情况下由于是基线对齐因此视觉上会感觉单选框或复选框旁边的文字比它们低，这个时候可以使用vertical-align来让他们垂直居中对齐。 可以使用关键字，也可以使用数值。 textarea 可以使用max-width和max-height来限制拖拽大小 可以使用resize: none来禁止拖拽 要使textarea在不同浏览器中具有相同的外观，可以： 使用CSS的width和height定义大小 使用overflow: auto来定义textarea滚动条自适应 表单对齐书上给了注册的例子： 实现方法： 每一行表单分为左栏加若干右栏 所有行的左栏长度相等 所有行的右栏所有盒子长度之和相等 左栏一般为一个label，右栏为若干文本框 所有左栏和右栏盒子都设为左浮动 左栏添加属性text-align: right使得文字右对齐 每一行左栏盒子长度加上所有右栏盒子长度之和等于行宽 每一行由一个p包裹住，并为p添加overflow: hidden来清除浮动 然后我又去看了一下各网站的登录界面，基本上是一个icon+一个input的模式： 实现方法： icon使用position: absolute脱离文档流并盖在input上 input将padding-left调到合适大小使得输入框不被icon盖住 浮动布局文档流简单来说就是元素在页面中出现的先后顺序。 正常文档流 ： “normal flow”，指默认情况下页面元素的布局情况。 脱离文档流：脱离正常文档流。要改变正常文档流，使用浮动和定位方法。 浮动可以使元素移到左边或者右边，并且允许后边的文字和元素环绕着它。 浮动后使用margin来定义和其他元素之间的间距。 绝对定位的元素忽略float属性。 float的取值表如下，默认为none： 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 当一个元素添加float属性为left或者right时，它将变为block类型。 浮动元素脱离正常文档流，若其height大于父元素的height或者父元素的height未定义，会造成父元素高度塌陷。可以为父元素添加overflow: hidden来解决。 若父元素和子元素都是浮动元素，则父元素会自适应地包含子元素。 若兄弟元素不是浮动元素，由于浮动元素脱离文档流，可能会出现覆盖等情况。 清除浮动 clear: both，用于浮动元素后边的元素，表示两边不允许出现浮动元素。 overflow: hidden，用于浮动元素的父元素，但会隐藏超出父元素的内容部分。 实际开发中，更经常使用:after伪元素结合clear: both来实现。 为了兼容ie，为父元素添加zoom: 1来消除浮动。 定位布局属性值 值 描述 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 sticky 粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。注意: Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。 inherit 规定应该从父元素继承 position 属性的值。 initial 设置该属性为默认值，详情查看 CSS initial 关键字。 absolute会将元素转换为块元素。 若想要子元素相对于父元素定位，一般给父元素添加position: relative，给子元素定义position: absolute来实现。祖先元素同理。 z-index属性默认情况下设置z-index无效，只有当元素定义position为relative、absolute、fixed时才会激活，z-index值越大，其堆叠顺序越高，越靠上（z方向上的靠上）。 CSS图形由于图片大小比较大，数据传输量大且一张图片会引发一次HTTP请求，因此对徐图形效果，一般更倾向于用CSS实现。 这里有一篇CSS制作图形速查表总结得比较全面，可以参考。 另外对于带有边框的图形，一般是用大小不同的两个相同图形实现，小的覆盖在大的上边。 性能优化属性缩写 border：border: 1px solid red 若不想要底边框，可以加上border-bottom: 0 若只想要底边框，可以border-bottom: 1px solid red padding： padding: 10px指上右下左均为10px padding: 10px 20px指上下为10px，左右为20px padding: 10px 20px 30px 40px的顺序为上右下左，从上开始按照顺时针顺序 margin： 类似于padding background： background: url(&#39;xxx.jpg&#39;) no-repeat 80px 40px,最后为background-position font： font: &quot;微软雅黑&quot; 12px/1.5em bold 顺序为font-family、font-size、line-height、font-weight 简写形式必须指定font-family和font-size的值，其他属性没有指定则为默认值 简写形式中font-size和line-height之间需要加入一个斜杠/ color： 十六进制的颜色值若每两位值相同，可以缩写一半，比如color: #112233可以缩写为color: #123 语法压缩 当一个CSS规则只有一两个属性的时候，使用横向书写 可以省略最后一个属性的分号 background-image、cursor等属性url()中的路径不用加引号 如果某一个属性值为0，则不需要加单位 如果某一个属性值是以0为开头的小数，可以吧0省略 使用群组选择器合并相同样式 若同一个父元素的多个子元素都定义了相同的可继承属性，把这些属性定义在父元素中来精简代码 CSS压缩书中推荐了两个在线的压缩工具：CSS Compressor 和 YUI Compressor 以YUI Compressor为例，它会对CSS文件执行如下操作： 删除所有注释 删除无用空白符 删除结尾分号 删除属性值为0的单位 删除以0开头的小数前的0 合并相似属性（属性缩写） 将RGB颜色转换为十六进制颜色 图片压缩书中推荐的图片压缩工具： 在线的JPEGmini和TinyPNG以及本地的ImageOptim 高性能的选择器浏览器对选择器规则是从右到左进行解析的。 CSS选择的匹配效率： id选择器 class选择器 元素选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器 因此在使用选择器时应注意： 尽量不要使用通配符 不要在id选择器和class选择器前添加元素名 选择器最好不要超过三层，靠右的选择条件应尽可能精确 避免使用后代选择器，尽量少使用子选择器 CSS技巧水平居中 文字、inline元素和inline-*元素： text-align: center 块元素： margin: 0 auto 垂直居中 行内块元素使用vertical-align: middle 块元素将display改为table-cell然后使用vertical-align 多行文字使用一个标签将文字包起来并设为table-cell，然后再设置vertical-align 单行文字设置line-height和height属性值相同来实现 CSS Sprite又称为CSS精灵或CSS雪碧图，它将零散的小背景图合并成一张大背景图，然后再利用background-position属性进行定位从而现实小背景图。 使用CSS Sprite技术时，需要注意： 在开发后期而不是开发前期使用此技术 有条理地组织图片顺序，应将小背景图按照类别、风格、大小等分门别类地放好 控制雪碧图的大小，当图片大小小于200KB时传输时间是差不多的，因此雪碧图应控制在200KB以内 书中推荐了两个CSS Sprite工具：CSS Sprite Generator 和 Sprite Cow Icon Font图标使用字体文件实现小图标效果，从而减少图片的使用。 推荐的Icon Font网站：http://www.iconfont.cn/ 网站上就有使用教程 重要概念包含块containing block，决定一个元素大小和定位的元素。 时视觉格式化模型中的一个重要概念，与CSS盒子模型类似。其作用主要是为其内部的后代元素提供一个参考。 根元素（HTML元素）没有父元素，它存在的包含块被称为初始包含块 定位为fixed的元素的包含块为浏览器窗口 定位为是static和relative的元素的包含块是它最近的块级（block、inline-block或table-cell）祖先元素创建的 定位为absolute的元素的包含块是它最近的定位不是static的祖先元素，可以是块元素也可以是行内元素 层叠上下文 一个元素在z轴上的堆叠顺序： 层叠级别越大越靠上 同等层叠级别，后边的堆叠在前边的上边（后来者居上） 不同的层叠上下文比较的是父级层叠上下文，与自身无关 BFC和IFCBFC： block formatting context， 块级格式上下文 IFC： inline formatting context， 行级格式上下文 若一个元素具备以下任何一个条件，则会创造创造一个新的BFC： 根元素 float属性不是none position属性是absolute或fixed overflow属性值不是visible display属性为inline-block、table-caption、table-cell W3C描述BFC的特点为： 在一个BFC中，盒子从顶端开始垂直一个接着一个地排列。两个相邻盒子之间的垂直间距有margin决定。同一个BFC中，两个相邻块盒子之间垂直方向上的外边距会叠加。 在一个BFC中，每一个盒子的左外边界（margin-left）会紧贴着容器的border-left，右边同理，即使存在浮动元素也是如此。 可以得到结论： 在一个BFC内部，盒子会在垂直方向上一个接着一个地排列 在一个BFC内部，相邻的margin-top、margin-bottom会叠加 在一个BFC内部，每一个盒子的左外边界（margin-left）会紧贴着容器（包含盒子）的border-left，即使存在浮动元素也是如此 在一个BFC内部，如果存在内部元素是一个新的BFC，并且存在内部元素是浮动元素，则这个新的BFC的区域不会与浮动元素的区域重叠 BFC就是页面上一个隔离的盒子，该盒子内部的子元素不会影响到外边的元素 计算一个BFC的高度时，其内部浮动元素的高度也会计算其中 BFC的用途： 创建BFC来避免垂直外边距叠加（例如使用div将一个盒子包起来并给这个div添加overflow属性） 创建BFC来清除浮动（为父元素添加overflow: hidden，利用结论第六条） 创建BFC来实现自适应布局 好了到这里，这本书就看完了，一些细节的东西了解到了很多，下面开始看html5+css3。 - 2018 - 09 - 11 -]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型链:prototype与__proto__]]></title>
    <url>%2FJavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE-prototype%E4%B8%8E-proto.html</url>
    <content type="text"><![CDATA[主要看了这一篇，讲解的很清晰，最主要的一点为： 若： var Person = function () { }; var p = new Person(); 则： p.__proto__ = Person.prototype; 当调用p.xxx()时，首先在p中找xxx这个属性，没有的话从p的__proto__(即Person的prototype)中寻找，如果没有，则继续向上寻找（p.__proto__.__proto__即Person.prototype.__proto__, …）。 例如下面这个例子： var Person = function() { Person.prototype.Say = function () { alert("Person say"); } } var Programmer = function() {} Programmer.prototype = new Person(); var p = new Programmer(); 我们可以得出： p.__proto__ = Programmer.prototype p.__proto__.__proto__ = Programmer.prototype.__proto__ = Person.prototype 所以在调用p.Say()方法时，现在p中寻找这个属性，如果没有就在p.__proto__中寻找，然后一步一步往上，最后在Person.prototype找到这个方法。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下Chrome谷歌浏览器部分网站图片显示不正常的解决方法]]></title>
    <url>%2Fubuntu%E4%B8%8BChrome%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[由于Chrome设置了使用微软雅黑字体导致了部分图片显示不正常， 在浏览器设置中将字体换回ubuntu刷新页面会发现图片已经显示正常。]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>Chrome</tag>
        <tag>图片显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 18.04下安装稳定版Chrome谷歌浏览器]]></title>
    <url>%2Fubuntu-18-04%E4%B8%8B%E5%AE%89%E8%A3%85%E7%A8%B3%E5%AE%9A%E7%89%88Chrome%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8.html</url>
    <content type="text"><![CDATA[由于官方下载页面打不开，因此找了一个网盘下载的，网盘下载点击这里。 安装相关依赖： sudo apt-get install libcurl3 sudo apt-get install libappindicator1 sudo apt-get install libpango1.0-0 sudo apt-get install libgooglepinyin0 进入下载目录，运行下列命令即可： sudo mv google-chrome-stable_current_amd64.deb /usr/local cd /usr/local sudo dpkg -i google-chrome-stable_current_amd64.deb 进行更新： sudo apt-get update sudo apt-get upgrade 显示如下提示即安装成功： zmj@zmj:/usr/local$ sudo dpkg -i google-chrome-stable_current_amd64.deb Selecting previously unselected package google-chrome-stable. (Reading database ... 217976 files and directories currently installed.) Preparing to unpack google-chrome-stable_current_amd64.deb ... Unpacking google-chrome-stable (51.0.2704.106-1) ... Setting up google-chrome-stable (51.0.2704.106-1) ... update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/x-www-browser (x-www-browser) in auto mode update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/gnome-www-browser (gnome-www-browser) in auto mode update-alternatives: using /usr/bin/google-chrome-stable to provide /usr/bin/google-chrome (google-chrome) in auto mode Processing triggers for gnome-menus (3.13.3-11ubuntu1.1) ... Processing triggers for desktop-file-utils (0.23-1ubuntu3.18.04.1) ... Processing triggers for mime-support (3.60ubuntu1) ... Processing triggers for man-db (2.8.3-2ubuntu0.1) ...]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04中安装iNode]]></title>
    <url>%2Fubuntu18-04%E4%B8%AD%E5%AE%89%E8%A3%85iNode.html</url>
    <content type="text"><![CDATA[首先在学校官网下载32位版本的iNode包（64位一直无法安装成功因此选择安装32位版本的）。 解压。 安装各种依赖库（如果某个命令无法运行可以在安装目录下运行./iNodeClient.sh查看当前需要安装的依赖）： sudo apt-get install lib32ncurses5 sudo apt-get install lib32z1 sudo aptitude install libgtk-x11-2.0 sudo apt-get install libgtk2.0-0:i386 libnss3:i386 libcurl3-gnutls:i386 libidn11:i386 libpango1.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386 sudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6 sudo apt-get dist-upgrade sudo ln -s /usr/lib/i386-linux-gnu/libjpeg.so.8 /usr/lib/i386-linux-gnu/libjpeg.so.62 sudo ln -s /usr/lib/i386-linux-gnu/libtiff.so.5 /usr/lib/i386-linux-gnu/libtiff.so.3 sudo apt-get install murrine-themes sudo apt-get install gtk2-engines-murrine sudo apt-get install libgtkmm-2.4-dev sudo apt-get install libcanberra-gtk-module:i386 在解压后的目录中运行： sudo ./install.sh 这个时候iNodeClient.destop就可以点击运行了。 添加用户名和密码后将NIC修改为enp7s0即可成功连接。 参考链接]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>iNode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ubuntu中安装Markdown神器Typora]]></title>
    <url>%2F%E5%9C%A8ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85Markdown%E7%A5%9E%E5%99%A8Typora.html</url>
    <content type="text"><![CDATA[在终端中执行以下命令即可： # optional, but recommended sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE # add Typora's repository sudo add-apt-repository 'deb http://typora.io linux/' sudo apt-get update # install typora sudo apt-get install typora 参考链接]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下无法将iNode绑定到侧边栏的解决办法]]></title>
    <url>%2Fubuntu%E4%B8%8B%E6%97%A0%E6%B3%95%E5%B0%86iNode%E7%BB%91%E5%AE%9A%E5%88%B0%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[将iNodeClient.desktop添加到/usr/share/applications中（cp命令）后，右键侧边栏上打开的iNode的图标即可Add to Favorites。]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>iNode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下创建文件夹快捷方式]]></title>
    <url>%2Fubuntu%E4%B8%8B%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[sudo ln -sT [srcDir] [dstDir/name] 例如创建hexo文件夹的桌面快捷方式： sudo ln -sT '/media/zmj/本地磁盘/hexo' '/home/zmj/Desktop/hexo' 参考链接]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>快捷方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见逆水寒男号女NPC奇物好感统计]]></title>
    <url>%2F%E9%81%87%E8%A7%81%E9%80%86%E6%B0%B4%E5%AF%92%E7%94%B7%E5%8F%B7%E5%A5%B3NPC%E5%A5%87%E7%89%A9%E5%A5%BD%E6%84%9F%E7%BB%9F%E8%AE%A1.html</url>
    <content type="text"><![CDATA[特别感谢秦沨_JONAS及其小伙伴们的辛苦统计！ B返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 半截蜡烛 2 2 2 2 5 拨浪鼓 10 15 20 15 10 筚篥 15 10 10 20 10 薄荷 10 15 10 15 15 剥皮小刀 20 10 15 10 10 冰糖糕 15 15 10 15 15 布老虎 15 10 碧血战铠 15 5 5 5 5 碧血战籍 15 10 5 5 5 碧血毒蝎 20 5 5 5 5 C返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 草帽 15 15 10 10 10 彩球 10 15 10 15 15 词韵曲谱 15 20 15 蹴鞠 10 10 20 10 10 D返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 冬虫夏草 10 10 10 20 F返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 风俗画 5 5 20 G返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 弓箭 15 10 15 10 10 枸杞 10 15 蝈蝈笼 10 15 15 10 15 关外鹿肉 10 10 15 10 10 高丽泡菜 5 10 5 10 15 鬼谷算盘 5 10 5 5 关外鹿皮 15 10 15 10 10 关外人参 15 10 15 15 20 H返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 花盆土 2 5 2 2 2 红泪面脂 15 15 15 20 20 花瓶 2 5 5 5 2 虎皮围裙 10 10 15 10 10 虎骨酒 15 5 15 10 10 荷包 10 10 10 15 15 和田玉坠 10 15 15 15 20 和田玉石 10 15 15 20 20 毁诺城女装 5 15 20 15 15 河豚 10 10 15 15 15 化骨水 20 5 5 5 5 海螺 15 15 10 15 15 胡笳十八拍 5 10 5 20 15 火铳 20 5 20 5 5 黑白玲珑子 15 10 15 15 10 J返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 毽子 5 15 15 10 10 鸡毛掸子 5 10 15 10 5 金秀铁骨扇 15 10 15 10 10 金丝楠木 15 10 15 15 10 绢花绸伞 10 15 10 15 15 嘉禾肉粽 10 15 5 15 15 机械鸟 15 15 20 15 10 江山笔记 10 10 10 10 10 剑门豆腐 15 15 15 15 15 酒葫芦 10 10 15 10 15 金叶子 10 10 10 15 15 K返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 孔雀石 10 15 10 15 20 孔雀翎 15 10（20 15 15 L返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 绿茶茶叶 5 2 2 5 5 莲花河灯 10 20 狼毫笔 2 2 2 5 2 鎏金碧玉勺 10 15 10 15 15 楼兰蜜酒 10 15 15 15 20 灵芝 15 15 15 20 20 龙井黑猪肉 10 10 5 柳笛 10 15 10 15 15 龙渊 20 10 15 10 10 M返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 磨刀石 2 2 5 2 2 沐浴香药 15 10 15 20 20 明前龙井 15 10 20 美人图 20 棉花 5 5 2 2 2 N返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 女儿红 10 15 20 15 15 泥鳅 5 5 15 5 15 P返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 判官笔 5 5 5 10 10 苹果 5 20 霹雳堂火器 20 5 20 5 5 霹雳堂炮仗 15 5 20 Q返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 青城脸谱 15 5 15 10 5 邛窑茶盏 15 15 10 20 15 契丹瓜子 15 15 15 10 15 契丹牛乳 15 15 15 10 15 青铜锭 5 10 5 10 10 庆力善治方 10 10（15 10 10 10 R返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 阮 5 20 汝窑茶盏 10 15 10 20 10 S返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 神秘妆匣 2 2 2 2 2 时空碎片 2 2 2 2 2 锁子甲 15 5 15 5 5 水域全图 15 10 15 10 10 兽皮包裹 15 10 15 10 10 碎月海龟 10 10 15 15 10 碎月明虾 15 15 10 15 15 扇子 10 15 10 15 15 蒜香排骨 10 10 5 10 梳妆匣 10 15 20 20 20 蛇骨手串 20 5 15 10 10 司南 15 15 15 10 10 三合美酒 10 15 20 15 15 蓑衣（农家 15 10 10 10 10 蓑衣（桃溪 15 T返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 陶罐 5 2 5 2 2 桃溪钓竿 10 15 10 10 10 桃溪花枝 10 20 10 10 糖葫芦 10 20 15 15 10 团扇 5 20 20 桃木剑 10 15 10 10 10 桃溪河虾 20 10 15 桃花雪 10 20 15 15 15 桃溪泥人 15 20 10 桃溪豆腐 15 20 10 15 铜镜 10 15 10 15 15 铜丝手套 20 10 15 10 10 W返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 武经总要 5 10 5 10 5 武安蹴鞠 10 10 20 5 10 武林秘籍 20 10 15 5 5 X返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 小暖 15 20 20 15 10 雪梨 15 15 10 15 15 雪狐皮 20 15 15 15 15 雪村鸡蛋 15 15 10 10 15 熙春调味料 10 10 15 15 15 宣州紫毫笔 10 15 10 15 10 绣花娟帕 10 15 10 15 20 西湖莲花 10 15 10 15 15 西湖莲蓬 10 20 15 15 10 西域葡萄 15 15 15 15 15 西域炼乳 15 10 15 15 15 Y返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 一颗大白菜 2 2 2 2 2 一块木板 2 2 2 2 2 一块帆布 2 2 2 2 2 一根茄子 2 2 2 2 5 一根萝卜 2 2 2 2 2 一片枫叶 5 5 2 2 5 一袋面粉 2 2 2 2 2 一捆麻绳 2 2 2 2 5 一袋大麦 2 2 2 2 2 一块粗麻布 2 2 2 2 2 一袋麦麸 2 2 2 2 2 一束桃花 20 15 15 一袋红豆 2 2 2 5 2 一捆线球 2 2 2 2 2 一筐蔬菜 2 2 2 2 2 一屉包子 10 10 一只寒梅 20 15 羊毫笔 2 2 2 5 2 野生牛筋 10 10 15 10 萤火虫 15 20 10 15 15 云西竹笋 15 20 15 月影碎空残卷 20 15 15 5 5 养颜阿胶 20 20 20 20 20 药粥 15 15 10 10 玉扳指 20 5 15 15 15 玉红叶 15 15 10 20 20 Z返回首字母索引 道具 花将离 叶雪清 温柔 李师师 姬蜜儿 针线包 2 5 2 2 2 竹哨 15 15 10 10 10 竹陀螺 10 15 20 10 10 醉螺 10 10 15 10 15 粽子 5 5 2 5 竹笋 10 竹竿 2 2 5 2 2 追风翼（白帝城 15 10 20 10 10 追风翼 15 10 15 10 10]]></content>
      <tags>
        <tag>遇见逆水寒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT刷题记录]]></title>
    <url>%2FPAT%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[OJ：牛客网 1001 A+B Format (20)题目描述 Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). 输入描述 Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. 输出描述 For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. 输入例子 -1000000 9 输出例子 -999,991 实现代码 #include using namespace std; int main() { int digit[10]; for (int i = 0; i < 10; i++) digit[i] = -1; int a,b,re; cin >> a >> b; re = a + b; if (re < 0) { couttmp_n>>tmp_value; polynomials.push_back(item(tmp_n,tmp_value)); } cin>>k; while (k--) { cin>>tmp_n>>tmp_value; bool hasItem = false; for (int i = 0; i < polynomials.size(); i++) { if (polynomials[i].n == tmp_n) { hasItem = true; polynomials[i].value+=tmp_value; if (polynomials[i].value == 0) polynomials.erase(polynomials.begin()+i); break; } } if (!hasItem) polynomials.push_back(item(tmp_n,tmp_value)); } for (int k = 0; k < polynomials.size(); k++) { for (int i = 0; i < polynomials.size()-1; i++) { if (polynomials[i].n < polynomials[i+1].n) { item tmp_item = polynomials[i]; polynomials[i] = polynomials[i+1]; polynomials[i+1] = tmp_item; } } } cout>m>>c1>>c2; vector teamsCount; int tmp1,tmp2,tmp3; for (int i = 0; i < n; i++) { cin>>tmp1; teamsCount.push_back(tmp1); } vector roads(n); for (int i = 0; i < m; i++) { cin>>tmp1>>tmp2>>tmp3; roads[tmp1].push_back(road(tmp2,tmp3)); roads[tmp2].push_back(road(tmp1,tmp3)); } vector maxTeams(n); for (int i = 0; i < n; i++) maxTeams[i] = 0; maxTeams[c1] = teamsCount[c1]; vector minLen(n); for (int i = 0; i < n; i++) minLen[i] = INT_MAX; minLen[c1] = 0; int currentCity = c1; vector minLenRoadCount(n); for (int i = 0; i < n; i++) minLenRoadCount[i] = 1; vector visited(n); for (int i = 0; i < n; i++) visited[i] = false; visited[c1] = true; while (currentCity != c2) { int len = roads[currentCity].size(); for (int i = 0; i < len; i++) { if (visited[roads[currentCity][i].endCity]) continue; int endCity = roads[currentCity][i].endCity; int length = roads[currentCity][i].length; if (minLen[endCity] > minLen[currentCity] + length) { minLen[endCity] = minLen[currentCity] + length; minLenRoadCount[endCity] = 1; maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity]; } else if (minLen[endCity] == minLen[currentCity] + length) { minLenRoadCount[endCity]++; if (maxTeams[endCity] < maxTeams[currentCity] + teamsCount[endCity]) maxTeams[endCity] = maxTeams[currentCity] + teamsCount[endCity]; } } int min = INT_MAX; for (int i = 0; i < n; i++) { if (visited[i]) continue; if (minLen[i] < min) { min = minLen[i]; currentCity = i; } } visited[currentCity] = true; } coutid>>k; nodes[id].id = id; nodes[id].childs_count = k; while (k--) { cin>>tmp; (nodes[id].childs).push_back(tmp); } } vector this_level, next_level; this_level.push_back(1); while (1) { int count_output = 0; for (int i = 0; i < this_level.size(); i++) { if (nodes[this_level[i]].childs_count == 0) count_output++; else next_level.insert(next_level.begin(),nodes[this_level[i]].childs.begin(),nodes[this_level[i]].childs.end()); } cout>out; result_in_id = result_out_id = id; result_in_time = in; result_out_time = out; n--; while (n--) { cin>>id>>in>>out; if (a_larger_than_b(result_in_time,in)) { result_in_id = id; result_in_time = in; } if (a_larger_than_b(out,result_out_time)) { result_out_id = id; result_out_time = out; } } cout]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猫眼电影加密数字破解（爬取评分票房票价）]]></title>
    <url>%2F%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%A0%B4%E8%A7%A3%EF%BC%88%E7%88%AC%E5%8F%96%E8%AF%84%E5%88%86%E7%A5%A8%E6%88%BF%E7%A5%A8%E4%BB%B7%EF%BC%89.html</url>
    <content type="text"><![CDATA[背景在爬取猫眼电影相关数据时发现爬取下来的评分、票房、票价不是具体的数字而是一串类似于\uf5fb的码，需要解密。 而这些密码是每次访问时随机生成的，和0-9的映射关系也是随机的。 解密办法下载动态字体文件，解析映射关系。 解密思路首先找到动态字体文件的地址（head标签内的style标签内）： &lt;style> @font-face { font-family: stonefont; src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot'); src: url('//vfile.meituan.net/colorstone/e954129d5204b4e8c783c95f7da4c2733168.eot?#iefix') format('embedded-opentype'), url('//vfile.meituan.net/colorstone/8f497cdb4e39d1f3dcbafa28a486aea42076.woff') format('woff'); } .stonefont { font-family: stonefont; } &lt;/style> 其中的.woff文件是我们需要的。 爬取代码如下（利用scrapy）： #下载字体文件 font_url = sel.xpath('/html/head/style/text()').extract()[0] font_url = 'http:'+font_url[font_url.rfind('url')+5:font_url.find('woff')+4] print(font_url) woff_path = 'tmp.woff' f = urllib.request.urlopen(font_url) data = f.read() with open(woff_path, "wb") as code: code.write(data) 利用TTFont将woff文件转换为xml文件： font1 = TTFont('tmp.woff') font1.saveXML('tmp.xml') 查看xml文件会发现一个映射关系： &lt;GlyphOrder> &lt;!-- The 'id' attribute is only for humans; it is ignored when parsed. --> &lt;GlyphID id="0" name="glyph00000"/> &lt;GlyphID id="1" name="x"/> &lt;GlyphID id="2" name="uniF753"/> &lt;GlyphID id="3" name="uniEA72"/> &lt;GlyphID id="4" name="uniEE4E"/> &lt;GlyphID id="5" name="uniECE6"/> &lt;GlyphID id="6" name="uniE140"/> &lt;GlyphID id="7" name="uniF4B0"/> &lt;GlyphID id="8" name="uniE1B7"/> &lt;GlyphID id="9" name="uniF245"/> &lt;GlyphID id="10" name="uniE488"/> &lt;GlyphID id="11" name="uniE6DA"/> &lt;/GlyphOrder> 但是使用这个映射关系解码发现解密出来的数字不对，因此GlyphOrder并不是我们需要的映射关系。 xml文件往下翻，发现了字体数据： &lt;TTGlyph name="uniF245" xMin="0" yMin="0" xMax="508" yMax="716"> &lt;contour> &lt;pt x="323" y="0" on="1"/> &lt;pt x="323" y="171" on="1"/> &lt;pt x="13" y="171" on="1"/> &lt;pt x="13" y="252" on="1"/> &lt;pt x="339" y="716" on="1"/> &lt;pt x="411" y="716" on="1"/> &lt;pt x="411" y="252" on="1"/> &lt;pt x="508" y="252" on="1"/> &lt;pt x="508" y="171" on="1"/> &lt;pt x="411" y="171" on="1"/> &lt;pt x="411" y="0" on="1"/> &lt;/contour> &lt;contour> &lt;pt x="323" y="252" on="1"/> &lt;pt x="323" y="575" on="1"/> &lt;pt x="99" y="252" on="1"/> &lt;/contour> &lt;instructions/> &lt;/TTGlyph> 看到这里突然想到，无论unicode码怎么变，数字渲染出来的样子是不会变的，因此可以从字体数据入手： 0-9每一个数字都有对应的一个TTGlyph数据，首先对一个已知映射关系的字体文件进行分析，获取0-9的字体数据，然后对于每次下载的动态字体文件，将其字体信息与0-9的字体数据进行对比就可以知道其映射关系了。 首先需要一份已知映射关系的xml文件作为映射关系对比文件，将其命名为data.xml，然后使用百度字体编辑器分析其对应的woff获取其映射关系(由于我的data.xml对应的woff文件删掉了，因此这里截图的是一个随机的woff文件对应的映射关系，可能与后边的代码内的映射关系不同，特此说明)： 创建data.xml对应的映射关系的字典： data_dict = {"uniE184":"4","uniE80B":"3","uniF22E":"8","uniE14C":"0", "uniF5FB":"6","uniEE59":"5","uniEBD3":"1","uniED85":"7","uniECB8":"2","uniE96A":"9"} 要对比字体数据就要对xml文件进行分析，因此创建相关xml分析函数： 获取某节点指定属性的值： def getValue(node, attribute): return node.attributes[attribute].value 字体数据的标签为TTGlyph，创建获取一个xml文件中所有的文字信息节点的函数： def getTTGlyphList(xml_path): dataXmlfilepath = os.path.abspath(xml_path) dataDomObj = xmldom.parse(dataXmlfilepath) dataElementObj = dataDomObj.documentElement dataTTGlyphList = dataElementObj.getElementsByTagName('TTGlyph') return dataTTGlyphList 判断两个TTGlyph节点数据是否相同的函数： def isEqual(ttglyph_a, ttglyph_b): a_pt_list = ttglyph_a.getElementsByTagName('pt') b_pt_list = ttglyph_b.getElementsByTagName('pt') a_len = len(a_pt_list) b_len = len(b_pt_list) if a_len != b_len: return False for i in range(a_len): if getValue(a_pt_list[i], 'x') != getValue(b_pt_list[i], 'x') or getValue(a_pt_list[i], 'y') != getValue(b_pt_list[i], 'y') or getValue(a_pt_list[i], 'on') != getValue(b_pt_list[i], 'on'): return False return True =============================================== 相关函数建好后可以继续分析： 由于每次的unicode码是随机生成的，因此还需要知道新的0-9对应的unicode码是多少，为了方便直接使用函数获取了上边提到过的映射关系不对的GlyphOrder，是一个key为unicode，value为数字的字典： decode_dict = dict(enumerate(font1.getGlyphOrder()[2:])) decode_dict = dict(zip(decode_dict.values(),decode_dict.keys())) 获取已知映射关系的data.xml的字体数据节点和新的动态字体文件的数据节点： dataTTGlyphList = getTTGlyphList("data.xml") tmpTTGlyphList = getTTGlyphList("tmp.xml") 利用字体数据更新映射字典： decode_dict = refresh(decode_dict,tmpTTGlyphList,dataTTGlyphList) 更新函数的具体实现如下： def refresh(dict, ttGlyphList_a, ttGlyphList_data): data_dict = {"uniE184":"4","uniE80B":"3","uniF22E":"8","uniE14C":"0", "uniF5FB":"6","uniEE59":"5","uniEBD3":"1","uniED85":"7","uniECB8":"2","uniE96A":"9"} data_keys = data_dict.keys() for ttglyph_data in ttGlyphList_data: if getValue(ttglyph_data,'name') in data_keys: for ttglyph_a in ttGlyphList_a: if isEqual(ttglyph_a, ttglyph_data): dict[getValue(ttglyph_a,'name')] = data_dict[getValue(ttglyph_data,'name')] break return dict 考虑到小数的情况，加入小数点映射： decode_dict['.'] = '.' 实现解码函数（输入映射字典和一个需要解密的数值，输出解密后的结果如15.6）： def decode(decode_dict, code): _lst_uincode = [] for item in code.__repr__().split("\\u"): _lst_uincode.append("uni" + item[:4].upper()) if item[4:]: _lst_uincode.append(item[4:]) _lst_uincode = _lst_uincode[1:-1] result = "".join([str(decode_dict[i]) for i in _lst_uincode]) return result ================================================== 具体代码链接]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业FinalReport]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9AFinalReport.html</url>
    <content type="text"><![CDATA[简短的课程学习自我总结（400字以内） 请不用讲述与分析、设计、开发、管理无关的话题 可以包括对同学帮助的致谢（同学姓名请用 github 昵称表示，不许出现真实姓名） 0 ~ 400字，即没有这段也没关系 感谢所有队友（Eileen101 、hanxu1997 、heygrandpa 、Lisa-bao 、samayuki 、Mars_i ）在这次作业中所做的所有贡献。 跟着这次课程和队友们一起感受了开发一个项目大概的过程：需求分析、Product Backing、UI设计、迭代等等。同时参与到项目开发中更加了解了前端后端 的联系、熟悉了爬虫技术等。 PSP 2.1 统计表 PSP2.1 Time(%) Planning 5 Estimate 5 Development 85 Analysis 20 Design Spec 5 Design Review 5 Coding Standard 3 Design 8 Coding 20 Code Review 4 Test 20 Reporting 10 Test Report 3 Size Measurement 3 Postmortem &amp; Process Improvement Plan 4 个人分支的 GIT 统计报告（不需要解释原因）- 仅需要提交截图 自认为最得意/或有价值/或有苦劳的工作清单，含简短说明（一句话）解决动态字体反爬虫 说明：猫眼电影网站的评分票房和票价为了反爬虫使用动态字体，利用字体形状不变进行解密。 个人的技术类、项目管理类博客清单（只需要名称与 url ）猫眼电影加密数字破解（爬取评分票房票价）]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业十六]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%8D%81%E5%85%AD.html</url>
    <content type="text"><![CDATA[使用 ECB 实现 make reservation 用例的详细设计（包含用例简介，顺序图，类图） 用例简介用户提交订单后填写用户信息、确认房间和时间后完成订单。 顺序图 类图 将逻辑设计类图映射到实际项目框架的包图。用树形结构表述实现的包和类]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>UMLet</tag>
        <tag>用例图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week11-week12]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week11-week12.html</url>
    <content type="text"><![CDATA[实现本地服务器Tornado利用tornado框架搭建本地服务器。 主要学习以下内容： define Future RequestHandler 协程装饰器 http相关 json相关 正则表达式匹配url 优化继续调整参数和网络进行优化 整合将训练模型单独整合为一个函数，server单独为一个文件，运行server，在开启本地服务器时，调用此函数训练模型，选定一个测试数据后直接进行预测。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week09-week10]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week09-week10.html</url>
    <content type="text"><![CDATA[项目实现 分类后的音频作为训练集 读入训练集后对语音进行初始化和特征提取 定义参数 实现网络结构（七层卷积三次下采样） 训练模型并进行检验（对单词识别） 优化根据准确率和Tensor flow Board不断调整参数和网络结构。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业十三]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%8D%81%E4%B8%89.html</url>
    <content type="text"><![CDATA[描述软件架构与框架之间的区别与联系软件架构软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。 软件框架软件框架其实就是将代码放到一个我们看不到的容器中，规定架构。当我们使用的时候直接调用。 区别框架是软件，架构不是软件。 框架是一种特殊的软件，它并不能提供完整无缺的解决方案，而是为构建解决方案提供良好的基础。框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务可以被最终应用系统直接调用，而框架中的扩展点是供应用开发人员定制的“可变化点” 软件架构不是软件，而是关于软件如何设计的重要决策。软件架构决策涉及到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件框架之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。 我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构。 联系架构是框架的抽象，框架是架构的具体实现。 框架可能集合了一种或多种架构。 以你的项目为案例绘制三层架构模型图，细致到分区 结合你程序的结构，从程序员角度说明三层架构给开发者带来的便利1、开发人员可以只关注整个结构中的其中某一层； 2、可以很容易的用新的实现来替换原有层次的实现； 3、可以降低层与层之间的依赖； 4、有利于标准化； 5、利于各层逻辑的复用。 6、结构更加的明确 7、在后期维护的时候，极大地降低了维护成本和维护时间 研究 VUE 与 Flux 状态管理的异同Vuex采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 核心概念： State：Vuex 使用单一状态树——用一个对象就包含了全部的应用层级状态。 Getter：Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。 Action：和Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Module：模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。 Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 Flux参考链接 Flux是Facebook用于构建客户端Web应用程序的一个系统架构。它通过利用单向数据流来补充React的可组合视图组件。它更像是一种模式，而不是一个正式的框架。Flux将一个应用分成四个部分。 View： 视图层 Action（动作）：视图层发出的消息（比如mouseClick） Dispatcher（派发器）：用来接收Actions、执行回调函数 Store（数据层）：用来存放应用的状态，一旦发生变动就提醒Views要更新页面 流程： 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 区别：Vuex将action分为了异步和同步两种而Flux没有区分。 联系：Vuex是基于Flux进行改进的。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>Flux</tag>
        <tag>三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week07-week08]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week07-week08.html</url>
    <content type="text"><![CDATA[音频分类将1000个音频分别放入对应文件夹中： filename.txt 存储文件对应位置。 以上所有存储在classification文件夹中。 建立filename.py来生成filename.txt： import os textname = 'filename.txt' with open(textname, 'w') as f: for root, dirs, afiles in os.walk('./classification'): for subdir in dirs: for subroot, subdirs, subfiles in os.walk('./classification/'+subdir): for filename in subfiles: apath = os.path.join(subdir, filename) f.write(apath) f.write('\n') 生成的filename.txt为： MFCC学习链接 MFCC(Mel-frequency cepstral coefficients)：梅尔频率倒谱系数。 梅尔频率是基于人耳听觉特性提出的概念， 它与Hz频率成非线性对应关系。 MFCC则是利用它们之间的这种关系，计算得到的Hz频谱特征，主要用于语音数据特征提取和降低运算维度。 主要用于语音数据特征提取和降低运算维度。 例如：对于一帧有512维(采样点)数据，经过MFCC后可以提取出最重要的40维(一般而言)数据同时也达到了将维的目的。 MFCC的步骤为： 预加重 分帧 加窗 快速傅里叶变换(FFT) 梅尔滤波器组 离散余弦变换(DCT) 其中最重要的就是FFT和梅尔滤波器组，这两个进行了主要的降维操作。 了解相关库和函数 scipy.io.wavfile python_speech_features librosa pydub tf.sparse_tensor_to_dense tf.edit_distance tf.nn.ctc_loss]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业九]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E4%B9%9D.html</url>
    <content type="text"><![CDATA[业务描述链接 用例图 活动图 领域模型 状态图 系统顺序图]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>UMLet</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week05-week06]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week05-week06.html</url>
    <content type="text"><![CDATA[过拟合过拟合，就是拟合函数由于顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。 正则化参考链接 当训练数据不够多或训练过度时，常常会导致过拟合。正则化就是避免过拟合的一个办法。 正则化是通过约束参数的范数使其不要太大，所以可以在一定程度上减少过拟合情况。 L2正则化（权重衰减）L2正则化就是在代价函数后面再加上一个正则化项： L1正则化L1正则化就是在原始的代价函数后面加上一个L1正则化项，即所有权重w的绝对值的和，乘以λ/n： Batch Normalization(BN)在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。 训练过程中采用batch 随机梯度下降，其中E(xk)指的是每一批训练数据神经元xk的平均值；分母指的是每一批数据神经元xk激活度的一个标准差。 引入了可学习参数γ、β： 因此Batch Normalization网络层的前向传导过程公式为： 其中m为mini-batch size。 在CNN中的使用由于BN是对单个神经元的运算，因此为了避免参数过多的情况，使用类似权值共享的策略，把一整张特征图当作一个神经元处理。 cifar 10继续调整网络结构和参数。 项目准备了解频谱图以及音频采样。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>BN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week03-week04]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week03-week04.html</url>
    <content type="text"><![CDATA[Tmux ：终端分割 tmux是指通过一个终端登录远程主机并运行后，在其中可以开启多个控制台的终端复用软件。 常用快捷键Ctrl+b ：激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 Ctrl-b s 在 Tmux 的会话间切换 Ctrl-b % 上下分屏 Ctrl-b “ 左右分屏 Ctrl-b +方向键 进入对应的窗格 Ctrl-b c 创建窗口 Ctrl-b +数字 切换窗口 Ctrl-b &amp; 离开一个会话[exited] Ctrl-b d 从一个会话中脱离[dettached] ssh下载MobaXterm来在windows下使用ssh 连接命令： ssh username@xxx.xxx.xxx.xxx password 监控显卡nvidia smi GPU使用表的具体含义： 第一张表格中： 第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。 第二栏的Temp：是温度，单位摄氏度。 第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。 第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。 第五栏的Bus-Id是涉及GPU总线的东西，domain:bus:device.function 第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。 第五第六栏下方的Memory Usage是显存使用率。 第七栏是浮动的GPU利用率。 第八栏上方是关于ECC的东西。 第八栏下方Compute M是计算模式。 第二张表示每个进程占用的显存使用情况。 使用watch命令实时监测显卡watch的基本用法： watch [options] command 最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。 例如：设置每 10s 显示一次显存的情况 watch -n 10 nvidia-smi cifar10继续调整网络结构和参数来增加准确率。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业八]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%85%AB.html</url>
    <content type="text"><![CDATA[建模工具： UMLet 14.1.1 stand-alone 使用 UML State Model 建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。 建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。 研究淘宝退货流程活动图，对退货业务对象状态建模]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>UMLet</tag>
        <tag>用例图</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业七]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E4%B8%83.html</url>
    <content type="text"><![CDATA[领域建模阅读 Asg_RH 文档，按用例构建领域模型。 按 Task2 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸。 说明：请不要受 PCMEF 层次结构影响。你需要识别实体（E）和 中介实体（M，也称状态实体） 在单页面应用（如 vue）中，E 一般与数据库构建有关， M 一般与 store 模式 有关 在 java web 应用中，E 一般与数据库构建有关， M 一般与 session 有关 数据库建模(E-R 模型) - 按 Task 3 要求，给出系统的 E-R 模型（数据逻辑模型） - 建模工具 PowerDesigner（简称PD） 或开源工具 OpenSystemArchitect - 不负责的链接 http://www.cnblogs.com/mcgrady/archive/2013/05/25/3098588.html - 导出 Mysql 物理数据库的脚本 - 简单叙说 数据库逻辑模型 与 领域模型 的异同 -- +--------------------------------------------------------- -- | MODEL : -- | AUTHOR : -- | GENERATED BY: Open System Architect -- +--------------------------------------------------------- -- | WARNING : Review before execution -- +--------------------------------------------------------- -- +--------------------------------------------------------- -- | CREATE -- +--------------------------------------------------------- CREATE TABLE `CardHolder` ( firstName LONGTEXT NOT NULL, lastName LONGTEXT NOT NULL, address LONGTEXT NOT NULL, phoneNumber CHAR NOT NULL ); CREATE TABLE `CreditCard` ( type LONGTEXT NOT NULL, number INTEGER NOT NULL, securityCode INTEGER NOT NULL, expireDate DATE NOT NULL, holderDetail LONGTEXT NOT NULL, PRIMARY KEY (number) ); CREATE TABLE `Payment` ( price INTEGER NOT NULL, isSuccessful BIT NOT NULL ); CREATE TABLE `Customer` ( firstName LONGTEXT NOT NULL, lastName LONGTEXT NOT NULL, gender BIT NOT NULL, email LONGTEXT NOT NULL ); CREATE TABLE `ShoppingBasket` ( numberOfReservation INTEGER NOT NULL, totalPrice INTEGER NOT NULL ); CREATE TABLE `Reservation` ( orderDate DATE NOT NULL, checkInDate DATE NOT NULL, checkOutDate DATE NOT NULL, details LONGTEXT, roomCount INTEGER NOT NULL, smokingPermission BIT NOT NULL, specialRequirement LONGTEXT ); CREATE TABLE `Room` ( number INTEGER NOT NULL, type LONGTEXT NOT NULL, price INTEGER NOT NULL, date DATE NOT NULL, numberOfAdults INTEGER, numberOfChildren INTEGER, PRIMARY KEY (number) ); CREATE TABLE `Hotel` ( name LONGTEXT NOT NULL, address LONGTEXT NOT NULL, star_rating SMALLINT, PRIMARY KEY (address) ); CREATE TABLE `Destination` ( city LONGTEXT NOT NULL, region LONGTEXT NOT NULL ); 异： 领域模型更注重整体，数据库逻辑模型更注重开发。 同： 都用于业务分析，抽象提取逻辑和实体来帮助分析业务。]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>UMLet</tag>
        <tag>用例图</tag>
        <tag>数据库建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业六]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E5%85%AD.html</url>
    <content type="text"><![CDATA[用例建模阅读 Asg_RH 文档，绘制用例图。 按 Task1 要求，请使用工具 UMLet，截图格式务必是 png 并控制尺寸 选择你熟悉的定旅馆在线服务系统（或移动 APP），如绘制用例图。并满足以下要求： 对比 Asg_RH 用例图，请用色彩标注出创新用例或子用例 尽可能识别外部系统，并用色彩标注新的外部系统和服务 对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法 在基础功能上进行延伸 按照模块进行深入 按照用户需求的变化 按照技术的变化 请使用 SCRUM 方法，在（任务b）用例图基础上，编制某定旅馆开发的需求 （backlog） ID Name Imp Est How to demo 1 选择酒店 40 5 选择酒店所在城市、预定时间、酒店关键字 2 预订酒店 45 6 选择酒店、选择房间类型、查看评价、选择时间、确认信息 3 确认订单 25 3 查看信息 4 支付订单 40 4 选择付款方式付款 5 管理订单 30 5 查看订单信息、删除订单 业务建模在（任务b）基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。 选择你身边的银行 ATM，用活动图描绘取款业务流程 查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务的过程。分析客户要完成退货业务，在淘宝网上需要实现哪些系统用例 用例文本编写 在大作业基础上，分析三种用例文本的优点和缺点 用例文本 优点 缺点 详细用例 详细、深入 繁琐导致耗时长 casual 用例 较详细、编写较简便 细节不足，不够正式 brief用例 简介、编写简便 缺少细节]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>UMLet</tag>
        <tag>用例图</tag>
        <tag>SCRUM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客谷歌百度收录踩坑日记]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E8%B0%B7%E6%AD%8C%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0.html</url>
    <content type="text"><![CDATA[百度收录文件验证无论怎么把渲染关掉或者render_skip都说我的格式错误，看了一下源代码发现即使不渲染最后也会加上html的标签，于是放弃这个放弃了这个方式。 百度收录html验证本来以为这个应该会直接就验证通过了，但是只要我修改了html，百度就无法访问我的博客，遂也放弃了这个方法.. 百度收录CNAME验证使用阿里云进行云解析但是阿里云现在不支持xxx.github.io的域名… 于是踏上了新征程： 自定义域名在阿里云买了一个最便宜的.top域名，把自定义域名和博客绑定上之后博客就无法访问了，需要细心等待，谷歌了一下一般不会超过48h就会绑定成功可以正常使用。 阿里云的速度挺快，不到一个小时就好了。 弄好自定义域名之后就悲催地发现评论板块无法登陆…磕磕绊绊改好配置后，终于开始重新进行百度收录了！ 谷歌收录由于白天的阴影先弄了谷歌收录，没有遇到什么大坑，一切都非常顺利，直到上sitemap时出现了两个问题： sitmap.xml不存在安装sitemap插件时一定要加上--save！！： npm install hexo-generator-sitemap --save 而不是 npm install hexo-generator-sitemap 测试sitmap.xml出现错误：此位置的 Sitemap 不允许此网址搜了一下，各家有各家的错误原因，我的是因为我在谷歌收录的网址是原网址https://mikqueenge.github.io，而上传的sitemap.xml的地址自动被解析为自定义域名http://blog.zmj97.top/sitemap.xml才出现了错误，再添加收录网站http://blog.zmj97.top然后在这个地址下添加sitemap即可。 百度收录token数据引入-&gt;链接提交-&gt;自动提交-&gt;主动推送（实时）-&gt;推送接口 中的接口调用地址中有token的值。 自动抓取sitemap失败直接访问提交的数据文件地址http://blog.zmj97.top/baidu_sitemap.txt是可以看到的，但是因为 GitHub 屏蔽了百度的爬虫所以百度无法抓取… 然后发现我的配置跟主动推送的配置（参考链接）很像，但是deploy baidu_submitter一直出错，看了错误信息才发现是因为把baidu_url_submit:下的path: baidu_urls.txt擅自改了文件名导致的… 终于好了…踩坑结束！]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网站收录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo博客自定义域名后gitment评论系统登陆出现redirect error返回主页的解决办法]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Ehexo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%90%8Egitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%99%BB%E9%99%86%E5%87%BA%E7%8E%B0redirect-error%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[背景： 原地址：https://mikqueenge.github.io 新域名：http://blog.zmj97.top(这里一定要注意！从阿里云买的域名使用的协议是http！) 今天下午兴致勃勃地买了个域名绑定到这个博客上后，发现昨天好不容易跳了各种坑才实现的评论功能无法登陆了！ 每一次点击评论里的登陆都会回到index页面，地址栏显示地地址为https://blog.zmj97.top/?error=redirect_uri_mismatch&amp;error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.&amp;error_uri=https%3A%2F%2Fdeveloper.github.com%2Fv3%2Foauth%2F%23redirect-uri-mismatch 一看这个提示，redirect error 让人不禁想到OAuth应用注册时填写的Authorization callback URL回调URL， 各种百度谷歌了一下，如果自定义了域名的话回调URL要填写自定义域名，而且一个字符都不能出错！否则就会出现上述无法登陆的情况… 试了一晚上，回调URL可能出现的字符错误有以下几个： 多加空格 协议错误，区分http和https 多加/ 最后终于成功时我的OAuth应用信息的究极形态如下： 心好累…]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
        <tag>OAuth</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接入gitment为hexo添加评论功能]]></title>
    <url>%2F%E6%8E%A5%E5%85%A5gitment%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[注册一个OAuth application注册链接 其中： Application name 为应用名，取一个跟自己博客相关的名字即可； Homepage URL 为博客地址，例如我的为：https://mikqueenge.github.io； Application description 为应用描述，可不填； Authorization callback URL 为回调URL，可不填； 点击 Register application 祝成功后会得到这个应用的 client ID 和 client secret，等下配置文件时会用到。 配置文件主题：landscape 创建git.ejs在themes/landscape/layout/_partial/post文件夹中创建文件git.ejs，写入下面的代码： var gitment = new Gitment({ id: '{{ page.date }}', //添加此句解决Error：validation failed的问题 owner: "%%%%%%%",//github用户名，例如MIKQUEENGE repo: "%%%%%%%",//用户存储评论的github项目名称，例如MIKQUEENGE.github.io oauth: { client_id: "%%%%%%%%%%%%",//注册OAuth Application时生产的ClinetID client_secret:"%%%%%%%%%%",//注册OAuth Application时生成的Client Secret }, }) gitment.render('git') 配置article.ejs在themes/landscape/layout/_partial/article.ejs文件的结尾添加： 登陆与添加评论完成上述配置后部署并打开某篇文章，拉到最底部可以看到评论区： 点击登陆后就可以添加评论啦！ 遇到问题Error：validation failedmd文件名太长导致id出现问题，使用上述代码是不会出现这个问题的。 如果出现这个问题，解决方案为在gitment配置文件（如上述的git.ejs）中的var gitment = new Gitment({})内添加id: &#39;&#39;,（不要忘记这个逗号） 参考链接： Hexo博客yelee主题添加Gitment评论系统 Gitment评论功能接入踩坑教程]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo创建的tags和categories页面为空的解决办法]]></title>
    <url>%2Fhexo%E5%88%9B%E5%BB%BA%E7%9A%84tags%E5%92%8Ccategories%E9%A1%B5%E9%9D%A2%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[主题：landscape 添加type以及menu后仍然显示空白的解决办法： 打开landscape/_partial/article.ejs， 在&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;的div内添加代码： 重新打开即可看到正常显示的标签和分类页。 修改categories页面样式（也可以自己设计修改）： 打开landscape/source/css/_partial/article.styl，在尾部添加： .category-all-page { a:link { font-size: 14px; color: #333; text-decoration: none; } a:hover { font-size: 14px; color: #d8d; text-decoration: none; font-weight: bold; } .category-all-title { text-align: left; } .category-all { margin-top: 20px; } .category-list { margin: 0; padding: 0; list-style: none; } .category-list-item { text-align: center; display: inline-block; margin: 8px; padding: 8px; width: 150px; position: relative; background-color: rgba(237, 237, 237, 0.53); border-radius: 1px; box-shadow:0px 0px 0px 1px #ccc; } .category-list-link { color: #333; } .category-list-count { color: #333; &amp;:before { display: inline; content: " (" } &amp;:after { display: inline; content: ") " } } .category-list-child { padding-left: 10px; color: #333;} }]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分析与设计作业五]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A%E4%BA%94.html</url>
    <content type="text"><![CDATA[配置mongoDB参考教程：https://www.yiibai.com/mongodb/mongodb_environment.html 下载需要科学上网。 另外： 将F:\mongodb\bin\添加到环境变量中。 每次开启前用这个命令修改db缓存路径： mongod -dbpath f:\mongodb\data 然后再打开另一个cmd窗口输入mongod即可。 了解Python+Flask后端服务实现（win10）参考资料：http://www.jb51.net/article/60738.htm 环境配置安装pymongo、flask、Pillow： easy_install pymongo easy_install flask easy_install Pillow IDE使用PyCharm 打开PyCharm-&gt;新建项目-&gt;选择Flask框架-&gt;修改路径-&gt;创建 得到了一个最简单的hello world的项目： Flask 快速入门参考链接 运行刚刚创建的hello world程序： 在浏览器输入网址http://127.0.0.1:5000/： 调试模式在代码修改的时候服务器能够自动加载，并且如果发生错误，它会提供一个有用的调试器。 使用 app.debug = True app.run() 或者 app.run(debug=True) 开启调试模式。 路由route() 装饰器用于把一个函数绑定到一个 URL 上。 静态绑定@app.route('/') def index(): return 'Index Page' @app.route('/hello') def hello(): return 'Hello World' 动态绑定把一些特定的字段标记成 &lt;variable_name&gt;来进行动态绑定，还可以用 &lt;converter:variable_name&gt;限制格式： @app.route('/user/&lt;username>') def show_user_profile(username): # show the user profile for that user return 'User %s' % username @app.route('/post/&lt;int:post_id>') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id 有如下三种转换器： int 接受整数 float 同 int 一样，但是接受浮点数 path 和默认的相似，但也接受斜线 HTTP方法默认情况下，路由只会响应 GET 请求，但是能够通过给 route() 装饰器提供 methods 参数来改变： @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': do_the_login() else: show_the_login_form() 常见HTTP方法 GET 浏览器通知服务器只 获取 页面上的信息并且发送回来。这可能是最常用的方法。 HEAD 浏览器告诉服务器获取信息，但是只对 头信息 感兴趣，不需要整个页面的内容。应用应该处理起来像接收到一个 GET 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，底层的 Werkzeug 库会为你处理的。 POST 浏览器通知服务器它要在 URL 上 提交 一些信息，服务器必须保证数据被存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。 PUT 同 POST 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 POST 是不可能实现的，因为它只会被触发一次。 DELETE 移除给定位置的信息。 OPTIONS 给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。 构建url可以使用函数url_for() 来针对一个特定的函数构建一个 URL。 它能够接受函数名作为第一参数，以及一些关键字参数，每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数： >>> from flask import Flask, url_for >>> app = Flask(__name__) >>> @app.route('/') ... def index(): pass ... >>> @app.route('/login') ... def login(): pass ... >>> @app.route('/user/&lt;username>') ... def profile(username): pass ... >>> with app.test_request_context(): ... print url_for('index') ... print url_for('login') ... print url_for('login', next='/') ... print url_for('profile', username='John Doe') ... / /login /login?next=/ /user/John%20Doe 渲染静态文件只要在你的包中或模块旁边创建一个名为 static 的文件夹，在应用中使用 /static 即可访问。 给静态文件生成 URL： url_for('static', filename='style.css') 这个文件应该存储在 static/style.css，而使用PyCharm创建Flask项目时已经为你创建好了static目录： 渲染模板由于必须自行做好 HTML 转义以保持应用程序的安全，Flask 自动配置好了 Jinja2 模版。 可以使用方法 render_template() 来渲染模版： from flask import render_template @app.route('/hello/') @app.route('/hello/&lt;name>') def hello(name=None): return render_template('hello.html', name=name) Flask 将会在 templates 文件夹中寻找模版。 后续链接]]></content>
      <categories>
        <category>系统分析与设计</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能指针]]></title>
    <url>%2F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[为什么使用动态指针？在C++中，动态内存的管理是通过一对运算符来完成的： new: 在动态内存中为对象分配空间并返回一个指向该对象的指针，同时可以对这个对象初始化。 delete: 接受一个动态对象的指针，销毁该对象并释放与之关联的内存。 这样动态内存的使用就很容易出现问题： 忘记释放内存（delete）就会产生内存泄漏的问题。 过早释放内存（在还有指针引用该内存的时候就释放了它）就会产生引用非法内存的指针。 为了防止出现这种情况，更容易更安全地使用动态内存， 自C++11开始提供了两种智能指针类型来管理动态对象。 什么是智能指针？智能指针是存储指向动态分配（堆）对象指针的类。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。 智能指针的原理是什么？资源分配即初始化RAII（Resource Acquisition Is Initialization）：RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。 定义一个类来封装资源的分配和释放，在构造函数完成资源的分配和初始化，在析构函数完成资源的清理，可以保证资源的正确初始化和释放。 在类中采用引用计数的方法。在智能指针的内部有一个计数器，记录了当前内存资源到底有多少指针在引用，当新增加一个这个资源的引用时，计数器就会+1，否则-1，当计数器的值变为0时，这个智能指针就会自动释放它管理的 这个资源。 常见的智能指针？C++11提供的两个智能指针为shared_ptr和unique_ptr，还定义了一个伴随类weak_ptr，这三个类都定义在memory头文件中。以及C++98引入的使用起来到处是坑的auto_ptr。 shared_ptr（官方文档） shared_ptr允许多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。 每多一个指针指向它，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。 shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。 不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。 unique_ptr unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。 相比于原始指针，unique_ptr用其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。 unique_ptr指针本身的生命周期： 从unique_ptr指针创建时开始，直到离开作用域。 离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。 unique_ptr指针与其所指对象的关系： 在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。 weak_ptr weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。 weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。 weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。 循环引用问题首先看下面的代码理解什么是循环引用： class B; class A { public: shared_ptr m_b; }; class B { public: shared_ptr m_a; }; void test() { shared_ptr a(new A); //new出来的A的引用计数此时为1 shared_ptr b(new B); //new出来的B的引用计数此时为1 a->m_b = b; //B的引用计数增加为2 b->m_a = a; //A的引用计数增加为2 //b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放 //a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放 } 因为weak_ptr的构造和析构不会引起引用计数的增加或减少，所以可以用weak_ptr解决这个问题（weak_ptr必须与shared_ptr配合使用,不能单独使用）： class B; class A { public: weak_ptr m_b; }; class B { public: weak_ptr m_a; }; void test() { shared_ptr a(new A); shared_ptr b(new B); a->m_b = b; b->m_a = a; } auto_ptr缺陷：（参考链接，来源：知乎，作者：Sen Zhang） auto_ptr采用可以采用copy语义来转移指针资源的所有权的同时将原指针置为NULL，这跟通常理解的copy行为是不一致的，而这样的行为要有些场合下不是我们希望看到的。 例如参考《Effective STL》第8条，sort的快排实现中有将元素复制到某个局部临时对象中，但对于auto_ptr，却将原元素置为null，这就导致最后的排序结果中可能有大量的null。 而现在C++11的对move语义的支持，使得这样的资源转移通常只会在必要的场合发生，例如转移一个临时变量（右值）给某个named variable（左值） 这也就是用unique_ptr代替auto_ptr的原因， 本质上来说，就是unique_ptr禁用了copy，而用move替代。 std::unique_ptr b0(new bar()); std::unique_ptr b1(std::move(b0)); 智能指针的实现template class SmartPointer { public: //构造函数 SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){ if(p) *_reference_count = 1; else *_reference_count = 0; } //拷贝构造函数 SmartPointer(const SmartPointer& src) { if(this!=&src) { _ptr = src._ptr; _reference_count = src._reference_count; (*_reference_count)++; } } //重载赋值操作符 SmartPointer& operator=(const SmartPointer& src) { if(_ptr==src._ptr) { return *this; } releaseCount(); _ptr = src._ptr; _reference_count = src._reference_count; (*_reference_count)++; return *this; } //重载操作符 T& operator*() { if(ptr) { return *_ptr; } //throw exception } //重载操作符 T* operator->() { if(_ptr) { return _ptr; } //throw exception } //析构函数 ~SmartPointer() { if (--(*_reference_count) == 0) { delete _ptr; delete _reference_count; } } private: T *_ptr; size_t *_reference_count; void releaseCount() { if(_ptr) { (*_reference_count)--; if((*_reference_count)==0) { delete _ptr; delete _reference_count; } } } }; int main() { SmartPointer cp1(new char('a')); SmartPointer cp2(cp1); SmartPointer cp3; cp3 = cp2; cp3 = cp1; cp3 = cp3; SmartPointer cp4(new char('b')); cp3 = cp4; }]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy常用函数和数据类型]]></title>
    <url>%2Fnumpy%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[np.random.randnp.random.rand(d0,d1,…,dn)表示创造一个(n+1)维的大小为d0*d1*…*dn的数组，其中每一个数都是随机产生的[0, 1)内的数。 >>> np.random.rand(3,2) array([[0.91184685, 0.81463722], [0.9261665 , 0.960428 ], [0.52837831, 0.61184641]]) np.float32数据类型，32位浮点数。 np.dot矩阵乘法。np.dot(x, y)表示矩阵x和y相乘。 >>> a = [1, 2] >>> b = [[3], [4]] >>> np.dot(a,b) array([11])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用TensorBoard可视化工具]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8TensorBoard%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[图表可视化在理解和调试时显得非常有帮助。 安装：pip3 install --upgrade tensorboard 名称域（Name scoping）和节点（Node）典型的TensorFlow有数以千计的节点，为了简单起见，我们可以为变量名（节点）划分范围。 这个范围称为名称域，即tf.name_scope(&#39;xxx&#39;)，其中xxx是这个名称域的名字。 在定义好名称域后，TensorBoard的显示界面里这个名称域内的变量并不会显示，而是只显示一个xxx节点，这个点是可展开的，展开后才会显示这个名称域内的节点。 TensorFlow 图表有两种连接关系：数据依赖和控制依赖。数据依赖显示两个操作之间的tensor流程，用实心箭头表示，控制依赖用虚线表示。 具体的符号表： 符号 意义 High-level节点代表一个名称域，双击则展开一个高层节点。 彼此之间不连接的有限个节点序列。 彼此之间相连的有限个节点序列。 一个单独的操作节点。 一个常量结点。 一个摘要节点。 显示各操作间的数据流边。 显示各操作间的控制依赖边。 引用边，表示出度操作节点可以使入度tensor发生变化。 Scalar使用summary scalar（标量统计）: xentropy = ... # xentropy的定义 tf.summary.scalar('xentropy_mean', xentropy) # xentropy_mean为定义的xentropy的标签名 Histogram使用summary histogram统计某个Tensor的取值分布: with tf.name_scope('layer1'): with tf.name_scope('biases'): biases = ... # 具体声明这里不再给出 tf.summary.histogram('layer1' + '/biases', biases) with tf.name_scope('weights'): weights= ... tf.summary.histogram('layer1' + '/weights', weights) with tf.name_scope('outputs'): outputs= ... tf.summary.histogram('layer1' + '/weights', outputs) 合并Summary # 将各个summary操作合并为一个操作merged_summary_op merged_summary_op = tf.summary.merge_all() # 数据写入器，'/logs'为训练日志的存储路径 summary_writer = tf.summary.FileWriter('./logs', sess.graph) total_step = 0 while training: total_step += 1 session.run(training_op) if total_step % 100 == 0: ... summary_str = sess.run(merged_summary_op, feed_dict{...}) # 注意这里必须加feed_dict否则会报错 summary_writer.add_summary(summary_str, total_step) # 使用summary_writer将数据写入磁盘 生成TensorBoard界面运行添加了各种summary的操作的代码后，打开cmd，进入代码所在文件夹，输入： tensorboard --logdir=logs 按照运行后的提示： TensorBoard 1.7.0 at http://MengjieZhang:6006 (Press CTRL+C to quit) 打开浏览器，输入地址 http://MengjieZhang:6006 即可以看到TensorBoard界面。 具体代码：input_data下载链接 import input_data import tensorflow as tf def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial) def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME') def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') mnist = input_data.read_data_sets('data', one_hot=True) mnistGraph = tf.Graph() with mnistGraph.as_default(): with tf.name_scope('input'): x = tf.placeholder("float", shape=[None, 784]) y_ = tf.placeholder("float", shape=[None, 10]) W = tf.Variable(tf.zeros([784,10])) b = tf.Variable(tf.zeros([10])) with tf.name_scope('hidden1'): W_conv1 = weight_variable([5, 5, 1, 32]) b_conv1 = bias_variable([32]) x_image = tf.reshape(x, [-1,28,28,1]) h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1) h_pool1 = max_pool_2x2(h_conv1) tf.summary.histogram('W_conv1', W_conv1) tf.summary.histogram('b_conv1', b_conv1) with tf.name_scope('hidden2'): W_conv2 = weight_variable([5, 5, 32, 64]) b_conv2 = bias_variable([64]) h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2) h_pool2 = max_pool_2x2(h_conv2) tf.summary.histogram('W_conv2', W_conv2) tf.summary.histogram('b_conv2', b_conv2) with tf.name_scope('fc1'): W_fc1 = weight_variable([7 * 7 * 64, 1024]) b_fc1 = bias_variable([1024]) h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64]) h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) keep_prob = tf.placeholder("float") h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) tf.summary.histogram('W_fc1', W_fc1) tf.summary.histogram('b_fc1', b_fc1) with tf.name_scope('fc2'): W_fc2 = weight_variable([1024, 10]) b_fc2 = bias_variable([10]) y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2) tf.summary.histogram('W_fc2', W_fc2) tf.summary.histogram('b_fc2', b_fc2) with tf.name_scope('train'): cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv)) train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy) correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float")) tf.summary.scalar('loss', cross_entropy) tf.summary.scalar('accuracy', accuracy) with tf.Session(graph=mnistGraph) as sess: sess.run(tf.initialize_all_variables()) merged_summary_op = tf.summary.merge_all() summary_writer = tf.summary.FileWriter('./logs', sess.graph) for i in range(3000): batch = mnist.train.next_batch(50) if i%100 == 0: train_accuracy = accuracy.eval(feed_dict={ x:batch[0], y_: batch[1], keep_prob: 1.0}) print ("step %d, training accuracy %g" % (i, train_accuracy)) summary_str = sess.run(merged_summary_op, feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5}) summary_writer.add_summary(summary_str, i) train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5}) accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32)) good = 0 total = 0 for i in range(10): testSet = mnist.test.next_batch(50) good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0}) total += testSet[0].shape[0] print ("test accuracy %g"%(good/total)) 运行后的TensorBoard界面：]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>TensorBoard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow训练MNIST报错ResourceExhaustedError]]></title>
    <url>%2FTensorFlow%E8%AE%AD%E7%BB%83MNIST%E6%8A%A5%E9%94%99ResourceExhaustedError.html</url>
    <content type="text"><![CDATA[在最后测试的一步报错： ResourceExhaustedError (see above for traceback): OOM when allocating tensor 搜索了一下才知道是GPU显存不足（emmmm….）造成的，可以把最后测试的那行代码改为将测试集分成几个小部分分别测试最后再求精度的平均值： accuracy_sum = tf.reduce_sum(tf.cast(correct_prediction, tf.float32)) good = 0 total = 0 for i in range(10): testSet = mnist.test.next_batch(50) good += accuracy_sum.eval(feed_dict={ x: testSet[0], y_: testSet[1], keep_prob: 1.0}) total += testSet[0].shape[0] print ("test accuracy %g"%(good/total))]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow基础知识]]></title>
    <url>%2FTensorFlow%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。 下图就是一个数据流图。数据流图是一个用来描述数学计算的由“结点”（nodes）和“线”(edges)组成的有向图。 “节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点或者是输出（push out）的终点，以及读取/写入持久变量（persistent variable）的终点。 “线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“张量”（tensor），即大小可动态调整的多维数据数组。 一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 开始学习官方基础知识链接 使用图 (graph) 来表示计算任务. 在被称之为 会话 (Session) 的上下文 (context) 中执行图. 使用 tensor 表示数据. 通过 变量 (Variable) 维护状态. 使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据. 图中的节点被称之为 op (operation 的缩写). 一个 op 获得 0 个或多个 Tensor, 执行计算,产生 0 个或多个 Tensor. 每个 Tensor 是一个类型化的多维数组. 构建图（创造节点）import tensorflow as tf # 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点 # 加到默认图中. # # 构造器的返回值代表该常量 op 的返回值. matrix1 = tf.constant([[3., 3.]]) # 创建另外一个常量 op, 产生一个 2x1 矩阵. matrix2 = tf.constant([[2.],[2.]]) # 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入. # 返回值 'product' 代表矩阵乘法的结果. product = tf.matmul(matrix1, matrix2) 启动图# 启动默认图. sess = tf.Session() # 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数. # 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回 # 矩阵乘法 op 的输出. # # 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的. # # 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行. # # 返回值 'result' 是一个 numpy `ndarray` 对象. result = sess.run(product) print result # ==> [[ 12.]] # 任务完成, 关闭会话. sess.close() 也可以： with tf.Session() as sess: result = sess.run([product]) print result TensorTensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor.可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和一个 shape. 变量变量维护图执行过程中的状态信息。 启动图后, 变量必须先经过初始化 (init) op 初始化, 必须增加一个初始化 op 到图中：init_op = tf.initialize_all_variables() 启动图后首先运行 ‘init’ op：sess.run(init_op) Fetch为了取回操作的输出内容, 可以在使用 Session 对象的 run() 调用 执行图时, 传入一些 tensor来取回结果。 FeedTensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor,可以对图中任何操作提交补丁, 直接插入一个 tensor。 最常见的用例是将某些特殊的操作指定为 “feed” 操作,标记的方法是使用 tf.placeholder() 为这些操作创建占位符. input1 = tf.placeholder(tf.types.float32) input2 = tf.placeholder(tf.types.float32) output = tf.mul(input1, input2) with tf.Session() as sess: print sess.run([output], feed_dict={input1:[7.], input2:[2.]})]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo markdown添加的图片在github page中无法显示的问题]]></title>
    <url>%2F%E5%85%B3%E4%BA%8Ehexo-markdown%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8github-page%E4%B8%AD%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[云端 试了很多网站的图片，发现主要是CSDN和博客园的图片无法显示。 推荐用Bing或者Google搜索外网图片添加。 本地 在source目录下新建images目录，将要添加的图片存放在这个目录下，md引用时使用/images/…]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习周报week01&week02]]></title>
    <url>%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5week01-week02.html</url>
    <content type="text"><![CDATA[Week1配置Cuda、Cudnn和Tensorflow要注意版本对应 学习基础知识神经网络基本原理感知器一个圆圈表示一个感知器，x1、x2、x3…为输入，output为对应的输出。为了简化问题，output只取0或1. 权重和阈值threshold为阈值，xi为输入，wi为对应的权重，表示输入的重要性。 矢量化 将输入x1,x2,x3,…写为矢量x: &lt; x1,x2,x3,… &gt; 将权重w1,w2,w3,…写为矢量w: &lt; w1,w2,w3,… &gt; 则 w·x = ∑ wx 设 b 等于负的阈值 b = -threshold 实际的决策模型多个感知器组成的多层网络： 神经网络的运作过程 确定输入和输出 找到一种或多种算法，可以从输入得到输出（决定决策模型） 找到一组已知答案的数据集，用来训练模型，估算w和b估算w和b：试错法首先获取一组随机的w和x，将w（或b）进行微小变动，记作Δw（或Δb），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组w和b，就是我们要的值。这个过程称为模型的训练。 一旦新的数据产生，输入模型，就可以得到结果，同时对w和b进行校正 输出的连续性为了保证能观察到w和b的微小变化对结果造成的影响，必须将”输出”改造成一个连续性函数。一般使用sigmoid函数。 将output记为z：z = wx + b 则结果的sigmoid函数为σ(z)：σ(z) = 1 / (1 + e^(-z)) 实际上，Δσ满足下面的公式：即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。 反向传播（BP） 即估算w和b的试错法的具体实现。 反向传播算法主要由两个过程（激励传播、权重更新）反复循环迭代，直到结果误差在可容忍的限度结束。 激励传播每次迭代中的传播环节包含两步： 前向传播阶段——按照当前w和b计算output（激励响应）； 反向传播阶段——将output和目标输出求差，从而获得隐层和输出层的响应误差。 权重更新对于每个权重 wi ，按照以下步骤进行更新： 将输入激励和响应误差相乘，从而获得权重的梯度； 将这个梯度乘上一个比例并取反后加到权重上。 这个比例将会影响到训练过程的速度和效果，因此称为“训练因子”。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。 关于算法推导（梯度下降+链式求导），网上的博客质量良莠不齐，因此打算等买的书到了之后再研究一下，这里就不再列出。 卷积神经网络（CNN） 卷积神经网络由三部分构成： 第一部分是输入层。 第二部分由n个卷积层和池化层的组合组成。 第三部分由一个全连结的多层感知机分类器构成。 卷积神经网络与普通神经网络的区别在于，卷积神经网络包含了一个特征抽取器（即第二部分）。 卷积神经网络的卷积层中，一个神经元只和部分邻层神经元连接。 在每一个卷积层中，通常包含若干个特征平面(feature map)，每个特征平面由一些矩形排列的的神经元组成，同一特征平面的神经元共享权值，这里共享的权值就是卷积核。 卷积核一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将通过学习得到合理的权值（反向传播）。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接（减少参数），同时又降低了过拟合（参数过多导致）的风险。 子采样也叫做池化（pooling），也可以认为是下采样，通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。 与普通的神经网络相比，包含卷积和子采样的卷积神经网络大大简化了模型复杂度，减少了模型的参数。 局部连接假设一张图大小为n1*n2，一个卷积核的大小为m1*m2，对于卷积后生成的每一个数据xi，它都是原图中对应位置的m1*m2矩阵和这个卷积核对应点相乘求和得到的。 也就是说xi只和原图中对应的m1*m2的那个矩阵中的元素连接，而不是和整张图的n1*n2个元素连接。 因此局部连接使得参数数量变为全连接的（m1*m2）/（n1*n2）。 权值共享即对于一个卷积核遍历原数据矩阵，生成的一个新的数据矩阵的每一个元素来说，它们的权值都为这个卷积核。 这样就导致了权值数几乎变为了不权值共享时的数据量分之一。 多卷积核用一个卷积核对整张图卷积可以看作是提取了原图的一个特征。 使用一个卷积核只提取了一个特征，因此为了充分的提取特征，要使用多个卷积核，得到多个特征平面。 下采样（池化）当输入数据过多时，参数的量就不可避免的变得很多，为了防止参数过多导致过拟合，需要下采样。 常见网络结构了解LeNet Input Layer：1*32*32图像 Conv1 Layer：包含6个卷积核，kernal size：5*5，parameters:（5*5+1）*6=156个 Subsampling Layer：average pooling，size：2*2, Activation Function：sigmoid Conv3 Layer：包含16个卷积核，kernal size：5*5 Subsampling Layer：average pooling，size：2*2 Conv5 Layer：包含120个卷积核，kernal size：5*5 Fully Connected Layer：Activation Function：sigmoid Output Layer：Gaussian connection AlexNetAlexNet结构图 AlexNet结构精简版 对比一下即可理解精简版中符号的含义（以第一层为例）： 卷积核大小为11*11，共有96个卷积核，步长为4，下采样矩阵大小为2*2。 fc：full connect，全连接。 激活函数变为ReLU：斜坡函数 f(x) = max(0, x)及其变种。 VGGVGG结构图 VGG-19网络结构精简版 GoogLeNet讲解链接 主要特征是重新启用全连接以及提出了网中网的结构。 网上的博客写的都比较粗略，有时间看一下相关资料或者论文。 ResNet残差网络模型主要的创新为残差网络，本质上是要解决层次比较深时无法训练的问题： ResNet网络结构 DenseNetDenseNet网络结构 Dense Block结构 还是只看懂了大概，需要后续学习。 利用LeNet5网络模型实现MNIST手写数字识别主要的关键点是熟悉TensorFlow相关变量和含义 完成TensorFlow官方MINIST识别教程。 使用国内网站来更方便的浏览。 Week2利用VGG16实现CIFAR-10动物分类教程页链接 学习使用TensorBoard了解Batch Normalization(BN)批标准化文献链接：Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift 在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署hexo后github pages页面未更新或无法打开问题]]></title>
    <url>%2F%E9%83%A8%E7%BD%B2hexo%E5%90%8Egithub-pages%E9%A1%B5%E9%9D%A2%E6%9C%AA%E6%9B%B4%E6%96%B0%E6%88%96%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[部署本地编写完成后，要同步Github Pages，运行以下三个命令即可： hexo clean hexo g hexo d 需要注意的是这些命令应该在hexo目录的根目录下进行。 部署后页面未更新使用无痕模式浏览或者等一段时间再查看。 更推荐运行hexo s后利用本地服务器在localhost:4000查看效果，效果满意后直接部署，过段时间页面自然会更新的。]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆和栈的区别]]></title>
    <url>%2F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[参考： 链接1 链接2 一个由C/C++编译的程序占用的内存分为以下几个部分：1、栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2、堆区（heap）一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式倒是类似于数据结构中的链表。 3、全局区/静态区（static）全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 4、文字常量区存放常量字符串。程序结束后由系统释放。 5、程序代码区存放函数体的二进制代码。 堆和栈的区别：1、申请方式栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等。 堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收。 2、操作方式栈区：操作方式类似于数据结构中的栈。 堆区：不同于数据结构中的堆，分配方式类似于链表。 3、申请后系统的响应栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（overflow）。 堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，从而代码中的delete语句才能正确的释放本内存空间，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 4、申请大小的限制栈区：在Windows下,栈是是一块确定的连续内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区：堆是向高地址扩展的数据结构，由于系统是用链表来存储的空闲内存地址的，它是不连续的，链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 5、申请效率的比较栈区：系统自动分配，速度较快。但程序员是无法控制的。 堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不在堆也不在栈，而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 6、堆和栈中的存储内容栈区：在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，接着是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
</search>
